#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DungeonCrawler

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "DungeonCrawler_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Engine_structs.hpp"
#include "AIModule_structs.hpp"
#include "UMG_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "EnhancedInput_structs.hpp"
#include "InputCore_structs.hpp"
#include "CommonInput_structs.hpp"


namespace SDK::Params
{

// Function DungeonCrawler.AccountLink.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct AccountLink_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AccountLink_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on AccountLink_BroadcastMsgBlueprint");
static_assert(sizeof(AccountLink_BroadcastMsgBlueprint) == 0x000004, "Wrong size on AccountLink_BroadcastMsgBlueprint");
static_assert(offsetof(AccountLink_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'AccountLink_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.AccountLink.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct AccountLink_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AccountLink_UnbindMsg) == 0x000008, "Wrong alignment on AccountLink_UnbindMsg");
static_assert(sizeof(AccountLink_UnbindMsg) == 0x000010, "Wrong size on AccountLink_UnbindMsg");
static_assert(offsetof(AccountLink_UnbindMsg, InMsgType) == 0x000000, "Member 'AccountLink_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(AccountLink_UnbindMsg, InObject) == 0x000008, "Member 'AccountLink_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.AccountLink.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct AccountLink_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AccountLink_UnbindMsgAll) == 0x000008, "Wrong alignment on AccountLink_UnbindMsgAll");
static_assert(sizeof(AccountLink_UnbindMsgAll) == 0x000008, "Wrong size on AccountLink_UnbindMsgAll");
static_assert(offsetof(AccountLink_UnbindMsgAll, InObject) == 0x000000, "Member 'AccountLink_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.AccountLinkAll.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct AccountLinkAll_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AccountLinkAll_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on AccountLinkAll_BroadcastMsgBlueprint");
static_assert(sizeof(AccountLinkAll_BroadcastMsgBlueprint) == 0x000004, "Wrong size on AccountLinkAll_BroadcastMsgBlueprint");
static_assert(offsetof(AccountLinkAll_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'AccountLinkAll_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.AccountLinkAll.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct AccountLinkAll_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AccountLinkAll_UnbindMsg) == 0x000008, "Wrong alignment on AccountLinkAll_UnbindMsg");
static_assert(sizeof(AccountLinkAll_UnbindMsg) == 0x000010, "Wrong size on AccountLinkAll_UnbindMsg");
static_assert(offsetof(AccountLinkAll_UnbindMsg, InMsgType) == 0x000000, "Member 'AccountLinkAll_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(AccountLinkAll_UnbindMsg, InObject) == 0x000008, "Member 'AccountLinkAll_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.AccountLinkAll.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct AccountLinkAll_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AccountLinkAll_UnbindMsgAll) == 0x000008, "Wrong alignment on AccountLinkAll_UnbindMsgAll");
static_assert(sizeof(AccountLinkAll_UnbindMsgAll) == 0x000008, "Wrong size on AccountLinkAll_UnbindMsgAll");
static_assert(offsetof(AccountLinkAll_UnbindMsgAll, InObject) == 0x000000, "Member 'AccountLinkAll_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.AccountSession.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct AccountSession_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AccountSession_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on AccountSession_BroadcastMsgBlueprint");
static_assert(sizeof(AccountSession_BroadcastMsgBlueprint) == 0x000004, "Wrong size on AccountSession_BroadcastMsgBlueprint");
static_assert(offsetof(AccountSession_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'AccountSession_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.AccountSession.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct AccountSession_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AccountSession_UnbindMsg) == 0x000008, "Wrong alignment on AccountSession_UnbindMsg");
static_assert(sizeof(AccountSession_UnbindMsg) == 0x000010, "Wrong size on AccountSession_UnbindMsg");
static_assert(offsetof(AccountSession_UnbindMsg, InMsgType) == 0x000000, "Member 'AccountSession_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(AccountSession_UnbindMsg, InObject) == 0x000008, "Member 'AccountSession_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.AccountSession.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct AccountSession_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AccountSession_UnbindMsgAll) == 0x000008, "Wrong alignment on AccountSession_UnbindMsgAll");
static_assert(sizeof(AccountSession_UnbindMsgAll) == 0x000008, "Wrong size on AccountSession_UnbindMsgAll");
static_assert(offsetof(AccountSession_UnbindMsgAll, InObject) == 0x000000, "Member 'AccountSession_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBase.BindMsgOwner
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBase_BindMsgOwner final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBindMsgNode*                           InMsgDynamicDelegate;                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBase_BindMsgOwner) == 0x000008, "Wrong alignment on DCWidgetBase_BindMsgOwner");
static_assert(sizeof(DCWidgetBase_BindMsgOwner) == 0x000010, "Wrong size on DCWidgetBase_BindMsgOwner");
static_assert(offsetof(DCWidgetBase_BindMsgOwner, InMsgType) == 0x000000, "Member 'DCWidgetBase_BindMsgOwner::InMsgType' has a wrong offset!");
static_assert(offsetof(DCWidgetBase_BindMsgOwner, InMsgDynamicDelegate) == 0x000008, "Member 'DCWidgetBase_BindMsgOwner::InMsgDynamicDelegate' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCWidgetBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCWidgetBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCWidgetBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCWidgetBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCWidgetBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCWidgetBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBase.GetOwningBaseInterfaceBlueprint
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBase_GetOwningBaseInterfaceBlueprint final
{
public:
	TScriptInterface<class IBaseInterface>        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBase_GetOwningBaseInterfaceBlueprint) == 0x000008, "Wrong alignment on DCWidgetBase_GetOwningBaseInterfaceBlueprint");
static_assert(sizeof(DCWidgetBase_GetOwningBaseInterfaceBlueprint) == 0x000010, "Wrong size on DCWidgetBase_GetOwningBaseInterfaceBlueprint");
static_assert(offsetof(DCWidgetBase_GetOwningBaseInterfaceBlueprint, ReturnValue) == 0x000000, "Member 'DCWidgetBase_GetOwningBaseInterfaceBlueprint::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBase.IsSpectating
// 0x0001 (0x0001 - 0x0000)
struct DCWidgetBase_IsSpectating final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBase_IsSpectating) == 0x000001, "Wrong alignment on DCWidgetBase_IsSpectating");
static_assert(sizeof(DCWidgetBase_IsSpectating) == 0x000001, "Wrong size on DCWidgetBase_IsSpectating");
static_assert(offsetof(DCWidgetBase_IsSpectating, ReturnValue) == 0x000000, "Member 'DCWidgetBase_IsSpectating::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBase_UnbindMsg) == 0x000008, "Wrong alignment on DCWidgetBase_UnbindMsg");
static_assert(sizeof(DCWidgetBase_UnbindMsg) == 0x000010, "Wrong size on DCWidgetBase_UnbindMsg");
static_assert(offsetof(DCWidgetBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCWidgetBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCWidgetBase_UnbindMsg, InObject) == 0x000008, "Member 'DCWidgetBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCWidgetBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCWidgetBase_UnbindMsgAll");
static_assert(sizeof(DCWidgetBase_UnbindMsgAll) == 0x000008, "Wrong size on DCWidgetBase_UnbindMsgAll");
static_assert(offsetof(DCWidgetBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCWidgetBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBase.UnbindMsgOwner
// 0x0008 (0x0008 - 0x0000)
struct DCWidgetBase_UnbindMsgOwner final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBase_UnbindMsgOwner) == 0x000008, "Wrong alignment on DCWidgetBase_UnbindMsgOwner");
static_assert(sizeof(DCWidgetBase_UnbindMsgOwner) == 0x000008, "Wrong size on DCWidgetBase_UnbindMsgOwner");
static_assert(offsetof(DCWidgetBase_UnbindMsgOwner, InMsgType) == 0x000000, "Member 'DCWidgetBase_UnbindMsgOwner::InMsgType' has a wrong offset!");

// Function DungeonCrawler.DCInventoryBase.OnRep_Indexes
// 0x0010 (0x0010 - 0x0000)
struct DCInventoryBase_OnRep_Indexes final
{
public:
	TArray<int32>                                 OldIndexes;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInventoryBase_OnRep_Indexes) == 0x000008, "Wrong alignment on DCInventoryBase_OnRep_Indexes");
static_assert(sizeof(DCInventoryBase_OnRep_Indexes) == 0x000010, "Wrong size on DCInventoryBase_OnRep_Indexes");
static_assert(offsetof(DCInventoryBase_OnRep_Indexes, OldIndexes) == 0x000000, "Member 'DCInventoryBase_OnRep_Indexes::OldIndexes' has a wrong offset!");

// Function DungeonCrawler.DCInventoryBase.OnRep_Version
// 0x0028 (0x0028 - 0x0000)
struct DCInventoryBase_OnRep_Version final
{
public:
	struct FDCInventoryVersion                    OldVersion;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInventoryBase_OnRep_Version) == 0x000008, "Wrong alignment on DCInventoryBase_OnRep_Version");
static_assert(sizeof(DCInventoryBase_OnRep_Version) == 0x000028, "Wrong size on DCInventoryBase_OnRep_Version");
static_assert(offsetof(DCInventoryBase_OnRep_Version, OldVersion) == 0x000000, "Member 'DCInventoryBase_OnRep_Version::OldVersion' has a wrong offset!");

// Function DungeonCrawler.DCBoxInventory.OnRep_BoxSize
// 0x0008 (0x0008 - 0x0000)
struct DCBoxInventory_OnRep_BoxSize final
{
public:
	struct FIntPoint                              OldBoxSize;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCBoxInventory_OnRep_BoxSize) == 0x000004, "Wrong alignment on DCBoxInventory_OnRep_BoxSize");
static_assert(sizeof(DCBoxInventory_OnRep_BoxSize) == 0x000008, "Wrong size on DCBoxInventory_OnRep_BoxSize");
static_assert(offsetof(DCBoxInventory_OnRep_BoxSize, OldBoxSize) == 0x000000, "Member 'DCBoxInventory_OnRep_BoxSize::OldBoxSize' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.GetQualityLevel
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionsVideosSlotWidget_GetQualityLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsVideosSlotWidget_GetQualityLevel) == 0x000004, "Wrong alignment on GameMenuOptionsVideosSlotWidget_GetQualityLevel");
static_assert(sizeof(GameMenuOptionsVideosSlotWidget_GetQualityLevel) == 0x000004, "Wrong size on GameMenuOptionsVideosSlotWidget_GetQualityLevel");
static_assert(offsetof(GameMenuOptionsVideosSlotWidget_GetQualityLevel, ReturnValue) == 0x000000, "Member 'GameMenuOptionsVideosSlotWidget_GetQualityLevel::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnQualityLevel
// 0x0008 (0x0008 - 0x0000)
struct GameMenuOptionsVideosSlotWidget_OnQualityLevel final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldValue;                                          // 0x0004(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsVideosSlotWidget_OnQualityLevel) == 0x000004, "Wrong alignment on GameMenuOptionsVideosSlotWidget_OnQualityLevel");
static_assert(sizeof(GameMenuOptionsVideosSlotWidget_OnQualityLevel) == 0x000008, "Wrong size on GameMenuOptionsVideosSlotWidget_OnQualityLevel");
static_assert(offsetof(GameMenuOptionsVideosSlotWidget_OnQualityLevel, NewValue) == 0x000000, "Member 'GameMenuOptionsVideosSlotWidget_OnQualityLevel::NewValue' has a wrong offset!");
static_assert(offsetof(GameMenuOptionsVideosSlotWidget_OnQualityLevel, OldValue) == 0x000004, "Member 'GameMenuOptionsVideosSlotWidget_OnQualityLevel::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.SetQualityLevel
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionsVideosSlotWidget_SetQualityLevel final
{
public:
	int32                                         InQualityLevel;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsVideosSlotWidget_SetQualityLevel) == 0x000004, "Wrong alignment on GameMenuOptionsVideosSlotWidget_SetQualityLevel");
static_assert(sizeof(GameMenuOptionsVideosSlotWidget_SetQualityLevel) == 0x000004, "Wrong size on GameMenuOptionsVideosSlotWidget_SetQualityLevel");
static_assert(offsetof(GameMenuOptionsVideosSlotWidget_SetQualityLevel, InQualityLevel) == 0x000000, "Member 'GameMenuOptionsVideosSlotWidget_SetQualityLevel::InQualityLevel' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.SetTitle
// 0x0018 (0x0018 - 0x0000)
struct GameMenuOptionsVideosSlotWidget_SetTitle final
{
public:
	class FText                                   InTitle;                                           // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsVideosSlotWidget_SetTitle) == 0x000008, "Wrong alignment on GameMenuOptionsVideosSlotWidget_SetTitle");
static_assert(sizeof(GameMenuOptionsVideosSlotWidget_SetTitle) == 0x000018, "Wrong size on GameMenuOptionsVideosSlotWidget_SetTitle");
static_assert(offsetof(GameMenuOptionsVideosSlotWidget_SetTitle, InTitle) == 0x000000, "Member 'GameMenuOptionsVideosSlotWidget_SetTitle::InTitle' has a wrong offset!");

// Function DungeonCrawler.ArenaSelectSlotWidget.OnGameUserSettingControlsChanged
// 0x0088 (0x0088 - 0x0000)
struct ArenaSelectSlotWidget_OnGameUserSettingControlsChanged final
{
public:
	struct FGameUserSettingControls               InGameUserSettingControls;                         // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameUserSettingControls               InOldGameUserSettingControls;                      // 0x0040(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInForce;                                          // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2357[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ArenaSelectSlotWidget_OnGameUserSettingControlsChanged) == 0x000008, "Wrong alignment on ArenaSelectSlotWidget_OnGameUserSettingControlsChanged");
static_assert(sizeof(ArenaSelectSlotWidget_OnGameUserSettingControlsChanged) == 0x000088, "Wrong size on ArenaSelectSlotWidget_OnGameUserSettingControlsChanged");
static_assert(offsetof(ArenaSelectSlotWidget_OnGameUserSettingControlsChanged, InGameUserSettingControls) == 0x000000, "Member 'ArenaSelectSlotWidget_OnGameUserSettingControlsChanged::InGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(ArenaSelectSlotWidget_OnGameUserSettingControlsChanged, InOldGameUserSettingControls) == 0x000040, "Member 'ArenaSelectSlotWidget_OnGameUserSettingControlsChanged::InOldGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(ArenaSelectSlotWidget_OnGameUserSettingControlsChanged, bInForce) == 0x000080, "Member 'ArenaSelectSlotWidget_OnGameUserSettingControlsChanged::bInForce' has a wrong offset!");

// Function DungeonCrawler.ArenaSelectSlotWidget.CanJoin
// 0x0001 (0x0001 - 0x0000)
struct ArenaSelectSlotWidget_CanJoin final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArenaSelectSlotWidget_CanJoin) == 0x000001, "Wrong alignment on ArenaSelectSlotWidget_CanJoin");
static_assert(sizeof(ArenaSelectSlotWidget_CanJoin) == 0x000001, "Wrong size on ArenaSelectSlotWidget_CanJoin");
static_assert(offsetof(ArenaSelectSlotWidget_CanJoin, ReturnValue) == 0x000000, "Member 'ArenaSelectSlotWidget_CanJoin::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ArenaSelectSlotWidget.GetBeginTime
// 0x0008 (0x0008 - 0x0000)
struct ArenaSelectSlotWidget_GetBeginTime final
{
public:
	struct FDateTime                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArenaSelectSlotWidget_GetBeginTime) == 0x000008, "Wrong alignment on ArenaSelectSlotWidget_GetBeginTime");
static_assert(sizeof(ArenaSelectSlotWidget_GetBeginTime) == 0x000008, "Wrong size on ArenaSelectSlotWidget_GetBeginTime");
static_assert(offsetof(ArenaSelectSlotWidget_GetBeginTime, ReturnValue) == 0x000000, "Member 'ArenaSelectSlotWidget_GetBeginTime::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ArenaSelectSlotWidget.GetEndTime
// 0x0008 (0x0008 - 0x0000)
struct ArenaSelectSlotWidget_GetEndTime final
{
public:
	struct FDateTime                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArenaSelectSlotWidget_GetEndTime) == 0x000008, "Wrong alignment on ArenaSelectSlotWidget_GetEndTime");
static_assert(sizeof(ArenaSelectSlotWidget_GetEndTime) == 0x000008, "Wrong size on ArenaSelectSlotWidget_GetEndTime");
static_assert(offsetof(ArenaSelectSlotWidget_GetEndTime, ReturnValue) == 0x000000, "Member 'ArenaSelectSlotWidget_GetEndTime::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameModeAIControllerBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCGameModeAIControllerBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameModeAIControllerBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCGameModeAIControllerBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCGameModeAIControllerBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCGameModeAIControllerBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCGameModeAIControllerBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCGameModeAIControllerBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCGameModeAIControllerBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCGameModeAIControllerBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameModeAIControllerBase_UnbindMsg) == 0x000008, "Wrong alignment on DCGameModeAIControllerBase_UnbindMsg");
static_assert(sizeof(DCGameModeAIControllerBase_UnbindMsg) == 0x000010, "Wrong size on DCGameModeAIControllerBase_UnbindMsg");
static_assert(offsetof(DCGameModeAIControllerBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCGameModeAIControllerBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCGameModeAIControllerBase_UnbindMsg, InObject) == 0x000008, "Member 'DCGameModeAIControllerBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCGameModeAIControllerBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCGameModeAIControllerBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameModeAIControllerBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCGameModeAIControllerBase_UnbindMsgAll");
static_assert(sizeof(DCGameModeAIControllerBase_UnbindMsgAll) == 0x000008, "Wrong size on DCGameModeAIControllerBase_UnbindMsgAll");
static_assert(offsetof(DCGameModeAIControllerBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCGameModeAIControllerBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCue
// 0x0020 (0x0020 - 0x0000)
struct DCGameplayAbilityBase_AddGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_AddGameplayCue) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_AddGameplayCue");
static_assert(sizeof(DCGameplayAbilityBase_AddGameplayCue) == 0x000020, "Wrong size on DCGameplayAbilityBase_AddGameplayCue");
static_assert(offsetof(DCGameplayAbilityBase_AddGameplayCue, GameplayCueTag) == 0x000000, "Member 'DCGameplayAbilityBase_AddGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_AddGameplayCue, EffectContext) == 0x000008, "Member 'DCGameplayAbilityBase_AddGameplayCue::EffectContext' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueLocal
// 0x0020 (0x0020 - 0x0000)
struct DCGameplayAbilityBase_AddGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_AddGameplayCueLocal) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_AddGameplayCueLocal");
static_assert(sizeof(DCGameplayAbilityBase_AddGameplayCueLocal) == 0x000020, "Wrong size on DCGameplayAbilityBase_AddGameplayCueLocal");
static_assert(offsetof(DCGameplayAbilityBase_AddGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'DCGameplayAbilityBase_AddGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_AddGameplayCueLocal, EffectContext) == 0x000008, "Member 'DCGameplayAbilityBase_AddGameplayCueLocal::EffectContext' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueLocalWithParams
// 0x00E0 (0x00E0 - 0x0000)
struct DCGameplayAbilityBase_AddGameplayCueLocalWithParams final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Params_0;                                          // 0x0008(0x00D8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_AddGameplayCueLocalWithParams) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_AddGameplayCueLocalWithParams");
static_assert(sizeof(DCGameplayAbilityBase_AddGameplayCueLocalWithParams) == 0x0000E0, "Wrong size on DCGameplayAbilityBase_AddGameplayCueLocalWithParams");
static_assert(offsetof(DCGameplayAbilityBase_AddGameplayCueLocalWithParams, GameplayCueTag) == 0x000000, "Member 'DCGameplayAbilityBase_AddGameplayCueLocalWithParams::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_AddGameplayCueLocalWithParams, Params_0) == 0x000008, "Member 'DCGameplayAbilityBase_AddGameplayCueLocalWithParams::Params_0' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueWithParams
// 0x00E0 (0x00E0 - 0x0000)
struct DCGameplayAbilityBase_AddGameplayCueWithParams final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Params_0;                                          // 0x0008(0x00D8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_AddGameplayCueWithParams) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_AddGameplayCueWithParams");
static_assert(sizeof(DCGameplayAbilityBase_AddGameplayCueWithParams) == 0x0000E0, "Wrong size on DCGameplayAbilityBase_AddGameplayCueWithParams");
static_assert(offsetof(DCGameplayAbilityBase_AddGameplayCueWithParams, GameplayCueTag) == 0x000000, "Member 'DCGameplayAbilityBase_AddGameplayCueWithParams::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_AddGameplayCueWithParams, Params_0) == 0x000008, "Member 'DCGameplayAbilityBase_AddGameplayCueWithParams::Params_0' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainer
// 0x00D8 (0x00D8 - 0x0000)
struct DCGameplayAbilityBase_ApplyEffectContainer final
{
public:
	struct FGameplayTag                           ContainerTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         OverrideGameplayLevel;                             // 0x00B8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCountToApply;                                    // 0x00BC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsApplyTargetSelf;                                // 0x00C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235B[0x7];                                     // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x00C8(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_ApplyEffectContainer) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_ApplyEffectContainer");
static_assert(sizeof(DCGameplayAbilityBase_ApplyEffectContainer) == 0x0000D8, "Wrong size on DCGameplayAbilityBase_ApplyEffectContainer");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainer, ContainerTag) == 0x000000, "Member 'DCGameplayAbilityBase_ApplyEffectContainer::ContainerTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainer, EventData) == 0x000008, "Member 'DCGameplayAbilityBase_ApplyEffectContainer::EventData' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainer, OverrideGameplayLevel) == 0x0000B8, "Member 'DCGameplayAbilityBase_ApplyEffectContainer::OverrideGameplayLevel' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainer, InCountToApply) == 0x0000BC, "Member 'DCGameplayAbilityBase_ApplyEffectContainer::InCountToApply' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainer, bIsApplyTargetSelf) == 0x0000C0, "Member 'DCGameplayAbilityBase_ApplyEffectContainer::bIsApplyTargetSelf' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainer, ReturnValue) == 0x0000C8, "Member 'DCGameplayAbilityBase_ApplyEffectContainer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainerSpec
// 0x0060 (0x0060 - 0x0000)
struct DCGameplayAbilityBase_ApplyEffectContainerSpec final
{
public:
	struct FDCGameplayEffectContainerSpec         ContainerSpec;                                     // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InCountToApply;                                    // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsApplyTargetSelf;                                // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235C[0x3];                                     // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_ApplyEffectContainerSpec) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_ApplyEffectContainerSpec");
static_assert(sizeof(DCGameplayAbilityBase_ApplyEffectContainerSpec) == 0x000060, "Wrong size on DCGameplayAbilityBase_ApplyEffectContainerSpec");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainerSpec, ContainerSpec) == 0x000000, "Member 'DCGameplayAbilityBase_ApplyEffectContainerSpec::ContainerSpec' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainerSpec, InCountToApply) == 0x000048, "Member 'DCGameplayAbilityBase_ApplyEffectContainerSpec::InCountToApply' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainerSpec, bIsApplyTargetSelf) == 0x00004C, "Member 'DCGameplayAbilityBase_ApplyEffectContainerSpec::bIsApplyTargetSelf' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainerSpec, ReturnValue) == 0x000050, "Member 'DCGameplayAbilityBase_ApplyEffectContainerSpec::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainerSpecArray
// 0x00D8 (0x00D8 - 0x0000)
struct DCGameplayAbilityBase_ApplyEffectContainerSpecArray final
{
public:
	TArray<struct FDCGameplayEffectContainerSpec> OutContainerSpecArray;                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ContainerTag;                                      // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0018(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x00C8(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_ApplyEffectContainerSpecArray) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_ApplyEffectContainerSpecArray");
static_assert(sizeof(DCGameplayAbilityBase_ApplyEffectContainerSpecArray) == 0x0000D8, "Wrong size on DCGameplayAbilityBase_ApplyEffectContainerSpecArray");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainerSpecArray, OutContainerSpecArray) == 0x000000, "Member 'DCGameplayAbilityBase_ApplyEffectContainerSpecArray::OutContainerSpecArray' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainerSpecArray, ContainerTag) == 0x000010, "Member 'DCGameplayAbilityBase_ApplyEffectContainerSpecArray::ContainerTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainerSpecArray, EventData) == 0x000018, "Member 'DCGameplayAbilityBase_ApplyEffectContainerSpecArray::EventData' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyEffectContainerSpecArray, ReturnValue) == 0x0000C8, "Member 'DCGameplayAbilityBase_ApplyEffectContainerSpecArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.ApplyMovementModifier
// 0x0008 (0x0008 - 0x0000)
struct DCGameplayAbilityBase_ApplyMovementModifier final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_ApplyMovementModifier) == 0x000004, "Wrong alignment on DCGameplayAbilityBase_ApplyMovementModifier");
static_assert(sizeof(DCGameplayAbilityBase_ApplyMovementModifier) == 0x000008, "Wrong size on DCGameplayAbilityBase_ApplyMovementModifier");
static_assert(offsetof(DCGameplayAbilityBase_ApplyMovementModifier, EventTag) == 0x000000, "Member 'DCGameplayAbilityBase_ApplyMovementModifier::EventTag' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.ApplyPremadeSpecArray
// 0x00C8 (0x00C8 - 0x0000)
struct DCGameplayAbilityBase_ApplyPremadeSpecArray final
{
public:
	struct FGameplayTag                           ContainerTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x00B8(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_ApplyPremadeSpecArray) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_ApplyPremadeSpecArray");
static_assert(sizeof(DCGameplayAbilityBase_ApplyPremadeSpecArray) == 0x0000C8, "Wrong size on DCGameplayAbilityBase_ApplyPremadeSpecArray");
static_assert(offsetof(DCGameplayAbilityBase_ApplyPremadeSpecArray, ContainerTag) == 0x000000, "Member 'DCGameplayAbilityBase_ApplyPremadeSpecArray::ContainerTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyPremadeSpecArray, EventData) == 0x000008, "Member 'DCGameplayAbilityBase_ApplyPremadeSpecArray::EventData' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ApplyPremadeSpecArray, ReturnValue) == 0x0000B8, "Member 'DCGameplayAbilityBase_ApplyPremadeSpecArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.CopyPremadeSpecArray
// 0x0008 (0x0008 - 0x0000)
struct DCGameplayAbilityBase_CopyPremadeSpecArray final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_CopyPremadeSpecArray) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_CopyPremadeSpecArray");
static_assert(sizeof(DCGameplayAbilityBase_CopyPremadeSpecArray) == 0x000008, "Wrong size on DCGameplayAbilityBase_CopyPremadeSpecArray");
static_assert(offsetof(DCGameplayAbilityBase_CopyPremadeSpecArray, InActor) == 0x000000, "Member 'DCGameplayAbilityBase_CopyPremadeSpecArray::InActor' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCue
// 0x0020 (0x0020 - 0x0000)
struct DCGameplayAbilityBase_ExecuteGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_ExecuteGameplayCue) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_ExecuteGameplayCue");
static_assert(sizeof(DCGameplayAbilityBase_ExecuteGameplayCue) == 0x000020, "Wrong size on DCGameplayAbilityBase_ExecuteGameplayCue");
static_assert(offsetof(DCGameplayAbilityBase_ExecuteGameplayCue, GameplayCueTag) == 0x000000, "Member 'DCGameplayAbilityBase_ExecuteGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ExecuteGameplayCue, EffectContext) == 0x000008, "Member 'DCGameplayAbilityBase_ExecuteGameplayCue::EffectContext' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueLocal
// 0x0020 (0x0020 - 0x0000)
struct DCGameplayAbilityBase_ExecuteGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_ExecuteGameplayCueLocal) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_ExecuteGameplayCueLocal");
static_assert(sizeof(DCGameplayAbilityBase_ExecuteGameplayCueLocal) == 0x000020, "Wrong size on DCGameplayAbilityBase_ExecuteGameplayCueLocal");
static_assert(offsetof(DCGameplayAbilityBase_ExecuteGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'DCGameplayAbilityBase_ExecuteGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ExecuteGameplayCueLocal, EffectContext) == 0x000008, "Member 'DCGameplayAbilityBase_ExecuteGameplayCueLocal::EffectContext' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueLocalWithParams
// 0x00E0 (0x00E0 - 0x0000)
struct DCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Params_0;                                          // 0x0008(0x00D8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams");
static_assert(sizeof(DCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams) == 0x0000E0, "Wrong size on DCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams");
static_assert(offsetof(DCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams, GameplayCueTag) == 0x000000, "Member 'DCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams, Params_0) == 0x000008, "Member 'DCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams::Params_0' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueWithParams
// 0x00E0 (0x00E0 - 0x0000)
struct DCGameplayAbilityBase_ExecuteGameplayCueWithParams final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 Params_0;                                          // 0x0008(0x00D8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_ExecuteGameplayCueWithParams) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_ExecuteGameplayCueWithParams");
static_assert(sizeof(DCGameplayAbilityBase_ExecuteGameplayCueWithParams) == 0x0000E0, "Wrong size on DCGameplayAbilityBase_ExecuteGameplayCueWithParams");
static_assert(offsetof(DCGameplayAbilityBase_ExecuteGameplayCueWithParams, GameplayCueTag) == 0x000000, "Member 'DCGameplayAbilityBase_ExecuteGameplayCueWithParams::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_ExecuteGameplayCueWithParams, Params_0) == 0x000008, "Member 'DCGameplayAbilityBase_ExecuteGameplayCueWithParams::Params_0' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.GetEffectAssetTagsInEffectContainerArray
// 0x0028 (0x0028 - 0x0000)
struct DCGameplayAbilityBase_GetEffectAssetTagsInEffectContainerArray final
{
public:
	struct FGameplayTag                           InContainerTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0008(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_GetEffectAssetTagsInEffectContainerArray) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_GetEffectAssetTagsInEffectContainerArray");
static_assert(sizeof(DCGameplayAbilityBase_GetEffectAssetTagsInEffectContainerArray) == 0x000028, "Wrong size on DCGameplayAbilityBase_GetEffectAssetTagsInEffectContainerArray");
static_assert(offsetof(DCGameplayAbilityBase_GetEffectAssetTagsInEffectContainerArray, InContainerTag) == 0x000000, "Member 'DCGameplayAbilityBase_GetEffectAssetTagsInEffectContainerArray::InContainerTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_GetEffectAssetTagsInEffectContainerArray, ReturnValue) == 0x000008, "Member 'DCGameplayAbilityBase_GetEffectAssetTagsInEffectContainerArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.GetGameplayTriggerTag
// 0x000C (0x000C - 0x0000)
struct DCGameplayAbilityBase_GetGameplayTriggerTag final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_GetGameplayTriggerTag) == 0x000004, "Wrong alignment on DCGameplayAbilityBase_GetGameplayTriggerTag");
static_assert(sizeof(DCGameplayAbilityBase_GetGameplayTriggerTag) == 0x00000C, "Wrong size on DCGameplayAbilityBase_GetGameplayTriggerTag");
static_assert(offsetof(DCGameplayAbilityBase_GetGameplayTriggerTag, Param_Index) == 0x000000, "Member 'DCGameplayAbilityBase_GetGameplayTriggerTag::Param_Index' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_GetGameplayTriggerTag, ReturnValue) == 0x000004, "Member 'DCGameplayAbilityBase_GetGameplayTriggerTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.GetSetByCallerValueInEffectContainerArray
// 0x0014 (0x0014 - 0x0000)
struct DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray final
{
public:
	struct FGameplayTag                           ContainerTag;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SetByCallerDataTag;                                // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray) == 0x000004, "Wrong alignment on DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray");
static_assert(sizeof(DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray) == 0x000014, "Wrong size on DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray");
static_assert(offsetof(DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray, ContainerTag) == 0x000000, "Member 'DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray::ContainerTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray, SetByCallerDataTag) == 0x000008, "Member 'DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray::SetByCallerDataTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray, ReturnValue) == 0x000010, "Member 'DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerPremadeSpec
// 0x00C8 (0x00C8 - 0x0000)
struct DCGameplayAbilityBase_MakeEffectContainerPremadeSpec final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ContainerTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0010(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         OverrideGameplayLevel;                             // 0x00C0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235D[0x4];                                     // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGameplayAbilityBase_MakeEffectContainerPremadeSpec) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_MakeEffectContainerPremadeSpec");
static_assert(sizeof(DCGameplayAbilityBase_MakeEffectContainerPremadeSpec) == 0x0000C8, "Wrong size on DCGameplayAbilityBase_MakeEffectContainerPremadeSpec");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerPremadeSpec, InActor) == 0x000000, "Member 'DCGameplayAbilityBase_MakeEffectContainerPremadeSpec::InActor' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerPremadeSpec, ContainerTag) == 0x000008, "Member 'DCGameplayAbilityBase_MakeEffectContainerPremadeSpec::ContainerTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerPremadeSpec, EventData) == 0x000010, "Member 'DCGameplayAbilityBase_MakeEffectContainerPremadeSpec::EventData' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerPremadeSpec, OverrideGameplayLevel) == 0x0000C0, "Member 'DCGameplayAbilityBase_MakeEffectContainerPremadeSpec::OverrideGameplayLevel' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerSpec
// 0x00D0 (0x00D0 - 0x0000)
struct DCGameplayAbilityBase_MakeEffectContainerSpec final
{
public:
	TArray<struct FDCGameplayEffectContainerSpec> OutContainerSpecArray;                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ContainerTag;                                      // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0018(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         OverrideGameplayLevel;                             // 0x00C8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235E[0x4];                                     // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGameplayAbilityBase_MakeEffectContainerSpec) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_MakeEffectContainerSpec");
static_assert(sizeof(DCGameplayAbilityBase_MakeEffectContainerSpec) == 0x0000D0, "Wrong size on DCGameplayAbilityBase_MakeEffectContainerSpec");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerSpec, OutContainerSpecArray) == 0x000000, "Member 'DCGameplayAbilityBase_MakeEffectContainerSpec::OutContainerSpecArray' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerSpec, ContainerTag) == 0x000010, "Member 'DCGameplayAbilityBase_MakeEffectContainerSpec::ContainerTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerSpec, EventData) == 0x000018, "Member 'DCGameplayAbilityBase_MakeEffectContainerSpec::EventData' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerSpec, OverrideGameplayLevel) == 0x0000C8, "Member 'DCGameplayAbilityBase_MakeEffectContainerSpec::OverrideGameplayLevel' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerSpecFromContainer
// 0x0140 (0x0140 - 0x0000)
struct DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer final
{
public:
	TArray<struct FDCGameplayEffectContainerSpec> OutContainerSpecArray;                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectContainer             Container;                                         // 0x0010(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0088(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         OverrideGameplayLevel;                             // 0x0138(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235F[0x4];                                     // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer) == 0x000008, "Wrong alignment on DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer");
static_assert(sizeof(DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer) == 0x000140, "Wrong size on DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer, OutContainerSpecArray) == 0x000000, "Member 'DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer::OutContainerSpecArray' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer, Container) == 0x000010, "Member 'DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer::Container' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer, EventData) == 0x000088, "Member 'DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer::EventData' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer, OverrideGameplayLevel) == 0x000138, "Member 'DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer::OverrideGameplayLevel' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.RemoveGameplayCue
// 0x0008 (0x0008 - 0x0000)
struct DCGameplayAbilityBase_RemoveGameplayCue final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_RemoveGameplayCue) == 0x000004, "Wrong alignment on DCGameplayAbilityBase_RemoveGameplayCue");
static_assert(sizeof(DCGameplayAbilityBase_RemoveGameplayCue) == 0x000008, "Wrong size on DCGameplayAbilityBase_RemoveGameplayCue");
static_assert(offsetof(DCGameplayAbilityBase_RemoveGameplayCue, GameplayCueTag) == 0x000000, "Member 'DCGameplayAbilityBase_RemoveGameplayCue::GameplayCueTag' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.RemoveGameplayCueLocal
// 0x0008 (0x0008 - 0x0000)
struct DCGameplayAbilityBase_RemoveGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_RemoveGameplayCueLocal) == 0x000004, "Wrong alignment on DCGameplayAbilityBase_RemoveGameplayCueLocal");
static_assert(sizeof(DCGameplayAbilityBase_RemoveGameplayCueLocal) == 0x000008, "Wrong size on DCGameplayAbilityBase_RemoveGameplayCueLocal");
static_assert(offsetof(DCGameplayAbilityBase_RemoveGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'DCGameplayAbilityBase_RemoveGameplayCueLocal::GameplayCueTag' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.RemoveMovementModifier
// 0x0008 (0x0008 - 0x0000)
struct DCGameplayAbilityBase_RemoveMovementModifier final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayAbilityBase_RemoveMovementModifier) == 0x000004, "Wrong alignment on DCGameplayAbilityBase_RemoveMovementModifier");
static_assert(sizeof(DCGameplayAbilityBase_RemoveMovementModifier) == 0x000008, "Wrong size on DCGameplayAbilityBase_RemoveMovementModifier");
static_assert(offsetof(DCGameplayAbilityBase_RemoveMovementModifier, EventTag) == 0x000000, "Member 'DCGameplayAbilityBase_RemoveMovementModifier::EventTag' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.HasMovementModifier
// 0x000C (0x000C - 0x0000)
struct DCGameplayAbilityBase_HasMovementModifier final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2360[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGameplayAbilityBase_HasMovementModifier) == 0x000004, "Wrong alignment on DCGameplayAbilityBase_HasMovementModifier");
static_assert(sizeof(DCGameplayAbilityBase_HasMovementModifier) == 0x00000C, "Wrong size on DCGameplayAbilityBase_HasMovementModifier");
static_assert(offsetof(DCGameplayAbilityBase_HasMovementModifier, EventTag) == 0x000000, "Member 'DCGameplayAbilityBase_HasMovementModifier::EventTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_HasMovementModifier, ReturnValue) == 0x000008, "Member 'DCGameplayAbilityBase_HasMovementModifier::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayAbilityBase.IsMovementModifierApplied
// 0x000C (0x000C - 0x0000)
struct DCGameplayAbilityBase_IsMovementModifierApplied final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2361[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGameplayAbilityBase_IsMovementModifierApplied) == 0x000004, "Wrong alignment on DCGameplayAbilityBase_IsMovementModifierApplied");
static_assert(sizeof(DCGameplayAbilityBase_IsMovementModifierApplied) == 0x00000C, "Wrong size on DCGameplayAbilityBase_IsMovementModifierApplied");
static_assert(offsetof(DCGameplayAbilityBase_IsMovementModifierApplied, EventTag) == 0x000000, "Member 'DCGameplayAbilityBase_IsMovementModifierApplied::EventTag' has a wrong offset!");
static_assert(offsetof(DCGameplayAbilityBase_IsMovementModifierApplied, ReturnValue) == 0x000008, "Member 'DCGameplayAbilityBase_IsMovementModifierApplied::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_Interact.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_Interact_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_Interact_EventReceived) == 0x000008, "Wrong alignment on GA_Interact_EventReceived");
static_assert(sizeof(GA_Interact_EventReceived) == 0x0000B8, "Wrong size on GA_Interact_EventReceived");
static_assert(offsetof(GA_Interact_EventReceived, EventTag) == 0x000000, "Member 'GA_Interact_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_Interact_EventReceived, EventData) == 0x000008, "Member 'GA_Interact_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_Interact.IsValidData
// 0x00B8 (0x00B8 - 0x0000)
struct GA_Interact_IsValidData final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2363[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_Interact_IsValidData) == 0x000008, "Wrong alignment on GA_Interact_IsValidData");
static_assert(sizeof(GA_Interact_IsValidData) == 0x0000B8, "Wrong size on GA_Interact_IsValidData");
static_assert(offsetof(GA_Interact_IsValidData, EventData) == 0x000000, "Member 'GA_Interact_IsValidData::EventData' has a wrong offset!");
static_assert(offsetof(GA_Interact_IsValidData, ReturnValue) == 0x0000B0, "Member 'GA_Interact_IsValidData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_Interact.OnSkillCheckFinished
// 0x0001 (0x0001 - 0x0000)
struct GA_Interact_OnSkillCheckFinished final
{
public:
	ESkillCheckResult                             Result;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_Interact_OnSkillCheckFinished) == 0x000001, "Wrong alignment on GA_Interact_OnSkillCheckFinished");
static_assert(sizeof(GA_Interact_OnSkillCheckFinished) == 0x000001, "Wrong size on GA_Interact_OnSkillCheckFinished");
static_assert(offsetof(GA_Interact_OnSkillCheckFinished, Result) == 0x000000, "Member 'GA_Interact_OnSkillCheckFinished::Result' has a wrong offset!");

// Function DungeonCrawler.DCExpressmanComponent.ShowSystemMessage_Client
// 0x0018 (0x0018 - 0x0000)
struct DCExpressmanComponent_ShowSystemMessage_Client final
{
public:
	class FText                                   InMsg;                                             // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCExpressmanComponent_ShowSystemMessage_Client) == 0x000008, "Wrong alignment on DCExpressmanComponent_ShowSystemMessage_Client");
static_assert(sizeof(DCExpressmanComponent_ShowSystemMessage_Client) == 0x000018, "Wrong size on DCExpressmanComponent_ShowSystemMessage_Client");
static_assert(offsetof(DCExpressmanComponent_ShowSystemMessage_Client, InMsg) == 0x000000, "Member 'DCExpressmanComponent_ShowSystemMessage_Client::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCActorBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCActorBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActorBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCActorBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCActorBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCActorBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCActorBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCActorBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCActorBase.HasActorBegunPlayBlueprint
// 0x0001 (0x0001 - 0x0000)
struct DCActorBase_HasActorBegunPlayBlueprint final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActorBase_HasActorBegunPlayBlueprint) == 0x000001, "Wrong alignment on DCActorBase_HasActorBegunPlayBlueprint");
static_assert(sizeof(DCActorBase_HasActorBegunPlayBlueprint) == 0x000001, "Wrong size on DCActorBase_HasActorBegunPlayBlueprint");
static_assert(offsetof(DCActorBase_HasActorBegunPlayBlueprint, ReturnValue) == 0x000000, "Member 'DCActorBase_HasActorBegunPlayBlueprint::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCActorBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCActorBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActorBase_UnbindMsg) == 0x000008, "Wrong alignment on DCActorBase_UnbindMsg");
static_assert(sizeof(DCActorBase_UnbindMsg) == 0x000010, "Wrong size on DCActorBase_UnbindMsg");
static_assert(offsetof(DCActorBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCActorBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCActorBase_UnbindMsg, InObject) == 0x000008, "Member 'DCActorBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCActorBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCActorBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActorBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCActorBase_UnbindMsgAll");
static_assert(sizeof(DCActorBase_UnbindMsgAll) == 0x000008, "Wrong size on DCActorBase_UnbindMsgAll");
static_assert(offsetof(DCActorBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCActorBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCInteractableActorBase.InteractFailed
// 0x0010 (0x0010 - 0x0000)
struct DCInteractableActorBase_InteractFailed final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInteractableActorBase_InteractFailed) == 0x000008, "Wrong alignment on DCInteractableActorBase_InteractFailed");
static_assert(sizeof(DCInteractableActorBase_InteractFailed) == 0x000010, "Wrong size on DCInteractableActorBase_InteractFailed");
static_assert(offsetof(DCInteractableActorBase_InteractFailed, Interacter) == 0x000000, "Member 'DCInteractableActorBase_InteractFailed::Interacter' has a wrong offset!");
static_assert(offsetof(DCInteractableActorBase_InteractFailed, EventTag) == 0x000008, "Member 'DCInteractableActorBase_InteractFailed::EventTag' has a wrong offset!");

// Function DungeonCrawler.DCInteractableActorBase.InteractFound
// 0x0010 (0x0010 - 0x0000)
struct DCInteractableActorBase_InteractFound final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    InteractPart;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInteractableActorBase_InteractFound) == 0x000008, "Wrong alignment on DCInteractableActorBase_InteractFound");
static_assert(sizeof(DCInteractableActorBase_InteractFound) == 0x000010, "Wrong size on DCInteractableActorBase_InteractFound");
static_assert(offsetof(DCInteractableActorBase_InteractFound, Interacter) == 0x000000, "Member 'DCInteractableActorBase_InteractFound::Interacter' has a wrong offset!");
static_assert(offsetof(DCInteractableActorBase_InteractFound, InteractPart) == 0x000008, "Member 'DCInteractableActorBase_InteractFound::InteractPart' has a wrong offset!");

// Function DungeonCrawler.DCInteractableActorBase.InteractLost
// 0x0008 (0x0008 - 0x0000)
struct DCInteractableActorBase_InteractLost final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInteractableActorBase_InteractLost) == 0x000008, "Wrong alignment on DCInteractableActorBase_InteractLost");
static_assert(sizeof(DCInteractableActorBase_InteractLost) == 0x000008, "Wrong size on DCInteractableActorBase_InteractLost");
static_assert(offsetof(DCInteractableActorBase_InteractLost, Interacter) == 0x000000, "Member 'DCInteractableActorBase_InteractLost::Interacter' has a wrong offset!");

// Function DungeonCrawler.DCInteractableActorBase.InteractStarted
// 0x0010 (0x0010 - 0x0000)
struct DCInteractableActorBase_InteractStarted final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInteractableActorBase_InteractStarted) == 0x000008, "Wrong alignment on DCInteractableActorBase_InteractStarted");
static_assert(sizeof(DCInteractableActorBase_InteractStarted) == 0x000010, "Wrong size on DCInteractableActorBase_InteractStarted");
static_assert(offsetof(DCInteractableActorBase_InteractStarted, Interacter) == 0x000000, "Member 'DCInteractableActorBase_InteractStarted::Interacter' has a wrong offset!");
static_assert(offsetof(DCInteractableActorBase_InteractStarted, EventTag) == 0x000008, "Member 'DCInteractableActorBase_InteractStarted::EventTag' has a wrong offset!");

// Function DungeonCrawler.DCInteractableActorBase.InteractSucceed
// 0x0100 (0x0100 - 0x0000)
struct DCInteractableActorBase_InteractSucceed final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StateTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TriggerTag;                                        // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0018(0x00E8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInteractableActorBase_InteractSucceed) == 0x000008, "Wrong alignment on DCInteractableActorBase_InteractSucceed");
static_assert(sizeof(DCInteractableActorBase_InteractSucceed) == 0x000100, "Wrong size on DCInteractableActorBase_InteractSucceed");
static_assert(offsetof(DCInteractableActorBase_InteractSucceed, Interacter) == 0x000000, "Member 'DCInteractableActorBase_InteractSucceed::Interacter' has a wrong offset!");
static_assert(offsetof(DCInteractableActorBase_InteractSucceed, StateTag) == 0x000008, "Member 'DCInteractableActorBase_InteractSucceed::StateTag' has a wrong offset!");
static_assert(offsetof(DCInteractableActorBase_InteractSucceed, TriggerTag) == 0x000010, "Member 'DCInteractableActorBase_InteractSucceed::TriggerTag' has a wrong offset!");
static_assert(offsetof(DCInteractableActorBase_InteractSucceed, HitResult) == 0x000018, "Member 'DCInteractableActorBase_InteractSucceed::HitResult' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.CheckQuestUseItem
// 0x0108 (0x0108 - 0x0000)
struct PropsActorBase_CheckQuestUseItem final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              ItemData;                                          // 0x0008(0x0100)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_CheckQuestUseItem) == 0x000008, "Wrong alignment on PropsActorBase_CheckQuestUseItem");
static_assert(sizeof(PropsActorBase_CheckQuestUseItem) == 0x000108, "Wrong size on PropsActorBase_CheckQuestUseItem");
static_assert(offsetof(PropsActorBase_CheckQuestUseItem, Interacter) == 0x000000, "Member 'PropsActorBase_CheckQuestUseItem::Interacter' has a wrong offset!");
static_assert(offsetof(PropsActorBase_CheckQuestUseItem, ItemData) == 0x000008, "Member 'PropsActorBase_CheckQuestUseItem::ItemData' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.GameplayTagUpdated
// 0x000C (0x000C - 0x0000)
struct PropsActorBase_GameplayTagUpdated final
{
public:
	struct FGameplayTag                           InGameplayTag;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_GameplayTagUpdated) == 0x000004, "Wrong alignment on PropsActorBase_GameplayTagUpdated");
static_assert(sizeof(PropsActorBase_GameplayTagUpdated) == 0x00000C, "Wrong size on PropsActorBase_GameplayTagUpdated");
static_assert(offsetof(PropsActorBase_GameplayTagUpdated, InGameplayTag) == 0x000000, "Member 'PropsActorBase_GameplayTagUpdated::InGameplayTag' has a wrong offset!");
static_assert(offsetof(PropsActorBase_GameplayTagUpdated, InCount) == 0x000008, "Member 'PropsActorBase_GameplayTagUpdated::InCount' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.GetDesignDataAssetProps
// 0x0008 (0x0008 - 0x0000)
struct PropsActorBase_GetDesignDataAssetProps final
{
public:
	const class UDesignDataAssetProps*            ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_GetDesignDataAssetProps) == 0x000008, "Wrong alignment on PropsActorBase_GetDesignDataAssetProps");
static_assert(sizeof(PropsActorBase_GetDesignDataAssetProps) == 0x000008, "Wrong size on PropsActorBase_GetDesignDataAssetProps");
static_assert(offsetof(PropsActorBase_GetDesignDataAssetProps, ReturnValue) == 0x000000, "Member 'PropsActorBase_GetDesignDataAssetProps::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.GetDesignDataProps
// 0x00B0 (0x00B0 - 0x0000)
struct PropsActorBase_GetDesignDataProps final
{
public:
	struct FDesignDataProps                       ReturnValue;                                       // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_GetDesignDataProps) == 0x000008, "Wrong alignment on PropsActorBase_GetDesignDataProps");
static_assert(sizeof(PropsActorBase_GetDesignDataProps) == 0x0000B0, "Wrong size on PropsActorBase_GetDesignDataProps");
static_assert(offsetof(PropsActorBase_GetDesignDataProps, ReturnValue) == 0x000000, "Member 'PropsActorBase_GetDesignDataProps::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.GetPropsId
// 0x0010 (0x0010 - 0x0000)
struct PropsActorBase_GetPropsId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_GetPropsId) == 0x000004, "Wrong alignment on PropsActorBase_GetPropsId");
static_assert(sizeof(PropsActorBase_GetPropsId) == 0x000010, "Wrong size on PropsActorBase_GetPropsId");
static_assert(offsetof(PropsActorBase_GetPropsId, ReturnValue) == 0x000000, "Member 'PropsActorBase_GetPropsId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.IsNetLoadOnClient
// 0x0001 (0x0001 - 0x0000)
struct PropsActorBase_IsNetLoadOnClient final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_IsNetLoadOnClient) == 0x000001, "Wrong alignment on PropsActorBase_IsNetLoadOnClient");
static_assert(sizeof(PropsActorBase_IsNetLoadOnClient) == 0x000001, "Wrong size on PropsActorBase_IsNetLoadOnClient");
static_assert(offsetof(PropsActorBase_IsNetLoadOnClient, ReturnValue) == 0x000000, "Member 'PropsActorBase_IsNetLoadOnClient::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.OnImpactEnduranceExhausted
// 0x0430 (0x0430 - 0x0000)
struct PropsActorBase_OnImpactEnduranceExhausted final
{
public:
	float                                         ExhaustedTime;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_236D[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0010(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_OnImpactEnduranceExhausted) == 0x000008, "Wrong alignment on PropsActorBase_OnImpactEnduranceExhausted");
static_assert(sizeof(PropsActorBase_OnImpactEnduranceExhausted) == 0x000430, "Wrong size on PropsActorBase_OnImpactEnduranceExhausted");
static_assert(offsetof(PropsActorBase_OnImpactEnduranceExhausted, ExhaustedTime) == 0x000000, "Member 'PropsActorBase_OnImpactEnduranceExhausted::ExhaustedTime' has a wrong offset!");
static_assert(offsetof(PropsActorBase_OnImpactEnduranceExhausted, GameplayEffectClass) == 0x000008, "Member 'PropsActorBase_OnImpactEnduranceExhausted::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(PropsActorBase_OnImpactEnduranceExhausted, EffectContext) == 0x000010, "Member 'PropsActorBase_OnImpactEnduranceExhausted::EffectContext' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.SetPropsId
// 0x0010 (0x0010 - 0x0000)
struct PropsActorBase_SetPropsId final
{
public:
	struct FPrimaryAssetId                        InPropsId;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_SetPropsId) == 0x000004, "Wrong alignment on PropsActorBase_SetPropsId");
static_assert(sizeof(PropsActorBase_SetPropsId) == 0x000010, "Wrong size on PropsActorBase_SetPropsId");
static_assert(offsetof(PropsActorBase_SetPropsId, InPropsId) == 0x000000, "Member 'PropsActorBase_SetPropsId::InPropsId' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.SetSoundData
// 0x0010 (0x0010 - 0x0000)
struct PropsActorBase_SetSoundData final
{
public:
	struct FPrimaryAssetId                        InSoundDataId;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_SetSoundData) == 0x000004, "Wrong alignment on PropsActorBase_SetSoundData");
static_assert(sizeof(PropsActorBase_SetSoundData) == 0x000010, "Wrong size on PropsActorBase_SetSoundData");
static_assert(offsetof(PropsActorBase_SetSoundData, InSoundDataId) == 0x000000, "Member 'PropsActorBase_SetSoundData::InSoundDataId' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.StartLooting
// 0x00F0 (0x00F0 - 0x0000)
struct PropsActorBase_StartLooting final
{
public:
	class ADCPlayerCharacterBase*                 Looter;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_StartLooting) == 0x000008, "Wrong alignment on PropsActorBase_StartLooting");
static_assert(sizeof(PropsActorBase_StartLooting) == 0x0000F0, "Wrong size on PropsActorBase_StartLooting");
static_assert(offsetof(PropsActorBase_StartLooting, Looter) == 0x000000, "Member 'PropsActorBase_StartLooting::Looter' has a wrong offset!");
static_assert(offsetof(PropsActorBase_StartLooting, HitResult) == 0x000008, "Member 'PropsActorBase_StartLooting::HitResult' has a wrong offset!");

// Function DungeonCrawler.PropsActorBase.UpdateInteractDepthValue
// 0x0004 (0x0004 - 0x0000)
struct PropsActorBase_UpdateInteractDepthValue final
{
public:
	int32                                         DepthValue;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PropsActorBase_UpdateInteractDepthValue) == 0x000004, "Wrong alignment on PropsActorBase_UpdateInteractDepthValue");
static_assert(sizeof(PropsActorBase_UpdateInteractDepthValue) == 0x000004, "Wrong size on PropsActorBase_UpdateInteractDepthValue");
static_assert(offsetof(PropsActorBase_UpdateInteractDepthValue, DepthValue) == 0x000000, "Member 'PropsActorBase_UpdateInteractDepthValue::DepthValue' has a wrong offset!");

// Function DungeonCrawler.FloorPortalScrollBase.ClosePortalScroll
// 0x0008 (0x0008 - 0x0000)
struct FloorPortalScrollBase_ClosePortalScroll final
{
public:
	class ADCPlayerCharacterBase*                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FloorPortalScrollBase_ClosePortalScroll) == 0x000008, "Wrong alignment on FloorPortalScrollBase_ClosePortalScroll");
static_assert(sizeof(FloorPortalScrollBase_ClosePortalScroll) == 0x000008, "Wrong size on FloorPortalScrollBase_ClosePortalScroll");
static_assert(offsetof(FloorPortalScrollBase_ClosePortalScroll, Character) == 0x000000, "Member 'FloorPortalScrollBase_ClosePortalScroll::Character' has a wrong offset!");

// Function DungeonCrawler.LobbyUserSlotBase.SetNicknameBlueprint
// 0x0040 (0x0040 - 0x0000)
struct LobbyUserSlotBase_SetNicknameBlueprint final
{
public:
	struct FNickname                              InNickName;                                        // 0x0000(0x0040)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LobbyUserSlotBase_SetNicknameBlueprint) == 0x000008, "Wrong alignment on LobbyUserSlotBase_SetNicknameBlueprint");
static_assert(sizeof(LobbyUserSlotBase_SetNicknameBlueprint) == 0x000040, "Wrong size on LobbyUserSlotBase_SetNicknameBlueprint");
static_assert(offsetof(LobbyUserSlotBase_SetNicknameBlueprint, InNickName) == 0x000000, "Member 'LobbyUserSlotBase_SetNicknameBlueprint::InNickName' has a wrong offset!");

// Function DungeonCrawler.DCCommonActivatableWidgetBase.BindMsgOwner
// 0x0010 (0x0010 - 0x0000)
struct DCCommonActivatableWidgetBase_BindMsgOwner final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBindMsgNode*                           InMsgDynamicDelegate;                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonActivatableWidgetBase_BindMsgOwner) == 0x000008, "Wrong alignment on DCCommonActivatableWidgetBase_BindMsgOwner");
static_assert(sizeof(DCCommonActivatableWidgetBase_BindMsgOwner) == 0x000010, "Wrong size on DCCommonActivatableWidgetBase_BindMsgOwner");
static_assert(offsetof(DCCommonActivatableWidgetBase_BindMsgOwner, InMsgType) == 0x000000, "Member 'DCCommonActivatableWidgetBase_BindMsgOwner::InMsgType' has a wrong offset!");
static_assert(offsetof(DCCommonActivatableWidgetBase_BindMsgOwner, InMsgDynamicDelegate) == 0x000008, "Member 'DCCommonActivatableWidgetBase_BindMsgOwner::InMsgDynamicDelegate' has a wrong offset!");

// Function DungeonCrawler.DCCommonActivatableWidgetBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCCommonActivatableWidgetBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonActivatableWidgetBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCCommonActivatableWidgetBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCCommonActivatableWidgetBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCCommonActivatableWidgetBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCCommonActivatableWidgetBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCCommonActivatableWidgetBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCCommonActivatableWidgetBase.GetOwningBaseInterfaceBlueprint
// 0x0010 (0x0010 - 0x0000)
struct DCCommonActivatableWidgetBase_GetOwningBaseInterfaceBlueprint final
{
public:
	TScriptInterface<class IBaseInterface>        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonActivatableWidgetBase_GetOwningBaseInterfaceBlueprint) == 0x000008, "Wrong alignment on DCCommonActivatableWidgetBase_GetOwningBaseInterfaceBlueprint");
static_assert(sizeof(DCCommonActivatableWidgetBase_GetOwningBaseInterfaceBlueprint) == 0x000010, "Wrong size on DCCommonActivatableWidgetBase_GetOwningBaseInterfaceBlueprint");
static_assert(offsetof(DCCommonActivatableWidgetBase_GetOwningBaseInterfaceBlueprint, ReturnValue) == 0x000000, "Member 'DCCommonActivatableWidgetBase_GetOwningBaseInterfaceBlueprint::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCommonActivatableWidgetBase.IsSpectating
// 0x0001 (0x0001 - 0x0000)
struct DCCommonActivatableWidgetBase_IsSpectating final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonActivatableWidgetBase_IsSpectating) == 0x000001, "Wrong alignment on DCCommonActivatableWidgetBase_IsSpectating");
static_assert(sizeof(DCCommonActivatableWidgetBase_IsSpectating) == 0x000001, "Wrong size on DCCommonActivatableWidgetBase_IsSpectating");
static_assert(offsetof(DCCommonActivatableWidgetBase_IsSpectating, ReturnValue) == 0x000000, "Member 'DCCommonActivatableWidgetBase_IsSpectating::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCommonActivatableWidgetBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCCommonActivatableWidgetBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonActivatableWidgetBase_UnbindMsg) == 0x000008, "Wrong alignment on DCCommonActivatableWidgetBase_UnbindMsg");
static_assert(sizeof(DCCommonActivatableWidgetBase_UnbindMsg) == 0x000010, "Wrong size on DCCommonActivatableWidgetBase_UnbindMsg");
static_assert(offsetof(DCCommonActivatableWidgetBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCCommonActivatableWidgetBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCCommonActivatableWidgetBase_UnbindMsg, InObject) == 0x000008, "Member 'DCCommonActivatableWidgetBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCCommonActivatableWidgetBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCCommonActivatableWidgetBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonActivatableWidgetBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCCommonActivatableWidgetBase_UnbindMsgAll");
static_assert(sizeof(DCCommonActivatableWidgetBase_UnbindMsgAll) == 0x000008, "Wrong size on DCCommonActivatableWidgetBase_UnbindMsgAll");
static_assert(offsetof(DCCommonActivatableWidgetBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCCommonActivatableWidgetBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCCommonActivatableWidgetBase.UnbindMsgOwner
// 0x0008 (0x0008 - 0x0000)
struct DCCommonActivatableWidgetBase_UnbindMsgOwner final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonActivatableWidgetBase_UnbindMsgOwner) == 0x000008, "Wrong alignment on DCCommonActivatableWidgetBase_UnbindMsgOwner");
static_assert(sizeof(DCCommonActivatableWidgetBase_UnbindMsgOwner) == 0x000008, "Wrong size on DCCommonActivatableWidgetBase_UnbindMsgOwner");
static_assert(offsetof(DCCommonActivatableWidgetBase_UnbindMsgOwner, InMsgType) == 0x000000, "Member 'DCCommonActivatableWidgetBase_UnbindMsgOwner::InMsgType' has a wrong offset!");

// Function DungeonCrawler.GameGroupWidgetBase.OnGroupWidgetVisibilityChanged
// 0x0001 (0x0001 - 0x0000)
struct GameGroupWidgetBase_OnGroupWidgetVisibilityChanged final
{
public:
	ESlateVisibility                              NewVisibility;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameGroupWidgetBase_OnGroupWidgetVisibilityChanged) == 0x000001, "Wrong alignment on GameGroupWidgetBase_OnGroupWidgetVisibilityChanged");
static_assert(sizeof(GameGroupWidgetBase_OnGroupWidgetVisibilityChanged) == 0x000001, "Wrong size on GameGroupWidgetBase_OnGroupWidgetVisibilityChanged");
static_assert(offsetof(GameGroupWidgetBase_OnGroupWidgetVisibilityChanged, NewVisibility) == 0x000000, "Member 'GameGroupWidgetBase_OnGroupWidgetVisibilityChanged::NewVisibility' has a wrong offset!");

// Function DungeonCrawler.GameMusicSelectGroupWidget.OnCurrentMusicSlotChanged
// 0x0008 (0x0008 - 0x0000)
struct GameMusicSelectGroupWidget_OnCurrentMusicSlotChanged final
{
public:
	class UGameMusicSlotWidget*                   InSelectedSlot;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMusicSelectGroupWidget_OnCurrentMusicSlotChanged) == 0x000008, "Wrong alignment on GameMusicSelectGroupWidget_OnCurrentMusicSlotChanged");
static_assert(sizeof(GameMusicSelectGroupWidget_OnCurrentMusicSlotChanged) == 0x000008, "Wrong size on GameMusicSelectGroupWidget_OnCurrentMusicSlotChanged");
static_assert(offsetof(GameMusicSelectGroupWidget_OnCurrentMusicSlotChanged, InSelectedSlot) == 0x000000, "Member 'GameMusicSelectGroupWidget_OnCurrentMusicSlotChanged::InSelectedSlot' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct EquipmentInventoryComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on EquipmentInventoryComponent_BroadcastMsgBlueprint");
static_assert(sizeof(EquipmentInventoryComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on EquipmentInventoryComponent_BroadcastMsgBlueprint");
static_assert(offsetof(EquipmentInventoryComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'EquipmentInventoryComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.GetCurrentHoldingItemData
// 0x0100 (0x0100 - 0x0000)
struct EquipmentInventoryComponent_GetCurrentHoldingItemData final
{
public:
	struct FItemData                              ReturnValue;                                       // 0x0000(0x0100)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_GetCurrentHoldingItemData) == 0x000008, "Wrong alignment on EquipmentInventoryComponent_GetCurrentHoldingItemData");
static_assert(sizeof(EquipmentInventoryComponent_GetCurrentHoldingItemData) == 0x000100, "Wrong size on EquipmentInventoryComponent_GetCurrentHoldingItemData");
static_assert(offsetof(EquipmentInventoryComponent_GetCurrentHoldingItemData, ReturnValue) == 0x000000, "Member 'EquipmentInventoryComponent_GetCurrentHoldingItemData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.HideEquippedItemActorsInGame
// 0x0001 (0x0001 - 0x0000)
struct EquipmentInventoryComponent_HideEquippedItemActorsInGame final
{
public:
	bool                                          bHidden;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_HideEquippedItemActorsInGame) == 0x000001, "Wrong alignment on EquipmentInventoryComponent_HideEquippedItemActorsInGame");
static_assert(sizeof(EquipmentInventoryComponent_HideEquippedItemActorsInGame) == 0x000001, "Wrong size on EquipmentInventoryComponent_HideEquippedItemActorsInGame");
static_assert(offsetof(EquipmentInventoryComponent_HideEquippedItemActorsInGame, bHidden) == 0x000000, "Member 'EquipmentInventoryComponent_HideEquippedItemActorsInGame::bHidden' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.OnRep_EquipAnimData
// 0x02D0 (0x02D0 - 0x0000)
struct EquipmentInventoryComponent_OnRep_EquipAnimData final
{
public:
	struct FDCEquipAnimData                       OldEquipAnimData;                                  // 0x0000(0x02D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_OnRep_EquipAnimData) == 0x000008, "Wrong alignment on EquipmentInventoryComponent_OnRep_EquipAnimData");
static_assert(sizeof(EquipmentInventoryComponent_OnRep_EquipAnimData) == 0x0002D0, "Wrong size on EquipmentInventoryComponent_OnRep_EquipAnimData");
static_assert(offsetof(EquipmentInventoryComponent_OnRep_EquipAnimData, OldEquipAnimData) == 0x000000, "Member 'EquipmentInventoryComponent_OnRep_EquipAnimData::OldEquipAnimData' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.OnRep_EquippedItemActors
// 0x0010 (0x0010 - 0x0000)
struct EquipmentInventoryComponent_OnRep_EquippedItemActors final
{
public:
	TArray<class AItemActor*>                     OldEquippedItemActors;                             // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_OnRep_EquippedItemActors) == 0x000008, "Wrong alignment on EquipmentInventoryComponent_OnRep_EquippedItemActors");
static_assert(sizeof(EquipmentInventoryComponent_OnRep_EquippedItemActors) == 0x000010, "Wrong size on EquipmentInventoryComponent_OnRep_EquippedItemActors");
static_assert(offsetof(EquipmentInventoryComponent_OnRep_EquippedItemActors, OldEquippedItemActors) == 0x000000, "Member 'EquipmentInventoryComponent_OnRep_EquippedItemActors::OldEquippedItemActors' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.OnRep_InventoryData
// 0x0010 (0x0010 - 0x0000)
struct EquipmentInventoryComponent_OnRep_InventoryData final
{
public:
	struct FDCEquipmentInventoryData              OldInventoryData;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_OnRep_InventoryData) == 0x000008, "Wrong alignment on EquipmentInventoryComponent_OnRep_InventoryData");
static_assert(sizeof(EquipmentInventoryComponent_OnRep_InventoryData) == 0x000010, "Wrong size on EquipmentInventoryComponent_OnRep_InventoryData");
static_assert(offsetof(EquipmentInventoryComponent_OnRep_InventoryData, OldInventoryData) == 0x000000, "Member 'EquipmentInventoryComponent_OnRep_InventoryData::OldInventoryData' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.OnRep_QuickSlotData
// 0x0008 (0x0008 - 0x0000)
struct EquipmentInventoryComponent_OnRep_QuickSlotData final
{
public:
	struct FDCQuickSlotData                       OldQuickSlotData;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_OnRep_QuickSlotData) == 0x000004, "Wrong alignment on EquipmentInventoryComponent_OnRep_QuickSlotData");
static_assert(sizeof(EquipmentInventoryComponent_OnRep_QuickSlotData) == 0x000008, "Wrong size on EquipmentInventoryComponent_OnRep_QuickSlotData");
static_assert(offsetof(EquipmentInventoryComponent_OnRep_QuickSlotData, OldQuickSlotData) == 0x000000, "Member 'EquipmentInventoryComponent_OnRep_QuickSlotData::OldQuickSlotData' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.OnRep_SheathItemActors
// 0x0010 (0x0010 - 0x0000)
struct EquipmentInventoryComponent_OnRep_SheathItemActors final
{
public:
	TArray<class AItemActor*>                     OldSheathItemActors;                               // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_OnRep_SheathItemActors) == 0x000008, "Wrong alignment on EquipmentInventoryComponent_OnRep_SheathItemActors");
static_assert(sizeof(EquipmentInventoryComponent_OnRep_SheathItemActors) == 0x000010, "Wrong size on EquipmentInventoryComponent_OnRep_SheathItemActors");
static_assert(offsetof(EquipmentInventoryComponent_OnRep_SheathItemActors, OldSheathItemActors) == 0x000000, "Member 'EquipmentInventoryComponent_OnRep_SheathItemActors::OldSheathItemActors' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct EquipmentInventoryComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_UnbindMsg) == 0x000008, "Wrong alignment on EquipmentInventoryComponent_UnbindMsg");
static_assert(sizeof(EquipmentInventoryComponent_UnbindMsg) == 0x000010, "Wrong size on EquipmentInventoryComponent_UnbindMsg");
static_assert(offsetof(EquipmentInventoryComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'EquipmentInventoryComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(EquipmentInventoryComponent_UnbindMsg, InObject) == 0x000008, "Member 'EquipmentInventoryComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct EquipmentInventoryComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on EquipmentInventoryComponent_UnbindMsgAll");
static_assert(sizeof(EquipmentInventoryComponent_UnbindMsgAll) == 0x000008, "Wrong size on EquipmentInventoryComponent_UnbindMsgAll");
static_assert(offsetof(EquipmentInventoryComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'EquipmentInventoryComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.ClientReqChangeQuickSlot
// 0x0002 (0x0002 - 0x0000)
struct EquipmentInventoryComponent_ClientReqChangeQuickSlot final
{
public:
	EEquipmentQuickSlotType                       QuickSlotType;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCondition;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_ClientReqChangeQuickSlot) == 0x000001, "Wrong alignment on EquipmentInventoryComponent_ClientReqChangeQuickSlot");
static_assert(sizeof(EquipmentInventoryComponent_ClientReqChangeQuickSlot) == 0x000002, "Wrong size on EquipmentInventoryComponent_ClientReqChangeQuickSlot");
static_assert(offsetof(EquipmentInventoryComponent_ClientReqChangeQuickSlot, QuickSlotType) == 0x000000, "Member 'EquipmentInventoryComponent_ClientReqChangeQuickSlot::QuickSlotType' has a wrong offset!");
static_assert(offsetof(EquipmentInventoryComponent_ClientReqChangeQuickSlot, bSkipCondition) == 0x000001, "Member 'EquipmentInventoryComponent_ClientReqChangeQuickSlot::bSkipCondition' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.GetCurrentActiveSlotType
// 0x0001 (0x0001 - 0x0000)
struct EquipmentInventoryComponent_GetCurrentActiveSlotType final
{
public:
	EEquipmentQuickSlotType                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_GetCurrentActiveSlotType) == 0x000001, "Wrong alignment on EquipmentInventoryComponent_GetCurrentActiveSlotType");
static_assert(sizeof(EquipmentInventoryComponent_GetCurrentActiveSlotType) == 0x000001, "Wrong size on EquipmentInventoryComponent_GetCurrentActiveSlotType");
static_assert(offsetof(EquipmentInventoryComponent_GetCurrentActiveSlotType, ReturnValue) == 0x000000, "Member 'EquipmentInventoryComponent_GetCurrentActiveSlotType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.EquipmentInventoryComponent.GetItemsBySlotType
// 0x0018 (0x0018 - 0x0000)
struct EquipmentInventoryComponent_GetItemsBySlotType final
{
public:
	struct FGameplayTag                           ItemSlotType;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UItem*>                          ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentInventoryComponent_GetItemsBySlotType) == 0x000008, "Wrong alignment on EquipmentInventoryComponent_GetItemsBySlotType");
static_assert(sizeof(EquipmentInventoryComponent_GetItemsBySlotType) == 0x000018, "Wrong size on EquipmentInventoryComponent_GetItemsBySlotType");
static_assert(offsetof(EquipmentInventoryComponent_GetItemsBySlotType, ItemSlotType) == 0x000000, "Member 'EquipmentInventoryComponent_GetItemsBySlotType::ItemSlotType' has a wrong offset!");
static_assert(offsetof(EquipmentInventoryComponent_GetItemsBySlotType, ReturnValue) == 0x000008, "Member 'EquipmentInventoryComponent_GetItemsBySlotType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDungeonResultGroupWidget.OnDungeonResultGroupVisibilityChanged
// 0x0001 (0x0001 - 0x0000)
struct DCDungeonResultGroupWidget_OnDungeonResultGroupVisibilityChanged final
{
public:
	ESlateVisibility                              NewVisibility;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonResultGroupWidget_OnDungeonResultGroupVisibilityChanged) == 0x000001, "Wrong alignment on DCDungeonResultGroupWidget_OnDungeonResultGroupVisibilityChanged");
static_assert(sizeof(DCDungeonResultGroupWidget_OnDungeonResultGroupVisibilityChanged) == 0x000001, "Wrong size on DCDungeonResultGroupWidget_OnDungeonResultGroupVisibilityChanged");
static_assert(offsetof(DCDungeonResultGroupWidget_OnDungeonResultGroupVisibilityChanged, NewVisibility) == 0x000000, "Member 'DCDungeonResultGroupWidget_OnDungeonResultGroupVisibilityChanged::NewVisibility' has a wrong offset!");

// Function DungeonCrawler.GA_ItemInstallBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ItemInstallBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ItemInstallBase_EventReceived) == 0x000008, "Wrong alignment on GA_ItemInstallBase_EventReceived");
static_assert(sizeof(GA_ItemInstallBase_EventReceived) == 0x0000B8, "Wrong size on GA_ItemInstallBase_EventReceived");
static_assert(offsetof(GA_ItemInstallBase_EventReceived, EventTag) == 0x000000, "Member 'GA_ItemInstallBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ItemInstallBase_EventReceived, EventData) == 0x000008, "Member 'GA_ItemInstallBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_LobbyEmoteBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_LobbyEmoteBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_LobbyEmoteBase_OnCancelled) == 0x000008, "Wrong alignment on GA_LobbyEmoteBase_OnCancelled");
static_assert(sizeof(GA_LobbyEmoteBase_OnCancelled) == 0x0000B8, "Wrong size on GA_LobbyEmoteBase_OnCancelled");
static_assert(offsetof(GA_LobbyEmoteBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_LobbyEmoteBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_LobbyEmoteBase_OnCancelled, EventData) == 0x000008, "Member 'GA_LobbyEmoteBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_LobbyEmoteBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_LobbyEmoteBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_LobbyEmoteBase_OnCompleted) == 0x000008, "Wrong alignment on GA_LobbyEmoteBase_OnCompleted");
static_assert(sizeof(GA_LobbyEmoteBase_OnCompleted) == 0x0000B8, "Wrong size on GA_LobbyEmoteBase_OnCompleted");
static_assert(offsetof(GA_LobbyEmoteBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_LobbyEmoteBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_LobbyEmoteBase_OnCompleted, EventData) == 0x000008, "Member 'GA_LobbyEmoteBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_LobbyEmoteBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_LobbyEmoteBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_LobbyEmoteBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_LobbyEmoteBase_ReceivedEvent");
static_assert(sizeof(GA_LobbyEmoteBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_LobbyEmoteBase_ReceivedEvent");
static_assert(offsetof(GA_LobbyEmoteBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_LobbyEmoteBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_LobbyEmoteBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_LobbyEmoteBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.DCCommonButtonBase.BindMsgOwner
// 0x0010 (0x0010 - 0x0000)
struct DCCommonButtonBase_BindMsgOwner final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBindMsgNode*                           InMsgDynamicDelegate;                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonButtonBase_BindMsgOwner) == 0x000008, "Wrong alignment on DCCommonButtonBase_BindMsgOwner");
static_assert(sizeof(DCCommonButtonBase_BindMsgOwner) == 0x000010, "Wrong size on DCCommonButtonBase_BindMsgOwner");
static_assert(offsetof(DCCommonButtonBase_BindMsgOwner, InMsgType) == 0x000000, "Member 'DCCommonButtonBase_BindMsgOwner::InMsgType' has a wrong offset!");
static_assert(offsetof(DCCommonButtonBase_BindMsgOwner, InMsgDynamicDelegate) == 0x000008, "Member 'DCCommonButtonBase_BindMsgOwner::InMsgDynamicDelegate' has a wrong offset!");

// Function DungeonCrawler.DCCommonButtonBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCCommonButtonBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonButtonBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCCommonButtonBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCCommonButtonBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCCommonButtonBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCCommonButtonBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCCommonButtonBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCCommonButtonBase.GetOwningBaseInterfaceBlueprint
// 0x0010 (0x0010 - 0x0000)
struct DCCommonButtonBase_GetOwningBaseInterfaceBlueprint final
{
public:
	TScriptInterface<class IBaseInterface>        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonButtonBase_GetOwningBaseInterfaceBlueprint) == 0x000008, "Wrong alignment on DCCommonButtonBase_GetOwningBaseInterfaceBlueprint");
static_assert(sizeof(DCCommonButtonBase_GetOwningBaseInterfaceBlueprint) == 0x000010, "Wrong size on DCCommonButtonBase_GetOwningBaseInterfaceBlueprint");
static_assert(offsetof(DCCommonButtonBase_GetOwningBaseInterfaceBlueprint, ReturnValue) == 0x000000, "Member 'DCCommonButtonBase_GetOwningBaseInterfaceBlueprint::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCommonButtonBase.GetTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCCommonButtonBase_GetTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonButtonBase_GetTooltipWidget) == 0x000008, "Wrong alignment on DCCommonButtonBase_GetTooltipWidget");
static_assert(sizeof(DCCommonButtonBase_GetTooltipWidget) == 0x000008, "Wrong size on DCCommonButtonBase_GetTooltipWidget");
static_assert(offsetof(DCCommonButtonBase_GetTooltipWidget, ReturnValue) == 0x000000, "Member 'DCCommonButtonBase_GetTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCommonButtonBase.SetBlockClick
// 0x0001 (0x0001 - 0x0000)
struct DCCommonButtonBase_SetBlockClick final
{
public:
	bool                                          bInIsBlocked;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonButtonBase_SetBlockClick) == 0x000001, "Wrong alignment on DCCommonButtonBase_SetBlockClick");
static_assert(sizeof(DCCommonButtonBase_SetBlockClick) == 0x000001, "Wrong size on DCCommonButtonBase_SetBlockClick");
static_assert(offsetof(DCCommonButtonBase_SetBlockClick, bInIsBlocked) == 0x000000, "Member 'DCCommonButtonBase_SetBlockClick::bInIsBlocked' has a wrong offset!");

// Function DungeonCrawler.DCCommonButtonBase.SetButtonText
// 0x0018 (0x0018 - 0x0000)
struct DCCommonButtonBase_SetButtonText final
{
public:
	class FText                                   InButtonText;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonButtonBase_SetButtonText) == 0x000008, "Wrong alignment on DCCommonButtonBase_SetButtonText");
static_assert(sizeof(DCCommonButtonBase_SetButtonText) == 0x000018, "Wrong size on DCCommonButtonBase_SetButtonText");
static_assert(offsetof(DCCommonButtonBase_SetButtonText, InButtonText) == 0x000000, "Member 'DCCommonButtonBase_SetButtonText::InButtonText' has a wrong offset!");

// Function DungeonCrawler.DCCommonButtonBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCCommonButtonBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonButtonBase_UnbindMsg) == 0x000008, "Wrong alignment on DCCommonButtonBase_UnbindMsg");
static_assert(sizeof(DCCommonButtonBase_UnbindMsg) == 0x000010, "Wrong size on DCCommonButtonBase_UnbindMsg");
static_assert(offsetof(DCCommonButtonBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCCommonButtonBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCCommonButtonBase_UnbindMsg, InObject) == 0x000008, "Member 'DCCommonButtonBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCCommonButtonBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCCommonButtonBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonButtonBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCCommonButtonBase_UnbindMsgAll");
static_assert(sizeof(DCCommonButtonBase_UnbindMsgAll) == 0x000008, "Wrong size on DCCommonButtonBase_UnbindMsgAll");
static_assert(offsetof(DCCommonButtonBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCCommonButtonBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCCommonButtonBase.UnbindMsgOwner
// 0x0008 (0x0008 - 0x0000)
struct DCCommonButtonBase_UnbindMsgOwner final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommonButtonBase_UnbindMsgOwner) == 0x000008, "Wrong alignment on DCCommonButtonBase_UnbindMsgOwner");
static_assert(sizeof(DCCommonButtonBase_UnbindMsgOwner) == 0x000008, "Wrong size on DCCommonButtonBase_UnbindMsgOwner");
static_assert(offsetof(DCCommonButtonBase_UnbindMsgOwner, InMsgType) == 0x000000, "Member 'DCCommonButtonBase_UnbindMsgOwner::InMsgType' has a wrong offset!");

// Function DungeonCrawler.GameAmmoWidget.OnEquipItemActorsEvent
// 0x0010 (0x0010 - 0x0000)
struct GameAmmoWidget_OnEquipItemActorsEvent final
{
public:
	TArray<class AItemActor*>                     ItemActors;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameAmmoWidget_OnEquipItemActorsEvent) == 0x000008, "Wrong alignment on GameAmmoWidget_OnEquipItemActorsEvent");
static_assert(sizeof(GameAmmoWidget_OnEquipItemActorsEvent) == 0x000010, "Wrong size on GameAmmoWidget_OnEquipItemActorsEvent");
static_assert(offsetof(GameAmmoWidget_OnEquipItemActorsEvent, ItemActors) == 0x000000, "Member 'GameAmmoWidget_OnEquipItemActorsEvent::ItemActors' has a wrong offset!");

// Function DungeonCrawler.DCCharacterInventoryWidget.GetTitle
// 0x0018 (0x0018 - 0x0000)
struct DCCharacterInventoryWidget_GetTitle final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterInventoryWidget_GetTitle) == 0x000008, "Wrong alignment on DCCharacterInventoryWidget_GetTitle");
static_assert(sizeof(DCCharacterInventoryWidget_GetTitle) == 0x000018, "Wrong size on DCCharacterInventoryWidget_GetTitle");
static_assert(offsetof(DCCharacterInventoryWidget_GetTitle, ReturnValue) == 0x000000, "Member 'DCCharacterInventoryWidget_GetTitle::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterInventoryWidget.GetTitleColor
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterInventoryWidget_GetTitleColor final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterInventoryWidget_GetTitleColor) == 0x000004, "Wrong alignment on DCCharacterInventoryWidget_GetTitleColor");
static_assert(sizeof(DCCharacterInventoryWidget_GetTitleColor) == 0x000010, "Wrong size on DCCharacterInventoryWidget_GetTitleColor");
static_assert(offsetof(DCCharacterInventoryWidget_GetTitleColor, ReturnValue) == 0x000000, "Member 'DCCharacterInventoryWidget_GetTitleColor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_PickUp.OnPickedUp
// 0x0010 (0x0010 - 0x0000)
struct GA_PickUp_OnPickedUp final
{
public:
	class AActor*                                 ItemHolderToPickUp;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDestroy;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2380[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_PickUp_OnPickedUp) == 0x000008, "Wrong alignment on GA_PickUp_OnPickedUp");
static_assert(sizeof(GA_PickUp_OnPickedUp) == 0x000010, "Wrong size on GA_PickUp_OnPickedUp");
static_assert(offsetof(GA_PickUp_OnPickedUp, ItemHolderToPickUp) == 0x000000, "Member 'GA_PickUp_OnPickedUp::ItemHolderToPickUp' has a wrong offset!");
static_assert(offsetof(GA_PickUp_OnPickedUp, bShouldDestroy) == 0x000008, "Member 'GA_PickUp_OnPickedUp::bShouldDestroy' has a wrong offset!");

// Function DungeonCrawler.ItemHolderActorBase.InitItemHolderActor
// 0x0100 (0x0100 - 0x0000)
struct ItemHolderActorBase_InitItemHolderActor final
{
public:
	struct FItemData                              InItemData;                                        // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemHolderActorBase_InitItemHolderActor) == 0x000008, "Wrong alignment on ItemHolderActorBase_InitItemHolderActor");
static_assert(sizeof(ItemHolderActorBase_InitItemHolderActor) == 0x000100, "Wrong size on ItemHolderActorBase_InitItemHolderActor");
static_assert(offsetof(ItemHolderActorBase_InitItemHolderActor, InItemData) == 0x000000, "Member 'ItemHolderActorBase_InitItemHolderActor::InItemData' has a wrong offset!");

// Function DungeonCrawler.ItemHolderActorBase.OnRep_ArtDataItem
// 0x0008 (0x0008 - 0x0000)
struct ItemHolderActorBase_OnRep_ArtDataItem final
{
public:
	class UArtDataItem*                           OldArtDataItem;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemHolderActorBase_OnRep_ArtDataItem) == 0x000008, "Wrong alignment on ItemHolderActorBase_OnRep_ArtDataItem");
static_assert(sizeof(ItemHolderActorBase_OnRep_ArtDataItem) == 0x000008, "Wrong size on ItemHolderActorBase_OnRep_ArtDataItem");
static_assert(offsetof(ItemHolderActorBase_OnRep_ArtDataItem, OldArtDataItem) == 0x000000, "Member 'ItemHolderActorBase_OnRep_ArtDataItem::OldArtDataItem' has a wrong offset!");

// Function DungeonCrawler.ItemHolderActorBase.OnRep_ItemInfo
// 0x0168 (0x0168 - 0x0000)
struct ItemHolderActorBase_OnRep_ItemInfo final
{
public:
	struct FDCItemInfo                            OldItemInfo;                                       // 0x0000(0x0168)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemHolderActorBase_OnRep_ItemInfo) == 0x000008, "Wrong alignment on ItemHolderActorBase_OnRep_ItemInfo");
static_assert(sizeof(ItemHolderActorBase_OnRep_ItemInfo) == 0x000168, "Wrong size on ItemHolderActorBase_OnRep_ItemInfo");
static_assert(offsetof(ItemHolderActorBase_OnRep_ItemInfo, OldItemInfo) == 0x000000, "Member 'ItemHolderActorBase_OnRep_ItemInfo::OldItemInfo' has a wrong offset!");

// Function DungeonCrawler.ItemHolderActorBase.OverrideItemArtData
// 0x0008 (0x0008 - 0x0000)
struct ItemHolderActorBase_OverrideItemArtData final
{
public:
	class UArtDataItem*                           NewItemArtData;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemHolderActorBase_OverrideItemArtData) == 0x000008, "Wrong alignment on ItemHolderActorBase_OverrideItemArtData");
static_assert(sizeof(ItemHolderActorBase_OverrideItemArtData) == 0x000008, "Wrong size on ItemHolderActorBase_OverrideItemArtData");
static_assert(offsetof(ItemHolderActorBase_OverrideItemArtData, NewItemArtData) == 0x000000, "Member 'ItemHolderActorBase_OverrideItemArtData::NewItemArtData' has a wrong offset!");

// Function DungeonCrawler.ItemHolderActorBase.SetItemId
// 0x0010 (0x0010 - 0x0000)
struct ItemHolderActorBase_SetItemId final
{
public:
	struct FPrimaryAssetId                        InItemId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemHolderActorBase_SetItemId) == 0x000004, "Wrong alignment on ItemHolderActorBase_SetItemId");
static_assert(sizeof(ItemHolderActorBase_SetItemId) == 0x000010, "Wrong size on ItemHolderActorBase_SetItemId");
static_assert(offsetof(ItemHolderActorBase_SetItemId, InItemId) == 0x000000, "Member 'ItemHolderActorBase_SetItemId::InItemId' has a wrong offset!");

// Function DungeonCrawler.ItemHolderActorBase.GetItemId
// 0x0010 (0x0010 - 0x0000)
struct ItemHolderActorBase_GetItemId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemHolderActorBase_GetItemId) == 0x000004, "Wrong alignment on ItemHolderActorBase_GetItemId");
static_assert(sizeof(ItemHolderActorBase_GetItemId) == 0x000010, "Wrong size on ItemHolderActorBase_GetItemId");
static_assert(offsetof(ItemHolderActorBase_GetItemId, ReturnValue) == 0x000000, "Member 'ItemHolderActorBase_GetItemId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGenericGameplayTagEvent.WaitGenericGameplayTagEvent
// 0x0018 (0x0018 - 0x0000)
struct DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InOptionalExternalTarget;                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitGenericGameplayTagEvent*      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent) == 0x000008, "Wrong alignment on DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent");
static_assert(sizeof(DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent) == 0x000018, "Wrong size on DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent");
static_assert(offsetof(DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent, OwningAbility) == 0x000000, "Member 'DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent, InOptionalExternalTarget) == 0x000008, "Member 'DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent::InOptionalExternalTarget' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent, ReturnValue) == 0x000010, "Member 'DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCQuestLogDealTableWidget.OnMatchStateChange
// 0x0001 (0x0001 - 0x0000)
struct DCQuestLogDealTableWidget_OnMatchStateChange final
{
public:
	bool                                          bIsMatching;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestLogDealTableWidget_OnMatchStateChange) == 0x000001, "Wrong alignment on DCQuestLogDealTableWidget_OnMatchStateChange");
static_assert(sizeof(DCQuestLogDealTableWidget_OnMatchStateChange) == 0x000001, "Wrong size on DCQuestLogDealTableWidget_OnMatchStateChange");
static_assert(offsetof(DCQuestLogDealTableWidget_OnMatchStateChange, bIsMatching) == 0x000000, "Member 'DCQuestLogDealTableWidget_OnMatchStateChange::bIsMatching' has a wrong offset!");

// Function DungeonCrawler.DCQuestLogDealTableWidget.GetQuestState
// 0x0001 (0x0001 - 0x0000)
struct DCQuestLogDealTableWidget_GetQuestState final
{
public:
	EDCQuestState                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestLogDealTableWidget_GetQuestState) == 0x000001, "Wrong alignment on DCQuestLogDealTableWidget_GetQuestState");
static_assert(sizeof(DCQuestLogDealTableWidget_GetQuestState) == 0x000001, "Wrong size on DCQuestLogDealTableWidget_GetQuestState");
static_assert(offsetof(DCQuestLogDealTableWidget_GetQuestState, ReturnValue) == 0x000000, "Member 'DCQuestLogDealTableWidget_GetQuestState::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.KarmaReportWidgetBase.OnFMsgWidgetKarmaReportActionResponseBlueprint
// 0x00B0 (0x00B0 - 0x0000)
struct KarmaReportWidgetBase_OnFMsgWidgetKarmaReportActionResponseBlueprint final
{
public:
	struct FMsgWidgetKarmaReportActionResponse    InMsg;                                             // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KarmaReportWidgetBase_OnFMsgWidgetKarmaReportActionResponseBlueprint) == 0x000008, "Wrong alignment on KarmaReportWidgetBase_OnFMsgWidgetKarmaReportActionResponseBlueprint");
static_assert(sizeof(KarmaReportWidgetBase_OnFMsgWidgetKarmaReportActionResponseBlueprint) == 0x0000B0, "Wrong size on KarmaReportWidgetBase_OnFMsgWidgetKarmaReportActionResponseBlueprint");
static_assert(offsetof(KarmaReportWidgetBase_OnFMsgWidgetKarmaReportActionResponseBlueprint, InMsg) == 0x000000, "Member 'KarmaReportWidgetBase_OnFMsgWidgetKarmaReportActionResponseBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.KarmaReportWidgetBase.OnFMsgWidgetKarmaReportInfoNotifyBlueprint
// 0x0038 (0x0038 - 0x0000)
struct KarmaReportWidgetBase_OnFMsgWidgetKarmaReportInfoNotifyBlueprint final
{
public:
	struct FMsgWidgetKarmaReportInfoNotify        InMsg;                                             // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KarmaReportWidgetBase_OnFMsgWidgetKarmaReportInfoNotifyBlueprint) == 0x000008, "Wrong alignment on KarmaReportWidgetBase_OnFMsgWidgetKarmaReportInfoNotifyBlueprint");
static_assert(sizeof(KarmaReportWidgetBase_OnFMsgWidgetKarmaReportInfoNotifyBlueprint) == 0x000038, "Wrong size on KarmaReportWidgetBase_OnFMsgWidgetKarmaReportInfoNotifyBlueprint");
static_assert(offsetof(KarmaReportWidgetBase_OnFMsgWidgetKarmaReportInfoNotifyBlueprint, InMsg) == 0x000000, "Member 'KarmaReportWidgetBase_OnFMsgWidgetKarmaReportInfoNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.AddPlayerMappableConfigByTag
// 0x000C (0x000C - 0x0000)
struct DCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag final
{
public:
	struct FGameplayTag                           InputConfigTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FModifyContextOptions                  Options;                                           // 0x0008(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_238A[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag) == 0x000004, "Wrong alignment on DCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag");
static_assert(sizeof(DCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag) == 0x00000C, "Wrong size on DCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag");
static_assert(offsetof(DCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag, InputConfigTag) == 0x000000, "Member 'DCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag::InputConfigTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag, Options) == 0x000008, "Member 'DCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag::Options' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.RemovePlayerMappableConfigByTag
// 0x000C (0x000C - 0x0000)
struct DCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag final
{
public:
	struct FGameplayTag                           InputConfigTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FModifyContextOptions                  Options;                                           // 0x0008(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_238B[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag) == 0x000004, "Wrong alignment on DCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag");
static_assert(sizeof(DCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag) == 0x00000C, "Wrong size on DCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag");
static_assert(offsetof(DCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag, InputConfigTag) == 0x000000, "Member 'DCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag::InputConfigTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag, Options) == 0x000008, "Member 'DCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag::Options' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.GetInputConfig
// 0x0010 (0x0010 - 0x0000)
struct DCEnhancedInputLocalPlayerSubsystem_GetInputConfig final
{
public:
	struct FGameplayTag                           ConfigTag;                                         // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDCInputConfig*                   ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLocalPlayerSubsystem_GetInputConfig) == 0x000008, "Wrong alignment on DCEnhancedInputLocalPlayerSubsystem_GetInputConfig");
static_assert(sizeof(DCEnhancedInputLocalPlayerSubsystem_GetInputConfig) == 0x000010, "Wrong size on DCEnhancedInputLocalPlayerSubsystem_GetInputConfig");
static_assert(offsetof(DCEnhancedInputLocalPlayerSubsystem_GetInputConfig, ConfigTag) == 0x000000, "Member 'DCEnhancedInputLocalPlayerSubsystem_GetInputConfig::ConfigTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLocalPlayerSubsystem_GetInputConfig, ReturnValue) == 0x000008, "Member 'DCEnhancedInputLocalPlayerSubsystem_GetInputConfig::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.GetPlayerMappableInputConfig
// 0x0010 (0x0010 - 0x0000)
struct DCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig final
{
public:
	struct FGameplayTag                           ConfigTag;                                         // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UPlayerMappableInputConfig*       ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig) == 0x000008, "Wrong alignment on DCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig");
static_assert(sizeof(DCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig) == 0x000010, "Wrong size on DCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig");
static_assert(offsetof(DCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig, ConfigTag) == 0x000000, "Member 'DCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig::ConfigTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig, ReturnValue) == 0x000008, "Member 'DCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskAttributeChanged.ListenForAttributeChange
// 0x0048 (0x0048 - 0x0000)
struct AsyncTaskAttributeChanged_ListenForAttributeChange final
{
public:
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0008(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAsyncTaskAttributeChanged*             ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskAttributeChanged_ListenForAttributeChange) == 0x000008, "Wrong alignment on AsyncTaskAttributeChanged_ListenForAttributeChange");
static_assert(sizeof(AsyncTaskAttributeChanged_ListenForAttributeChange) == 0x000048, "Wrong size on AsyncTaskAttributeChanged_ListenForAttributeChange");
static_assert(offsetof(AsyncTaskAttributeChanged_ListenForAttributeChange, AbilitySystemComponent) == 0x000000, "Member 'AsyncTaskAttributeChanged_ListenForAttributeChange::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AsyncTaskAttributeChanged_ListenForAttributeChange, Attribute) == 0x000008, "Member 'AsyncTaskAttributeChanged_ListenForAttributeChange::Attribute' has a wrong offset!");
static_assert(offsetof(AsyncTaskAttributeChanged_ListenForAttributeChange, ReturnValue) == 0x000040, "Member 'AsyncTaskAttributeChanged_ListenForAttributeChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskAttributeChanged.ListenForAttributesChange
// 0x0020 (0x0020 - 0x0000)
struct AsyncTaskAttributeChanged_ListenForAttributesChange final
{
public:
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAttribute>             Attributes;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAsyncTaskAttributeChanged*             ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskAttributeChanged_ListenForAttributesChange) == 0x000008, "Wrong alignment on AsyncTaskAttributeChanged_ListenForAttributesChange");
static_assert(sizeof(AsyncTaskAttributeChanged_ListenForAttributesChange) == 0x000020, "Wrong size on AsyncTaskAttributeChanged_ListenForAttributesChange");
static_assert(offsetof(AsyncTaskAttributeChanged_ListenForAttributesChange, AbilitySystemComponent) == 0x000000, "Member 'AsyncTaskAttributeChanged_ListenForAttributesChange::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AsyncTaskAttributeChanged_ListenForAttributesChange, Attributes) == 0x000008, "Member 'AsyncTaskAttributeChanged_ListenForAttributesChange::Attributes' has a wrong offset!");
static_assert(offsetof(AsyncTaskAttributeChanged_ListenForAttributesChange, ReturnValue) == 0x000018, "Member 'AsyncTaskAttributeChanged_ListenForAttributesChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskCooldownChanged.ListenForCooldownChange
// 0x0038 (0x0038 - 0x0000)
struct AsyncTaskCooldownChanged_ListenForCooldownChange final
{
public:
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  CooldownTags;                                      // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	bool                                          UseServerCooldown;                                 // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238F[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncTaskCooldownChanged*              ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskCooldownChanged_ListenForCooldownChange) == 0x000008, "Wrong alignment on AsyncTaskCooldownChanged_ListenForCooldownChange");
static_assert(sizeof(AsyncTaskCooldownChanged_ListenForCooldownChange) == 0x000038, "Wrong size on AsyncTaskCooldownChanged_ListenForCooldownChange");
static_assert(offsetof(AsyncTaskCooldownChanged_ListenForCooldownChange, AbilitySystemComponent) == 0x000000, "Member 'AsyncTaskCooldownChanged_ListenForCooldownChange::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AsyncTaskCooldownChanged_ListenForCooldownChange, CooldownTags) == 0x000008, "Member 'AsyncTaskCooldownChanged_ListenForCooldownChange::CooldownTags' has a wrong offset!");
static_assert(offsetof(AsyncTaskCooldownChanged_ListenForCooldownChange, UseServerCooldown) == 0x000028, "Member 'AsyncTaskCooldownChanged_ListenForCooldownChange::UseServerCooldown' has a wrong offset!");
static_assert(offsetof(AsyncTaskCooldownChanged_ListenForCooldownChange, ReturnValue) == 0x000030, "Member 'AsyncTaskCooldownChanged_ListenForCooldownChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskEffectInhibitionChanged.ListenForGameplayInhibitionChange
// 0x0018 (0x0018 - 0x0000)
struct AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange final
{
public:
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EffectGameplayTag;                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAsyncTaskEffectInhibitionChanged*      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange) == 0x000008, "Wrong alignment on AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange");
static_assert(sizeof(AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange) == 0x000018, "Wrong size on AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange");
static_assert(offsetof(AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange, AbilitySystemComponent) == 0x000000, "Member 'AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange, EffectGameplayTag) == 0x000008, "Member 'AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange::EffectGameplayTag' has a wrong offset!");
static_assert(offsetof(AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange, ReturnValue) == 0x000010, "Member 'AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.PlayerCharacterCaptureActor.GetCharacterMeshAnimInstance
// 0x0008 (0x0008 - 0x0000)
struct PlayerCharacterCaptureActor_GetCharacterMeshAnimInstance final
{
public:
	class UAnimInstance*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCharacterCaptureActor_GetCharacterMeshAnimInstance) == 0x000008, "Wrong alignment on PlayerCharacterCaptureActor_GetCharacterMeshAnimInstance");
static_assert(sizeof(PlayerCharacterCaptureActor_GetCharacterMeshAnimInstance) == 0x000008, "Wrong size on PlayerCharacterCaptureActor_GetCharacterMeshAnimInstance");
static_assert(offsetof(PlayerCharacterCaptureActor_GetCharacterMeshAnimInstance, ReturnValue) == 0x000000, "Member 'PlayerCharacterCaptureActor_GetCharacterMeshAnimInstance::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.PlayerCharacterCaptureActor.OnItemEquipped
// 0x0018 (0x0018 - 0x0000)
struct PlayerCharacterCaptureActor_OnItemEquipped final
{
public:
	const class UAnimationAsset*                  ItemStandIdle;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemHandType;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemSlotType;                                      // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCharacterCaptureActor_OnItemEquipped) == 0x000008, "Wrong alignment on PlayerCharacterCaptureActor_OnItemEquipped");
static_assert(sizeof(PlayerCharacterCaptureActor_OnItemEquipped) == 0x000018, "Wrong size on PlayerCharacterCaptureActor_OnItemEquipped");
static_assert(offsetof(PlayerCharacterCaptureActor_OnItemEquipped, ItemStandIdle) == 0x000000, "Member 'PlayerCharacterCaptureActor_OnItemEquipped::ItemStandIdle' has a wrong offset!");
static_assert(offsetof(PlayerCharacterCaptureActor_OnItemEquipped, ItemHandType) == 0x000008, "Member 'PlayerCharacterCaptureActor_OnItemEquipped::ItemHandType' has a wrong offset!");
static_assert(offsetof(PlayerCharacterCaptureActor_OnItemEquipped, ItemSlotType) == 0x000010, "Member 'PlayerCharacterCaptureActor_OnItemEquipped::ItemSlotType' has a wrong offset!");

// Function DungeonCrawler.PlayerCharacterCaptureActor.SetMeshRotation
// 0x0004 (0x0004 - 0x0000)
struct PlayerCharacterCaptureActor_SetMeshRotation final
{
public:
	float                                         InYaw;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCharacterCaptureActor_SetMeshRotation) == 0x000004, "Wrong alignment on PlayerCharacterCaptureActor_SetMeshRotation");
static_assert(sizeof(PlayerCharacterCaptureActor_SetMeshRotation) == 0x000004, "Wrong size on PlayerCharacterCaptureActor_SetMeshRotation");
static_assert(offsetof(PlayerCharacterCaptureActor_SetMeshRotation, InYaw) == 0x000000, "Member 'PlayerCharacterCaptureActor_SetMeshRotation::InYaw' has a wrong offset!");

// Function DungeonCrawler.PlayerCharacterCaptureActor.SetMeshRotationSpeedMultiplier
// 0x0004 (0x0004 - 0x0000)
struct PlayerCharacterCaptureActor_SetMeshRotationSpeedMultiplier final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCharacterCaptureActor_SetMeshRotationSpeedMultiplier) == 0x000004, "Wrong alignment on PlayerCharacterCaptureActor_SetMeshRotationSpeedMultiplier");
static_assert(sizeof(PlayerCharacterCaptureActor_SetMeshRotationSpeedMultiplier) == 0x000004, "Wrong size on PlayerCharacterCaptureActor_SetMeshRotationSpeedMultiplier");
static_assert(offsetof(PlayerCharacterCaptureActor_SetMeshRotationSpeedMultiplier, Value) == 0x000000, "Member 'PlayerCharacterCaptureActor_SetMeshRotationSpeedMultiplier::Value' has a wrong offset!");

// Function DungeonCrawler.PlayerCharacterCaptureActor.SetStartRotateLocation
// 0x0004 (0x0004 - 0x0000)
struct PlayerCharacterCaptureActor_SetStartRotateLocation final
{
public:
	float                                         InStartPosition;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCharacterCaptureActor_SetStartRotateLocation) == 0x000004, "Wrong alignment on PlayerCharacterCaptureActor_SetStartRotateLocation");
static_assert(sizeof(PlayerCharacterCaptureActor_SetStartRotateLocation) == 0x000004, "Wrong size on PlayerCharacterCaptureActor_SetStartRotateLocation");
static_assert(offsetof(PlayerCharacterCaptureActor_SetStartRotateLocation, InStartPosition) == 0x000000, "Member 'PlayerCharacterCaptureActor_SetStartRotateLocation::InStartPosition' has a wrong offset!");

// Function DungeonCrawler.PlayerCharacterCaptureActor.GetRenderTarget
// 0x0008 (0x0008 - 0x0000)
struct PlayerCharacterCaptureActor_GetRenderTarget final
{
public:
	class UTextureRenderTarget2D*                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCharacterCaptureActor_GetRenderTarget) == 0x000008, "Wrong alignment on PlayerCharacterCaptureActor_GetRenderTarget");
static_assert(sizeof(PlayerCharacterCaptureActor_GetRenderTarget) == 0x000008, "Wrong size on PlayerCharacterCaptureActor_GetRenderTarget");
static_assert(offsetof(PlayerCharacterCaptureActor_GetRenderTarget, ReturnValue) == 0x000000, "Member 'PlayerCharacterCaptureActor_GetRenderTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WindforceToActor.WindforceToActor
// 0x0030 (0x0030 - 0x0000)
struct DCAT_WindforceToActor_WindforceToActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCPlayerCharacterBase*                 TargetCharcter;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindVector;                                        // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WindforceToActor*                 ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WindforceToActor_WindforceToActor) == 0x000008, "Wrong alignment on DCAT_WindforceToActor_WindforceToActor");
static_assert(sizeof(DCAT_WindforceToActor_WindforceToActor) == 0x000030, "Wrong size on DCAT_WindforceToActor_WindforceToActor");
static_assert(offsetof(DCAT_WindforceToActor_WindforceToActor, OwningAbility) == 0x000000, "Member 'DCAT_WindforceToActor_WindforceToActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WindforceToActor_WindforceToActor, TargetCharcter) == 0x000008, "Member 'DCAT_WindforceToActor_WindforceToActor::TargetCharcter' has a wrong offset!");
static_assert(offsetof(DCAT_WindforceToActor_WindforceToActor, WindVector) == 0x000010, "Member 'DCAT_WindforceToActor_WindforceToActor::WindVector' has a wrong offset!");
static_assert(offsetof(DCAT_WindforceToActor_WindforceToActor, ReturnValue) == 0x000028, "Member 'DCAT_WindforceToActor_WindforceToActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskEffectStackChanged.ListenForGameplayEffectStackChange
// 0x0018 (0x0018 - 0x0000)
struct AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange final
{
public:
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EffectGameplayTag;                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAsyncTaskEffectStackChanged*           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange) == 0x000008, "Wrong alignment on AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange");
static_assert(sizeof(AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange) == 0x000018, "Wrong size on AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange");
static_assert(offsetof(AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange, AbilitySystemComponent) == 0x000000, "Member 'AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange, EffectGameplayTag) == 0x000008, "Member 'AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange::EffectGameplayTag' has a wrong offset!");
static_assert(offsetof(AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange, ReturnValue) == 0x000010, "Member 'AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivate
// 0x0028 (0x0028 - 0x0000)
struct AsyncTaskWaitGAActivated_WaitForAbilityActivate final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithTag;                                           // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithoutTag;                                        // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeTriggeredAbilities;                         // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2399[0x6];                                     // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncTaskWaitGAActivated*              ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskWaitGAActivated_WaitForAbilityActivate) == 0x000008, "Wrong alignment on AsyncTaskWaitGAActivated_WaitForAbilityActivate");
static_assert(sizeof(AsyncTaskWaitGAActivated_WaitForAbilityActivate) == 0x000028, "Wrong size on AsyncTaskWaitGAActivated_WaitForAbilityActivate");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate, TargetActor) == 0x000000, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate::TargetActor' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate, WithTag) == 0x000008, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate::WithTag' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate, WithoutTag) == 0x000010, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate::WithoutTag' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate, IncludeTriggeredAbilities) == 0x000018, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate::IncludeTriggeredAbilities' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate, TriggerOnce) == 0x000019, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate::TriggerOnce' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate, ReturnValue) == 0x000020, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivate_Query
// 0x0060 (0x0060 - 0x0000)
struct AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      Query;                                             // 0x0008(0x0048)(Parm, NativeAccessSpecifierPublic)
	bool                                          IncludeTriggeredAbilities;                         // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0051(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239A[0x6];                                     // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncTaskWaitGAActivated*              ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query) == 0x000008, "Wrong alignment on AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query");
static_assert(sizeof(AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query) == 0x000060, "Wrong size on AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query, TargetActor) == 0x000000, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query::TargetActor' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query, Query) == 0x000008, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query::Query' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query, IncludeTriggeredAbilities) == 0x000050, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query::IncludeTriggeredAbilities' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query, TriggerOnce) == 0x000051, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query::TriggerOnce' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query, ReturnValue) == 0x000058, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivateWithTagRequirements
// 0x00A0 (0x00A0 - 0x0000)
struct AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0008(0x0088)(Parm, NativeAccessSpecifierPublic)
	bool                                          IncludeTriggeredAbilities;                         // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0091(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239B[0x6];                                     // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncTaskWaitGAActivated*              ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements) == 0x000008, "Wrong alignment on AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements");
static_assert(sizeof(AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements) == 0x0000A0, "Wrong size on AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements, TargetActor) == 0x000000, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements::TargetActor' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements, TagRequirements) == 0x000008, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements::TagRequirements' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements, IncludeTriggeredAbilities) == 0x000090, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements::IncludeTriggeredAbilities' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements, TriggerOnce) == 0x000091, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements::TriggerOnce' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements, ReturnValue) == 0x000098, "Member 'AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskWaitGAActivated.OnAbilityActivate
// 0x0008 (0x0008 - 0x0000)
struct AsyncTaskWaitGAActivated_OnAbilityActivate final
{
public:
	class UGameplayAbility*                       ActivatedAbility;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskWaitGAActivated_OnAbilityActivate) == 0x000008, "Wrong alignment on AsyncTaskWaitGAActivated_OnAbilityActivate");
static_assert(sizeof(AsyncTaskWaitGAActivated_OnAbilityActivate) == 0x000008, "Wrong size on AsyncTaskWaitGAActivated_OnAbilityActivate");
static_assert(offsetof(AsyncTaskWaitGAActivated_OnAbilityActivate, ActivatedAbility) == 0x000000, "Member 'AsyncTaskWaitGAActivated_OnAbilityActivate::ActivatedAbility' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEnd
// 0x0028 (0x0028 - 0x0000)
struct AsyncTaskWaitGAEnded_WaitForAbilityEnd final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithTag;                                           // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithoutTag;                                        // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A2[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncTaskWaitGAEnded*                  ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskWaitGAEnded_WaitForAbilityEnd) == 0x000008, "Wrong alignment on AsyncTaskWaitGAEnded_WaitForAbilityEnd");
static_assert(sizeof(AsyncTaskWaitGAEnded_WaitForAbilityEnd) == 0x000028, "Wrong size on AsyncTaskWaitGAEnded_WaitForAbilityEnd");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEnd, TargetActor) == 0x000000, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEnd::TargetActor' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEnd, WithTag) == 0x000008, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEnd::WithTag' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEnd, WithoutTag) == 0x000010, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEnd::WithoutTag' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEnd, TriggerOnce) == 0x000018, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEnd::TriggerOnce' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEnd, ReturnValue) == 0x000020, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEnd::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEnd_Query
// 0x0060 (0x0060 - 0x0000)
struct AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      Query;                                             // 0x0008(0x0048)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A3[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncTaskWaitGAEnded*                  ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query) == 0x000008, "Wrong alignment on AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query");
static_assert(sizeof(AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query) == 0x000060, "Wrong size on AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query, TargetActor) == 0x000000, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query::TargetActor' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query, Query) == 0x000008, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query::Query' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query, TriggerOnce) == 0x000050, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query::TriggerOnce' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query, ReturnValue) == 0x000058, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEndWithTagRequirements
// 0x00A0 (0x00A0 - 0x0000)
struct AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0008(0x0088)(Parm, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0090(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A4[0x7];                                     // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncTaskWaitGAEnded*                  ReturnValue;                                       // 0x0098(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements) == 0x000008, "Wrong alignment on AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements");
static_assert(sizeof(AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements) == 0x0000A0, "Wrong size on AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements, TargetActor) == 0x000000, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements::TargetActor' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements, TagRequirements) == 0x000008, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements::TagRequirements' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements, TriggerOnce) == 0x000090, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements::TriggerOnce' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements, ReturnValue) == 0x000098, "Member 'AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskWaitGAEnded.OnAbilityEnded
// 0x0010 (0x0010 - 0x0000)
struct AsyncTaskWaitGAEnded_OnAbilityEnded final
{
public:
	struct FAbilityEndedData                      AbilityEndedData;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskWaitGAEnded_OnAbilityEnded) == 0x000008, "Wrong alignment on AsyncTaskWaitGAEnded_OnAbilityEnded");
static_assert(sizeof(AsyncTaskWaitGAEnded_OnAbilityEnded) == 0x000010, "Wrong size on AsyncTaskWaitGAEnded_OnAbilityEnded");
static_assert(offsetof(AsyncTaskWaitGAEnded_OnAbilityEnded, AbilityEndedData) == 0x000000, "Member 'AsyncTaskWaitGAEnded_OnAbilityEnded::AbilityEndedData' has a wrong offset!");

// Function DungeonCrawler.AsyncTaskWaitGameplayEvent.WaitGameplayEventToActor
// 0x0020 (0x0020 - 0x0000)
struct AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyTriggerOnce;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyMatchExact;                                    // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23A7[0x6];                                     // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncTaskWaitGameplayEvent*            ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor) == 0x000008, "Wrong alignment on AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor");
static_assert(sizeof(AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor) == 0x000020, "Wrong size on AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor");
static_assert(offsetof(AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor, TargetActor) == 0x000000, "Member 'AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor::TargetActor' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor, EventTag) == 0x000008, "Member 'AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor::EventTag' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor, OnlyTriggerOnce) == 0x000010, "Member 'AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor::OnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor, OnlyMatchExact) == 0x000011, "Member 'AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor::OnlyMatchExact' has a wrong offset!");
static_assert(offsetof(AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor, ReturnValue) == 0x000018, "Member 'AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor::ReturnValue' has a wrong offset!");

// DelegateFunction DungeonCrawler.AsyncTaskWaitGameplayEvent.EventReceivedDelegate__DelegateSignature
// 0x00B0 (0x00B0 - 0x0000)
struct AsyncTaskWaitGameplayEvent_EventReceivedDelegate__DelegateSignature final
{
public:
	struct FGameplayEventData                     Payload;                                           // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncTaskWaitGameplayEvent_EventReceivedDelegate__DelegateSignature) == 0x000008, "Wrong alignment on AsyncTaskWaitGameplayEvent_EventReceivedDelegate__DelegateSignature");
static_assert(sizeof(AsyncTaskWaitGameplayEvent_EventReceivedDelegate__DelegateSignature) == 0x0000B0, "Wrong size on AsyncTaskWaitGameplayEvent_EventReceivedDelegate__DelegateSignature");
static_assert(offsetof(AsyncTaskWaitGameplayEvent_EventReceivedDelegate__DelegateSignature, Payload) == 0x000000, "Member 'AsyncTaskWaitGameplayEvent_EventReceivedDelegate__DelegateSignature::Payload' has a wrong offset!");

// Function DungeonCrawler.ItemWidget.OnCanEquipByRequirementsChanged
// 0x0018 (0x0018 - 0x0000)
struct ItemWidget_OnCanEquipByRequirementsChanged final
{
public:
	bool                                          bCanEquip;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23AA[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemRequirementType>                  RequirementsNotMatched;                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemWidget_OnCanEquipByRequirementsChanged) == 0x000008, "Wrong alignment on ItemWidget_OnCanEquipByRequirementsChanged");
static_assert(sizeof(ItemWidget_OnCanEquipByRequirementsChanged) == 0x000018, "Wrong size on ItemWidget_OnCanEquipByRequirementsChanged");
static_assert(offsetof(ItemWidget_OnCanEquipByRequirementsChanged, bCanEquip) == 0x000000, "Member 'ItemWidget_OnCanEquipByRequirementsChanged::bCanEquip' has a wrong offset!");
static_assert(offsetof(ItemWidget_OnCanEquipByRequirementsChanged, RequirementsNotMatched) == 0x000008, "Member 'ItemWidget_OnCanEquipByRequirementsChanged::RequirementsNotMatched' has a wrong offset!");

// Function DungeonCrawler.ItemWidget.OnItemData
// 0x0200 (0x0200 - 0x0000)
struct ItemWidget_OnItemData final
{
public:
	struct FItemData                              NewItemData;                                       // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FItemData                              OldItemData;                                       // 0x0100(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemWidget_OnItemData) == 0x000008, "Wrong alignment on ItemWidget_OnItemData");
static_assert(sizeof(ItemWidget_OnItemData) == 0x000200, "Wrong size on ItemWidget_OnItemData");
static_assert(offsetof(ItemWidget_OnItemData, NewItemData) == 0x000000, "Member 'ItemWidget_OnItemData::NewItemData' has a wrong offset!");
static_assert(offsetof(ItemWidget_OnItemData, OldItemData) == 0x000100, "Member 'ItemWidget_OnItemData::OldItemData' has a wrong offset!");

// Function DungeonCrawler.ItemWidget.SetItemData
// 0x0100 (0x0100 - 0x0000)
struct ItemWidget_SetItemData final
{
public:
	struct FItemData                              NewItemData;                                       // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemWidget_SetItemData) == 0x000008, "Wrong alignment on ItemWidget_SetItemData");
static_assert(sizeof(ItemWidget_SetItemData) == 0x000100, "Wrong size on ItemWidget_SetItemData");
static_assert(offsetof(ItemWidget_SetItemData, NewItemData) == 0x000000, "Member 'ItemWidget_SetItemData::NewItemData' has a wrong offset!");

// Function DungeonCrawler.ItemWidget.SetItemIcon
// 0x0010 (0x0010 - 0x0000)
struct ItemWidget_SetItemIcon final
{
public:
	class UTexture2D*                             ItemIconTexture;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemInventorySize                     ItemInventorySize;                                 // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemWidget_SetItemIcon) == 0x000008, "Wrong alignment on ItemWidget_SetItemIcon");
static_assert(sizeof(ItemWidget_SetItemIcon) == 0x000010, "Wrong size on ItemWidget_SetItemIcon");
static_assert(offsetof(ItemWidget_SetItemIcon, ItemIconTexture) == 0x000000, "Member 'ItemWidget_SetItemIcon::ItemIconTexture' has a wrong offset!");
static_assert(offsetof(ItemWidget_SetItemIcon, ItemInventorySize) == 0x000008, "Member 'ItemWidget_SetItemIcon::ItemInventorySize' has a wrong offset!");

// Function DungeonCrawler.ItemWidget.SetItemOwnerActor
// 0x0008 (0x0008 - 0x0000)
struct ItemWidget_SetItemOwnerActor final
{
public:
	class AActor*                                 InItemOwnedActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemWidget_SetItemOwnerActor) == 0x000008, "Wrong alignment on ItemWidget_SetItemOwnerActor");
static_assert(sizeof(ItemWidget_SetItemOwnerActor) == 0x000008, "Wrong size on ItemWidget_SetItemOwnerActor");
static_assert(offsetof(ItemWidget_SetItemOwnerActor, InItemOwnedActor) == 0x000000, "Member 'ItemWidget_SetItemOwnerActor::InItemOwnedActor' has a wrong offset!");

// Function DungeonCrawler.ItemWidget.GetItemData
// 0x0100 (0x0100 - 0x0000)
struct ItemWidget_GetItemData final
{
public:
	struct FItemData                              ReturnValue;                                       // 0x0000(0x0100)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemWidget_GetItemData) == 0x000008, "Wrong alignment on ItemWidget_GetItemData");
static_assert(sizeof(ItemWidget_GetItemData) == 0x000100, "Wrong size on ItemWidget_GetItemData");
static_assert(offsetof(ItemWidget_GetItemData, ReturnValue) == 0x000000, "Member 'ItemWidget_GetItemData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ItemWidget.GetItemIconImage
// 0x0008 (0x0008 - 0x0000)
struct ItemWidget_GetItemIconImage final
{
public:
	class UImage*                                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemWidget_GetItemIconImage) == 0x000008, "Wrong alignment on ItemWidget_GetItemIconImage");
static_assert(sizeof(ItemWidget_GetItemIconImage) == 0x000008, "Wrong size on ItemWidget_GetItemIconImage");
static_assert(offsetof(ItemWidget_GetItemIconImage, ReturnValue) == 0x000000, "Member 'ItemWidget_GetItemIconImage::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ControllableItemWidget.OnLeftMouseButtonDoubleClick
// 0x00B8 (0x00B8 - 0x0000)
struct ControllableItemWidget_OnLeftMouseButtonDoubleClick final
{
public:
	struct FEventReply                            ReturnValue;                                       // 0x0000(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControllableItemWidget_OnLeftMouseButtonDoubleClick) == 0x000008, "Wrong alignment on ControllableItemWidget_OnLeftMouseButtonDoubleClick");
static_assert(sizeof(ControllableItemWidget_OnLeftMouseButtonDoubleClick) == 0x0000B8, "Wrong size on ControllableItemWidget_OnLeftMouseButtonDoubleClick");
static_assert(offsetof(ControllableItemWidget_OnLeftMouseButtonDoubleClick, ReturnValue) == 0x000000, "Member 'ControllableItemWidget_OnLeftMouseButtonDoubleClick::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ControllableItemWidget.OnLeftMouseButtonDown
// 0x0170 (0x0170 - 0x0000)
struct ControllableItemWidget_OnLeftMouseButtonDown final
{
public:
	struct FGeometry                              MyGeometry;                                        // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPointerEvent                          MouseEvent;                                        // 0x0038(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInventoryItemLinkButtonPressed;                   // 0x00B0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23AB[0x7];                                     // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEventReply                            ReturnValue;                                       // 0x00B8(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControllableItemWidget_OnLeftMouseButtonDown) == 0x000008, "Wrong alignment on ControllableItemWidget_OnLeftMouseButtonDown");
static_assert(sizeof(ControllableItemWidget_OnLeftMouseButtonDown) == 0x000170, "Wrong size on ControllableItemWidget_OnLeftMouseButtonDown");
static_assert(offsetof(ControllableItemWidget_OnLeftMouseButtonDown, MyGeometry) == 0x000000, "Member 'ControllableItemWidget_OnLeftMouseButtonDown::MyGeometry' has a wrong offset!");
static_assert(offsetof(ControllableItemWidget_OnLeftMouseButtonDown, MouseEvent) == 0x000038, "Member 'ControllableItemWidget_OnLeftMouseButtonDown::MouseEvent' has a wrong offset!");
static_assert(offsetof(ControllableItemWidget_OnLeftMouseButtonDown, bInventoryItemLinkButtonPressed) == 0x0000B0, "Member 'ControllableItemWidget_OnLeftMouseButtonDown::bInventoryItemLinkButtonPressed' has a wrong offset!");
static_assert(offsetof(ControllableItemWidget_OnLeftMouseButtonDown, ReturnValue) == 0x0000B8, "Member 'ControllableItemWidget_OnLeftMouseButtonDown::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ControllableItemWidget.OnRightMouseButtonDown
// 0x0170 (0x0170 - 0x0000)
struct ControllableItemWidget_OnRightMouseButtonDown final
{
public:
	struct FGeometry                              MyGeometry;                                        // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPointerEvent                          MouseEvent;                                        // 0x0038(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInventoryDropButtonPressed;                       // 0x00B0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInventorySplitButtonPressed;                      // 0x00B1(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23AC[0x6];                                     // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEventReply                            ReturnValue;                                       // 0x00B8(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ControllableItemWidget_OnRightMouseButtonDown) == 0x000008, "Wrong alignment on ControllableItemWidget_OnRightMouseButtonDown");
static_assert(sizeof(ControllableItemWidget_OnRightMouseButtonDown) == 0x000170, "Wrong size on ControllableItemWidget_OnRightMouseButtonDown");
static_assert(offsetof(ControllableItemWidget_OnRightMouseButtonDown, MyGeometry) == 0x000000, "Member 'ControllableItemWidget_OnRightMouseButtonDown::MyGeometry' has a wrong offset!");
static_assert(offsetof(ControllableItemWidget_OnRightMouseButtonDown, MouseEvent) == 0x000038, "Member 'ControllableItemWidget_OnRightMouseButtonDown::MouseEvent' has a wrong offset!");
static_assert(offsetof(ControllableItemWidget_OnRightMouseButtonDown, bInventoryDropButtonPressed) == 0x0000B0, "Member 'ControllableItemWidget_OnRightMouseButtonDown::bInventoryDropButtonPressed' has a wrong offset!");
static_assert(offsetof(ControllableItemWidget_OnRightMouseButtonDown, bInventorySplitButtonPressed) == 0x0000B1, "Member 'ControllableItemWidget_OnRightMouseButtonDown::bInventorySplitButtonPressed' has a wrong offset!");
static_assert(offsetof(ControllableItemWidget_OnRightMouseButtonDown, ReturnValue) == 0x0000B8, "Member 'ControllableItemWidget_OnRightMouseButtonDown::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AttackInputManagerComponent.EventReceived
// 0x00B0 (0x00B0 - 0x0000)
struct AttackInputManagerComponent_EventReceived final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttackInputManagerComponent_EventReceived) == 0x000008, "Wrong alignment on AttackInputManagerComponent_EventReceived");
static_assert(sizeof(AttackInputManagerComponent_EventReceived) == 0x0000B0, "Wrong size on AttackInputManagerComponent_EventReceived");
static_assert(offsetof(AttackInputManagerComponent_EventReceived, EventData) == 0x000000, "Member 'AttackInputManagerComponent_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.AttackInputManagerComponent.GetCurrentTriggerTag
// 0x0010 (0x0010 - 0x0000)
struct AttackInputManagerComponent_GetCurrentTriggerTag final
{
public:
	struct FGameplayTag                           TriggerTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttackInputManagerComponent_GetCurrentTriggerTag) == 0x000004, "Wrong alignment on AttackInputManagerComponent_GetCurrentTriggerTag");
static_assert(sizeof(AttackInputManagerComponent_GetCurrentTriggerTag) == 0x000010, "Wrong size on AttackInputManagerComponent_GetCurrentTriggerTag");
static_assert(offsetof(AttackInputManagerComponent_GetCurrentTriggerTag, TriggerTag) == 0x000000, "Member 'AttackInputManagerComponent_GetCurrentTriggerTag::TriggerTag' has a wrong offset!");
static_assert(offsetof(AttackInputManagerComponent_GetCurrentTriggerTag, ReturnValue) == 0x000008, "Member 'AttackInputManagerComponent_GetCurrentTriggerTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.AttackInputManagerComponent.HandleAttackInput
// 0x0008 (0x0008 - 0x0000)
struct AttackInputManagerComponent_HandleAttackInput final
{
public:
	struct FGameplayTag                           InputTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttackInputManagerComponent_HandleAttackInput) == 0x000004, "Wrong alignment on AttackInputManagerComponent_HandleAttackInput");
static_assert(sizeof(AttackInputManagerComponent_HandleAttackInput) == 0x000008, "Wrong size on AttackInputManagerComponent_HandleAttackInput");
static_assert(offsetof(AttackInputManagerComponent_HandleAttackInput, InputTag) == 0x000000, "Member 'AttackInputManagerComponent_HandleAttackInput::InputTag' has a wrong offset!");

// Function DungeonCrawler.AttackInputManagerComponent.OnAbilityActivate
// 0x0008 (0x0008 - 0x0000)
struct AttackInputManagerComponent_OnAbilityActivate final
{
public:
	class UGameplayAbility*                       ActivatedAbility;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttackInputManagerComponent_OnAbilityActivate) == 0x000008, "Wrong alignment on AttackInputManagerComponent_OnAbilityActivate");
static_assert(sizeof(AttackInputManagerComponent_OnAbilityActivate) == 0x000008, "Wrong size on AttackInputManagerComponent_OnAbilityActivate");
static_assert(offsetof(AttackInputManagerComponent_OnAbilityActivate, ActivatedAbility) == 0x000000, "Member 'AttackInputManagerComponent_OnAbilityActivate::ActivatedAbility' has a wrong offset!");

// Function DungeonCrawler.AttackInputManagerComponent.OnAbilityEnded
// 0x0010 (0x0010 - 0x0000)
struct AttackInputManagerComponent_OnAbilityEnded final
{
public:
	struct FAbilityEndedData                      AbilityEndedData;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttackInputManagerComponent_OnAbilityEnded) == 0x000008, "Wrong alignment on AttackInputManagerComponent_OnAbilityEnded");
static_assert(sizeof(AttackInputManagerComponent_OnAbilityEnded) == 0x000010, "Wrong size on AttackInputManagerComponent_OnAbilityEnded");
static_assert(offsetof(AttackInputManagerComponent_OnAbilityEnded, AbilityEndedData) == 0x000000, "Member 'AttackInputManagerComponent_OnAbilityEnded::AbilityEndedData' has a wrong offset!");

// Function DungeonCrawler.AttackInputManagerComponent.SetAttackEnabled
// 0x0001 (0x0001 - 0x0000)
struct AttackInputManagerComponent_SetAttackEnabled final
{
public:
	bool                                          bIsAttackEnabled;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AttackInputManagerComponent_SetAttackEnabled) == 0x000001, "Wrong alignment on AttackInputManagerComponent_SetAttackEnabled");
static_assert(sizeof(AttackInputManagerComponent_SetAttackEnabled) == 0x000001, "Wrong size on AttackInputManagerComponent_SetAttackEnabled");
static_assert(offsetof(AttackInputManagerComponent_SetAttackEnabled, bIsAttackEnabled) == 0x000000, "Member 'AttackInputManagerComponent_SetAttackEnabled::bIsAttackEnabled' has a wrong offset!");

// Function DungeonCrawler.DCArenaWidget.GetCurrentPhase
// 0x0001 (0x0001 - 0x0000)
struct DCArenaWidget_GetCurrentPhase final
{
public:
	EGameStateType                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArenaWidget_GetCurrentPhase) == 0x000001, "Wrong alignment on DCArenaWidget_GetCurrentPhase");
static_assert(sizeof(DCArenaWidget_GetCurrentPhase) == 0x000001, "Wrong size on DCArenaWidget_GetCurrentPhase");
static_assert(offsetof(DCArenaWidget_GetCurrentPhase, ReturnValue) == 0x000000, "Member 'DCArenaWidget_GetCurrentPhase::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCArenaWidget.GetNumMaxPlayers
// 0x0004 (0x0004 - 0x0000)
struct DCArenaWidget_GetNumMaxPlayers final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArenaWidget_GetNumMaxPlayers) == 0x000004, "Wrong alignment on DCArenaWidget_GetNumMaxPlayers");
static_assert(sizeof(DCArenaWidget_GetNumMaxPlayers) == 0x000004, "Wrong size on DCArenaWidget_GetNumMaxPlayers");
static_assert(offsetof(DCArenaWidget_GetNumMaxPlayers, ReturnValue) == 0x000000, "Member 'DCArenaWidget_GetNumMaxPlayers::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCArenaWidget.GetNumPlayers
// 0x0004 (0x0004 - 0x0000)
struct DCArenaWidget_GetNumPlayers final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArenaWidget_GetNumPlayers) == 0x000004, "Wrong alignment on DCArenaWidget_GetNumPlayers");
static_assert(sizeof(DCArenaWidget_GetNumPlayers) == 0x000004, "Wrong size on DCArenaWidget_GetNumPlayers");
static_assert(offsetof(DCArenaWidget_GetNumPlayers, ReturnValue) == 0x000000, "Member 'DCArenaWidget_GetNumPlayers::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCArenaWidget.GetRemainIntermissionTime
// 0x0008 (0x0008 - 0x0000)
struct DCArenaWidget_GetRemainIntermissionTime final
{
public:
	struct FTimespan                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArenaWidget_GetRemainIntermissionTime) == 0x000008, "Wrong alignment on DCArenaWidget_GetRemainIntermissionTime");
static_assert(sizeof(DCArenaWidget_GetRemainIntermissionTime) == 0x000008, "Wrong size on DCArenaWidget_GetRemainIntermissionTime");
static_assert(offsetof(DCArenaWidget_GetRemainIntermissionTime, ReturnValue) == 0x000000, "Member 'DCArenaWidget_GetRemainIntermissionTime::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCArenaWidget.GetRemainRoundTime
// 0x0008 (0x0008 - 0x0000)
struct DCArenaWidget_GetRemainRoundTime final
{
public:
	struct FTimespan                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArenaWidget_GetRemainRoundTime) == 0x000008, "Wrong alignment on DCArenaWidget_GetRemainRoundTime");
static_assert(sizeof(DCArenaWidget_GetRemainRoundTime) == 0x000008, "Wrong size on DCArenaWidget_GetRemainRoundTime");
static_assert(offsetof(DCArenaWidget_GetRemainRoundTime, ReturnValue) == 0x000000, "Member 'DCArenaWidget_GetRemainRoundTime::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCArenaWidget.GetRemainWelcomeTime
// 0x0008 (0x0008 - 0x0000)
struct DCArenaWidget_GetRemainWelcomeTime final
{
public:
	struct FTimespan                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArenaWidget_GetRemainWelcomeTime) == 0x000008, "Wrong alignment on DCArenaWidget_GetRemainWelcomeTime");
static_assert(sizeof(DCArenaWidget_GetRemainWelcomeTime) == 0x000008, "Wrong size on DCArenaWidget_GetRemainWelcomeTime");
static_assert(offsetof(DCArenaWidget_GetRemainWelcomeTime, ReturnValue) == 0x000000, "Member 'DCArenaWidget_GetRemainWelcomeTime::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCArenaWidget.GetRoundTime
// 0x0008 (0x0008 - 0x0000)
struct DCArenaWidget_GetRoundTime final
{
public:
	struct FTimespan                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArenaWidget_GetRoundTime) == 0x000008, "Wrong alignment on DCArenaWidget_GetRoundTime");
static_assert(sizeof(DCArenaWidget_GetRoundTime) == 0x000008, "Wrong size on DCArenaWidget_GetRoundTime");
static_assert(offsetof(DCArenaWidget_GetRoundTime, ReturnValue) == 0x000000, "Member 'DCArenaWidget_GetRoundTime::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCArenaWidget.IsDrawLastRound
// 0x0001 (0x0001 - 0x0000)
struct DCArenaWidget_IsDrawLastRound final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArenaWidget_IsDrawLastRound) == 0x000001, "Wrong alignment on DCArenaWidget_IsDrawLastRound");
static_assert(sizeof(DCArenaWidget_IsDrawLastRound) == 0x000001, "Wrong size on DCArenaWidget_IsDrawLastRound");
static_assert(offsetof(DCArenaWidget_IsDrawLastRound, ReturnValue) == 0x000000, "Member 'DCArenaWidget_IsDrawLastRound::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCArenaWidget.IsWinLastRound
// 0x0001 (0x0001 - 0x0000)
struct DCArenaWidget_IsWinLastRound final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArenaWidget_IsWinLastRound) == 0x000001, "Wrong alignment on DCArenaWidget_IsWinLastRound");
static_assert(sizeof(DCArenaWidget_IsWinLastRound) == 0x000001, "Wrong size on DCArenaWidget_IsWinLastRound");
static_assert(offsetof(DCArenaWidget_IsWinLastRound, ReturnValue) == 0x000000, "Member 'DCArenaWidget_IsWinLastRound::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameModeBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCGameModeBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameModeBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCGameModeBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCGameModeBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCGameModeBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCGameModeBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCGameModeBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCGameModeBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCGameModeBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameModeBase_UnbindMsg) == 0x000008, "Wrong alignment on DCGameModeBase_UnbindMsg");
static_assert(sizeof(DCGameModeBase_UnbindMsg) == 0x000010, "Wrong size on DCGameModeBase_UnbindMsg");
static_assert(offsetof(DCGameModeBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCGameModeBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCGameModeBase_UnbindMsg, InObject) == 0x000008, "Member 'DCGameModeBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCGameModeBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCGameModeBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameModeBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCGameModeBase_UnbindMsgAll");
static_assert(sizeof(DCGameModeBase_UnbindMsgAll) == 0x000008, "Wrong size on DCGameModeBase_UnbindMsgAll");
static_assert(offsetof(DCGameModeBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCGameModeBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCDungeonGameMode.OnFloorRuleData
// 0x0040 (0x0040 - 0x0000)
struct DCDungeonGameMode_OnFloorRuleData final
{
public:
	struct FGameFloorRuleData                     InFloorRuleData;                                   // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonGameMode_OnFloorRuleData) == 0x000008, "Wrong alignment on DCDungeonGameMode_OnFloorRuleData");
static_assert(sizeof(DCDungeonGameMode_OnFloorRuleData) == 0x000040, "Wrong size on DCDungeonGameMode_OnFloorRuleData");
static_assert(offsetof(DCDungeonGameMode_OnFloorRuleData, InFloorRuleData) == 0x000000, "Member 'DCDungeonGameMode_OnFloorRuleData::InFloorRuleData' has a wrong offset!");

// Function DungeonCrawler.DCDungeonGameMode.RegisterPoolingObject
// 0x0010 (0x0010 - 0x0000)
struct DCDungeonGameMode_RegisterPoolingObject final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonGameMode_RegisterPoolingObject) == 0x000004, "Wrong alignment on DCDungeonGameMode_RegisterPoolingObject");
static_assert(sizeof(DCDungeonGameMode_RegisterPoolingObject) == 0x000010, "Wrong size on DCDungeonGameMode_RegisterPoolingObject");
static_assert(offsetof(DCDungeonGameMode_RegisterPoolingObject, PrimaryAssetId) == 0x000000, "Member 'DCDungeonGameMode_RegisterPoolingObject::PrimaryAssetId' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitDistChangeFromLocation.WaitDistanceChange
// 0x0030 (0x0030 - 0x0000)
struct DCAT_WaitDistChangeFromLocation_WaitDistanceChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistance;                                   // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23B9[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitDistChangeFromLocation*       ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitDistChangeFromLocation_WaitDistanceChange) == 0x000008, "Wrong alignment on DCAT_WaitDistChangeFromLocation_WaitDistanceChange");
static_assert(sizeof(DCAT_WaitDistChangeFromLocation_WaitDistanceChange) == 0x000030, "Wrong size on DCAT_WaitDistChangeFromLocation_WaitDistanceChange");
static_assert(offsetof(DCAT_WaitDistChangeFromLocation_WaitDistanceChange, OwningAbility) == 0x000000, "Member 'DCAT_WaitDistChangeFromLocation_WaitDistanceChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromLocation_WaitDistanceChange, TargetLocation) == 0x000008, "Member 'DCAT_WaitDistChangeFromLocation_WaitDistanceChange::TargetLocation' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromLocation_WaitDistanceChange, MaximumDistance) == 0x000020, "Member 'DCAT_WaitDistChangeFromLocation_WaitDistanceChange::MaximumDistance' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromLocation_WaitDistanceChange, ReturnValue) == 0x000028, "Member 'DCAT_WaitDistChangeFromLocation_WaitDistanceChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.BlizzardBase.OnBlizzardIndex
// 0x0004 (0x0004 - 0x0000)
struct BlizzardBase_OnBlizzardIndex final
{
public:
	int32                                         InIndex;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlizzardBase_OnBlizzardIndex) == 0x000004, "Wrong alignment on BlizzardBase_OnBlizzardIndex");
static_assert(sizeof(BlizzardBase_OnBlizzardIndex) == 0x000004, "Wrong size on BlizzardBase_OnBlizzardIndex");
static_assert(offsetof(BlizzardBase_OnBlizzardIndex, InIndex) == 0x000000, "Member 'BlizzardBase_OnBlizzardIndex::InIndex' has a wrong offset!");

// Function DungeonCrawler.BlizzardBase.OnNewPlayerCharacterRegistered
// 0x0008 (0x0008 - 0x0000)
struct BlizzardBase_OnNewPlayerCharacterRegistered final
{
public:
	class ADCCharacterBase*                       InRegisteredCharacter;                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlizzardBase_OnNewPlayerCharacterRegistered) == 0x000008, "Wrong alignment on BlizzardBase_OnNewPlayerCharacterRegistered");
static_assert(sizeof(BlizzardBase_OnNewPlayerCharacterRegistered) == 0x000008, "Wrong size on BlizzardBase_OnNewPlayerCharacterRegistered");
static_assert(offsetof(BlizzardBase_OnNewPlayerCharacterRegistered, InRegisteredCharacter) == 0x000000, "Member 'BlizzardBase_OnNewPlayerCharacterRegistered::InRegisteredCharacter' has a wrong offset!");

// Function DungeonCrawler.BlizzardBase.OnRep_GameBlizzardData
// 0x0040 (0x0040 - 0x0000)
struct BlizzardBase_OnRep_GameBlizzardData final
{
public:
	struct FGameBlizzardData                      InOldGameBlizzardData;                             // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlizzardBase_OnRep_GameBlizzardData) == 0x000008, "Wrong alignment on BlizzardBase_OnRep_GameBlizzardData");
static_assert(sizeof(BlizzardBase_OnRep_GameBlizzardData) == 0x000040, "Wrong size on BlizzardBase_OnRep_GameBlizzardData");
static_assert(offsetof(BlizzardBase_OnRep_GameBlizzardData, InOldGameBlizzardData) == 0x000000, "Member 'BlizzardBase_OnRep_GameBlizzardData::InOldGameBlizzardData' has a wrong offset!");

// Function DungeonCrawler.BlizzardBase.OnRep_GameFloorRuleData
// 0x0040 (0x0040 - 0x0000)
struct BlizzardBase_OnRep_GameFloorRuleData final
{
public:
	struct FGameFloorRuleData                     InOldGameFloorRuleData;                            // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlizzardBase_OnRep_GameFloorRuleData) == 0x000008, "Wrong alignment on BlizzardBase_OnRep_GameFloorRuleData");
static_assert(sizeof(BlizzardBase_OnRep_GameFloorRuleData) == 0x000040, "Wrong size on BlizzardBase_OnRep_GameFloorRuleData");
static_assert(offsetof(BlizzardBase_OnRep_GameFloorRuleData, InOldGameFloorRuleData) == 0x000000, "Member 'BlizzardBase_OnRep_GameFloorRuleData::InOldGameFloorRuleData' has a wrong offset!");

// Function DungeonCrawler.BlizzardInterface.BindBlizzardDataDelegate
// 0x0010 (0x0010 - 0x0000)
struct BlizzardInterface_BindBlizzardDataDelegate final
{
public:
	TDelegate<void(struct FGameBlizzardData& InBlizzardData)> InBindDelegate;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlizzardInterface_BindBlizzardDataDelegate) == 0x000004, "Wrong alignment on BlizzardInterface_BindBlizzardDataDelegate");
static_assert(sizeof(BlizzardInterface_BindBlizzardDataDelegate) == 0x000010, "Wrong size on BlizzardInterface_BindBlizzardDataDelegate");
static_assert(offsetof(BlizzardInterface_BindBlizzardDataDelegate, InBindDelegate) == 0x000000, "Member 'BlizzardInterface_BindBlizzardDataDelegate::InBindDelegate' has a wrong offset!");

// Function DungeonCrawler.BlizzardInterface.UnbindBlizzardDataDelegate
// 0x0008 (0x0008 - 0x0000)
struct BlizzardInterface_UnbindBlizzardDataDelegate final
{
public:
	class UObject*                                InBoundObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlizzardInterface_UnbindBlizzardDataDelegate) == 0x000008, "Wrong alignment on BlizzardInterface_UnbindBlizzardDataDelegate");
static_assert(sizeof(BlizzardInterface_UnbindBlizzardDataDelegate) == 0x000008, "Wrong size on BlizzardInterface_UnbindBlizzardDataDelegate");
static_assert(offsetof(BlizzardInterface_UnbindBlizzardDataDelegate, InBoundObject) == 0x000000, "Member 'BlizzardInterface_UnbindBlizzardDataDelegate::InBoundObject' has a wrong offset!");

// Function DungeonCrawler.BlizzardInterface.GetBlizzardData
// 0x0040 (0x0040 - 0x0000)
struct BlizzardInterface_GetBlizzardData final
{
public:
	struct FGameBlizzardData                      ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlizzardInterface_GetBlizzardData) == 0x000008, "Wrong alignment on BlizzardInterface_GetBlizzardData");
static_assert(sizeof(BlizzardInterface_GetBlizzardData) == 0x000040, "Wrong size on BlizzardInterface_GetBlizzardData");
static_assert(offsetof(BlizzardInterface_GetBlizzardData, ReturnValue) == 0x000000, "Member 'BlizzardInterface_GetBlizzardData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.BlizzardInterface.LogHandleBlizzardData
// 0x0048 (0x0048 - 0x0000)
struct BlizzardInterface_LogHandleBlizzardData final
{
public:
	const class UObject*                          InHandler;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameBlizzardData                      InBlizzardData;                                    // 0x0008(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlizzardInterface_LogHandleBlizzardData) == 0x000008, "Wrong alignment on BlizzardInterface_LogHandleBlizzardData");
static_assert(sizeof(BlizzardInterface_LogHandleBlizzardData) == 0x000048, "Wrong size on BlizzardInterface_LogHandleBlizzardData");
static_assert(offsetof(BlizzardInterface_LogHandleBlizzardData, InHandler) == 0x000000, "Member 'BlizzardInterface_LogHandleBlizzardData::InHandler' has a wrong offset!");
static_assert(offsetof(BlizzardInterface_LogHandleBlizzardData, InBlizzardData) == 0x000008, "Member 'BlizzardInterface_LogHandleBlizzardData::InBlizzardData' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayCue
// 0x00E8 (0x00E8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_AddGameplayCue final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0010(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_AddGameplayCue) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_AddGameplayCue");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_AddGameplayCue) == 0x0000E8, "Wrong size on DCAbilitySystemBlueprintLibrary_AddGameplayCue");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayCue, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayCue::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayCue, GameplayCueTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayCue, GameplayCueParameters) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayCue::GameplayCueParameters' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayCueLocal
// 0x00E8 (0x00E8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0010(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal) == 0x0000E8, "Wrong size on DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal, GameplayCueTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal, GameplayCueParameters) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal::GameplayCueParameters' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_AddGameplayTag final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23BE[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_AddGameplayTag) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_AddGameplayTag");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_AddGameplayTag) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_AddGameplayTag");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayTag, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayTag::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayTag, InGameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayTag::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayTag, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayTagContainer
// 0x0030 (0x0030 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InGameplayTagContainer;                            // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer) == 0x000030, "Wrong size on DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer, InGameplayTagContainer) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer::InGameplayTagContainer' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer, ReturnValue) == 0x000028, "Member 'DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddLooseGameplayTag
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_AddLooseGameplayTag final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_AddLooseGameplayTag) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_AddLooseGameplayTag");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_AddLooseGameplayTag) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_AddLooseGameplayTag");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddLooseGameplayTag, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_AddLooseGameplayTag::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AddLooseGameplayTag, GameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_AddLooseGameplayTag::GameplayTag' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimFromHitResultToActorViewPoint
// 0x0108 (0x0108 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             InHitResult;                                       // 0x0008(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     OutHitResults;                                     // 0x00F0(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0100(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23BF[0x7];                                     // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint) == 0x000108, "Wrong size on DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint, InHitResult) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint::InHitResult' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint, OutHitResults) == 0x0000F0, "Member 'DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint::OutHitResults' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint, TraceChannel) == 0x000100, "Member 'DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint::TraceChannel' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimLineWithActorPointToViewPointResult
// 0x0038 (0x0038 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceStart;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     OutHitResults;                                     // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C0[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRange;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult) == 0x000038, "Wrong size on DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult, TraceStart) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult::TraceStart' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult, OutHitResults) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult::OutHitResults' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult, TraceChannel) == 0x000030, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult::TraceChannel' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult, MaxRange) == 0x000034, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult::MaxRange' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimLineWithActorViewPoint
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     OutHitResults;                                     // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C1[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRange;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint, OutHitResults) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint::OutHitResults' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint, TraceChannel) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint::TraceChannel' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint, MaxRange) == 0x00001C, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint::MaxRange' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimLineWithActorViewPointToPoint
// 0x0038 (0x0038 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     OutHitResults;                                     // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C2[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint) == 0x000038, "Wrong size on DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint, TraceEnd) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint::TraceEnd' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint, OutHitResults) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint::OutHitResults' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint, TraceChannel) == 0x000030, "Member 'DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint::TraceChannel' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimSphereWithActorViewPoint
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C3[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHitResults;                                     // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C4[0x3];                                     // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxRange;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint, Radius) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint::Radius' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint, OutHitResults) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint::OutHitResults' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint, TraceChannel) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint::TraceChannel' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint, MaxRange) == 0x000024, "Member 'DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint::MaxRange' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyEffectContainerSpec
// 0x0060 (0x0060 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec final
{
public:
	struct FDCGameplayEffectContainerSpec         ContainerSpec;                                     // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InStackCount;                                      // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsApplyTargetSelf;                                // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C5[0x3];                                     // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec) == 0x000060, "Wrong size on DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec, ContainerSpec) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec::ContainerSpec' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec, InStackCount) == 0x000048, "Member 'DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec::InStackCount' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec, bIsApplyTargetSelf) == 0x00004C, "Member 'DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec::bIsApplyTargetSelf' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec, ReturnValue) == 0x000050, "Member 'DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffect
// 0x02B8 (0x02B8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataGameplayEffect              InDesignDataGameplayEffect;                        // 0x0008(0x02A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 InSourceActor;                                     // 0x02A8(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ReturnValue;                                       // 0x02B0(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect) == 0x0002B8, "Wrong size on DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect, InDesignDataGameplayEffect) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect::InDesignDataGameplayEffect' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect, InSourceActor) == 0x0002A8, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect::InSourceActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect, ReturnValue) == 0x0002B0, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffectByIds
// 0x0030 (0x0030 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                InGameplayEffectIdArray;                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 InSourceActor;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds) == 0x000030, "Wrong size on DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds, InGameplayEffectIdArray) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds::InGameplayEffectIdArray' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds, InSourceActor) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds::InSourceActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds, ReturnValue) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffects
// 0x0030 (0x0030 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectData>          InGameplayEffectDataArray;                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 InSourceActor;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects) == 0x000030, "Wrong size on DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects, InGameplayEffectDataArray) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects::InGameplayEffectDataArray' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects, InSourceActor) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects::InSourceActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects, ReturnValue) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyPremadeSpecArray
// 0x00D0 (0x00D0 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ContainerTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0010(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    ReturnValue;                                       // 0x00C0(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray) == 0x0000D0, "Wrong size on DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray, ContainerTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray::ContainerTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray, EventData) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray::EventData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray, ReturnValue) == 0x0000C0, "Member 'DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.CancelAllAbilities
// 0x0008 (0x0008 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_CancelAllAbilities final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_CancelAllAbilities) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_CancelAllAbilities");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_CancelAllAbilities) == 0x000008, "Wrong size on DCAbilitySystemBlueprintLibrary_CancelAllAbilities");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_CancelAllAbilities, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_CancelAllAbilities::InActor' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ClearAllAbilities
// 0x0008 (0x0008 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_ClearAllAbilities final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_ClearAllAbilities) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_ClearAllAbilities");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_ClearAllAbilities) == 0x000008, "Wrong size on DCAbilitySystemBlueprintLibrary_ClearAllAbilities");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ClearAllAbilities, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_ClearAllAbilities::InActor' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextAddHitResult
// 0x0510 (0x0510 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0420(0x00E8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bReset;                                            // 0x0508(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C6[0x7];                                     // 0x0509(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult) == 0x000510, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult, HitResult) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult::HitResult' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult, bReset) == 0x000508, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult::bReset' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetEffectCauser
// 0x0428 (0x0428 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0420(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser) == 0x000428, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser, ReturnValue) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetHitResult
// 0x0508 (0x0508 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FHitResult                             ReturnValue;                                       // 0x0420(0x00E8)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult) == 0x000508, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult, ReturnValue) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetInstigatorActor
// 0x0428 (0x0428 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0420(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor) == 0x000428, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor, ReturnValue) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetOrigin
// 0x0438 (0x0438 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0420(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin) == 0x000438, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin, ReturnValue) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetOriginalInstigatorActor
// 0x0428 (0x0428 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0420(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor) == 0x000428, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor, ReturnValue) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetSoundDataPrimaryAssetId
// 0x0430 (0x0430 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0420(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId) == 0x000430, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId, ReturnValue) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetSourceObject
// 0x0428 (0x0428 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0420(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject) == 0x000428, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject, ReturnValue) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextHasHitResult
// 0x0428 (0x0428 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0420(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C7[0x7];                                     // 0x0421(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult) == 0x000428, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult, ReturnValue) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextSetOrigin
// 0x0438 (0x0438 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0420(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin) == 0x000438, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin, Origin) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin::Origin' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextSetSoundDataPrimaryAssetId
// 0x0430 (0x0430 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId final
{
public:
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0000(0x0420)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0420(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId) == 0x000430, "Wrong size on DCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId, PrimaryAssetId) == 0x000420, "Member 'DCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId::PrimaryAssetId' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetEffectId
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_EffectContextGetEffectId final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_EffectContextGetEffectId) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_EffectContextGetEffectId");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_EffectContextGetEffectId) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_EffectContextGetEffectId");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_EffectContextGetEffectId, EffectContextHandle) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_EffectContextGetEffectId::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_EffectContextGetEffectId, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_EffectContextGetEffectId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetItemDatas
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_EffectContextGetItemDatas final
{
public:
	struct FGameplayEffectContextHandle           EffectContextHandle;                               // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	TArray<struct FItemData>                      ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_EffectContextGetItemDatas) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_EffectContextGetItemDatas");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_EffectContextGetItemDatas) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_EffectContextGetItemDatas");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_EffectContextGetItemDatas, EffectContextHandle) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_EffectContextGetItemDatas::EffectContextHandle' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_EffectContextGetItemDatas, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_EffectContextGetItemDatas::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetSoundData
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_EffectContextGetSoundData final
{
public:
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class USoundData*                             ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_EffectContextGetSoundData) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_EffectContextGetSoundData");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_EffectContextGetSoundData) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_EffectContextGetSoundData");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_EffectContextGetSoundData, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_EffectContextGetSoundData::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_EffectContextGetSoundData, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_EffectContextGetSoundData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetSoundDataPrimaryAssetId
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId final
{
public:
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextSetSoundDataPrimaryAssetId
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId final
{
public:
	struct FGameplayEffectContextHandle           EffectContext;                                     // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0018(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId, EffectContext) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId::EffectContext' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId, PrimaryAssetId) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId::PrimaryAssetId' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ExecuteGameplayCue
// 0x00E8 (0x00E8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0010(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue) == 0x0000E8, "Wrong size on DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue, GameplayCueTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue, GameplayCueParameters) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue::GameplayCueParameters' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ExecuteGameplayCueLocal
// 0x00E8 (0x00E8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0010(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal) == 0x0000E8, "Wrong size on DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal, GameplayCueTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal, GameplayCueParameters) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal::GameplayCueParameters' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.FindSocketOwningMeshComponent
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          Object;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           AvatarActor;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent, SocketName) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent::SocketName' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent, Object) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent::Object' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent, AvatarActor) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent::AvatarActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetActorAttributeValue
// 0x0048 (0x0048 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetActorAttributeValue final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     InAttribute;                                       // 0x0008(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C8[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetActorAttributeValue) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetActorAttributeValue");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetActorAttributeValue) == 0x000048, "Wrong size on DCAbilitySystemBlueprintLibrary_GetActorAttributeValue");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetActorAttributeValue, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetActorAttributeValue::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetActorAttributeValue, InAttribute) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetActorAttributeValue::InAttribute' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetActorAttributeValue, ReturnValue) == 0x000040, "Member 'DCAbilitySystemBlueprintLibrary_GetActorAttributeValue::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetBoundingBoxPointsLocation
// 0x0088 (0x0088 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTarget;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutTop;                                            // 0x0010(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutBottom;                                         // 0x0028(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLeft;                                           // 0x0040(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutRight;                                          // 0x0058(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutCenter;                                         // 0x0070(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation) == 0x000088, "Wrong size on DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation, InTarget) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation::InTarget' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation, OutTop) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation::OutTop' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation, OutBottom) == 0x000028, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation::OutBottom' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation, OutLeft) == 0x000040, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation::OutLeft' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation, OutRight) == 0x000058, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation::OutRight' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation, OutCenter) == 0x000070, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation::OutCenter' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetBoundingBoxPointsLocationFromLocation
// 0x0098 (0x0098 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation final
{
public:
	class AActor*                                 InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InStartLocation;                                   // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutTop;                                            // 0x0020(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutBottom;                                         // 0x0038(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLeft;                                           // 0x0050(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutRight;                                          // 0x0068(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutCenter;                                         // 0x0080(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation) == 0x000098, "Wrong size on DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation, InTarget) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation::InTarget' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation, InStartLocation) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation::InStartLocation' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation, OutTop) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation::OutTop' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation, OutBottom) == 0x000038, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation::OutBottom' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation, OutLeft) == 0x000050, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation::OutLeft' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation, OutRight) == 0x000068, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation::OutRight' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation, OutCenter) == 0x000080, "Member 'DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation::OutCenter' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetCharacterPrimitiveAttributes
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetCharacterPrimitiveAttributes final
{
public:
	TArray<struct FGameplayAttribute>             ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetCharacterPrimitiveAttributes) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetCharacterPrimitiveAttributes");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetCharacterPrimitiveAttributes) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_GetCharacterPrimitiveAttributes");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetCharacterPrimitiveAttributes, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetCharacterPrimitiveAttributes::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetCurrentMontagePlayRate
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetCurrentMontagePlayRate final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C9[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetCurrentMontagePlayRate) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetCurrentMontagePlayRate");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetCurrentMontagePlayRate) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_GetCurrentMontagePlayRate");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetCurrentMontagePlayRate, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetCurrentMontagePlayRate::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetCurrentMontagePlayRate, ReturnValue) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetCurrentMontagePlayRate::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetCurrentMontageSectionName
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName, ReturnValue) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetCurseDebuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetCurseDebuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetCurseDebuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetCurseDebuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetCurseDebuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetCurseDebuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetCurseDebuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetCurseDebuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetDCAbilitySystemComponent
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetDCAbilitySystemComponent final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAbilitySystemComponent*              ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetDCAbilitySystemComponent) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetDCAbilitySystemComponent");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetDCAbilitySystemComponent) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_GetDCAbilitySystemComponent");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetDCAbilitySystemComponent, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetDCAbilitySystemComponent::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetDCAbilitySystemComponent, ReturnValue) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetDCAbilitySystemComponent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetDefaultUnscaledCapsuleSize
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutRadius;                                         // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutHalfHeight;                                     // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize, OutRadius) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize::OutRadius' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize, OutHalfHeight) == 0x00000C, "Member 'DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize::OutHalfHeight' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetEffectAssetTagsInEffectContainerArray
// 0x0038 (0x0038 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray final
{
public:
	struct FGameplayTag                           InEventTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectContainer>     InEffectContainer;                                 // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0018(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray) == 0x000038, "Wrong size on DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray, InEventTag) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray::InEventTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray, InEffectContainer) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray::InEffectContainer' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetEffectSpec
// 0x02A8 (0x02A8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetEffectSpec final
{
public:
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    OutEffectSpec;                                     // 0x0010(0x0298)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetEffectSpec) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetEffectSpec");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetEffectSpec) == 0x0002A8, "Wrong size on DCAbilitySystemBlueprintLibrary_GetEffectSpec");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetEffectSpec, SpecHandle) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetEffectSpec::SpecHandle' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetEffectSpec, OutEffectSpec) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetEffectSpec::OutEffectSpec' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayAbilityData
// 0x0090 (0x0090 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetGameplayAbilityData final
{
public:
	struct FDesignDataGameplayAbility             InDesignDataGameplayAbility;                       // 0x0000(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FDCGameplayAbilityData                 OutGameplayAbilityData;                            // 0x0068(0x0028)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetGameplayAbilityData) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetGameplayAbilityData");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetGameplayAbilityData) == 0x000090, "Wrong size on DCAbilitySystemBlueprintLibrary_GetGameplayAbilityData");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayAbilityData, InDesignDataGameplayAbility) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayAbilityData::InDesignDataGameplayAbility' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayAbilityData, OutGameplayAbilityData) == 0x000068, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayAbilityData::OutGameplayAbilityData' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayDataFromDesignDataSkill
// 0x0100 (0x0100 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill final
{
public:
	struct FDesignDataSkill                       InDesignDataSkill;                                 // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayAbilityData>         OutGameplayAbilityDataArray;                       // 0x00E0(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectData>          OutGameplayEffectDataArray;                        // 0x00F0(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill) == 0x000100, "Wrong size on DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill, InDesignDataSkill) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill::InDesignDataSkill' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill, OutGameplayAbilityDataArray) == 0x0000E0, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill::OutGameplayAbilityDataArray' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill, OutGameplayEffectDataArray) == 0x0000F0, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill::OutGameplayEffectDataArray' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayDataFromDesignDataSpell
// 0x00F8 (0x00F8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell final
{
public:
	struct FDesignDataSpell                       InDesignDataSpell;                                 // 0x0000(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayAbilityData>         OutGameplayAbilityDataArray;                       // 0x00D8(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectData>          OutGameplayEffectDataArray;                        // 0x00E8(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell) == 0x0000F8, "Wrong size on DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell, InDesignDataSpell) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell::InDesignDataSpell' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell, OutGameplayAbilityDataArray) == 0x0000D8, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell::OutGameplayAbilityDataArray' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell, OutGameplayEffectDataArray) == 0x0000E8, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell::OutGameplayEffectDataArray' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectData
// 0x0308 (0x0308 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetGameplayEffectData final
{
public:
	struct FDesignDataGameplayEffect              InDesignDataGameplayEffect;                        // 0x0000(0x02A0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectData                  OutGameplayEffectData;                             // 0x02A0(0x0068)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetGameplayEffectData) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetGameplayEffectData");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetGameplayEffectData) == 0x000308, "Wrong size on DCAbilitySystemBlueprintLibrary_GetGameplayEffectData");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayEffectData, InDesignDataGameplayEffect) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayEffectData::InDesignDataGameplayEffect' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayEffectData, OutGameplayEffectData) == 0x0002A0, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayEffectData::OutGameplayEffectData' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectSetByCallerValue
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue final
{
public:
	struct FGameplayTag                           InSetByCallerTag;                                  // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InSetByCallerValue;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue) == 0x000004, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue, InSetByCallerTag) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue::InSetByCallerTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue, InSetByCallerValue) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue::InSetByCallerValue' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue, ReturnValue) == 0x00000C, "Member 'DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGrantedTag
// 0x0030 (0x0030 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetGrantedTag final
{
public:
	struct FGameplayEffectSpecHandle              SpecHandle;                                        // 0x0000(0x0010)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetGrantedTag) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetGrantedTag");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetGrantedTag) == 0x000030, "Wrong size on DCAbilitySystemBlueprintLibrary_GetGrantedTag");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGrantedTag, SpecHandle) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetGrantedTag::SpecHandle' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetGrantedTag, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetGrantedTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetItemActor
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetItemActor final
{
public:
	struct FGameplayEffectContextHandle           Handle;                                            // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class AItemActor*                             ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetItemActor) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetItemActor");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetItemActor) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_GetItemActor");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetItemActor, Handle) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetItemActor::Handle' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetItemActor, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_GetItemActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetItemDataFromDesignData
// 0x0298 (0x0298 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData final
{
public:
	struct FDesignDataItem                        InDesignDataItem;                                  // 0x0000(0x0198)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FItemData                              OutItemData;                                       // 0x0198(0x0100)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData) == 0x000298, "Wrong size on DCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData, InDesignDataItem) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData::InDesignDataItem' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData, OutItemData) == 0x000198, "Member 'DCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData::OutItemData' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMagicBuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetMagicBuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetMagicBuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetMagicBuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetMagicBuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetMagicBuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMagicBuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetMagicBuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMagicDebuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetMagicDebuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetMagicDebuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetMagicDebuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetMagicDebuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetMagicDebuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMagicDebuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetMagicDebuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMatchingAbilityActivated
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDCGameplayAbilityBase*>         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated, InGameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMatchingAbilityActivatedCount
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CA[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount, InGameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMatchingAbilityActivatedTriggers
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers, InGameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMeleeAttackAbilityDamageRatioFromDesignData
// 0x0070 (0x0070 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromDesignData final
{
public:
	struct FDesignDataGameplayAbility             DesignDataGameplayAbility;                         // 0x0000(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0068(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CB[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromDesignData) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromDesignData");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromDesignData) == 0x000070, "Wrong size on DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromDesignData");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromDesignData, DesignDataGameplayAbility) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromDesignData::DesignDataGameplayAbility' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromDesignData, ReturnValue) == 0x000068, "Member 'DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromDesignData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMeleeAttackAbilityDamageRatioFromEffectSpec
// 0x02A0 (0x02A0 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromEffectSpec final
{
public:
	struct FGameplayEffectSpec                    InSpec;                                            // 0x0000(0x0298)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0298(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CC[0x4];                                     // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromEffectSpec) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromEffectSpec");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromEffectSpec) == 0x0002A0, "Wrong size on DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromEffectSpec");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromEffectSpec, InSpec) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromEffectSpec::InSpec' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromEffectSpec, ReturnValue) == 0x000298, "Member 'DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromEffectSpec::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMoveSpeedBuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetMoveSpeedBuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetMoveSpeedBuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetMoveSpeedBuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetMoveSpeedBuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetMoveSpeedBuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMoveSpeedBuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetMoveSpeedBuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMoveSpeedDebuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetMoveSpeedDebuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetMoveSpeedDebuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetMoveSpeedDebuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetMoveSpeedDebuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetMoveSpeedDebuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetMoveSpeedDebuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetMoveSpeedDebuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetOwnedGameplayTags
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0008(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags, TagContainer) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags::TagContainer' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetProjectileDamageCurveFloatValue
// 0x02A0 (0x02A0 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetProjectileDamageCurveFloatValue final
{
public:
	struct FGameplayEffectSpec                    InSpec;                                            // 0x0000(0x0298)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0298(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CD[0x4];                                     // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetProjectileDamageCurveFloatValue) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetProjectileDamageCurveFloatValue");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetProjectileDamageCurveFloatValue) == 0x0002A0, "Wrong size on DCAbilitySystemBlueprintLibrary_GetProjectileDamageCurveFloatValue");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetProjectileDamageCurveFloatValue, InSpec) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetProjectileDamageCurveFloatValue::InSpec' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetProjectileDamageCurveFloatValue, ReturnValue) == 0x000298, "Member 'DCAbilitySystemBlueprintLibrary_GetProjectileDamageCurveFloatValue::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetProtectionBuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetProtectionBuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetProtectionBuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetProtectionBuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetProtectionBuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetProtectionBuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetProtectionBuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetProtectionBuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableBuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetRemovableBuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetRemovableBuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetRemovableBuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetRemovableBuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetRemovableBuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetRemovableBuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetRemovableBuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableCurseDebuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetRemovableCurseDebuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetRemovableCurseDebuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetRemovableCurseDebuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetRemovableCurseDebuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetRemovableCurseDebuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetRemovableCurseDebuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetRemovableCurseDebuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableDebuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetRemovableDebuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetRemovableDebuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetRemovableDebuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetRemovableDebuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetRemovableDebuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetRemovableDebuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetRemovableDebuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableDrunkDebuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetRemovableDrunkDebuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetRemovableDrunkDebuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetRemovableDrunkDebuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetRemovableDrunkDebuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetRemovableDrunkDebuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetRemovableDrunkDebuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetRemovableDrunkDebuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableMagicBuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetRemovableMagicBuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetRemovableMagicBuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetRemovableMagicBuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetRemovableMagicBuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetRemovableMagicBuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetRemovableMagicBuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetRemovableMagicBuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableMagicDebuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetRemovableMagicDebuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetRemovableMagicDebuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetRemovableMagicDebuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetRemovableMagicDebuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetRemovableMagicDebuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetRemovableMagicDebuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetRemovableMagicDebuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableMoveSpeedBuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedBuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedBuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedBuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedBuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedBuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedBuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedBuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableMoveSpeedDebuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedDebuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedDebuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedDebuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedDebuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedDebuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedDebuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedDebuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableProtectionBuffEffectTagQuery
// 0x0198 (0x0198 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetRemovableProtectionBuffEffectTagQuery final
{
public:
	struct FGameplayEffectQuery                   ReturnValue;                                       // 0x0000(0x0198)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetRemovableProtectionBuffEffectTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetRemovableProtectionBuffEffectTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetRemovableProtectionBuffEffectTagQuery) == 0x000198, "Wrong size on DCAbilitySystemBlueprintLibrary_GetRemovableProtectionBuffEffectTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetRemovableProtectionBuffEffectTagQuery, ReturnValue) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetRemovableProtectionBuffEffectTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInAbilityAssets
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets final
{
public:
	struct FGameplayTag                           InEventTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InSetByCallerDataTag;                              // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDesignDataAssetGameplayAbility*> InAbilities;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CE[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets, InEventTag) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets::InEventTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets, InSetByCallerDataTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets::InSetByCallerDataTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets, InAbilities) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets::InAbilities' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets, ReturnValue) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInAbilityData
// 0x0040 (0x0040 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData final
{
public:
	struct FGameplayTag                           InEventTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InSetByCallerDataTag;                              // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayAbilityData                 InAbilityData;                                     // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bShouldGetOnlyOneValueInData;                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23CF[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x003C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData) == 0x000040, "Wrong size on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData, InEventTag) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData::InEventTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData, InSetByCallerDataTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData::InSetByCallerDataTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData, InAbilityData) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData::InAbilityData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData, bShouldGetOnlyOneValueInData) == 0x000038, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData::bShouldGetOnlyOneValueInData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData, ReturnValue) == 0x00003C, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInAbilityIds
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds final
{
public:
	struct FGameplayTag                           InEventTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InSetByCallerDataTag;                              // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                InAbilities;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D0[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds, InEventTag) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds::InEventTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds, InSetByCallerDataTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds::InSetByCallerDataTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds, InAbilities) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds::InAbilities' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds, ReturnValue) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInContainer
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer final
{
public:
	struct FGameplayTag                           InEventTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InSetByCallerDataTag;                              // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectContainer>     InEffectContainer;                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D1[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer, InEventTag) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer::InEventTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer, InSetByCallerDataTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer::InSetByCallerDataTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer, InEffectContainer) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer::InEffectContainer' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer, ReturnValue) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInContainerSpecArray
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray final
{
public:
	struct FGameplayTag                           InEventTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InSetByCallerDataTag;                              // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectContainerSpec> InEffectHandle;                                    // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D2[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray, InEventTag) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray::InEventTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray, InSetByCallerDataTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray::InSetByCallerDataTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray, InEffectHandle) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray::InEffectHandle' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray, ReturnValue) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInEffectAssets
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets final
{
public:
	struct FGameplayTag                           InSetByCallerDataTag;                              // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDesignDataAssetGameplayEffect*> InEffects;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D3[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets, InSetByCallerDataTag) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets::InSetByCallerDataTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets, InEffects) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets::InEffects' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInEffectData
// 0x0078 (0x0078 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData final
{
public:
	struct FGameplayTag                           InSetByCallerDataTag;                              // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectData                  InEffectData;                                      // 0x0008(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0070(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D4[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData) == 0x000078, "Wrong size on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData, InSetByCallerDataTag) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData::InSetByCallerDataTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData, InEffectData) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData::InEffectData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData, ReturnValue) == 0x000070, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInEffectIds
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds final
{
public:
	struct FGameplayTag                           InSetByCallerDataTag;                              // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                InEffects;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D5[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds, InSetByCallerDataTag) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds::InSetByCallerDataTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds, InEffects) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds::InEffects' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSocketLocationBySocketName
// 0x0030 (0x0030 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName final
{
public:
	class FName                                   SocketName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          Object;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           AvatarActor;                                       // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutSocketLocation;                                 // 0x0018(0x0018)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName) == 0x000030, "Wrong size on DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName, SocketName) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName::SocketName' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName, Object) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName::Object' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName, AvatarActor) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName::AvatarActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName, OutSocketLocation) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName::OutSocketLocation' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GiveAbilities
// 0x0038 (0x0038 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GiveAbilities final
{
public:
	class UObject*                                SourceObject;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InActor;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayAbilityData>         InGameplayAbilityDataArray;                        // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnlyOnce;                                  // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D6[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilitySpecHandle>     ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GiveAbilities) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GiveAbilities");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GiveAbilities) == 0x000038, "Wrong size on DCAbilitySystemBlueprintLibrary_GiveAbilities");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GiveAbilities, SourceObject) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GiveAbilities::SourceObject' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GiveAbilities, InActor) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GiveAbilities::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GiveAbilities, InGameplayAbilityDataArray) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GiveAbilities::InGameplayAbilityDataArray' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GiveAbilities, bTriggerOnlyOnce) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_GiveAbilities::bTriggerOnlyOnce' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GiveAbilities, ReturnValue) == 0x000028, "Member 'DCAbilitySystemBlueprintLibrary_GiveAbilities::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GiveAbility
// 0x0040 (0x0040 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_GiveAbility final
{
public:
	class UObject*                                SourceObject;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InActor;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayAbilityData                 InGameplayAbilityData;                             // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnlyOnce;                                  // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D7[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilitySpecHandle             ReturnValue;                                       // 0x003C(0x0004)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_GiveAbility) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_GiveAbility");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_GiveAbility) == 0x000040, "Wrong size on DCAbilitySystemBlueprintLibrary_GiveAbility");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GiveAbility, SourceObject) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_GiveAbility::SourceObject' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GiveAbility, InActor) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_GiveAbility::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GiveAbility, InGameplayAbilityData) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_GiveAbility::InGameplayAbilityData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GiveAbility, bTriggerOnlyOnce) == 0x000038, "Member 'DCAbilitySystemBlueprintLibrary_GiveAbility::bTriggerOnlyOnce' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_GiveAbility, ReturnValue) == 0x00003C, "Member 'DCAbilitySystemBlueprintLibrary_GiveAbility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.HasAnyMatchingGameplayTags
// 0x0030 (0x0030 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Tags;                                              // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D8[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags) == 0x000030, "Wrong size on DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags, Tags) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags::Tags' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags, ReturnValue) == 0x000028, "Member 'DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.HasMatchingGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagToCheck;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23D9[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag, TagToCheck) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag::TagToCheck' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsInstigatorAppliedEffectToTarget
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget final
{
public:
	const class AActor*                           InInstigator;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTarget;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23DA[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget, InInstigator) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget::InInstigator' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget, InTarget) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget::InTarget' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget, InGameplayTag) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsMagicalAttackHit
// 0x00B8 (0x00B8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsMagicalAttackHit final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23DB[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsMagicalAttackHit) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsMagicalAttackHit");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsMagicalAttackHit) == 0x0000B8, "Wrong size on DCAbilitySystemBlueprintLibrary_IsMagicalAttackHit");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsMagicalAttackHit, EventData) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsMagicalAttackHit::EventData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsMagicalAttackHit, ReturnValue) == 0x0000B0, "Member 'DCAbilitySystemBlueprintLibrary_IsMagicalAttackHit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsMatchingAbilityActivated
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23DC[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated, InGameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsMeaningfulCharacterTarget
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsMeaningfulCharacterTarget final
{
public:
	const class AActor*                           InTarget;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23DD[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsMeaningfulCharacterTarget) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsMeaningfulCharacterTarget");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsMeaningfulCharacterTarget) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_IsMeaningfulCharacterTarget");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsMeaningfulCharacterTarget, InTarget) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsMeaningfulCharacterTarget::InTarget' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsMeaningfulCharacterTarget, ReturnValue) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_IsMeaningfulCharacterTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsMeleeAttackHit
// 0x00B8 (0x00B8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsMeleeAttackHit final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23DE[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsMeleeAttackHit) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsMeleeAttackHit");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsMeleeAttackHit) == 0x0000B8, "Wrong size on DCAbilitySystemBlueprintLibrary_IsMeleeAttackHit");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsMeleeAttackHit, EventData) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsMeleeAttackHit::EventData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsMeleeAttackHit, ReturnValue) == 0x0000B0, "Member 'DCAbilitySystemBlueprintLibrary_IsMeleeAttackHit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsOnHitSkillActivatingPhysicalAttackHit
// 0x00B8 (0x00B8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsOnHitSkillActivatingPhysicalAttackHit final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23DF[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsOnHitSkillActivatingPhysicalAttackHit) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsOnHitSkillActivatingPhysicalAttackHit");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsOnHitSkillActivatingPhysicalAttackHit) == 0x0000B8, "Wrong size on DCAbilitySystemBlueprintLibrary_IsOnHitSkillActivatingPhysicalAttackHit");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsOnHitSkillActivatingPhysicalAttackHit, EventData) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsOnHitSkillActivatingPhysicalAttackHit::EventData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsOnHitSkillActivatingPhysicalAttackHit, ReturnValue) == 0x0000B0, "Member 'DCAbilitySystemBlueprintLibrary_IsOnHitSkillActivatingPhysicalAttackHit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsProjectileAttackHit
// 0x00B8 (0x00B8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsProjectileAttackHit final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E0[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsProjectileAttackHit) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsProjectileAttackHit");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsProjectileAttackHit) == 0x0000B8, "Wrong size on DCAbilitySystemBlueprintLibrary_IsProjectileAttackHit");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsProjectileAttackHit, EventData) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsProjectileAttackHit::EventData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsProjectileAttackHit, ReturnValue) == 0x0000B0, "Member 'DCAbilitySystemBlueprintLibrary_IsProjectileAttackHit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsRangedMagicalAttackHit
// 0x00B8 (0x00B8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsRangedMagicalAttackHit final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E1[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsRangedMagicalAttackHit) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsRangedMagicalAttackHit");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsRangedMagicalAttackHit) == 0x0000B8, "Wrong size on DCAbilitySystemBlueprintLibrary_IsRangedMagicalAttackHit");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsRangedMagicalAttackHit, EventData) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsRangedMagicalAttackHit::EventData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsRangedMagicalAttackHit, ReturnValue) == 0x0000B0, "Member 'DCAbilitySystemBlueprintLibrary_IsRangedMagicalAttackHit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsRangedPhysicalAttackHit
// 0x00B8 (0x00B8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsRangedPhysicalAttackHit final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E2[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsRangedPhysicalAttackHit) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsRangedPhysicalAttackHit");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsRangedPhysicalAttackHit) == 0x0000B8, "Wrong size on DCAbilitySystemBlueprintLibrary_IsRangedPhysicalAttackHit");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsRangedPhysicalAttackHit, EventData) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsRangedPhysicalAttackHit::EventData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsRangedPhysicalAttackHit, ReturnValue) == 0x0000B0, "Member 'DCAbilitySystemBlueprintLibrary_IsRangedPhysicalAttackHit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsSameTeam
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsSameTeam final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E3[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsSameTeam) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsSameTeam");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsSameTeam) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_IsSameTeam");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsSameTeam, SourceActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsSameTeam::SourceActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsSameTeam, TargetActor) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_IsSameTeam::TargetActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsSameTeam, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_IsSameTeam::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsSameTeamWithPartyId
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InPartyId;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E4[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId, SourceActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId::SourceActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId, InPartyId) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId::InPartyId' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId, ReturnValue) == 0x000018, "Member 'DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsSystemDamage
// 0x00B8 (0x00B8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsSystemDamage final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E5[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsSystemDamage) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsSystemDamage");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsSystemDamage) == 0x0000B8, "Wrong size on DCAbilitySystemBlueprintLibrary_IsSystemDamage");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsSystemDamage, EventData) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsSystemDamage::EventData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsSystemDamage, ReturnValue) == 0x0000B0, "Member 'DCAbilitySystemBlueprintLibrary_IsSystemDamage::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsSystemDamageFromEffectData
// 0x00B8 (0x00B8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsSystemDamageFromEffectData final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E6[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsSystemDamageFromEffectData) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsSystemDamageFromEffectData");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsSystemDamageFromEffectData) == 0x0000B8, "Wrong size on DCAbilitySystemBlueprintLibrary_IsSystemDamageFromEffectData");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsSystemDamageFromEffectData, EventData) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsSystemDamageFromEffectData::EventData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsSystemDamageFromEffectData, ReturnValue) == 0x0000B0, "Member 'DCAbilitySystemBlueprintLibrary_IsSystemDamageFromEffectData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsTargetLocationSightBlocked
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E7[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked, InLocation) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked::InLocation' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked, ReturnValue) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsTargetSightBlocked
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTarget;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetExcluded;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E8[0x6];                                     // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked, InTarget) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked::InTarget' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked, bIsTargetExcluded) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked::bIsTargetExcluded' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked, ReturnValue) == 0x000011, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsTargetSightBlockedFromLocation
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation final
{
public:
	class AActor*                                 InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTargetExcluded;                                 // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E9[0x6];                                     // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation, InTarget) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation::InTarget' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation, InLocation) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation::InLocation' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation, bIsTargetExcluded) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation::bIsTargetExcluded' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation, ReturnValue) == 0x000021, "Member 'DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsUtilityThrowableAttackHit
// 0x00B8 (0x00B8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_IsUtilityThrowableAttackHit final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00B0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23EA[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_IsUtilityThrowableAttackHit) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_IsUtilityThrowableAttackHit");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_IsUtilityThrowableAttackHit) == 0x0000B8, "Wrong size on DCAbilitySystemBlueprintLibrary_IsUtilityThrowableAttackHit");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsUtilityThrowableAttackHit, EventData) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_IsUtilityThrowableAttackHit::EventData' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_IsUtilityThrowableAttackHit, ReturnValue) == 0x0000B0, "Member 'DCAbilitySystemBlueprintLibrary_IsUtilityThrowableAttackHit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.MatchesQuery
// 0x0058 (0x0058 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_MatchesQuery final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      InTagQuery;                                        // 0x0008(0x0048)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23EB[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_MatchesQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_MatchesQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_MatchesQuery) == 0x000058, "Wrong size on DCAbilitySystemBlueprintLibrary_MatchesQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_MatchesQuery, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_MatchesQuery::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_MatchesQuery, InTagQuery) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_MatchesQuery::InTagQuery' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_MatchesQuery, ReturnValue) == 0x000050, "Member 'DCAbilitySystemBlueprintLibrary_MatchesQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.MessageNotifyByReasonTag
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MsgDuration;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23EC[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag, InGameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag, MsgDuration) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag::MsgDuration' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.MessageNotifyByReasonTagContainer
// 0x0030 (0x0030 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InGameplayTags;                                    // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         MsgDuration;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23ED[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer) == 0x000030, "Wrong size on DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer, InGameplayTags) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer::InGameplayTags' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer, MsgDuration) == 0x000028, "Member 'DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer::MsgDuration' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ParseOptionGameplayTag
// 0x0028 (0x0028 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag final
{
public:
	class FString                                 InOptionStr;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InOptionKey;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag) == 0x000028, "Wrong size on DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag, InOptionStr) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag::InOptionStr' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag, InOptionKey) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag::InOptionKey' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag, ReturnValue) == 0x000020, "Member 'DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveActiveEffectsWithGrantedTags
// 0x0030 (0x0030 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Tags;                                              // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23EE[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags) == 0x000030, "Wrong size on DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags, Tags) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags::Tags' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags, ReturnValue) == 0x000028, "Member 'DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveActiveGameplayEffect
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            InHandle;                                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23EF[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect, InHandle) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect::InHandle' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveEffectWithTagQuery
// 0x01A8 (0x01A8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectQuery                   InGameplayTagQuery;                                // 0x0008(0x0198)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x01A0(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F0[0x4];                                     // 0x01A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery) == 0x0001A8, "Wrong size on DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery, InGameplayTagQuery) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery::InGameplayTagQuery' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery, ReturnValue) == 0x0001A0, "Member 'DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayCue
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_RemoveGameplayCue final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_RemoveGameplayCue) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_RemoveGameplayCue");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_RemoveGameplayCue) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_RemoveGameplayCue");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveGameplayCue, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_RemoveGameplayCue::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveGameplayCue, GameplayCueTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_RemoveGameplayCue::GameplayCueTag' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayCueLocal
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal, GameplayCueTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal::GameplayCueTag' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_RemoveGameplayTag final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F1[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_RemoveGameplayTag) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_RemoveGameplayTag");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_RemoveGameplayTag) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_RemoveGameplayTag");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveGameplayTag, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_RemoveGameplayTag::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveGameplayTag, InGameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_RemoveGameplayTag::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveGameplayTag, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_RemoveGameplayTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveLooseGameplayTagAll
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0008(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll) == 0x000010, "Wrong size on DCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll, GameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll::GameplayTag' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SendGameplayEventToActorOverride
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectData>          InOverrideGameplayEffectDataArray;                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride) == 0x000020, "Wrong size on DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride, Actor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride::Actor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride, EventTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride::EventTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride, InOverrideGameplayEffectDataArray) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride::InOverrideGameplayEffectDataArray' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SetAnimationStateGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F2[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag, InGameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SetModeGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_SetModeGameplayTag final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F3[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_SetModeGameplayTag) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_SetModeGameplayTag");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_SetModeGameplayTag) == 0x000018, "Wrong size on DCAbilitySystemBlueprintLibrary_SetModeGameplayTag");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_SetModeGameplayTag, InActor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_SetModeGameplayTag::InActor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_SetModeGameplayTag, InGameplayTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_SetModeGameplayTag::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_SetModeGameplayTag, ReturnValue) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_SetModeGameplayTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.TriggerAbilityFromGameplayEvent
// 0x00C8 (0x00C8 - 0x0000)
struct DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     Payload;                                           // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x00C0(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F4[0x4];                                     // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent) == 0x000008, "Wrong alignment on DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent");
static_assert(sizeof(DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent) == 0x0000C8, "Wrong size on DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent, Actor) == 0x000000, "Member 'DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent::Actor' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent, EventTag) == 0x000008, "Member 'DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent::EventTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent, Payload) == 0x000010, "Member 'DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent::Payload' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent, ReturnValue) == 0x0000C0, "Member 'DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerWidget.GetSelectCategoryTextVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCReportPlayerWidget_GetSelectCategoryTextVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerWidget_GetSelectCategoryTextVisibility) == 0x000001, "Wrong alignment on DCReportPlayerWidget_GetSelectCategoryTextVisibility");
static_assert(sizeof(DCReportPlayerWidget_GetSelectCategoryTextVisibility) == 0x000001, "Wrong size on DCReportPlayerWidget_GetSelectCategoryTextVisibility");
static_assert(offsetof(DCReportPlayerWidget_GetSelectCategoryTextVisibility, ReturnValue) == 0x000000, "Member 'DCReportPlayerWidget_GetSelectCategoryTextVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerWidget.HandleCheckStatedChanged
// 0x0002 (0x0002 - 0x0000)
struct DCReportPlayerWidget_HandleCheckStatedChanged final
{
public:
	EDCReportPlayerCategory                       InCategory;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InbNewChecked;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerWidget_HandleCheckStatedChanged) == 0x000001, "Wrong alignment on DCReportPlayerWidget_HandleCheckStatedChanged");
static_assert(sizeof(DCReportPlayerWidget_HandleCheckStatedChanged) == 0x000002, "Wrong size on DCReportPlayerWidget_HandleCheckStatedChanged");
static_assert(offsetof(DCReportPlayerWidget_HandleCheckStatedChanged, InCategory) == 0x000000, "Member 'DCReportPlayerWidget_HandleCheckStatedChanged::InCategory' has a wrong offset!");
static_assert(offsetof(DCReportPlayerWidget_HandleCheckStatedChanged, InbNewChecked) == 0x000001, "Member 'DCReportPlayerWidget_HandleCheckStatedChanged::InbNewChecked' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerWidget.HandleReportTextChanged
// 0x0018 (0x0018 - 0x0000)
struct DCReportPlayerWidget_HandleReportTextChanged final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerWidget_HandleReportTextChanged) == 0x000008, "Wrong alignment on DCReportPlayerWidget_HandleReportTextChanged");
static_assert(sizeof(DCReportPlayerWidget_HandleReportTextChanged) == 0x000018, "Wrong size on DCReportPlayerWidget_HandleReportTextChanged");
static_assert(offsetof(DCReportPlayerWidget_HandleReportTextChanged, InText) == 0x000000, "Member 'DCReportPlayerWidget_HandleReportTextChanged::InText' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerWidget.IsReportCategorySelected
// 0x0001 (0x0001 - 0x0000)
struct DCReportPlayerWidget_IsReportCategorySelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerWidget_IsReportCategorySelected) == 0x000001, "Wrong alignment on DCReportPlayerWidget_IsReportCategorySelected");
static_assert(sizeof(DCReportPlayerWidget_IsReportCategorySelected) == 0x000001, "Wrong size on DCReportPlayerWidget_IsReportCategorySelected");
static_assert(offsetof(DCReportPlayerWidget_IsReportCategorySelected, ReturnValue) == 0x000000, "Member 'DCReportPlayerWidget_IsReportCategorySelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerWidget.OnBlockConfirmed
// 0x0001 (0x0001 - 0x0000)
struct DCReportPlayerWidget_OnBlockConfirmed final
{
public:
	EPopupResult                                  PopupResult;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerWidget_OnBlockConfirmed) == 0x000001, "Wrong alignment on DCReportPlayerWidget_OnBlockConfirmed");
static_assert(sizeof(DCReportPlayerWidget_OnBlockConfirmed) == 0x000001, "Wrong size on DCReportPlayerWidget_OnBlockConfirmed");
static_assert(offsetof(DCReportPlayerWidget_OnBlockConfirmed, PopupResult) == 0x000000, "Member 'DCReportPlayerWidget_OnBlockConfirmed::PopupResult' has a wrong offset!");

// Function DungeonCrawler.BTT_BlueprintBase.OnTaskFinished
// 0x0018 (0x0018 - 0x0000)
struct BTT_BlueprintBase_OnTaskFinished final
{
public:
	class AAIController*                          OwnerController;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  ControlledPawn;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBTNodeResult                                 TaskResult;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FF[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BTT_BlueprintBase_OnTaskFinished) == 0x000008, "Wrong alignment on BTT_BlueprintBase_OnTaskFinished");
static_assert(sizeof(BTT_BlueprintBase_OnTaskFinished) == 0x000018, "Wrong size on BTT_BlueprintBase_OnTaskFinished");
static_assert(offsetof(BTT_BlueprintBase_OnTaskFinished, OwnerController) == 0x000000, "Member 'BTT_BlueprintBase_OnTaskFinished::OwnerController' has a wrong offset!");
static_assert(offsetof(BTT_BlueprintBase_OnTaskFinished, ControlledPawn) == 0x000008, "Member 'BTT_BlueprintBase_OnTaskFinished::ControlledPawn' has a wrong offset!");
static_assert(offsetof(BTT_BlueprintBase_OnTaskFinished, TaskResult) == 0x000010, "Member 'BTT_BlueprintBase_OnTaskFinished::TaskResult' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGameplayTags.GameplayTagCallback
// 0x000C (0x000C - 0x0000)
struct DCAT_WaitGameplayTags_GameplayTagCallback final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewCount;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGameplayTags_GameplayTagCallback) == 0x000004, "Wrong alignment on DCAT_WaitGameplayTags_GameplayTagCallback");
static_assert(sizeof(DCAT_WaitGameplayTags_GameplayTagCallback) == 0x00000C, "Wrong size on DCAT_WaitGameplayTags_GameplayTagCallback");
static_assert(offsetof(DCAT_WaitGameplayTags_GameplayTagCallback, Tag) == 0x000000, "Member 'DCAT_WaitGameplayTags_GameplayTagCallback::Tag' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTags_GameplayTagCallback, NewCount) == 0x000008, "Member 'DCAT_WaitGameplayTags_GameplayTagCallback::NewCount' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGameplayTagsAdded.WaitGameplayTagsAdded
// 0x0048 (0x0048 - 0x0000)
struct DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	bool                                          bIsWaitAnyTag;                                     // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2403[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InOptionalExternalTarget;                          // 0x0030(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnlyTriggerOnce;                                // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2404[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitGameplayTagsAdded*            ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded) == 0x000008, "Wrong alignment on DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded");
static_assert(sizeof(DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded) == 0x000048, "Wrong size on DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded");
static_assert(offsetof(DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded, OwningAbility) == 0x000000, "Member 'DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded, TagContainer) == 0x000008, "Member 'DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded::TagContainer' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded, bIsWaitAnyTag) == 0x000028, "Member 'DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded::bIsWaitAnyTag' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded, InOptionalExternalTarget) == 0x000030, "Member 'DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded::InOptionalExternalTarget' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded, bIsOnlyTriggerOnce) == 0x000038, "Member 'DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded::bIsOnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded, ReturnValue) == 0x000040, "Member 'DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerState.GetForceExitRemainSeconds
// 0x0004 (0x0004 - 0x0000)
struct DCPlayerState_GetForceExitRemainSeconds final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerState_GetForceExitRemainSeconds) == 0x000004, "Wrong alignment on DCPlayerState_GetForceExitRemainSeconds");
static_assert(sizeof(DCPlayerState_GetForceExitRemainSeconds) == 0x000004, "Wrong size on DCPlayerState_GetForceExitRemainSeconds");
static_assert(offsetof(DCPlayerState_GetForceExitRemainSeconds, ReturnValue) == 0x000000, "Member 'DCPlayerState_GetForceExitRemainSeconds::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAccountStatusUpgradeShopWidget.OnSetContentsBlockHours
// 0x0008 (0x0008 - 0x0000)
struct DCAccountStatusUpgradeShopWidget_OnSetContentsBlockHours final
{
public:
	EServicePolicyType                            InPolicyType;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240B[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InBlockHours;                                      // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAccountStatusUpgradeShopWidget_OnSetContentsBlockHours) == 0x000004, "Wrong alignment on DCAccountStatusUpgradeShopWidget_OnSetContentsBlockHours");
static_assert(sizeof(DCAccountStatusUpgradeShopWidget_OnSetContentsBlockHours) == 0x000008, "Wrong size on DCAccountStatusUpgradeShopWidget_OnSetContentsBlockHours");
static_assert(offsetof(DCAccountStatusUpgradeShopWidget_OnSetContentsBlockHours, InPolicyType) == 0x000000, "Member 'DCAccountStatusUpgradeShopWidget_OnSetContentsBlockHours::InPolicyType' has a wrong offset!");
static_assert(offsetof(DCAccountStatusUpgradeShopWidget_OnSetContentsBlockHours, InBlockHours) == 0x000004, "Member 'DCAccountStatusUpgradeShopWidget_OnSetContentsBlockHours::InBlockHours' has a wrong offset!");

// Function DungeonCrawler.DCAccountStatusUpgradeShopWidget.OnSetUpgradeShopInfo
// 0x0018 (0x0018 - 0x0000)
struct DCAccountStatusUpgradeShopWidget_OnSetUpgradeShopInfo final
{
public:
	struct FDCAccountStatusUpgradeShopInfo        InUpgradeShopInfo;                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAccountStatusUpgradeShopWidget_OnSetUpgradeShopInfo) == 0x000008, "Wrong alignment on DCAccountStatusUpgradeShopWidget_OnSetUpgradeShopInfo");
static_assert(sizeof(DCAccountStatusUpgradeShopWidget_OnSetUpgradeShopInfo) == 0x000018, "Wrong size on DCAccountStatusUpgradeShopWidget_OnSetUpgradeShopInfo");
static_assert(offsetof(DCAccountStatusUpgradeShopWidget_OnSetUpgradeShopInfo, InUpgradeShopInfo) == 0x000000, "Member 'DCAccountStatusUpgradeShopWidget_OnSetUpgradeShopInfo::InUpgradeShopInfo' has a wrong offset!");

// Function DungeonCrawler.DCQuestRequirementFetchWidget.GetFetchRequiredTitle
// 0x0018 (0x0018 - 0x0000)
struct DCQuestRequirementFetchWidget_GetFetchRequiredTitle final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestRequirementFetchWidget_GetFetchRequiredTitle) == 0x000008, "Wrong alignment on DCQuestRequirementFetchWidget_GetFetchRequiredTitle");
static_assert(sizeof(DCQuestRequirementFetchWidget_GetFetchRequiredTitle) == 0x000018, "Wrong size on DCQuestRequirementFetchWidget_GetFetchRequiredTitle");
static_assert(offsetof(DCQuestRequirementFetchWidget_GetFetchRequiredTitle, ReturnValue) == 0x000000, "Member 'DCQuestRequirementFetchWidget_GetFetchRequiredTitle::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCQuestRequirementFetchWidget.IsFilled
// 0x0001 (0x0001 - 0x0000)
struct DCQuestRequirementFetchWidget_IsFilled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestRequirementFetchWidget_IsFilled) == 0x000001, "Wrong alignment on DCQuestRequirementFetchWidget_IsFilled");
static_assert(sizeof(DCQuestRequirementFetchWidget_IsFilled) == 0x000001, "Wrong size on DCQuestRequirementFetchWidget_IsFilled");
static_assert(offsetof(DCQuestRequirementFetchWidget_IsFilled, ReturnValue) == 0x000000, "Member 'DCQuestRequirementFetchWidget_IsFilled::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCQuestRequirementFetchWidget.IsItemDeliveryAvailable
// 0x0001 (0x0001 - 0x0000)
struct DCQuestRequirementFetchWidget_IsItemDeliveryAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestRequirementFetchWidget_IsItemDeliveryAvailable) == 0x000001, "Wrong alignment on DCQuestRequirementFetchWidget_IsItemDeliveryAvailable");
static_assert(sizeof(DCQuestRequirementFetchWidget_IsItemDeliveryAvailable) == 0x000001, "Wrong size on DCQuestRequirementFetchWidget_IsItemDeliveryAvailable");
static_assert(offsetof(DCQuestRequirementFetchWidget_IsItemDeliveryAvailable, ReturnValue) == 0x000000, "Member 'DCQuestRequirementFetchWidget_IsItemDeliveryAvailable::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterCreateWidget.CanLaunchRedstoneShardShop
// 0x0001 (0x0001 - 0x0000)
struct CharacterCreateWidget_CanLaunchRedstoneShardShop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterCreateWidget_CanLaunchRedstoneShardShop) == 0x000001, "Wrong alignment on CharacterCreateWidget_CanLaunchRedstoneShardShop");
static_assert(sizeof(CharacterCreateWidget_CanLaunchRedstoneShardShop) == 0x000001, "Wrong size on CharacterCreateWidget_CanLaunchRedstoneShardShop");
static_assert(offsetof(CharacterCreateWidget_CanLaunchRedstoneShardShop, ReturnValue) == 0x000000, "Member 'CharacterCreateWidget_CanLaunchRedstoneShardShop::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterCreateWidget.GetCanCreateVisibility
// 0x0001 (0x0001 - 0x0000)
struct CharacterCreateWidget_GetCanCreateVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterCreateWidget_GetCanCreateVisibility) == 0x000001, "Wrong alignment on CharacterCreateWidget_GetCanCreateVisibility");
static_assert(sizeof(CharacterCreateWidget_GetCanCreateVisibility) == 0x000001, "Wrong size on CharacterCreateWidget_GetCanCreateVisibility");
static_assert(offsetof(CharacterCreateWidget_GetCanCreateVisibility, ReturnValue) == 0x000000, "Member 'CharacterCreateWidget_GetCanCreateVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterCreateWidget.GetCannotCreateVisibility
// 0x0001 (0x0001 - 0x0000)
struct CharacterCreateWidget_GetCannotCreateVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterCreateWidget_GetCannotCreateVisibility) == 0x000001, "Wrong alignment on CharacterCreateWidget_GetCannotCreateVisibility");
static_assert(sizeof(CharacterCreateWidget_GetCannotCreateVisibility) == 0x000001, "Wrong size on CharacterCreateWidget_GetCannotCreateVisibility");
static_assert(offsetof(CharacterCreateWidget_GetCannotCreateVisibility, ReturnValue) == 0x000000, "Member 'CharacterCreateWidget_GetCannotCreateVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterCreateWidget.GetCashPrice
// 0x0004 (0x0004 - 0x0000)
struct CharacterCreateWidget_GetCashPrice final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterCreateWidget_GetCashPrice) == 0x000004, "Wrong alignment on CharacterCreateWidget_GetCashPrice");
static_assert(sizeof(CharacterCreateWidget_GetCashPrice) == 0x000004, "Wrong size on CharacterCreateWidget_GetCashPrice");
static_assert(offsetof(CharacterCreateWidget_GetCashPrice, ReturnValue) == 0x000000, "Member 'CharacterCreateWidget_GetCashPrice::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterCreateWidget.GetPrice
// 0x0004 (0x0004 - 0x0000)
struct CharacterCreateWidget_GetPrice final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterCreateWidget_GetPrice) == 0x000004, "Wrong alignment on CharacterCreateWidget_GetPrice");
static_assert(sizeof(CharacterCreateWidget_GetPrice) == 0x000004, "Wrong size on CharacterCreateWidget_GetPrice");
static_assert(offsetof(CharacterCreateWidget_GetPrice, ReturnValue) == 0x000000, "Member 'CharacterCreateWidget_GetPrice::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterCreateWidget.OnClassSelectTileViewItemSelectionChanged
// 0x0008 (0x0008 - 0x0000)
struct CharacterCreateWidget_OnClassSelectTileViewItemSelectionChanged final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterCreateWidget_OnClassSelectTileViewItemSelectionChanged) == 0x000008, "Wrong alignment on CharacterCreateWidget_OnClassSelectTileViewItemSelectionChanged");
static_assert(sizeof(CharacterCreateWidget_OnClassSelectTileViewItemSelectionChanged) == 0x000008, "Wrong size on CharacterCreateWidget_OnClassSelectTileViewItemSelectionChanged");
static_assert(offsetof(CharacterCreateWidget_OnClassSelectTileViewItemSelectionChanged, InItem) == 0x000000, "Member 'CharacterCreateWidget_OnClassSelectTileViewItemSelectionChanged::InItem' has a wrong offset!");

// Function DungeonCrawler.CharacterCreateWidget.OnGenderClicked
// 0x0001 (0x0001 - 0x0000)
struct CharacterCreateWidget_OnGenderClicked final
{
public:
	EDCGender                                     Gender;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterCreateWidget_OnGenderClicked) == 0x000001, "Wrong alignment on CharacterCreateWidget_OnGenderClicked");
static_assert(sizeof(CharacterCreateWidget_OnGenderClicked) == 0x000001, "Wrong size on CharacterCreateWidget_OnGenderClicked");
static_assert(offsetof(CharacterCreateWidget_OnGenderClicked, Gender) == 0x000000, "Member 'CharacterCreateWidget_OnGenderClicked::Gender' has a wrong offset!");

// Function DungeonCrawler.CharacterCreateWidget.OnTextChangedNickName
// 0x0018 (0x0018 - 0x0000)
struct CharacterCreateWidget_OnTextChangedNickName final
{
public:
	class FText                                   InNickName;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterCreateWidget_OnTextChangedNickName) == 0x000008, "Wrong alignment on CharacterCreateWidget_OnTextChangedNickName");
static_assert(sizeof(CharacterCreateWidget_OnTextChangedNickName) == 0x000018, "Wrong size on CharacterCreateWidget_OnTextChangedNickName");
static_assert(offsetof(CharacterCreateWidget_OnTextChangedNickName, InNickName) == 0x000000, "Member 'CharacterCreateWidget_OnTextChangedNickName::InNickName' has a wrong offset!");

// Function DungeonCrawler.CharacterCreateWidget.SelectCharacterClass
// 0x0001 (0x0001 - 0x0000)
struct CharacterCreateWidget_SelectCharacterClass final
{
public:
	EDCCharacterClass                             CharacterClass;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterCreateWidget_SelectCharacterClass) == 0x000001, "Wrong alignment on CharacterCreateWidget_SelectCharacterClass");
static_assert(sizeof(CharacterCreateWidget_SelectCharacterClass) == 0x000001, "Wrong size on CharacterCreateWidget_SelectCharacterClass");
static_assert(offsetof(CharacterCreateWidget_SelectCharacterClass, CharacterClass) == 0x000000, "Member 'CharacterCreateWidget_SelectCharacterClass::CharacterClass' has a wrong offset!");

// Function DungeonCrawler.DCDataComponent.OnRep_AssetId
// 0x0010 (0x0010 - 0x0000)
struct DCDataComponent_OnRep_AssetId final
{
public:
	struct FPrimaryAssetId                        PrevAssetId;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataComponent_OnRep_AssetId) == 0x000004, "Wrong alignment on DCDataComponent_OnRep_AssetId");
static_assert(sizeof(DCDataComponent_OnRep_AssetId) == 0x000010, "Wrong size on DCDataComponent_OnRep_AssetId");
static_assert(offsetof(DCDataComponent_OnRep_AssetId, PrevAssetId) == 0x000000, "Member 'DCDataComponent_OnRep_AssetId::PrevAssetId' has a wrong offset!");

// Function DungeonCrawler.GA_PlayRandomMontageWaitForEvent.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_PlayRandomMontageWaitForEvent_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayRandomMontageWaitForEvent_AbilityActivated) == 0x000008, "Wrong alignment on GA_PlayRandomMontageWaitForEvent_AbilityActivated");
static_assert(sizeof(GA_PlayRandomMontageWaitForEvent_AbilityActivated) == 0x0000B0, "Wrong size on GA_PlayRandomMontageWaitForEvent_AbilityActivated");
static_assert(offsetof(GA_PlayRandomMontageWaitForEvent_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_PlayRandomMontageWaitForEvent_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayRandomMontageWaitForEvent.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayRandomMontageWaitForEvent_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayRandomMontageWaitForEvent_EventReceived) == 0x000008, "Wrong alignment on GA_PlayRandomMontageWaitForEvent_EventReceived");
static_assert(sizeof(GA_PlayRandomMontageWaitForEvent_EventReceived) == 0x0000B8, "Wrong size on GA_PlayRandomMontageWaitForEvent_EventReceived");
static_assert(offsetof(GA_PlayRandomMontageWaitForEvent_EventReceived, EventTag) == 0x000000, "Member 'GA_PlayRandomMontageWaitForEvent_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayRandomMontageWaitForEvent_EventReceived, EventData) == 0x000008, "Member 'GA_PlayRandomMontageWaitForEvent_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayRandomMontageWaitForEvent.EventReceivedBlueprint
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayRandomMontageWaitForEvent_EventReceivedBlueprint final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayRandomMontageWaitForEvent_EventReceivedBlueprint) == 0x000008, "Wrong alignment on GA_PlayRandomMontageWaitForEvent_EventReceivedBlueprint");
static_assert(sizeof(GA_PlayRandomMontageWaitForEvent_EventReceivedBlueprint) == 0x0000B8, "Wrong size on GA_PlayRandomMontageWaitForEvent_EventReceivedBlueprint");
static_assert(offsetof(GA_PlayRandomMontageWaitForEvent_EventReceivedBlueprint, EventTag) == 0x000000, "Member 'GA_PlayRandomMontageWaitForEvent_EventReceivedBlueprint::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayRandomMontageWaitForEvent_EventReceivedBlueprint, EventData) == 0x000008, "Member 'GA_PlayRandomMontageWaitForEvent_EventReceivedBlueprint::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayRandomMontageWaitForEvent.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayRandomMontageWaitForEvent_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayRandomMontageWaitForEvent_OnCancelled) == 0x000008, "Wrong alignment on GA_PlayRandomMontageWaitForEvent_OnCancelled");
static_assert(sizeof(GA_PlayRandomMontageWaitForEvent_OnCancelled) == 0x0000B8, "Wrong size on GA_PlayRandomMontageWaitForEvent_OnCancelled");
static_assert(offsetof(GA_PlayRandomMontageWaitForEvent_OnCancelled, EventTag) == 0x000000, "Member 'GA_PlayRandomMontageWaitForEvent_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayRandomMontageWaitForEvent_OnCancelled, EventData) == 0x000008, "Member 'GA_PlayRandomMontageWaitForEvent_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayRandomMontageWaitForEvent.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayRandomMontageWaitForEvent_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayRandomMontageWaitForEvent_OnCompleted) == 0x000008, "Wrong alignment on GA_PlayRandomMontageWaitForEvent_OnCompleted");
static_assert(sizeof(GA_PlayRandomMontageWaitForEvent_OnCompleted) == 0x0000B8, "Wrong size on GA_PlayRandomMontageWaitForEvent_OnCompleted");
static_assert(offsetof(GA_PlayRandomMontageWaitForEvent_OnCompleted, EventTag) == 0x000000, "Member 'GA_PlayRandomMontageWaitForEvent_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayRandomMontageWaitForEvent_OnCompleted, EventData) == 0x000008, "Member 'GA_PlayRandomMontageWaitForEvent_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectCharListWidget.GetPageArrowVisibility
// 0x0001 (0x0001 - 0x0000)
struct CharacterSelectCharListWidget_GetPageArrowVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectCharListWidget_GetPageArrowVisibility) == 0x000001, "Wrong alignment on CharacterSelectCharListWidget_GetPageArrowVisibility");
static_assert(sizeof(CharacterSelectCharListWidget_GetPageArrowVisibility) == 0x000001, "Wrong size on CharacterSelectCharListWidget_GetPageArrowVisibility");
static_assert(offsetof(CharacterSelectCharListWidget_GetPageArrowVisibility, ReturnValue) == 0x000000, "Member 'CharacterSelectCharListWidget_GetPageArrowVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectCharListWidget.GetSelectedCharacterWidgetData
// 0x0008 (0x0008 - 0x0000)
struct CharacterSelectCharListWidget_GetSelectedCharacterWidgetData final
{
public:
	class UCharacterSelectCharacterSlotWidgetData* ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectCharListWidget_GetSelectedCharacterWidgetData) == 0x000008, "Wrong alignment on CharacterSelectCharListWidget_GetSelectedCharacterWidgetData");
static_assert(sizeof(CharacterSelectCharListWidget_GetSelectedCharacterWidgetData) == 0x000008, "Wrong size on CharacterSelectCharListWidget_GetSelectedCharacterWidgetData");
static_assert(offsetof(CharacterSelectCharListWidget_GetSelectedCharacterWidgetData, ReturnValue) == 0x000000, "Member 'CharacterSelectCharListWidget_GetSelectedCharacterWidgetData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectCharListWidget.OnCharacterSlotData
// 0x0020 (0x0020 - 0x0000)
struct CharacterSelectCharListWidget_OnCharacterSlotData final
{
public:
	struct FCharacterSlotData                     NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FCharacterSlotData                     OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectCharListWidget_OnCharacterSlotData) == 0x000008, "Wrong alignment on CharacterSelectCharListWidget_OnCharacterSlotData");
static_assert(sizeof(CharacterSelectCharListWidget_OnCharacterSlotData) == 0x000020, "Wrong size on CharacterSelectCharListWidget_OnCharacterSlotData");
static_assert(offsetof(CharacterSelectCharListWidget_OnCharacterSlotData, NewValue) == 0x000000, "Member 'CharacterSelectCharListWidget_OnCharacterSlotData::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterSelectCharListWidget_OnCharacterSlotData, OldValue) == 0x000010, "Member 'CharacterSelectCharListWidget_OnCharacterSlotData::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectCharListWidget.OnCharacterSlotListViewItemClicked
// 0x0008 (0x0008 - 0x0000)
struct CharacterSelectCharListWidget_OnCharacterSlotListViewItemClicked final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectCharListWidget_OnCharacterSlotListViewItemClicked) == 0x000008, "Wrong alignment on CharacterSelectCharListWidget_OnCharacterSlotListViewItemClicked");
static_assert(sizeof(CharacterSelectCharListWidget_OnCharacterSlotListViewItemClicked) == 0x000008, "Wrong size on CharacterSelectCharListWidget_OnCharacterSlotListViewItemClicked");
static_assert(offsetof(CharacterSelectCharListWidget_OnCharacterSlotListViewItemClicked, Obj) == 0x000000, "Member 'CharacterSelectCharListWidget_OnCharacterSlotListViewItemClicked::Obj' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectCharListWidget.OnPageNumber
// 0x0008 (0x0008 - 0x0000)
struct CharacterSelectCharListWidget_OnPageNumber final
{
public:
	int32                                         CurrentPage;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPage;                                           // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectCharListWidget_OnPageNumber) == 0x000004, "Wrong alignment on CharacterSelectCharListWidget_OnPageNumber");
static_assert(sizeof(CharacterSelectCharListWidget_OnPageNumber) == 0x000008, "Wrong size on CharacterSelectCharListWidget_OnPageNumber");
static_assert(offsetof(CharacterSelectCharListWidget_OnPageNumber, CurrentPage) == 0x000000, "Member 'CharacterSelectCharListWidget_OnPageNumber::CurrentPage' has a wrong offset!");
static_assert(offsetof(CharacterSelectCharListWidget_OnPageNumber, MaxPage) == 0x000004, "Member 'CharacterSelectCharListWidget_OnPageNumber::MaxPage' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectCharListWidget.OnSelectedCharacterId
// 0x0010 (0x0010 - 0x0000)
struct CharacterSelectCharListWidget_OnSelectedCharacterId final
{
public:
	class FString                                 CharacterId;                                       // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectCharListWidget_OnSelectedCharacterId) == 0x000008, "Wrong alignment on CharacterSelectCharListWidget_OnSelectedCharacterId");
static_assert(sizeof(CharacterSelectCharListWidget_OnSelectedCharacterId) == 0x000010, "Wrong size on CharacterSelectCharListWidget_OnSelectedCharacterId");
static_assert(offsetof(CharacterSelectCharListWidget_OnSelectedCharacterId, CharacterId) == 0x000000, "Member 'CharacterSelectCharListWidget_OnSelectedCharacterId::CharacterId' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectCharSlotWidget.CanSelect
// 0x0001 (0x0001 - 0x0000)
struct CharacterSelectCharSlotWidget_CanSelect final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectCharSlotWidget_CanSelect) == 0x000001, "Wrong alignment on CharacterSelectCharSlotWidget_CanSelect");
static_assert(sizeof(CharacterSelectCharSlotWidget_CanSelect) == 0x000001, "Wrong size on CharacterSelectCharSlotWidget_CanSelect");
static_assert(offsetof(CharacterSelectCharSlotWidget_CanSelect, ReturnValue) == 0x000000, "Member 'CharacterSelectCharSlotWidget_CanSelect::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectCharSlotWidget.OnCharacterSlot
// 0x0180 (0x0180 - 0x0000)
struct CharacterSelectCharSlotWidget_OnCharacterSlot final
{
public:
	struct FCharacterSlot                         NewValue;                                          // 0x0000(0x00C0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FCharacterSlot                         OldValue;                                          // 0x00C0(0x00C0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectCharSlotWidget_OnCharacterSlot) == 0x000008, "Wrong alignment on CharacterSelectCharSlotWidget_OnCharacterSlot");
static_assert(sizeof(CharacterSelectCharSlotWidget_OnCharacterSlot) == 0x000180, "Wrong size on CharacterSelectCharSlotWidget_OnCharacterSlot");
static_assert(offsetof(CharacterSelectCharSlotWidget_OnCharacterSlot, NewValue) == 0x000000, "Member 'CharacterSelectCharSlotWidget_OnCharacterSlot::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterSelectCharSlotWidget_OnCharacterSlot, OldValue) == 0x0000C0, "Member 'CharacterSelectCharSlotWidget_OnCharacterSlot::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectCharSlotWidget.OnFMsgWidgetStreamingModeNotifyBlueprint
// 0x0020 (0x0020 - 0x0000)
struct CharacterSelectCharSlotWidget_OnFMsgWidgetStreamingModeNotifyBlueprint final
{
public:
	struct FMsgWidgetStreamingModeNotify          InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectCharSlotWidget_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000008, "Wrong alignment on CharacterSelectCharSlotWidget_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(sizeof(CharacterSelectCharSlotWidget_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000020, "Wrong size on CharacterSelectCharSlotWidget_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(offsetof(CharacterSelectCharSlotWidget_OnFMsgWidgetStreamingModeNotifyBlueprint, InMsg) == 0x000000, "Member 'CharacterSelectCharSlotWidget_OnFMsgWidgetStreamingModeNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectCharSlotWidget.IsSelected
// 0x0001 (0x0001 - 0x0000)
struct CharacterSelectCharSlotWidget_IsSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectCharSlotWidget_IsSelected) == 0x000001, "Wrong alignment on CharacterSelectCharSlotWidget_IsSelected");
static_assert(sizeof(CharacterSelectCharSlotWidget_IsSelected) == 0x000001, "Wrong size on CharacterSelectCharSlotWidget_IsSelected");
static_assert(offsetof(CharacterSelectCharSlotWidget_IsSelected, ReturnValue) == 0x000000, "Member 'CharacterSelectCharSlotWidget_IsSelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectWidget.CanEnterLobby
// 0x0001 (0x0001 - 0x0000)
struct CharacterSelectWidget_CanEnterLobby final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectWidget_CanEnterLobby) == 0x000001, "Wrong alignment on CharacterSelectWidget_CanEnterLobby");
static_assert(sizeof(CharacterSelectWidget_CanEnterLobby) == 0x000001, "Wrong size on CharacterSelectWidget_CanEnterLobby");
static_assert(offsetof(CharacterSelectWidget_CanEnterLobby, ReturnValue) == 0x000000, "Member 'CharacterSelectWidget_CanEnterLobby::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectWidget.CanLaunchRedstoneShardShop
// 0x0001 (0x0001 - 0x0000)
struct CharacterSelectWidget_CanLaunchRedstoneShardShop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectWidget_CanLaunchRedstoneShardShop) == 0x000001, "Wrong alignment on CharacterSelectWidget_CanLaunchRedstoneShardShop");
static_assert(sizeof(CharacterSelectWidget_CanLaunchRedstoneShardShop) == 0x000001, "Wrong size on CharacterSelectWidget_CanLaunchRedstoneShardShop");
static_assert(offsetof(CharacterSelectWidget_CanLaunchRedstoneShardShop, ReturnValue) == 0x000000, "Member 'CharacterSelectWidget_CanLaunchRedstoneShardShop::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectWidget.GetCashPrice
// 0x0004 (0x0004 - 0x0000)
struct CharacterSelectWidget_GetCashPrice final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectWidget_GetCashPrice) == 0x000004, "Wrong alignment on CharacterSelectWidget_GetCashPrice");
static_assert(sizeof(CharacterSelectWidget_GetCashPrice) == 0x000004, "Wrong size on CharacterSelectWidget_GetCashPrice");
static_assert(offsetof(CharacterSelectWidget_GetCashPrice, ReturnValue) == 0x000000, "Member 'CharacterSelectWidget_GetCashPrice::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectWidget.GetPrice
// 0x0004 (0x0004 - 0x0000)
struct CharacterSelectWidget_GetPrice final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectWidget_GetPrice) == 0x000004, "Wrong alignment on CharacterSelectWidget_GetPrice");
static_assert(sizeof(CharacterSelectWidget_GetPrice) == 0x000004, "Wrong size on CharacterSelectWidget_GetPrice");
static_assert(offsetof(CharacterSelectWidget_GetPrice, ReturnValue) == 0x000000, "Member 'CharacterSelectWidget_GetPrice::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterSelectWidget.IsNeedPurchase
// 0x0001 (0x0001 - 0x0000)
struct CharacterSelectWidget_IsNeedPurchase final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterSelectWidget_IsNeedPurchase) == 0x000001, "Wrong alignment on CharacterSelectWidget_IsNeedPurchase");
static_assert(sizeof(CharacterSelectWidget_IsNeedPurchase) == 0x000001, "Wrong size on CharacterSelectWidget_IsNeedPurchase");
static_assert(offsetof(CharacterSelectWidget_IsNeedPurchase, ReturnValue) == 0x000000, "Member 'CharacterSelectWidget_IsNeedPurchase::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnActionSpeed
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnActionSpeed final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnActionSpeed) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnActionSpeed");
static_assert(sizeof(CharacterStatusDetailWidget_OnActionSpeed) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnActionSpeed");
static_assert(offsetof(CharacterStatusDetailWidget_OnActionSpeed, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnActionSpeed::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnActionSpeed, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnActionSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnAgility
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnAgility final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnAgility) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnAgility");
static_assert(sizeof(CharacterStatusDetailWidget_OnAgility) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnAgility");
static_assert(offsetof(CharacterStatusDetailWidget_OnAgility, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnAgility::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnAgility, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnAgility::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnAirMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnAirMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnAirMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnAirMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnAirMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnAirMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnAirMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnAirMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnAirMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnAirMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnAirMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnAirMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnAirMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnAirMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnAirMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnAirMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnAirMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnAirMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnAirMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnAirMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnAirMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnAirMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnAirMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnAirMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnAirMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnAirMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnAirMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnAirMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnAirMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnAirMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnAirMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnAirMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnAirMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnAirMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnAirMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnAirMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnAirMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnAirMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnAirMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnAirMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnArcaneMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnArcaneMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnArcaneMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnArcaneMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnArcaneMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnArcaneMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnArcaneMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnArcaneMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnArcaneMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnArcaneMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnArcaneMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnArcaneMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnArcaneMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnArcaneMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnArcaneMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnArcaneMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnArcaneMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnArcaneMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnArcaneMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnArcaneMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnArcaneMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnArcaneMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnArcaneMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnArcaneMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnArcaneMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnArcaneMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnArcaneMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnArcaneMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnArcaneMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnArcaneMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnArcaneMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnArcaneMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnArcaneMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnArcaneMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnArcaneMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnArcaneMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnArcaneMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnArcaneMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnArcaneMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnArcaneMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnArmorPenetration
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnArmorPenetration final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnArmorPenetration) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnArmorPenetration");
static_assert(sizeof(CharacterStatusDetailWidget_OnArmorPenetration) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnArmorPenetration");
static_assert(offsetof(CharacterStatusDetailWidget_OnArmorPenetration, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnArmorPenetration::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnArmorPenetration, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnArmorPenetration::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnArmorRating
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnArmorRating final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnArmorRating) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnArmorRating");
static_assert(sizeof(CharacterStatusDetailWidget_OnArmorRating) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnArmorRating");
static_assert(offsetof(CharacterStatusDetailWidget_OnArmorRating, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnArmorRating::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnArmorRating, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnArmorRating::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnBuffDurationMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnBuffDurationMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnBuffDurationMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnBuffDurationMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnBuffDurationMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnBuffDurationMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnBuffDurationMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnBuffDurationMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnBuffDurationMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnBuffDurationMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnCooldownReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnCooldownReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnCooldownReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnCooldownReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnCooldownReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnCooldownReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnCooldownReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnCooldownReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnCooldownReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnCooldownReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDarkMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDarkMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDarkMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDarkMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnDarkMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDarkMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnDarkMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDarkMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDarkMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDarkMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDarkMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDarkMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDarkMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDarkMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnDarkMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDarkMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnDarkMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDarkMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDarkMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDarkMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDarkMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDarkMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDarkMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDarkMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnDarkMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDarkMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnDarkMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDarkMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDarkMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDarkMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDarkMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDarkMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDarkMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDarkMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnDarkMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDarkMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnDarkMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDarkMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDarkMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDarkMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDebuffDurationMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDebuffDurationMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDebuffDurationMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDebuffDurationMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnDebuffDurationMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDebuffDurationMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnDebuffDurationMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDebuffDurationMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDebuffDurationMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDebuffDurationMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDemonReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDemonReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDemonReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDemonReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnDemonReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDemonReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnDemonReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDemonReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDemonReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDemonReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDexterity
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDexterity final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDexterity) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDexterity");
static_assert(sizeof(CharacterStatusDetailWidget_OnDexterity) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDexterity");
static_assert(offsetof(CharacterStatusDetailWidget_OnDexterity, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDexterity::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDexterity, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDexterity::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDivineMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDivineMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDivineMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDivineMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnDivineMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDivineMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnDivineMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDivineMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDivineMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDivineMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDivineMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDivineMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDivineMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDivineMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnDivineMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDivineMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnDivineMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDivineMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDivineMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDivineMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDivineMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDivineMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDivineMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDivineMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnDivineMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDivineMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnDivineMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDivineMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDivineMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDivineMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnDivineMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnDivineMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnDivineMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnDivineMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnDivineMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnDivineMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnDivineMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnDivineMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnDivineMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnDivineMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnEarthMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnEarthMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnEarthMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnEarthMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnEarthMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnEarthMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnEarthMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnEarthMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnEarthMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnEarthMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnEarthMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnEarthMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnEarthMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnEarthMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnEarthMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnEarthMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnEarthMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnEarthMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnEarthMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnEarthMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnEarthMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnEarthMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnEarthMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnEarthMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnEarthMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnEarthMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnEarthMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnEarthMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnEarthMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnEarthMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnEarthMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnEarthMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnEarthMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnEarthMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnEarthMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnEarthMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnEarthMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnEarthMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnEarthMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnEarthMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnEvilMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnEvilMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnEvilMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnEvilMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnEvilMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnEvilMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnEvilMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnEvilMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnEvilMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnEvilMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnEvilMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnEvilMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnEvilMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnEvilMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnEvilMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnEvilMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnEvilMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnEvilMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnEvilMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnEvilMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnEvilMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnEvilMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnEvilMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnEvilMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnEvilMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnEvilMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnEvilMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnEvilMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnEvilMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnEvilMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnEvilMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnEvilMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnEvilMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnEvilMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnEvilMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnEvilMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnEvilMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnEvilMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnEvilMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnEvilMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnFireMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnFireMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnFireMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnFireMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnFireMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnFireMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnFireMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnFireMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnFireMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnFireMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnFireMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnFireMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnFireMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnFireMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnFireMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnFireMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnFireMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnFireMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnFireMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnFireMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnFireMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnFireMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnFireMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnFireMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnFireMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnFireMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnFireMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnFireMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnFireMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnFireMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnFireMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnFireMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnFireMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnFireMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnFireMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnFireMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnFireMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnFireMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnFireMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnFireMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnHeadshotReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnHeadshotReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnHeadshotReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnHeadshotReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnHeadshotReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnHeadshotReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnHeadshotReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnHeadshotReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnHeadshotReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnHeadshotReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnHealth
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnHealth final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnHealth) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnHealth");
static_assert(sizeof(CharacterStatusDetailWidget_OnHealth) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnHealth");
static_assert(offsetof(CharacterStatusDetailWidget_OnHealth, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnHealth::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnHealth, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnHealth::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnHealthRecoveryMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnHealthRecoveryMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnHealthRecoveryMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnHealthRecoveryMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnHealthRecoveryMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnHealthRecoveryMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnHealthRecoveryMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnHealthRecoveryMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnHealthRecoveryMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnHealthRecoveryMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnIceMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnIceMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnIceMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnIceMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnIceMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnIceMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnIceMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnIceMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnIceMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnIceMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnIceMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnIceMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnIceMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnIceMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnIceMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnIceMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnIceMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnIceMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnIceMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnIceMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnIceMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnIceMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnIceMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnIceMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnIceMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnIceMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnIceMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnIceMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnIceMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnIceMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnIceMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnIceMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnIceMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnIceMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnIceMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnIceMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnIceMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnIceMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnIceMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnIceMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnImpactPower
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnImpactPower final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnImpactPower) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnImpactPower");
static_assert(sizeof(CharacterStatusDetailWidget_OnImpactPower) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnImpactPower");
static_assert(offsetof(CharacterStatusDetailWidget_OnImpactPower, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnImpactPower::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnImpactPower, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnImpactPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnItemEquipSpeed
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnItemEquipSpeed final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnItemEquipSpeed) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnItemEquipSpeed");
static_assert(sizeof(CharacterStatusDetailWidget_OnItemEquipSpeed) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnItemEquipSpeed");
static_assert(offsetof(CharacterStatusDetailWidget_OnItemEquipSpeed, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnItemEquipSpeed::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnItemEquipSpeed, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnItemEquipSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnKnowledge
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnKnowledge final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnKnowledge) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnKnowledge");
static_assert(sizeof(CharacterStatusDetailWidget_OnKnowledge) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnKnowledge");
static_assert(offsetof(CharacterStatusDetailWidget_OnKnowledge, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnKnowledge::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnKnowledge, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnKnowledge::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnLightMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnLightMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnLightMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnLightMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnLightMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnLightMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnLightMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnLightMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnLightMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnLightMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnLightMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnLightMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnLightMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnLightMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnLightMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnLightMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnLightMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnLightMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnLightMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnLightMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnLightMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnLightMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnLightMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnLightMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnLightMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnLightMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnLightMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnLightMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightningMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnLightningMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnLightningMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnLightningMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnLightningMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnLightningMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightningMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnLightningMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightningMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnLightningMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightningMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnLightningMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnLightningMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnLightningMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnLightningMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnLightningMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightningMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnLightningMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightningMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnLightningMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightningMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnLightningMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnLightningMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnLightningMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnLightningMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnLightningMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightningMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnLightningMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightningMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnLightningMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightningMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnLightningMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnLightningMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnLightningMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnLightningMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnLightningMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightningMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnLightningMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnLightningMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnLightningMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnLuck
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnLuck final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnLuck) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnLuck");
static_assert(sizeof(CharacterStatusDetailWidget_OnLuck) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnLuck");
static_assert(offsetof(CharacterStatusDetailWidget_OnLuck, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnLuck::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnLuck, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnLuck::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalDamageAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalDamageAdd) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalDamageAdd");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalDamageAdd) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalDamageAdd");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageAdd, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalDamageAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageAdd, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalDamageAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalDamageBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalDamageBase) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalDamageBase");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalDamageBase) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalDamageBase");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageBase, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalDamageBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageBase, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalDamageBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalDamageMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalDamageMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalDamageMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalDamageMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalDamageMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalDamageMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageModBonus
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalDamageModBonus final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalDamageModBonus) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalDamageModBonus");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalDamageModBonus) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalDamageModBonus");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageModBonus, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalDamageModBonus::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageModBonus, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalDamageModBonus::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageModMagicalPower
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalDamageModMagicalPower final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalDamageModMagicalPower) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalDamageModMagicalPower");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalDamageModMagicalPower) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalDamageModMagicalPower");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageModMagicalPower, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalDamageModMagicalPower::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageModMagicalPower, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalDamageModMagicalPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageTrue
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalDamageTrue final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalDamageTrue) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalDamageTrue");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalDamageTrue) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalDamageTrue");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageTrue, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalDamageTrue::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalDamageTrue, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalDamageTrue::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalHealBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalHealBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalHealBase) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalHealBase");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalHealBase) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalHealBase");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalHealBase, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalHealBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalHealBase, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalHealBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalHealingReceiveMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalHealingReceiveMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalHealingReceiveMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalHealingReceiveMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalHealingReceiveMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalHealingReceiveMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalHealingReceiveMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalHealingReceiveMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalHealingReceiveMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalHealingReceiveMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalHealMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalHealMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalHealMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalHealMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalHealMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalHealMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalHealMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalHealMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalHealMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalHealMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalInteractionSpeed
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalInteractionSpeed final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalInteractionSpeed) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalInteractionSpeed");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalInteractionSpeed) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalInteractionSpeed");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalInteractionSpeed, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalInteractionSpeed::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalInteractionSpeed, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalInteractionSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalPower
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalPower final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalPower) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalPower");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalPower) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalPower");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalPower, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalPower::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalPower, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionBonus
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalReductionBonus final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalReductionBonus) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalReductionBonus");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalReductionBonus) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalReductionBonus");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalReductionBonus, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalReductionBonus::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalReductionBonus, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalReductionBonus::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicPenetration
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicPenetration final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicPenetration) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicPenetration");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicPenetration) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicPenetration");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicPenetration, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicPenetration::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicPenetration, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicPenetration::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnManualDexterity
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnManualDexterity final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnManualDexterity) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnManualDexterity");
static_assert(sizeof(CharacterStatusDetailWidget_OnManualDexterity) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnManualDexterity");
static_assert(offsetof(CharacterStatusDetailWidget_OnManualDexterity, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnManualDexterity::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnManualDexterity, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnManualDexterity::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealth
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMaxHealth final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMaxHealth) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMaxHealth");
static_assert(sizeof(CharacterStatusDetailWidget_OnMaxHealth) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMaxHealth");
static_assert(offsetof(CharacterStatusDetailWidget_OnMaxHealth, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMaxHealth::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMaxHealth, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMaxHealth::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMaxHealthAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMaxHealthAdd) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMaxHealthAdd");
static_assert(sizeof(CharacterStatusDetailWidget_OnMaxHealthAdd) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMaxHealthAdd");
static_assert(offsetof(CharacterStatusDetailWidget_OnMaxHealthAdd, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMaxHealthAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMaxHealthAdd, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMaxHealthAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMaxHealthBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMaxHealthBase) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMaxHealthBase");
static_assert(sizeof(CharacterStatusDetailWidget_OnMaxHealthBase) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMaxHealthBase");
static_assert(offsetof(CharacterStatusDetailWidget_OnMaxHealthBase, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMaxHealthBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMaxHealthBase, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMaxHealthBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMaxHealthMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMaxHealthMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMaxHealthMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnMaxHealthMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMaxHealthMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnMaxHealthMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMaxHealthMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMaxHealthMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMaxHealthMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxSpellCountMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMaxSpellCountMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMaxSpellCountMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMaxSpellCountMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnMaxSpellCountMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMaxSpellCountMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnMaxSpellCountMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMaxSpellCountMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMaxSpellCountMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMaxSpellCountMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryCapacity
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMemoryCapacity final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMemoryCapacity) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMemoryCapacity");
static_assert(sizeof(CharacterStatusDetailWidget_OnMemoryCapacity) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMemoryCapacity");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryCapacity, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMemoryCapacity::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryCapacity, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMemoryCapacity::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryCapacityAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMemoryCapacityAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMemoryCapacityAdd) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMemoryCapacityAdd");
static_assert(sizeof(CharacterStatusDetailWidget_OnMemoryCapacityAdd) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMemoryCapacityAdd");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryCapacityAdd, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMemoryCapacityAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryCapacityAdd, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMemoryCapacityAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryCapacityBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMemoryCapacityBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMemoryCapacityBase) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMemoryCapacityBase");
static_assert(sizeof(CharacterStatusDetailWidget_OnMemoryCapacityBase) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMemoryCapacityBase");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryCapacityBase, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMemoryCapacityBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryCapacityBase, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMemoryCapacityBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryCapacityMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMemoryCapacityMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMemoryCapacityMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMemoryCapacityMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnMemoryCapacityMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMemoryCapacityMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryCapacityMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMemoryCapacityMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryCapacityMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMemoryCapacityMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryMusicPayload
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMemoryMusicPayload final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMemoryMusicPayload) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMemoryMusicPayload");
static_assert(sizeof(CharacterStatusDetailWidget_OnMemoryMusicPayload) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMemoryMusicPayload");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryMusicPayload, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMemoryMusicPayload::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryMusicPayload, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMemoryMusicPayload::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryRecoveryMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMemoryRecoveryMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMemoryRecoveryMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMemoryRecoveryMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnMemoryRecoveryMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMemoryRecoveryMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryRecoveryMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMemoryRecoveryMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemoryRecoveryMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMemoryRecoveryMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemorySpellPayload
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMemorySpellPayload final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMemorySpellPayload) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMemorySpellPayload");
static_assert(sizeof(CharacterStatusDetailWidget_OnMemorySpellPayload) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMemorySpellPayload");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemorySpellPayload, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMemorySpellPayload::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMemorySpellPayload, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMemorySpellPayload::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeed
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMoveSpeed final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMoveSpeed) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMoveSpeed");
static_assert(sizeof(CharacterStatusDetailWidget_OnMoveSpeed) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMoveSpeed");
static_assert(offsetof(CharacterStatusDetailWidget_OnMoveSpeed, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMoveSpeed::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMoveSpeed, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMoveSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMoveSpeedAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMoveSpeedAdd) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMoveSpeedAdd");
static_assert(sizeof(CharacterStatusDetailWidget_OnMoveSpeedAdd) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMoveSpeedAdd");
static_assert(offsetof(CharacterStatusDetailWidget_OnMoveSpeedAdd, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMoveSpeedAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMoveSpeedAdd, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMoveSpeedAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMoveSpeedBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMoveSpeedBase) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMoveSpeedBase");
static_assert(sizeof(CharacterStatusDetailWidget_OnMoveSpeedBase) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMoveSpeedBase");
static_assert(offsetof(CharacterStatusDetailWidget_OnMoveSpeedBase, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMoveSpeedBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMoveSpeedBase, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMoveSpeedBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMoveSpeedMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMoveSpeedMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMoveSpeedMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnMoveSpeedMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMoveSpeedMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnMoveSpeedMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMoveSpeedMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMoveSpeedMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMoveSpeedMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedWithModifier
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnMoveSpeedWithModifier final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnMoveSpeedWithModifier) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnMoveSpeedWithModifier");
static_assert(sizeof(CharacterStatusDetailWidget_OnMoveSpeedWithModifier) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnMoveSpeedWithModifier");
static_assert(offsetof(CharacterStatusDetailWidget_OnMoveSpeedWithModifier, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnMoveSpeedWithModifier::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnMoveSpeedWithModifier, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnMoveSpeedWithModifier::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnOverhealedHealth
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnOverhealedHealth final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnOverhealedHealth) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnOverhealedHealth");
static_assert(sizeof(CharacterStatusDetailWidget_OnOverhealedHealth) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnOverhealedHealth");
static_assert(offsetof(CharacterStatusDetailWidget_OnOverhealedHealth, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnOverhealedHealth::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnOverhealedHealth, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnOverhealedHealth::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPersuasiveness
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPersuasiveness final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPersuasiveness) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPersuasiveness");
static_assert(sizeof(CharacterStatusDetailWidget_OnPersuasiveness) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPersuasiveness");
static_assert(offsetof(CharacterStatusDetailWidget_OnPersuasiveness, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPersuasiveness::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPersuasiveness, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPersuasiveness::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalDamageAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalDamageAdd) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalDamageAdd");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalDamageAdd) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalDamageAdd");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageAdd, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageAdd, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalDamageBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalDamageBase) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalDamageBase");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalDamageBase) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalDamageBase");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageBase, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageBase, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalDamageMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalDamageMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalDamageMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalDamageMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalDamageMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageModBonus
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalDamageModBonus final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalDamageModBonus) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalDamageModBonus");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalDamageModBonus) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalDamageModBonus");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageModBonus, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageModBonus::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageModBonus, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageModBonus::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageModPhysicalPower
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageTrue
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalDamageTrue final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalDamageTrue) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalDamageTrue");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalDamageTrue) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalDamageTrue");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageTrue, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageTrue::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageTrue, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageTrue::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageWeaponPrimary
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageWeaponSecondary
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalHeadshotPenetration
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalHeadshotPenetration final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalHeadshotPenetration) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalHeadshotPenetration");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalHeadshotPenetration) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalHeadshotPenetration");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalHeadshotPenetration, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalHeadshotPenetration::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalHeadshotPenetration, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalHeadshotPenetration::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalHealBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalHealBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalHealBase) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalHealBase");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalHealBase) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalHealBase");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalHealBase, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalHealBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalHealBase, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalHealBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalHealingReceiveMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalHealingReceiveMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalHealingReceiveMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalHealingReceiveMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalHealingReceiveMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalHealingReceiveMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalHealingReceiveMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalHealingReceiveMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalHealingReceiveMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalHealingReceiveMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalHealMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalHealMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalHealMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalHealMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalHealMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalHealMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalHealMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalHealMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalHealMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalHealMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalPower
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalPower final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalPower) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalPower");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalPower) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalPower");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalPower, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalPower::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalPower, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionArmorRating
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalReductionArmorRating final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalReductionArmorRating) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalReductionArmorRating");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalReductionArmorRating) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalReductionArmorRating");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalReductionArmorRating, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalReductionArmorRating::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalReductionArmorRating, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalReductionArmorRating::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionBonus
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalReductionBonus final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalReductionBonus) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalReductionBonus");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalReductionBonus) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalReductionBonus");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalReductionBonus, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalReductionBonus::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalReductionBonus, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalReductionBonus::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPhysicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPhysicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPhysicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnPhysicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPhysicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPhysicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPhysicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPhysicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPrimaryAbilityWidgetArray
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray final
{
public:
	TArray<class UItemTooltipStatWidgetData*>     NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UItemTooltipStatWidgetData*>     OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray");
static_assert(sizeof(CharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray");
static_assert(offsetof(CharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnPrimaryWeaponImpactPower
// 0x0008 (0x0008 - 0x0000)
struct CharacterStatusDetailWidget_OnPrimaryWeaponImpactPower final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldValue;                                          // 0x0004(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnPrimaryWeaponImpactPower) == 0x000004, "Wrong alignment on CharacterStatusDetailWidget_OnPrimaryWeaponImpactPower");
static_assert(sizeof(CharacterStatusDetailWidget_OnPrimaryWeaponImpactPower) == 0x000008, "Wrong size on CharacterStatusDetailWidget_OnPrimaryWeaponImpactPower");
static_assert(offsetof(CharacterStatusDetailWidget_OnPrimaryWeaponImpactPower, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnPrimaryWeaponImpactPower::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnPrimaryWeaponImpactPower, OldValue) == 0x000004, "Member 'CharacterStatusDetailWidget_OnPrimaryWeaponImpactPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnProjectileReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnProjectileReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnProjectileReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnProjectileReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnProjectileReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnProjectileReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnProjectileReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnProjectileReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnProjectileReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnProjectileReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnRegularInteractionSpeed
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnRegularInteractionSpeed final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnRegularInteractionSpeed) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnRegularInteractionSpeed");
static_assert(sizeof(CharacterStatusDetailWidget_OnRegularInteractionSpeed) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnRegularInteractionSpeed");
static_assert(offsetof(CharacterStatusDetailWidget_OnRegularInteractionSpeed, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnRegularInteractionSpeed::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnRegularInteractionSpeed, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnRegularInteractionSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnRegularInteractionSpeedBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnRegularInteractionSpeedBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnRegularInteractionSpeedBase) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnRegularInteractionSpeedBase");
static_assert(sizeof(CharacterStatusDetailWidget_OnRegularInteractionSpeedBase) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnRegularInteractionSpeedBase");
static_assert(offsetof(CharacterStatusDetailWidget_OnRegularInteractionSpeedBase, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnRegularInteractionSpeedBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnRegularInteractionSpeedBase, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnRegularInteractionSpeedBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnResourcefulness
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnResourcefulness final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnResourcefulness) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnResourcefulness");
static_assert(sizeof(CharacterStatusDetailWidget_OnResourcefulness) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnResourcefulness");
static_assert(offsetof(CharacterStatusDetailWidget_OnResourcefulness, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnResourcefulness::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnResourcefulness, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnResourcefulness::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnSecondaryAbilityWidgetArray
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray final
{
public:
	TArray<class UItemTooltipStatWidgetData*>     NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UItemTooltipStatWidgetData*>     OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray");
static_assert(sizeof(CharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray");
static_assert(offsetof(CharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnSecondaryWeaponImpactPower
// 0x0008 (0x0008 - 0x0000)
struct CharacterStatusDetailWidget_OnSecondaryWeaponImpactPower final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldValue;                                          // 0x0004(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnSecondaryWeaponImpactPower) == 0x000004, "Wrong alignment on CharacterStatusDetailWidget_OnSecondaryWeaponImpactPower");
static_assert(sizeof(CharacterStatusDetailWidget_OnSecondaryWeaponImpactPower) == 0x000008, "Wrong size on CharacterStatusDetailWidget_OnSecondaryWeaponImpactPower");
static_assert(offsetof(CharacterStatusDetailWidget_OnSecondaryWeaponImpactPower, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnSecondaryWeaponImpactPower::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnSecondaryWeaponImpactPower, OldValue) == 0x000004, "Member 'CharacterStatusDetailWidget_OnSecondaryWeaponImpactPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCastingSpeed
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnSpellCastingSpeed final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnSpellCastingSpeed) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnSpellCastingSpeed");
static_assert(sizeof(CharacterStatusDetailWidget_OnSpellCastingSpeed) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnSpellCastingSpeed");
static_assert(offsetof(CharacterStatusDetailWidget_OnSpellCastingSpeed, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnSpellCastingSpeed::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnSpellCastingSpeed, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnSpellCastingSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnSpiritMagicalReduction
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnSpiritMagicalReduction final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnSpiritMagicalReduction) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnSpiritMagicalReduction");
static_assert(sizeof(CharacterStatusDetailWidget_OnSpiritMagicalReduction) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnSpiritMagicalReduction");
static_assert(offsetof(CharacterStatusDetailWidget_OnSpiritMagicalReduction, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnSpiritMagicalReduction::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnSpiritMagicalReduction, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnSpiritMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnSpiritMagicalReductionMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnSpiritMagicalReductionMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnSpiritMagicalReductionMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnSpiritMagicalReductionMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnSpiritMagicalReductionMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnSpiritMagicalReductionMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnSpiritMagicalReductionMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnSpiritMagicalReductionMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnSpiritMagicalReductionMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnSpiritMagicalReductionMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnSpiritMagicalReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnSpiritMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnSpiritMagicalReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnSpiritMagicalReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnSpiritMagicalReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnSpiritMagicalReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnSpiritMagicalReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnSpiritMagicalReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnSpiritMagicalReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnSpiritMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnSpiritMagicResistance
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnSpiritMagicResistance final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnSpiritMagicResistance) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnSpiritMagicResistance");
static_assert(sizeof(CharacterStatusDetailWidget_OnSpiritMagicResistance) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnSpiritMagicResistance");
static_assert(offsetof(CharacterStatusDetailWidget_OnSpiritMagicResistance, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnSpiritMagicResistance::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnSpiritMagicResistance, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnSpiritMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnStrength
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnStrength final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnStrength) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnStrength");
static_assert(sizeof(CharacterStatusDetailWidget_OnStrength) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnStrength");
static_assert(offsetof(CharacterStatusDetailWidget_OnStrength, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnStrength::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnStrength, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnStrength::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnUndeadDamageMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnUndeadDamageMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnUndeadDamageMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnUndeadDamageMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnUndeadDamageMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnUndeadDamageMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnUndeadDamageMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnUndeadDamageMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnUndeadDamageMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnUndeadDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnUndeadReductionMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnUndeadReductionMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnUndeadReductionMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnUndeadReductionMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnUndeadReductionMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnUndeadReductionMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnUndeadReductionMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnUndeadReductionMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnUndeadReductionMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnUndeadReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectiveness
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnUtilityEffectiveness final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnUtilityEffectiveness) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnUtilityEffectiveness");
static_assert(sizeof(CharacterStatusDetailWidget_OnUtilityEffectiveness) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnUtilityEffectiveness");
static_assert(offsetof(CharacterStatusDetailWidget_OnUtilityEffectiveness, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnUtilityEffectiveness::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnUtilityEffectiveness, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnUtilityEffectiveness::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnUtilityEffectivenessAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnUtilityEffectivenessAdd) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnUtilityEffectivenessAdd");
static_assert(sizeof(CharacterStatusDetailWidget_OnUtilityEffectivenessAdd) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnUtilityEffectivenessAdd");
static_assert(offsetof(CharacterStatusDetailWidget_OnUtilityEffectivenessAdd, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnUtilityEffectivenessAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnUtilityEffectivenessAdd, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnUtilityEffectivenessAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnUtilityEffectivenessBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnUtilityEffectivenessBase) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnUtilityEffectivenessBase");
static_assert(sizeof(CharacterStatusDetailWidget_OnUtilityEffectivenessBase) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnUtilityEffectivenessBase");
static_assert(offsetof(CharacterStatusDetailWidget_OnUtilityEffectivenessBase, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnUtilityEffectivenessBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnUtilityEffectivenessBase, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnUtilityEffectivenessBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnUtilityEffectivenessMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnUtilityEffectivenessMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnUtilityEffectivenessMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnUtilityEffectivenessMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnUtilityEffectivenessMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnUtilityEffectivenessMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnUtilityEffectivenessMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnUtilityEffectivenessMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnUtilityEffectivenessMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnVigor
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnVigor final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnVigor) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnVigor");
static_assert(sizeof(CharacterStatusDetailWidget_OnVigor) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnVigor");
static_assert(offsetof(CharacterStatusDetailWidget_OnVigor, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnVigor::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnVigor, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnVigor::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnWeight
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnWeight final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnWeight) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnWeight");
static_assert(sizeof(CharacterStatusDetailWidget_OnWeight) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnWeight");
static_assert(offsetof(CharacterStatusDetailWidget_OnWeight, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnWeight::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnWeight, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnWeight::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimit
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnWeightLimit final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnWeightLimit) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnWeightLimit");
static_assert(sizeof(CharacterStatusDetailWidget_OnWeightLimit) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnWeightLimit");
static_assert(offsetof(CharacterStatusDetailWidget_OnWeightLimit, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnWeightLimit::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnWeightLimit, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnWeightLimit::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnWeightLimitAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnWeightLimitAdd) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnWeightLimitAdd");
static_assert(sizeof(CharacterStatusDetailWidget_OnWeightLimitAdd) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnWeightLimitAdd");
static_assert(offsetof(CharacterStatusDetailWidget_OnWeightLimitAdd, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnWeightLimitAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnWeightLimitAdd, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnWeightLimitAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnWeightLimitBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnWeightLimitBase) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnWeightLimitBase");
static_assert(sizeof(CharacterStatusDetailWidget_OnWeightLimitBase) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnWeightLimitBase");
static_assert(offsetof(CharacterStatusDetailWidget_OnWeightLimitBase, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnWeightLimitBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnWeightLimitBase, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnWeightLimitBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnWeightLimitMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnWeightLimitMod) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnWeightLimitMod");
static_assert(sizeof(CharacterStatusDetailWidget_OnWeightLimitMod) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnWeightLimitMod");
static_assert(offsetof(CharacterStatusDetailWidget_OnWeightLimitMod, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnWeightLimitMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnWeightLimitMod, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnWeightLimitMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.OnWill
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusDetailWidget_OnWill final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_OnWill) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_OnWill");
static_assert(sizeof(CharacterStatusDetailWidget_OnWill) == 0x000020, "Wrong size on CharacterStatusDetailWidget_OnWill");
static_assert(offsetof(CharacterStatusDetailWidget_OnWill, NewValue) == 0x000000, "Member 'CharacterStatusDetailWidget_OnWill::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusDetailWidget_OnWill, OldValue) == 0x000010, "Member 'CharacterStatusDetailWidget_OnWill::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusDetailWidget.SetupLobbyCharacter
// 0x0008 (0x0008 - 0x0000)
struct CharacterStatusDetailWidget_SetupLobbyCharacter final
{
public:
	const class ADCCharacterV2*                   InCharacter;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusDetailWidget_SetupLobbyCharacter) == 0x000008, "Wrong alignment on CharacterStatusDetailWidget_SetupLobbyCharacter");
static_assert(sizeof(CharacterStatusDetailWidget_SetupLobbyCharacter) == 0x000008, "Wrong size on CharacterStatusDetailWidget_SetupLobbyCharacter");
static_assert(offsetof(CharacterStatusDetailWidget_SetupLobbyCharacter, InCharacter) == 0x000000, "Member 'CharacterStatusDetailWidget_SetupLobbyCharacter::InCharacter' has a wrong offset!");

// Function DungeonCrawler.GA_InteractPassive.OnFoundNewInteractableTarget
// 0x0028 (0x0028 - 0x0000)
struct GA_InteractPassive_OnFoundNewInteractableTarget final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_InteractPassive_OnFoundNewInteractableTarget) == 0x000008, "Wrong alignment on GA_InteractPassive_OnFoundNewInteractableTarget");
static_assert(sizeof(GA_InteractPassive_OnFoundNewInteractableTarget) == 0x000028, "Wrong size on GA_InteractPassive_OnFoundNewInteractableTarget");
static_assert(offsetof(GA_InteractPassive_OnFoundNewInteractableTarget, Data) == 0x000000, "Member 'GA_InteractPassive_OnFoundNewInteractableTarget::Data' has a wrong offset!");

// Function DungeonCrawler.GA_InteractPassive.OnLostInteractableTarget
// 0x0028 (0x0028 - 0x0000)
struct GA_InteractPassive_OnLostInteractableTarget final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_InteractPassive_OnLostInteractableTarget) == 0x000008, "Wrong alignment on GA_InteractPassive_OnLostInteractableTarget");
static_assert(sizeof(GA_InteractPassive_OnLostInteractableTarget) == 0x000028, "Wrong size on GA_InteractPassive_OnLostInteractableTarget");
static_assert(offsetof(GA_InteractPassive_OnLostInteractableTarget, Data) == 0x000000, "Member 'GA_InteractPassive_OnLostInteractableTarget::Data' has a wrong offset!");

// Function DungeonCrawler.GA_InteractPassive.OnTargetGameplayTagChange
// 0x000C (0x000C - 0x0000)
struct GA_InteractPassive_OnTargetGameplayTagChange final
{
public:
	struct FGameplayTag                           InGameplayTag;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_InteractPassive_OnTargetGameplayTagChange) == 0x000004, "Wrong alignment on GA_InteractPassive_OnTargetGameplayTagChange");
static_assert(sizeof(GA_InteractPassive_OnTargetGameplayTagChange) == 0x00000C, "Wrong size on GA_InteractPassive_OnTargetGameplayTagChange");
static_assert(offsetof(GA_InteractPassive_OnTargetGameplayTagChange, InGameplayTag) == 0x000000, "Member 'GA_InteractPassive_OnTargetGameplayTagChange::InGameplayTag' has a wrong offset!");
static_assert(offsetof(GA_InteractPassive_OnTargetGameplayTagChange, InCount) == 0x000008, "Member 'GA_InteractPassive_OnTargetGameplayTagChange::InCount' has a wrong offset!");

// Function DungeonCrawler.GA_InteractPassive.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_InteractPassive_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_InteractPassive_ReceivedEvent) == 0x000008, "Wrong alignment on GA_InteractPassive_ReceivedEvent");
static_assert(sizeof(GA_InteractPassive_ReceivedEvent) == 0x0000B8, "Wrong size on GA_InteractPassive_ReceivedEvent");
static_assert(offsetof(GA_InteractPassive_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_InteractPassive_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_InteractPassive_ReceivedEvent, EventData) == 0x000008, "Member 'GA_InteractPassive_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnAgility
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnAgility final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnAgility) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnAgility");
static_assert(sizeof(CharacterStatusWidget_OnAgility) == 0x000020, "Wrong size on CharacterStatusWidget_OnAgility");
static_assert(offsetof(CharacterStatusWidget_OnAgility, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnAgility::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnAgility, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnAgility::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnDexterity
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnDexterity final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnDexterity) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnDexterity");
static_assert(sizeof(CharacterStatusWidget_OnDexterity) == 0x000020, "Wrong size on CharacterStatusWidget_OnDexterity");
static_assert(offsetof(CharacterStatusWidget_OnDexterity, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnDexterity::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnDexterity, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnDexterity::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnHealth
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnHealth final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnHealth) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnHealth");
static_assert(sizeof(CharacterStatusWidget_OnHealth) == 0x000020, "Wrong size on CharacterStatusWidget_OnHealth");
static_assert(offsetof(CharacterStatusWidget_OnHealth, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnHealth::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnHealth, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnHealth::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnKnowledge
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnKnowledge final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnKnowledge) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnKnowledge");
static_assert(sizeof(CharacterStatusWidget_OnKnowledge) == 0x000020, "Wrong size on CharacterStatusWidget_OnKnowledge");
static_assert(offsetof(CharacterStatusWidget_OnKnowledge, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnKnowledge::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnKnowledge, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnKnowledge::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnMaxHealth
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnMaxHealth final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnMaxHealth) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnMaxHealth");
static_assert(sizeof(CharacterStatusWidget_OnMaxHealth) == 0x000020, "Wrong size on CharacterStatusWidget_OnMaxHealth");
static_assert(offsetof(CharacterStatusWidget_OnMaxHealth, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnMaxHealth::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnMaxHealth, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnMaxHealth::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnMaxHealthAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnMaxHealthAdd) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnMaxHealthAdd");
static_assert(sizeof(CharacterStatusWidget_OnMaxHealthAdd) == 0x000020, "Wrong size on CharacterStatusWidget_OnMaxHealthAdd");
static_assert(offsetof(CharacterStatusWidget_OnMaxHealthAdd, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnMaxHealthAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnMaxHealthAdd, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnMaxHealthAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnMaxHealthBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnMaxHealthBase) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnMaxHealthBase");
static_assert(sizeof(CharacterStatusWidget_OnMaxHealthBase) == 0x000020, "Wrong size on CharacterStatusWidget_OnMaxHealthBase");
static_assert(offsetof(CharacterStatusWidget_OnMaxHealthBase, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnMaxHealthBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnMaxHealthBase, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnMaxHealthBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnMaxHealthMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnMaxHealthMod) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnMaxHealthMod");
static_assert(sizeof(CharacterStatusWidget_OnMaxHealthMod) == 0x000020, "Wrong size on CharacterStatusWidget_OnMaxHealthMod");
static_assert(offsetof(CharacterStatusWidget_OnMaxHealthMod, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnMaxHealthMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnMaxHealthMod, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnMaxHealthMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnMemoryCapacity
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnMemoryCapacity final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnMemoryCapacity) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnMemoryCapacity");
static_assert(sizeof(CharacterStatusWidget_OnMemoryCapacity) == 0x000020, "Wrong size on CharacterStatusWidget_OnMemoryCapacity");
static_assert(offsetof(CharacterStatusWidget_OnMemoryCapacity, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnMemoryCapacity::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnMemoryCapacity, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnMemoryCapacity::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnMemoryCapacityAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnMemoryCapacityAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnMemoryCapacityAdd) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnMemoryCapacityAdd");
static_assert(sizeof(CharacterStatusWidget_OnMemoryCapacityAdd) == 0x000020, "Wrong size on CharacterStatusWidget_OnMemoryCapacityAdd");
static_assert(offsetof(CharacterStatusWidget_OnMemoryCapacityAdd, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnMemoryCapacityAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnMemoryCapacityAdd, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnMemoryCapacityAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnMemoryCapacityBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnMemoryCapacityBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnMemoryCapacityBase) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnMemoryCapacityBase");
static_assert(sizeof(CharacterStatusWidget_OnMemoryCapacityBase) == 0x000020, "Wrong size on CharacterStatusWidget_OnMemoryCapacityBase");
static_assert(offsetof(CharacterStatusWidget_OnMemoryCapacityBase, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnMemoryCapacityBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnMemoryCapacityBase, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnMemoryCapacityBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnMemoryCapacityMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnMemoryCapacityMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnMemoryCapacityMod) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnMemoryCapacityMod");
static_assert(sizeof(CharacterStatusWidget_OnMemoryCapacityMod) == 0x000020, "Wrong size on CharacterStatusWidget_OnMemoryCapacityMod");
static_assert(offsetof(CharacterStatusWidget_OnMemoryCapacityMod, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnMemoryCapacityMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnMemoryCapacityMod, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnMemoryCapacityMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnMemoryMusicPayload
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnMemoryMusicPayload final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnMemoryMusicPayload) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnMemoryMusicPayload");
static_assert(sizeof(CharacterStatusWidget_OnMemoryMusicPayload) == 0x000020, "Wrong size on CharacterStatusWidget_OnMemoryMusicPayload");
static_assert(offsetof(CharacterStatusWidget_OnMemoryMusicPayload, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnMemoryMusicPayload::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnMemoryMusicPayload, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnMemoryMusicPayload::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnMemorySpellPayload
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnMemorySpellPayload final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnMemorySpellPayload) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnMemorySpellPayload");
static_assert(sizeof(CharacterStatusWidget_OnMemorySpellPayload) == 0x000020, "Wrong size on CharacterStatusWidget_OnMemorySpellPayload");
static_assert(offsetof(CharacterStatusWidget_OnMemorySpellPayload, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnMemorySpellPayload::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnMemorySpellPayload, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnMemorySpellPayload::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnOverhealedHealth
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnOverhealedHealth final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnOverhealedHealth) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnOverhealedHealth");
static_assert(sizeof(CharacterStatusWidget_OnOverhealedHealth) == 0x000020, "Wrong size on CharacterStatusWidget_OnOverhealedHealth");
static_assert(offsetof(CharacterStatusWidget_OnOverhealedHealth, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnOverhealedHealth::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnOverhealedHealth, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnOverhealedHealth::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnResourcefulness
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnResourcefulness final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnResourcefulness) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnResourcefulness");
static_assert(sizeof(CharacterStatusWidget_OnResourcefulness) == 0x000020, "Wrong size on CharacterStatusWidget_OnResourcefulness");
static_assert(offsetof(CharacterStatusWidget_OnResourcefulness, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnResourcefulness::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnResourcefulness, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnResourcefulness::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnStrength
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnStrength final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnStrength) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnStrength");
static_assert(sizeof(CharacterStatusWidget_OnStrength) == 0x000020, "Wrong size on CharacterStatusWidget_OnStrength");
static_assert(offsetof(CharacterStatusWidget_OnStrength, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnStrength::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnStrength, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnStrength::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectiveness
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnUtilityEffectiveness final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnUtilityEffectiveness) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnUtilityEffectiveness");
static_assert(sizeof(CharacterStatusWidget_OnUtilityEffectiveness) == 0x000020, "Wrong size on CharacterStatusWidget_OnUtilityEffectiveness");
static_assert(offsetof(CharacterStatusWidget_OnUtilityEffectiveness, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnUtilityEffectiveness::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnUtilityEffectiveness, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnUtilityEffectiveness::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnUtilityEffectivenessAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnUtilityEffectivenessAdd) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnUtilityEffectivenessAdd");
static_assert(sizeof(CharacterStatusWidget_OnUtilityEffectivenessAdd) == 0x000020, "Wrong size on CharacterStatusWidget_OnUtilityEffectivenessAdd");
static_assert(offsetof(CharacterStatusWidget_OnUtilityEffectivenessAdd, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnUtilityEffectivenessAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnUtilityEffectivenessAdd, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnUtilityEffectivenessAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnUtilityEffectivenessBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnUtilityEffectivenessBase) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnUtilityEffectivenessBase");
static_assert(sizeof(CharacterStatusWidget_OnUtilityEffectivenessBase) == 0x000020, "Wrong size on CharacterStatusWidget_OnUtilityEffectivenessBase");
static_assert(offsetof(CharacterStatusWidget_OnUtilityEffectivenessBase, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnUtilityEffectivenessBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnUtilityEffectivenessBase, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnUtilityEffectivenessBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnUtilityEffectivenessMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnUtilityEffectivenessMod) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnUtilityEffectivenessMod");
static_assert(sizeof(CharacterStatusWidget_OnUtilityEffectivenessMod) == 0x000020, "Wrong size on CharacterStatusWidget_OnUtilityEffectivenessMod");
static_assert(offsetof(CharacterStatusWidget_OnUtilityEffectivenessMod, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnUtilityEffectivenessMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnUtilityEffectivenessMod, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnUtilityEffectivenessMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnVigor
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnVigor final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnVigor) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnVigor");
static_assert(sizeof(CharacterStatusWidget_OnVigor) == 0x000020, "Wrong size on CharacterStatusWidget_OnVigor");
static_assert(offsetof(CharacterStatusWidget_OnVigor, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnVigor::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnVigor, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnVigor::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnWeight
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnWeight final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnWeight) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnWeight");
static_assert(sizeof(CharacterStatusWidget_OnWeight) == 0x000020, "Wrong size on CharacterStatusWidget_OnWeight");
static_assert(offsetof(CharacterStatusWidget_OnWeight, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnWeight::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnWeight, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnWeight::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnWeightLimit
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnWeightLimit final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnWeightLimit) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnWeightLimit");
static_assert(sizeof(CharacterStatusWidget_OnWeightLimit) == 0x000020, "Wrong size on CharacterStatusWidget_OnWeightLimit");
static_assert(offsetof(CharacterStatusWidget_OnWeightLimit, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnWeightLimit::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnWeightLimit, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnWeightLimit::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitAdd
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnWeightLimitAdd final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnWeightLimitAdd) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnWeightLimitAdd");
static_assert(sizeof(CharacterStatusWidget_OnWeightLimitAdd) == 0x000020, "Wrong size on CharacterStatusWidget_OnWeightLimitAdd");
static_assert(offsetof(CharacterStatusWidget_OnWeightLimitAdd, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnWeightLimitAdd::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnWeightLimitAdd, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnWeightLimitAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitBase
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnWeightLimitBase final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnWeightLimitBase) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnWeightLimitBase");
static_assert(sizeof(CharacterStatusWidget_OnWeightLimitBase) == 0x000020, "Wrong size on CharacterStatusWidget_OnWeightLimitBase");
static_assert(offsetof(CharacterStatusWidget_OnWeightLimitBase, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnWeightLimitBase::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnWeightLimitBase, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnWeightLimitBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitMod
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnWeightLimitMod final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnWeightLimitMod) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnWeightLimitMod");
static_assert(sizeof(CharacterStatusWidget_OnWeightLimitMod) == 0x000020, "Wrong size on CharacterStatusWidget_OnWeightLimitMod");
static_assert(offsetof(CharacterStatusWidget_OnWeightLimitMod, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnWeightLimitMod::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnWeightLimitMod, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnWeightLimitMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.CharacterStatusWidget.OnWill
// 0x0020 (0x0020 - 0x0000)
struct CharacterStatusWidget_OnWill final
{
public:
	struct FGameplayAttributeData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterStatusWidget_OnWill) == 0x000008, "Wrong alignment on CharacterStatusWidget_OnWill");
static_assert(sizeof(CharacterStatusWidget_OnWill) == 0x000020, "Wrong size on CharacterStatusWidget_OnWill");
static_assert(offsetof(CharacterStatusWidget_OnWill, NewValue) == 0x000000, "Member 'CharacterStatusWidget_OnWill::NewValue' has a wrong offset!");
static_assert(offsetof(CharacterStatusWidget_OnWill, OldValue) == 0x000010, "Member 'CharacterStatusWidget_OnWill::OldValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.OnDungeonRotationTimerData
// 0x0018 (0x0018 - 0x0000)
struct DungeonSelectWidget_OnDungeonRotationTimerData final
{
public:
	struct FDungeonRotationTimerData              NewValue;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDungeonRotationTimerData              OldValue;                                          // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_OnDungeonRotationTimerData) == 0x000004, "Wrong alignment on DungeonSelectWidget_OnDungeonRotationTimerData");
static_assert(sizeof(DungeonSelectWidget_OnDungeonRotationTimerData) == 0x000018, "Wrong size on DungeonSelectWidget_OnDungeonRotationTimerData");
static_assert(offsetof(DungeonSelectWidget_OnDungeonRotationTimerData, NewValue) == 0x000000, "Member 'DungeonSelectWidget_OnDungeonRotationTimerData::NewValue' has a wrong offset!");
static_assert(offsetof(DungeonSelectWidget_OnDungeonRotationTimerData, OldValue) == 0x00000C, "Member 'DungeonSelectWidget_OnDungeonRotationTimerData::OldValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.OnGameType
// 0x0002 (0x0002 - 0x0000)
struct DungeonSelectWidget_OnGameType final
{
public:
	EGameType                                     NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_OnGameType) == 0x000001, "Wrong alignment on DungeonSelectWidget_OnGameType");
static_assert(sizeof(DungeonSelectWidget_OnGameType) == 0x000002, "Wrong size on DungeonSelectWidget_OnGameType");
static_assert(offsetof(DungeonSelectWidget_OnGameType, NewValue) == 0x000000, "Member 'DungeonSelectWidget_OnGameType::NewValue' has a wrong offset!");
static_assert(offsetof(DungeonSelectWidget_OnGameType, OldValue) == 0x000001, "Member 'DungeonSelectWidget_OnGameType::OldValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.OnGameUserSettingControlsChanged
// 0x0088 (0x0088 - 0x0000)
struct DungeonSelectWidget_OnGameUserSettingControlsChanged final
{
public:
	struct FGameUserSettingControls               InGameUserSettingControls;                         // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameUserSettingControls               InOldGameUserSettingControls;                      // 0x0040(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInForce;                                          // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2430[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DungeonSelectWidget_OnGameUserSettingControlsChanged) == 0x000008, "Wrong alignment on DungeonSelectWidget_OnGameUserSettingControlsChanged");
static_assert(sizeof(DungeonSelectWidget_OnGameUserSettingControlsChanged) == 0x000088, "Wrong size on DungeonSelectWidget_OnGameUserSettingControlsChanged");
static_assert(offsetof(DungeonSelectWidget_OnGameUserSettingControlsChanged, InGameUserSettingControls) == 0x000000, "Member 'DungeonSelectWidget_OnGameUserSettingControlsChanged::InGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(DungeonSelectWidget_OnGameUserSettingControlsChanged, InOldGameUserSettingControls) == 0x000040, "Member 'DungeonSelectWidget_OnGameUserSettingControlsChanged::InOldGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(DungeonSelectWidget_OnGameUserSettingControlsChanged, bInForce) == 0x000080, "Member 'DungeonSelectWidget_OnGameUserSettingControlsChanged::bInForce' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.OnMatchMode
// 0x0002 (0x0002 - 0x0000)
struct DungeonSelectWidget_OnMatchMode final
{
public:
	EMatchMode                                    NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchMode                                    OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_OnMatchMode) == 0x000001, "Wrong alignment on DungeonSelectWidget_OnMatchMode");
static_assert(sizeof(DungeonSelectWidget_OnMatchMode) == 0x000002, "Wrong size on DungeonSelectWidget_OnMatchMode");
static_assert(offsetof(DungeonSelectWidget_OnMatchMode, NewValue) == 0x000000, "Member 'DungeonSelectWidget_OnMatchMode::NewValue' has a wrong offset!");
static_assert(offsetof(DungeonSelectWidget_OnMatchMode, OldValue) == 0x000001, "Member 'DungeonSelectWidget_OnMatchMode::OldValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.OnSetFeatureLockExpiredTime
// 0x0010 (0x0010 - 0x0000)
struct DungeonSelectWidget_OnSetFeatureLockExpiredTime final
{
public:
	bool                                          InIsLocked;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2431[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              InRemainTime;                                      // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_OnSetFeatureLockExpiredTime) == 0x000008, "Wrong alignment on DungeonSelectWidget_OnSetFeatureLockExpiredTime");
static_assert(sizeof(DungeonSelectWidget_OnSetFeatureLockExpiredTime) == 0x000010, "Wrong size on DungeonSelectWidget_OnSetFeatureLockExpiredTime");
static_assert(offsetof(DungeonSelectWidget_OnSetFeatureLockExpiredTime, InIsLocked) == 0x000000, "Member 'DungeonSelectWidget_OnSetFeatureLockExpiredTime::InIsLocked' has a wrong offset!");
static_assert(offsetof(DungeonSelectWidget_OnSetFeatureLockExpiredTime, InRemainTime) == 0x000008, "Member 'DungeonSelectWidget_OnSetFeatureLockExpiredTime::InRemainTime' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.SetGameType
// 0x0002 (0x0002 - 0x0000)
struct DungeonSelectWidget_SetGameType final
{
public:
	EMatchMode                                    InMatchMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     InGameType;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_SetGameType) == 0x000001, "Wrong alignment on DungeonSelectWidget_SetGameType");
static_assert(sizeof(DungeonSelectWidget_SetGameType) == 0x000002, "Wrong size on DungeonSelectWidget_SetGameType");
static_assert(offsetof(DungeonSelectWidget_SetGameType, InMatchMode) == 0x000000, "Member 'DungeonSelectWidget_SetGameType::InMatchMode' has a wrong offset!");
static_assert(offsetof(DungeonSelectWidget_SetGameType, InGameType) == 0x000001, "Member 'DungeonSelectWidget_SetGameType::InGameType' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.GetArenaAssistStat
// 0x0004 (0x0004 - 0x0000)
struct DungeonSelectWidget_GetArenaAssistStat final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_GetArenaAssistStat) == 0x000004, "Wrong alignment on DungeonSelectWidget_GetArenaAssistStat");
static_assert(sizeof(DungeonSelectWidget_GetArenaAssistStat) == 0x000004, "Wrong size on DungeonSelectWidget_GetArenaAssistStat");
static_assert(offsetof(DungeonSelectWidget_GetArenaAssistStat, ReturnValue) == 0x000000, "Member 'DungeonSelectWidget_GetArenaAssistStat::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.GetArenaBeginTime
// 0x0008 (0x0008 - 0x0000)
struct DungeonSelectWidget_GetArenaBeginTime final
{
public:
	struct FDateTime                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_GetArenaBeginTime) == 0x000008, "Wrong alignment on DungeonSelectWidget_GetArenaBeginTime");
static_assert(sizeof(DungeonSelectWidget_GetArenaBeginTime) == 0x000008, "Wrong size on DungeonSelectWidget_GetArenaBeginTime");
static_assert(offsetof(DungeonSelectWidget_GetArenaBeginTime, ReturnValue) == 0x000000, "Member 'DungeonSelectWidget_GetArenaBeginTime::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.GetArenaDeathStat
// 0x0004 (0x0004 - 0x0000)
struct DungeonSelectWidget_GetArenaDeathStat final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_GetArenaDeathStat) == 0x000004, "Wrong alignment on DungeonSelectWidget_GetArenaDeathStat");
static_assert(sizeof(DungeonSelectWidget_GetArenaDeathStat) == 0x000004, "Wrong size on DungeonSelectWidget_GetArenaDeathStat");
static_assert(offsetof(DungeonSelectWidget_GetArenaDeathStat, ReturnValue) == 0x000000, "Member 'DungeonSelectWidget_GetArenaDeathStat::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.GetArenaDrawStat
// 0x0004 (0x0004 - 0x0000)
struct DungeonSelectWidget_GetArenaDrawStat final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_GetArenaDrawStat) == 0x000004, "Wrong alignment on DungeonSelectWidget_GetArenaDrawStat");
static_assert(sizeof(DungeonSelectWidget_GetArenaDrawStat) == 0x000004, "Wrong size on DungeonSelectWidget_GetArenaDrawStat");
static_assert(offsetof(DungeonSelectWidget_GetArenaDrawStat, ReturnValue) == 0x000000, "Member 'DungeonSelectWidget_GetArenaDrawStat::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.GetArenaEndTime
// 0x0008 (0x0008 - 0x0000)
struct DungeonSelectWidget_GetArenaEndTime final
{
public:
	struct FDateTime                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_GetArenaEndTime) == 0x000008, "Wrong alignment on DungeonSelectWidget_GetArenaEndTime");
static_assert(sizeof(DungeonSelectWidget_GetArenaEndTime) == 0x000008, "Wrong size on DungeonSelectWidget_GetArenaEndTime");
static_assert(offsetof(DungeonSelectWidget_GetArenaEndTime, ReturnValue) == 0x000000, "Member 'DungeonSelectWidget_GetArenaEndTime::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.GetArenaKillStat
// 0x0004 (0x0004 - 0x0000)
struct DungeonSelectWidget_GetArenaKillStat final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_GetArenaKillStat) == 0x000004, "Wrong alignment on DungeonSelectWidget_GetArenaKillStat");
static_assert(sizeof(DungeonSelectWidget_GetArenaKillStat) == 0x000004, "Wrong size on DungeonSelectWidget_GetArenaKillStat");
static_assert(offsetof(DungeonSelectWidget_GetArenaKillStat, ReturnValue) == 0x000000, "Member 'DungeonSelectWidget_GetArenaKillStat::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.GetArenaLoseStat
// 0x0004 (0x0004 - 0x0000)
struct DungeonSelectWidget_GetArenaLoseStat final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_GetArenaLoseStat) == 0x000004, "Wrong alignment on DungeonSelectWidget_GetArenaLoseStat");
static_assert(sizeof(DungeonSelectWidget_GetArenaLoseStat) == 0x000004, "Wrong size on DungeonSelectWidget_GetArenaLoseStat");
static_assert(offsetof(DungeonSelectWidget_GetArenaLoseStat, ReturnValue) == 0x000000, "Member 'DungeonSelectWidget_GetArenaLoseStat::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.GetArenaWinStat
// 0x0004 (0x0004 - 0x0000)
struct DungeonSelectWidget_GetArenaWinStat final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_GetArenaWinStat) == 0x000004, "Wrong alignment on DungeonSelectWidget_GetArenaWinStat");
static_assert(sizeof(DungeonSelectWidget_GetArenaWinStat) == 0x000004, "Wrong size on DungeonSelectWidget_GetArenaWinStat");
static_assert(offsetof(DungeonSelectWidget_GetArenaWinStat, ReturnValue) == 0x000000, "Member 'DungeonSelectWidget_GetArenaWinStat::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectWidget.IsDungeonRestricted
// 0x0002 (0x0002 - 0x0000)
struct DungeonSelectWidget_IsDungeonRestricted final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectWidget_IsDungeonRestricted) == 0x000001, "Wrong alignment on DungeonSelectWidget_IsDungeonRestricted");
static_assert(sizeof(DungeonSelectWidget_IsDungeonRestricted) == 0x000002, "Wrong size on DungeonSelectWidget_IsDungeonRestricted");
static_assert(offsetof(DungeonSelectWidget_IsDungeonRestricted, InGameType) == 0x000000, "Member 'DungeonSelectWidget_IsDungeonRestricted::InGameType' has a wrong offset!");
static_assert(offsetof(DungeonSelectWidget_IsDungeonRestricted, ReturnValue) == 0x000001, "Member 'DungeonSelectWidget_IsDungeonRestricted::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_InteractRope.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_InteractRope_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_InteractRope_AbilityActivated) == 0x000008, "Wrong alignment on GA_InteractRope_AbilityActivated");
static_assert(sizeof(GA_InteractRope_AbilityActivated) == 0x0000B0, "Wrong size on GA_InteractRope_AbilityActivated");
static_assert(offsetof(GA_InteractRope_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_InteractRope_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_InteractRope.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_InteractRope_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_InteractRope_EventReceived) == 0x000008, "Wrong alignment on GA_InteractRope_EventReceived");
static_assert(sizeof(GA_InteractRope_EventReceived) == 0x0000B8, "Wrong size on GA_InteractRope_EventReceived");
static_assert(offsetof(GA_InteractRope_EventReceived, EventTag) == 0x000000, "Member 'GA_InteractRope_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_InteractRope_EventReceived, EventData) == 0x000008, "Member 'GA_InteractRope_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_InteractRope.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_InteractRope_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_InteractRope_OnCancelled) == 0x000008, "Wrong alignment on GA_InteractRope_OnCancelled");
static_assert(sizeof(GA_InteractRope_OnCancelled) == 0x0000B8, "Wrong size on GA_InteractRope_OnCancelled");
static_assert(offsetof(GA_InteractRope_OnCancelled, EventTag) == 0x000000, "Member 'GA_InteractRope_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_InteractRope_OnCancelled, EventData) == 0x000008, "Member 'GA_InteractRope_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_InteractRope.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_InteractRope_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_InteractRope_OnCompleted) == 0x000008, "Wrong alignment on GA_InteractRope_OnCompleted");
static_assert(sizeof(GA_InteractRope_OnCompleted) == 0x0000B8, "Wrong size on GA_InteractRope_OnCompleted");
static_assert(offsetof(GA_InteractRope_OnCompleted, EventTag) == 0x000000, "Member 'GA_InteractRope_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_InteractRope_OnCompleted, EventData) == 0x000008, "Member 'GA_InteractRope_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.ChatEditWidgetBase.IsEditableTextHasFocus
// 0x0001 (0x0001 - 0x0000)
struct ChatEditWidgetBase_IsEditableTextHasFocus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatEditWidgetBase_IsEditableTextHasFocus) == 0x000001, "Wrong alignment on ChatEditWidgetBase_IsEditableTextHasFocus");
static_assert(sizeof(ChatEditWidgetBase_IsEditableTextHasFocus) == 0x000001, "Wrong size on ChatEditWidgetBase_IsEditableTextHasFocus");
static_assert(offsetof(ChatEditWidgetBase_IsEditableTextHasFocus, ReturnValue) == 0x000000, "Member 'ChatEditWidgetBase_IsEditableTextHasFocus::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ChatEditWidgetBase.OnTextChanged
// 0x0018 (0x0018 - 0x0000)
struct ChatEditWidgetBase_OnTextChanged final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatEditWidgetBase_OnTextChanged) == 0x000008, "Wrong alignment on ChatEditWidgetBase_OnTextChanged");
static_assert(sizeof(ChatEditWidgetBase_OnTextChanged) == 0x000018, "Wrong size on ChatEditWidgetBase_OnTextChanged");
static_assert(offsetof(ChatEditWidgetBase_OnTextChanged, InText) == 0x000000, "Member 'ChatEditWidgetBase_OnTextChanged::InText' has a wrong offset!");

// Function DungeonCrawler.ChatEditWidgetBase.OnTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct ChatEditWidgetBase_OnTextCommitted final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   InCommitMethod;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2435[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChatEditWidgetBase_OnTextCommitted) == 0x000008, "Wrong alignment on ChatEditWidgetBase_OnTextCommitted");
static_assert(sizeof(ChatEditWidgetBase_OnTextCommitted) == 0x000020, "Wrong size on ChatEditWidgetBase_OnTextCommitted");
static_assert(offsetof(ChatEditWidgetBase_OnTextCommitted, InText) == 0x000000, "Member 'ChatEditWidgetBase_OnTextCommitted::InText' has a wrong offset!");
static_assert(offsetof(ChatEditWidgetBase_OnTextCommitted, InCommitMethod) == 0x000018, "Member 'ChatEditWidgetBase_OnTextCommitted::InCommitMethod' has a wrong offset!");

// Function DungeonCrawler.ChatEditWidgetBase.SetUserFocusText
// 0x0008 (0x0008 - 0x0000)
struct ChatEditWidgetBase_SetUserFocusText final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatEditWidgetBase_SetUserFocusText) == 0x000008, "Wrong alignment on ChatEditWidgetBase_SetUserFocusText");
static_assert(sizeof(ChatEditWidgetBase_SetUserFocusText) == 0x000008, "Wrong size on ChatEditWidgetBase_SetUserFocusText");
static_assert(offsetof(ChatEditWidgetBase_SetUserFocusText, PlayerController) == 0x000000, "Member 'ChatEditWidgetBase_SetUserFocusText::PlayerController' has a wrong offset!");

// Function DungeonCrawler.ChatFilterListEntryWidget.OnCheckStateChanged
// 0x0001 (0x0001 - 0x0000)
struct ChatFilterListEntryWidget_OnCheckStateChanged final
{
public:
	bool                                          bIsChecked;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatFilterListEntryWidget_OnCheckStateChanged) == 0x000001, "Wrong alignment on ChatFilterListEntryWidget_OnCheckStateChanged");
static_assert(sizeof(ChatFilterListEntryWidget_OnCheckStateChanged) == 0x000001, "Wrong size on ChatFilterListEntryWidget_OnCheckStateChanged");
static_assert(offsetof(ChatFilterListEntryWidget_OnCheckStateChanged, bIsChecked) == 0x000000, "Member 'ChatFilterListEntryWidget_OnCheckStateChanged::bIsChecked' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct InteractableTargetComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on InteractableTargetComponent_BroadcastMsgBlueprint");
static_assert(sizeof(InteractableTargetComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on InteractableTargetComponent_BroadcastMsgBlueprint");
static_assert(offsetof(InteractableTargetComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'InteractableTargetComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.CanInteract
// 0x0001 (0x0001 - 0x0000)
struct InteractableTargetComponent_CanInteract final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_CanInteract) == 0x000001, "Wrong alignment on InteractableTargetComponent_CanInteract");
static_assert(sizeof(InteractableTargetComponent_CanInteract) == 0x000001, "Wrong size on InteractableTargetComponent_CanInteract");
static_assert(offsetof(InteractableTargetComponent_CanInteract, ReturnValue) == 0x000000, "Member 'InteractableTargetComponent_CanInteract::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.InteractFailed
// 0x0010 (0x0010 - 0x0000)
struct InteractableTargetComponent_InteractFailed final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TriggerTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_InteractFailed) == 0x000008, "Wrong alignment on InteractableTargetComponent_InteractFailed");
static_assert(sizeof(InteractableTargetComponent_InteractFailed) == 0x000010, "Wrong size on InteractableTargetComponent_InteractFailed");
static_assert(offsetof(InteractableTargetComponent_InteractFailed, InteractingActor) == 0x000000, "Member 'InteractableTargetComponent_InteractFailed::InteractingActor' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_InteractFailed, TriggerTag) == 0x000008, "Member 'InteractableTargetComponent_InteractFailed::TriggerTag' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.InteractSucceed
// 0x0100 (0x0100 - 0x0000)
struct InteractableTargetComponent_InteractSucceed final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TriggerTag;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StateTag;                                          // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0018(0x00E8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_InteractSucceed) == 0x000008, "Wrong alignment on InteractableTargetComponent_InteractSucceed");
static_assert(sizeof(InteractableTargetComponent_InteractSucceed) == 0x000100, "Wrong size on InteractableTargetComponent_InteractSucceed");
static_assert(offsetof(InteractableTargetComponent_InteractSucceed, InteractingActor) == 0x000000, "Member 'InteractableTargetComponent_InteractSucceed::InteractingActor' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_InteractSucceed, TriggerTag) == 0x000008, "Member 'InteractableTargetComponent_InteractSucceed::TriggerTag' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_InteractSucceed, StateTag) == 0x000010, "Member 'InteractableTargetComponent_InteractSucceed::StateTag' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_InteractSucceed, HitResult) == 0x000018, "Member 'InteractableTargetComponent_InteractSucceed::HitResult' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.RegisterInteracter
// 0x0008 (0x0008 - 0x0000)
struct InteractableTargetComponent_RegisterInteracter final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_RegisterInteracter) == 0x000008, "Wrong alignment on InteractableTargetComponent_RegisterInteracter");
static_assert(sizeof(InteractableTargetComponent_RegisterInteracter) == 0x000008, "Wrong size on InteractableTargetComponent_RegisterInteracter");
static_assert(offsetof(InteractableTargetComponent_RegisterInteracter, InteractingActor) == 0x000000, "Member 'InteractableTargetComponent_RegisterInteracter::InteractingActor' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.SetInteractionData
// 0x00C0 (0x00C0 - 0x0000)
struct InteractableTargetComponent_SetInteractionData final
{
public:
	struct FDesignDataPropsInteract               InteractionData;                                   // 0x0000(0x00C0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_SetInteractionData) == 0x000008, "Wrong alignment on InteractableTargetComponent_SetInteractionData");
static_assert(sizeof(InteractableTargetComponent_SetInteractionData) == 0x0000C0, "Wrong size on InteractableTargetComponent_SetInteractionData");
static_assert(offsetof(InteractableTargetComponent_SetInteractionData, InteractionData) == 0x000000, "Member 'InteractableTargetComponent_SetInteractionData::InteractionData' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.SetInteractionDataV2
// 0x0008 (0x0008 - 0x0000)
struct InteractableTargetComponent_SetInteractionDataV2 final
{
public:
	const class UDCPropsInteractDataAsset*        InteractionSettingData;                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_SetInteractionDataV2) == 0x000008, "Wrong alignment on InteractableTargetComponent_SetInteractionDataV2");
static_assert(sizeof(InteractableTargetComponent_SetInteractionDataV2) == 0x000008, "Wrong size on InteractableTargetComponent_SetInteractionDataV2");
static_assert(offsetof(InteractableTargetComponent_SetInteractionDataV2, InteractionSettingData) == 0x000000, "Member 'InteractableTargetComponent_SetInteractionDataV2::InteractionSettingData' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.ShouldCancelOthersWhenInteractSucceed
// 0x000C (0x000C - 0x0000)
struct InteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed final
{
public:
	struct FGameplayTag                           StateTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2440[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed) == 0x000004, "Wrong alignment on InteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed");
static_assert(sizeof(InteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed) == 0x00000C, "Wrong size on InteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed");
static_assert(offsetof(InteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed, StateTag) == 0x000000, "Member 'InteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed::StateTag' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed, ReturnValue) == 0x000008, "Member 'InteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct InteractableTargetComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_UnbindMsg) == 0x000008, "Wrong alignment on InteractableTargetComponent_UnbindMsg");
static_assert(sizeof(InteractableTargetComponent_UnbindMsg) == 0x000010, "Wrong size on InteractableTargetComponent_UnbindMsg");
static_assert(offsetof(InteractableTargetComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'InteractableTargetComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_UnbindMsg, InObject) == 0x000008, "Member 'InteractableTargetComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct InteractableTargetComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on InteractableTargetComponent_UnbindMsgAll");
static_assert(sizeof(InteractableTargetComponent_UnbindMsgAll) == 0x000008, "Wrong size on InteractableTargetComponent_UnbindMsgAll");
static_assert(offsetof(InteractableTargetComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'InteractableTargetComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.UnregisterInteracter
// 0x0008 (0x0008 - 0x0000)
struct InteractableTargetComponent_UnregisterInteracter final
{
public:
	class AActor*                                 InteractingActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_UnregisterInteracter) == 0x000008, "Wrong alignment on InteractableTargetComponent_UnregisterInteracter");
static_assert(sizeof(InteractableTargetComponent_UnregisterInteracter) == 0x000008, "Wrong size on InteractableTargetComponent_UnregisterInteracter");
static_assert(offsetof(InteractableTargetComponent_UnregisterInteracter, InteractingActor) == 0x000000, "Member 'InteractableTargetComponent_UnregisterInteracter::InteractingActor' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.GetData
// 0x00C0 (0x00C0 - 0x0000)
struct InteractableTargetComponent_GetData final
{
public:
	struct FGameplayTag                           StateTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractionData                       ReturnValue;                                       // 0x0008(0x00B8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_GetData) == 0x000008, "Wrong alignment on InteractableTargetComponent_GetData");
static_assert(sizeof(InteractableTargetComponent_GetData) == 0x0000C0, "Wrong size on InteractableTargetComponent_GetData");
static_assert(offsetof(InteractableTargetComponent_GetData, StateTag) == 0x000000, "Member 'InteractableTargetComponent_GetData::StateTag' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_GetData, ReturnValue) == 0x000008, "Member 'InteractableTargetComponent_GetData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.GetInteractability
// 0x0018 (0x0018 - 0x0000)
struct InteractableTargetComponent_GetInteractability final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OutInteractFailedTag;                              // 0x0008(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCInteractableType                           ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2441[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractableTargetComponent_GetInteractability) == 0x000008, "Wrong alignment on InteractableTargetComponent_GetInteractability");
static_assert(sizeof(InteractableTargetComponent_GetInteractability) == 0x000018, "Wrong size on InteractableTargetComponent_GetInteractability");
static_assert(offsetof(InteractableTargetComponent_GetInteractability, Interacter) == 0x000000, "Member 'InteractableTargetComponent_GetInteractability::Interacter' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_GetInteractability, OutInteractFailedTag) == 0x000008, "Member 'InteractableTargetComponent_GetInteractability::OutInteractFailedTag' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_GetInteractability, ReturnValue) == 0x000010, "Member 'InteractableTargetComponent_GetInteractability::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.GetInteractableDataByStateMap
// 0x0050 (0x0050 - 0x0000)
struct InteractableTargetComponent_GetInteractableDataByStateMap final
{
public:
	TMap<struct FGameplayTag, struct FInteractionData> ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_GetInteractableDataByStateMap) == 0x000008, "Wrong alignment on InteractableTargetComponent_GetInteractableDataByStateMap");
static_assert(sizeof(InteractableTargetComponent_GetInteractableDataByStateMap) == 0x000050, "Wrong size on InteractableTargetComponent_GetInteractableDataByStateMap");
static_assert(offsetof(InteractableTargetComponent_GetInteractableDataByStateMap, ReturnValue) == 0x000000, "Member 'InteractableTargetComponent_GetInteractableDataByStateMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.GetInteractTargetData
// 0x0020 (0x0020 - 0x0000)
struct InteractableTargetComponent_GetInteractTargetData final
{
public:
	struct FInteractTargetData                    ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_GetInteractTargetData) == 0x000008, "Wrong alignment on InteractableTargetComponent_GetInteractTargetData");
static_assert(sizeof(InteractableTargetComponent_GetInteractTargetData) == 0x000020, "Wrong size on InteractableTargetComponent_GetInteractTargetData");
static_assert(offsetof(InteractableTargetComponent_GetInteractTargetData, ReturnValue) == 0x000000, "Member 'InteractableTargetComponent_GetInteractTargetData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.GetRemainingInteractCount
// 0x0004 (0x0004 - 0x0000)
struct InteractableTargetComponent_GetRemainingInteractCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_GetRemainingInteractCount) == 0x000004, "Wrong alignment on InteractableTargetComponent_GetRemainingInteractCount");
static_assert(sizeof(InteractableTargetComponent_GetRemainingInteractCount) == 0x000004, "Wrong size on InteractableTargetComponent_GetRemainingInteractCount");
static_assert(offsetof(InteractableTargetComponent_GetRemainingInteractCount, ReturnValue) == 0x000000, "Member 'InteractableTargetComponent_GetRemainingInteractCount::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.GetStateTag
// 0x0010 (0x0010 - 0x0000)
struct InteractableTargetComponent_GetStateTag final
{
public:
	struct FGameplayTag                           TriggerTag;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InteractableTargetComponent_GetStateTag) == 0x000004, "Wrong alignment on InteractableTargetComponent_GetStateTag");
static_assert(sizeof(InteractableTargetComponent_GetStateTag) == 0x000010, "Wrong size on InteractableTargetComponent_GetStateTag");
static_assert(offsetof(InteractableTargetComponent_GetStateTag, TriggerTag) == 0x000000, "Member 'InteractableTargetComponent_GetStateTag::TriggerTag' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_GetStateTag, ReturnValue) == 0x000008, "Member 'InteractableTargetComponent_GetStateTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.IsDetectable
// 0x0010 (0x0010 - 0x0000)
struct InteractableTargetComponent_IsDetectable final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2442[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractableTargetComponent_IsDetectable) == 0x000008, "Wrong alignment on InteractableTargetComponent_IsDetectable");
static_assert(sizeof(InteractableTargetComponent_IsDetectable) == 0x000010, "Wrong size on InteractableTargetComponent_IsDetectable");
static_assert(offsetof(InteractableTargetComponent_IsDetectable, Interacter) == 0x000000, "Member 'InteractableTargetComponent_IsDetectable::Interacter' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_IsDetectable, ReturnValue) == 0x000008, "Member 'InteractableTargetComponent_IsDetectable::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InteractableTargetComponent.ShouldConsumeHoldingItem
// 0x0010 (0x0010 - 0x0000)
struct InteractableTargetComponent_ShouldConsumeHoldingItem final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInteractionSucceed;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2443[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InteractableTargetComponent_ShouldConsumeHoldingItem) == 0x000008, "Wrong alignment on InteractableTargetComponent_ShouldConsumeHoldingItem");
static_assert(sizeof(InteractableTargetComponent_ShouldConsumeHoldingItem) == 0x000010, "Wrong size on InteractableTargetComponent_ShouldConsumeHoldingItem");
static_assert(offsetof(InteractableTargetComponent_ShouldConsumeHoldingItem, Interacter) == 0x000000, "Member 'InteractableTargetComponent_ShouldConsumeHoldingItem::Interacter' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_ShouldConsumeHoldingItem, bIsInteractionSucceed) == 0x000008, "Member 'InteractableTargetComponent_ShouldConsumeHoldingItem::bIsInteractionSucceed' has a wrong offset!");
static_assert(offsetof(InteractableTargetComponent_ShouldConsumeHoldingItem, ReturnValue) == 0x000009, "Member 'InteractableTargetComponent_ShouldConsumeHoldingItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAkComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCAkComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAkComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCAkComponent_BroadcastMsgBlueprint");
static_assert(sizeof(DCAkComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCAkComponent_BroadcastMsgBlueprint");
static_assert(offsetof(DCAkComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCAkComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCAkComponent.PostSoundEvent
// 0x0008 (0x0008 - 0x0000)
struct DCAkComponent_PostSoundEvent final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAkComponent_PostSoundEvent) == 0x000004, "Wrong alignment on DCAkComponent_PostSoundEvent");
static_assert(sizeof(DCAkComponent_PostSoundEvent) == 0x000008, "Wrong size on DCAkComponent_PostSoundEvent");
static_assert(offsetof(DCAkComponent_PostSoundEvent, Tag) == 0x000000, "Member 'DCAkComponent_PostSoundEvent::Tag' has a wrong offset!");

// Function DungeonCrawler.DCAkComponent.SetSoundSwitch
// 0x0030 (0x0030 - 0x0000)
struct DCAkComponent_SetSoundSwitch final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              SurfaceType;                                       // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2447[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SwitchGroup;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SwitchState;                                       // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAkComponent_SetSoundSwitch) == 0x000008, "Wrong alignment on DCAkComponent_SetSoundSwitch");
static_assert(sizeof(DCAkComponent_SetSoundSwitch) == 0x000030, "Wrong size on DCAkComponent_SetSoundSwitch");
static_assert(offsetof(DCAkComponent_SetSoundSwitch, Tag) == 0x000000, "Member 'DCAkComponent_SetSoundSwitch::Tag' has a wrong offset!");
static_assert(offsetof(DCAkComponent_SetSoundSwitch, SurfaceType) == 0x000008, "Member 'DCAkComponent_SetSoundSwitch::SurfaceType' has a wrong offset!");
static_assert(offsetof(DCAkComponent_SetSoundSwitch, SwitchGroup) == 0x000010, "Member 'DCAkComponent_SetSoundSwitch::SwitchGroup' has a wrong offset!");
static_assert(offsetof(DCAkComponent_SetSoundSwitch, SwitchState) == 0x000020, "Member 'DCAkComponent_SetSoundSwitch::SwitchState' has a wrong offset!");

// Function DungeonCrawler.DCAkComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCAkComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAkComponent_UnbindMsg) == 0x000008, "Wrong alignment on DCAkComponent_UnbindMsg");
static_assert(sizeof(DCAkComponent_UnbindMsg) == 0x000010, "Wrong size on DCAkComponent_UnbindMsg");
static_assert(offsetof(DCAkComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'DCAkComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCAkComponent_UnbindMsg, InObject) == 0x000008, "Member 'DCAkComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAkComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCAkComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAkComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on DCAkComponent_UnbindMsgAll");
static_assert(sizeof(DCAkComponent_UnbindMsgAll) == 0x000008, "Wrong size on DCAkComponent_UnbindMsgAll");
static_assert(offsetof(DCAkComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'DCAkComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.ChatFilterWidget.OnAddChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct ChatFilterWidget_OnAddChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatFilterWidget_OnAddChatFilterTag) == 0x000004, "Wrong alignment on ChatFilterWidget_OnAddChatFilterTag");
static_assert(sizeof(ChatFilterWidget_OnAddChatFilterTag) == 0x000008, "Wrong size on ChatFilterWidget_OnAddChatFilterTag");
static_assert(offsetof(ChatFilterWidget_OnAddChatFilterTag, InChatFilterTag) == 0x000000, "Member 'ChatFilterWidget_OnAddChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.ChatFilterWidget.OnAnyChatFilterTagSet
// 0x0001 (0x0001 - 0x0000)
struct ChatFilterWidget_OnAnyChatFilterTagSet final
{
public:
	bool                                          bInSet;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatFilterWidget_OnAnyChatFilterTagSet) == 0x000001, "Wrong alignment on ChatFilterWidget_OnAnyChatFilterTagSet");
static_assert(sizeof(ChatFilterWidget_OnAnyChatFilterTagSet) == 0x000001, "Wrong size on ChatFilterWidget_OnAnyChatFilterTagSet");
static_assert(offsetof(ChatFilterWidget_OnAnyChatFilterTagSet, bInSet) == 0x000000, "Member 'ChatFilterWidget_OnAnyChatFilterTagSet::bInSet' has a wrong offset!");

// Function DungeonCrawler.ChatFilterWidget.OnRemoveChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct ChatFilterWidget_OnRemoveChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatFilterWidget_OnRemoveChatFilterTag) == 0x000004, "Wrong alignment on ChatFilterWidget_OnRemoveChatFilterTag");
static_assert(sizeof(ChatFilterWidget_OnRemoveChatFilterTag) == 0x000008, "Wrong size on ChatFilterWidget_OnRemoveChatFilterTag");
static_assert(offsetof(ChatFilterWidget_OnRemoveChatFilterTag, InChatFilterTag) == 0x000000, "Member 'ChatFilterWidget_OnRemoveChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.ChatFilterWidget.RegenerateListItems
// 0x0018 (0x0018 - 0x0000)
struct ChatFilterWidget_RegenerateListItems final
{
public:
	class FText                                   FindFilter;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatFilterWidget_RegenerateListItems) == 0x000008, "Wrong alignment on ChatFilterWidget_RegenerateListItems");
static_assert(sizeof(ChatFilterWidget_RegenerateListItems) == 0x000018, "Wrong size on ChatFilterWidget_RegenerateListItems");
static_assert(offsetof(ChatFilterWidget_RegenerateListItems, FindFilter) == 0x000000, "Member 'ChatFilterWidget_RegenerateListItems::FindFilter' has a wrong offset!");

// Function DungeonCrawler.ChatFilterWidget.SetChatFilterListVisible
// 0x0001 (0x0001 - 0x0000)
struct ChatFilterWidget_SetChatFilterListVisible final
{
public:
	bool                                          InbVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatFilterWidget_SetChatFilterListVisible) == 0x000001, "Wrong alignment on ChatFilterWidget_SetChatFilterListVisible");
static_assert(sizeof(ChatFilterWidget_SetChatFilterListVisible) == 0x000001, "Wrong size on ChatFilterWidget_SetChatFilterListVisible");
static_assert(offsetof(ChatFilterWidget_SetChatFilterListVisible, InbVisible) == 0x000000, "Member 'ChatFilterWidget_SetChatFilterListVisible::InbVisible' has a wrong offset!");

// Function DungeonCrawler.ChatSetWidgetBase.IsTimerStart
// 0x0001 (0x0001 - 0x0000)
struct ChatSetWidgetBase_IsTimerStart final
{
public:
	bool                                          bIsFocused;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatSetWidgetBase_IsTimerStart) == 0x000001, "Wrong alignment on ChatSetWidgetBase_IsTimerStart");
static_assert(sizeof(ChatSetWidgetBase_IsTimerStart) == 0x000001, "Wrong size on ChatSetWidgetBase_IsTimerStart");
static_assert(offsetof(ChatSetWidgetBase_IsTimerStart, bIsFocused) == 0x000000, "Member 'ChatSetWidgetBase_IsTimerStart::bIsFocused' has a wrong offset!");

// Function DungeonCrawler.ChatSetWidgetBase.OnChatAccountData
// 0x00C0 (0x00C0 - 0x0000)
struct ChatSetWidgetBase_OnChatAccountData final
{
public:
	struct FChatAccountData                       NewItemData;                                       // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FChatAccountData                       OldItemData;                                       // 0x0060(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatSetWidgetBase_OnChatAccountData) == 0x000008, "Wrong alignment on ChatSetWidgetBase_OnChatAccountData");
static_assert(sizeof(ChatSetWidgetBase_OnChatAccountData) == 0x0000C0, "Wrong size on ChatSetWidgetBase_OnChatAccountData");
static_assert(offsetof(ChatSetWidgetBase_OnChatAccountData, NewItemData) == 0x000000, "Member 'ChatSetWidgetBase_OnChatAccountData::NewItemData' has a wrong offset!");
static_assert(offsetof(ChatSetWidgetBase_OnChatAccountData, OldItemData) == 0x000060, "Member 'ChatSetWidgetBase_OnChatAccountData::OldItemData' has a wrong offset!");

// Function DungeonCrawler.ChatSetWidgetBase.OnChatDataChanged
// 0x0018 (0x0018 - 0x0000)
struct ChatSetWidgetBase_OnChatDataChanged final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatSetWidgetBase_OnChatDataChanged) == 0x000008, "Wrong alignment on ChatSetWidgetBase_OnChatDataChanged");
static_assert(sizeof(ChatSetWidgetBase_OnChatDataChanged) == 0x000018, "Wrong size on ChatSetWidgetBase_OnChatDataChanged");
static_assert(offsetof(ChatSetWidgetBase_OnChatDataChanged, InText) == 0x000000, "Member 'ChatSetWidgetBase_OnChatDataChanged::InText' has a wrong offset!");

// Function DungeonCrawler.ChatSetWidgetBase.OnChatDataCommitted
// 0x0088 (0x0088 - 0x0000)
struct ChatSetWidgetBase_OnChatDataCommitted final
{
public:
	struct FChatData                              InChatData;                                        // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0080(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244D[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ChatSetWidgetBase_OnChatDataCommitted) == 0x000008, "Wrong alignment on ChatSetWidgetBase_OnChatDataCommitted");
static_assert(sizeof(ChatSetWidgetBase_OnChatDataCommitted) == 0x000088, "Wrong size on ChatSetWidgetBase_OnChatDataCommitted");
static_assert(offsetof(ChatSetWidgetBase_OnChatDataCommitted, InChatData) == 0x000000, "Member 'ChatSetWidgetBase_OnChatDataCommitted::InChatData' has a wrong offset!");
static_assert(offsetof(ChatSetWidgetBase_OnChatDataCommitted, ReturnValue) == 0x000080, "Member 'ChatSetWidgetBase_OnChatDataCommitted::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ChatSetWidgetBase.OnChatEditFocus
// 0x0001 (0x0001 - 0x0000)
struct ChatSetWidgetBase_OnChatEditFocus final
{
public:
	bool                                          InbFocus;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatSetWidgetBase_OnChatEditFocus) == 0x000001, "Wrong alignment on ChatSetWidgetBase_OnChatEditFocus");
static_assert(sizeof(ChatSetWidgetBase_OnChatEditFocus) == 0x000001, "Wrong size on ChatSetWidgetBase_OnChatEditFocus");
static_assert(offsetof(ChatSetWidgetBase_OnChatEditFocus, InbFocus) == 0x000000, "Member 'ChatSetWidgetBase_OnChatEditFocus::InbFocus' has a wrong offset!");

// Function DungeonCrawler.ChatSetWidgetBase.OnChatType
// 0x0002 (0x0002 - 0x0000)
struct ChatSetWidgetBase_OnChatType final
{
public:
	EChatType                                     NewItemData;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChatType                                     OldItemData;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatSetWidgetBase_OnChatType) == 0x000001, "Wrong alignment on ChatSetWidgetBase_OnChatType");
static_assert(sizeof(ChatSetWidgetBase_OnChatType) == 0x000002, "Wrong size on ChatSetWidgetBase_OnChatType");
static_assert(offsetof(ChatSetWidgetBase_OnChatType, NewItemData) == 0x000000, "Member 'ChatSetWidgetBase_OnChatType::NewItemData' has a wrong offset!");
static_assert(offsetof(ChatSetWidgetBase_OnChatType, OldItemData) == 0x000001, "Member 'ChatSetWidgetBase_OnChatType::OldItemData' has a wrong offset!");

// Function DungeonCrawler.ChatSetWidgetBase.SetIsChatFocused
// 0x0001 (0x0001 - 0x0000)
struct ChatSetWidgetBase_SetIsChatFocused final
{
public:
	bool                                          bIsFocused;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatSetWidgetBase_SetIsChatFocused) == 0x000001, "Wrong alignment on ChatSetWidgetBase_SetIsChatFocused");
static_assert(sizeof(ChatSetWidgetBase_SetIsChatFocused) == 0x000001, "Wrong size on ChatSetWidgetBase_SetIsChatFocused");
static_assert(offsetof(ChatSetWidgetBase_SetIsChatFocused, bIsFocused) == 0x000000, "Member 'ChatSetWidgetBase_SetIsChatFocused::bIsFocused' has a wrong offset!");

// Function DungeonCrawler.ChatSetWidgetBase.SetTimerTime
// 0x0008 (0x0008 - 0x0000)
struct ChatSetWidgetBase_SetTimerTime final
{
public:
	bool                                          IsStart;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244E[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerTime;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatSetWidgetBase_SetTimerTime) == 0x000004, "Wrong alignment on ChatSetWidgetBase_SetTimerTime");
static_assert(sizeof(ChatSetWidgetBase_SetTimerTime) == 0x000008, "Wrong size on ChatSetWidgetBase_SetTimerTime");
static_assert(offsetof(ChatSetWidgetBase_SetTimerTime, IsStart) == 0x000000, "Member 'ChatSetWidgetBase_SetTimerTime::IsStart' has a wrong offset!");
static_assert(offsetof(ChatSetWidgetBase_SetTimerTime, TimerTime) == 0x000004, "Member 'ChatSetWidgetBase_SetTimerTime::TimerTime' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.CreateCameraPostProcess
// 0x0030 (0x0030 - 0x0000)
struct DCPostProcessingComponent_CreateCameraPostProcess final
{
public:
	class UMaterialInstance*                      InMaterial;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            InCurve;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           InParameterNames;                                  // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   InMaterialName;                                    // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPostProcessingComponent_CreateCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_CreateCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_CreateCameraPostProcess) == 0x000030, "Wrong size on DCPostProcessingComponent_CreateCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_CreateCameraPostProcess, InMaterial) == 0x000000, "Member 'DCPostProcessingComponent_CreateCameraPostProcess::InMaterial' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_CreateCameraPostProcess, InCurve) == 0x000008, "Member 'DCPostProcessingComponent_CreateCameraPostProcess::InCurve' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_CreateCameraPostProcess, InParameterNames) == 0x000010, "Member 'DCPostProcessingComponent_CreateCameraPostProcess::InParameterNames' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_CreateCameraPostProcess, InMaterialName) == 0x000020, "Member 'DCPostProcessingComponent_CreateCameraPostProcess::InMaterialName' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_CreateCameraPostProcess, ReturnValue) == 0x000028, "Member 'DCPostProcessingComponent_CreateCameraPostProcess::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.FindCameraPostProcessMID
// 0x0010 (0x0010 - 0x0000)
struct DCPostProcessingComponent_FindCameraPostProcessMID final
{
public:
	class FName                                   InMaterialName;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPostProcessingComponent_FindCameraPostProcessMID) == 0x000008, "Wrong alignment on DCPostProcessingComponent_FindCameraPostProcessMID");
static_assert(sizeof(DCPostProcessingComponent_FindCameraPostProcessMID) == 0x000010, "Wrong size on DCPostProcessingComponent_FindCameraPostProcessMID");
static_assert(offsetof(DCPostProcessingComponent_FindCameraPostProcessMID, InMaterialName) == 0x000000, "Member 'DCPostProcessingComponent_FindCameraPostProcessMID::InMaterialName' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_FindCameraPostProcessMID, ReturnValue) == 0x000008, "Member 'DCPostProcessingComponent_FindCameraPostProcessMID::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.IsCameraPostProcess
// 0x0010 (0x0010 - 0x0000)
struct DCPostProcessingComponent_IsCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244F[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPostProcessingComponent_IsCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_IsCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_IsCameraPostProcess) == 0x000010, "Wrong size on DCPostProcessingComponent_IsCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_IsCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_IsCameraPostProcess::InMIDKey' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_IsCameraPostProcess, ReturnValue) == 0x000008, "Member 'DCPostProcessingComponent_IsCameraPostProcess::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.OnCameraPostProcessDataTimelineFinished
// 0x0010 (0x0010 - 0x0000)
struct DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETimelineDirection                            InTimelineDirection;                               // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2450[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished) == 0x000008, "Wrong alignment on DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished");
static_assert(sizeof(DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished) == 0x000010, "Wrong size on DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished");
static_assert(offsetof(DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished, DeltaTime) == 0x000000, "Member 'DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished::DeltaTime' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished, InTimelineDirection) == 0x000004, "Member 'DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished::InTimelineDirection' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished, InMIDKey) == 0x000008, "Member 'DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished::InMIDKey' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.OnCameraPostProcessDataTimelineUpdate
// 0x0010 (0x0010 - 0x0000)
struct DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETimelineDirection                            InTimelineDirection;                               // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2451[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate) == 0x000008, "Wrong alignment on DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate");
static_assert(sizeof(DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate) == 0x000010, "Wrong size on DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate");
static_assert(offsetof(DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate, DeltaTime) == 0x000000, "Member 'DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate::DeltaTime' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate, InTimelineDirection) == 0x000004, "Member 'DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate::InTimelineDirection' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate, InMIDKey) == 0x000008, "Member 'DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate::InMIDKey' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.PlayCameraPostProcess
// 0x0008 (0x0008 - 0x0000)
struct DCPostProcessingComponent_PlayCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPostProcessingComponent_PlayCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_PlayCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_PlayCameraPostProcess) == 0x000008, "Wrong size on DCPostProcessingComponent_PlayCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_PlayCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_PlayCameraPostProcess::InMIDKey' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.PlayFromStartCameraPostProcess
// 0x0008 (0x0008 - 0x0000)
struct DCPostProcessingComponent_PlayFromStartCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPostProcessingComponent_PlayFromStartCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_PlayFromStartCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_PlayFromStartCameraPostProcess) == 0x000008, "Wrong size on DCPostProcessingComponent_PlayFromStartCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_PlayFromStartCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_PlayFromStartCameraPostProcess::InMIDKey' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.RemoveCameraPostProcess
// 0x0010 (0x0010 - 0x0000)
struct DCPostProcessingComponent_RemoveCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InMaterialName;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPostProcessingComponent_RemoveCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_RemoveCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_RemoveCameraPostProcess) == 0x000010, "Wrong size on DCPostProcessingComponent_RemoveCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_RemoveCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_RemoveCameraPostProcess::InMIDKey' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_RemoveCameraPostProcess, InMaterialName) == 0x000008, "Member 'DCPostProcessingComponent_RemoveCameraPostProcess::InMaterialName' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.ReverseFromEndPlayCameraPostProcess
// 0x0008 (0x0008 - 0x0000)
struct DCPostProcessingComponent_ReverseFromEndPlayCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPostProcessingComponent_ReverseFromEndPlayCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_ReverseFromEndPlayCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_ReverseFromEndPlayCameraPostProcess) == 0x000008, "Wrong size on DCPostProcessingComponent_ReverseFromEndPlayCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_ReverseFromEndPlayCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_ReverseFromEndPlayCameraPostProcess::InMIDKey' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.ReversePlayCameraPostProcess
// 0x0008 (0x0008 - 0x0000)
struct DCPostProcessingComponent_ReversePlayCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPostProcessingComponent_ReversePlayCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_ReversePlayCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_ReversePlayCameraPostProcess) == 0x000008, "Wrong size on DCPostProcessingComponent_ReversePlayCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_ReversePlayCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_ReversePlayCameraPostProcess::InMIDKey' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.SetCameraPostProcess
// 0x0028 (0x0028 - 0x0000)
struct DCPostProcessingComponent_SetCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            InCurve;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           InParameterNames;                                  // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2452[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPostProcessingComponent_SetCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_SetCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_SetCameraPostProcess) == 0x000028, "Wrong size on DCPostProcessingComponent_SetCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_SetCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_SetCameraPostProcess::InMIDKey' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_SetCameraPostProcess, InCurve) == 0x000008, "Member 'DCPostProcessingComponent_SetCameraPostProcess::InCurve' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_SetCameraPostProcess, InParameterNames) == 0x000010, "Member 'DCPostProcessingComponent_SetCameraPostProcess::InParameterNames' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_SetCameraPostProcess, ReturnValue) == 0x000020, "Member 'DCPostProcessingComponent_SetCameraPostProcess::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.SetPlayPositionCameraPostProcess
// 0x0010 (0x0010 - 0x0000)
struct DCPostProcessingComponent_SetPlayPositionCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewTime;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireEvents;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireUpdate;                                       // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2453[0x2];                                     // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPostProcessingComponent_SetPlayPositionCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_SetPlayPositionCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_SetPlayPositionCameraPostProcess) == 0x000010, "Wrong size on DCPostProcessingComponent_SetPlayPositionCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_SetPlayPositionCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_SetPlayPositionCameraPostProcess::InMIDKey' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_SetPlayPositionCameraPostProcess, NewTime) == 0x000008, "Member 'DCPostProcessingComponent_SetPlayPositionCameraPostProcess::NewTime' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_SetPlayPositionCameraPostProcess, bFireEvents) == 0x00000C, "Member 'DCPostProcessingComponent_SetPlayPositionCameraPostProcess::bFireEvents' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_SetPlayPositionCameraPostProcess, bFireUpdate) == 0x00000D, "Member 'DCPostProcessingComponent_SetPlayPositionCameraPostProcess::bFireUpdate' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.SetPlayRateCameraPostProcess
// 0x0010 (0x0010 - 0x0000)
struct DCPostProcessingComponent_SetPlayRateCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewRate;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2454[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPostProcessingComponent_SetPlayRateCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_SetPlayRateCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_SetPlayRateCameraPostProcess) == 0x000010, "Wrong size on DCPostProcessingComponent_SetPlayRateCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_SetPlayRateCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_SetPlayRateCameraPostProcess::InMIDKey' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_SetPlayRateCameraPostProcess, NewRate) == 0x000008, "Member 'DCPostProcessingComponent_SetPlayRateCameraPostProcess::NewRate' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.SetTimeCameraPostProcess
// 0x0010 (0x0010 - 0x0000)
struct DCPostProcessingComponent_SetTimeCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewTime;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2455[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPostProcessingComponent_SetTimeCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_SetTimeCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_SetTimeCameraPostProcess) == 0x000010, "Wrong size on DCPostProcessingComponent_SetTimeCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_SetTimeCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_SetTimeCameraPostProcess::InMIDKey' has a wrong offset!");
static_assert(offsetof(DCPostProcessingComponent_SetTimeCameraPostProcess, NewTime) == 0x000008, "Member 'DCPostProcessingComponent_SetTimeCameraPostProcess::NewTime' has a wrong offset!");

// Function DungeonCrawler.DCPostProcessingComponent.StopCameraPostProcess
// 0x0008 (0x0008 - 0x0000)
struct DCPostProcessingComponent_StopCameraPostProcess final
{
public:
	class UMaterialInstanceDynamic*               InMIDKey;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPostProcessingComponent_StopCameraPostProcess) == 0x000008, "Wrong alignment on DCPostProcessingComponent_StopCameraPostProcess");
static_assert(sizeof(DCPostProcessingComponent_StopCameraPostProcess) == 0x000008, "Wrong size on DCPostProcessingComponent_StopCameraPostProcess");
static_assert(offsetof(DCPostProcessingComponent_StopCameraPostProcess, InMIDKey) == 0x000000, "Member 'DCPostProcessingComponent_StopCameraPostProcess::InMIDKey' has a wrong offset!");

// Function DungeonCrawler.CreateAccountNicknamePopup.OnTextChangedAccountNickname
// 0x0018 (0x0018 - 0x0000)
struct CreateAccountNicknamePopup_OnTextChangedAccountNickname final
{
public:
	class FText                                   InAccountNickname;                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CreateAccountNicknamePopup_OnTextChangedAccountNickname) == 0x000008, "Wrong alignment on CreateAccountNicknamePopup_OnTextChangedAccountNickname");
static_assert(sizeof(CreateAccountNicknamePopup_OnTextChangedAccountNickname) == 0x000018, "Wrong size on CreateAccountNicknamePopup_OnTextChangedAccountNickname");
static_assert(offsetof(CreateAccountNicknamePopup_OnTextChangedAccountNickname, InAccountNickname) == 0x000000, "Member 'CreateAccountNicknamePopup_OnTextChangedAccountNickname::InAccountNickname' has a wrong offset!");

// Function DungeonCrawler.ChatWidgetBase.ChangeDateTimeAsText
// 0x0020 (0x0020 - 0x0000)
struct ChatWidgetBase_ChangeDateTimeAsText final
{
public:
	struct FDateTime                              DateTime;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatWidgetBase_ChangeDateTimeAsText) == 0x000008, "Wrong alignment on ChatWidgetBase_ChangeDateTimeAsText");
static_assert(sizeof(ChatWidgetBase_ChangeDateTimeAsText) == 0x000020, "Wrong size on ChatWidgetBase_ChangeDateTimeAsText");
static_assert(offsetof(ChatWidgetBase_ChangeDateTimeAsText, DateTime) == 0x000000, "Member 'ChatWidgetBase_ChangeDateTimeAsText::DateTime' has a wrong offset!");
static_assert(offsetof(ChatWidgetBase_ChangeDateTimeAsText, ReturnValue) == 0x000008, "Member 'ChatWidgetBase_ChangeDateTimeAsText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ChatWidgetBase.FilterStreamingMode
// 0x0020 (0x0020 - 0x0000)
struct ChatWidgetBase_FilterStreamingMode final
{
public:
	class FString                                 OriginalStr;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatWidgetBase_FilterStreamingMode) == 0x000008, "Wrong alignment on ChatWidgetBase_FilterStreamingMode");
static_assert(sizeof(ChatWidgetBase_FilterStreamingMode) == 0x000020, "Wrong size on ChatWidgetBase_FilterStreamingMode");
static_assert(offsetof(ChatWidgetBase_FilterStreamingMode, OriginalStr) == 0x000000, "Member 'ChatWidgetBase_FilterStreamingMode::OriginalStr' has a wrong offset!");
static_assert(offsetof(ChatWidgetBase_FilterStreamingMode, ReturnValue) == 0x000010, "Member 'ChatWidgetBase_FilterStreamingMode::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ChatWidgetBase.OnChatRecordData
// 0x0120 (0x0120 - 0x0000)
struct ChatWidgetBase_OnChatRecordData final
{
public:
	struct FChatRecord                            NewValue;                                          // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FChatRecord                            OldValue;                                          // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChatWidgetBase_OnChatRecordData) == 0x000008, "Wrong alignment on ChatWidgetBase_OnChatRecordData");
static_assert(sizeof(ChatWidgetBase_OnChatRecordData) == 0x000120, "Wrong size on ChatWidgetBase_OnChatRecordData");
static_assert(offsetof(ChatWidgetBase_OnChatRecordData, NewValue) == 0x000000, "Member 'ChatWidgetBase_OnChatRecordData::NewValue' has a wrong offset!");
static_assert(offsetof(ChatWidgetBase_OnChatRecordData, OldValue) == 0x000090, "Member 'ChatWidgetBase_OnChatRecordData::OldValue' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_RangedAttackBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_RangedAttackBase_AbilityActivated");
static_assert(sizeof(GA_RangedAttackBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_RangedAttackBase_AbilityActivated");
static_assert(offsetof(GA_RangedAttackBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_RangedAttackBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.ActivateCrossHairPullAnimation
// 0x0008 (0x0008 - 0x0000)
struct GA_RangedAttackBase_ActivateCrossHairPullAnimation final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_ActivateCrossHairPullAnimation) == 0x000008, "Wrong alignment on GA_RangedAttackBase_ActivateCrossHairPullAnimation");
static_assert(sizeof(GA_RangedAttackBase_ActivateCrossHairPullAnimation) == 0x000008, "Wrong size on GA_RangedAttackBase_ActivateCrossHairPullAnimation");
static_assert(offsetof(GA_RangedAttackBase_ActivateCrossHairPullAnimation, PlayerController) == 0x000000, "Member 'GA_RangedAttackBase_ActivateCrossHairPullAnimation::PlayerController' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.CreatedProjectile
// 0x00F8 (0x00F8 - 0x0000)
struct GA_RangedAttackBase_CreatedProjectile final
{
public:
	class AProjectileActor*                       Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x00E8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x00F0(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_CreatedProjectile) == 0x000008, "Wrong alignment on GA_RangedAttackBase_CreatedProjectile");
static_assert(sizeof(GA_RangedAttackBase_CreatedProjectile) == 0x0000F8, "Wrong size on GA_RangedAttackBase_CreatedProjectile");
static_assert(offsetof(GA_RangedAttackBase_CreatedProjectile, Projectile) == 0x000000, "Member 'GA_RangedAttackBase_CreatedProjectile::Projectile' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_CreatedProjectile, HitResult) == 0x000008, "Member 'GA_RangedAttackBase_CreatedProjectile::HitResult' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_CreatedProjectile, EventTag) == 0x0000F0, "Member 'GA_RangedAttackBase_CreatedProjectile::EventTag' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.CreateProjectiles
// 0x00D8 (0x00D8 - 0x0000)
struct GA_RangedAttackBase_CreateProjectiles final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
	float                                         FirePower;                                         // 0x00B8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245E[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                StartLocation;                                     // 0x00C0(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_CreateProjectiles) == 0x000008, "Wrong alignment on GA_RangedAttackBase_CreateProjectiles");
static_assert(sizeof(GA_RangedAttackBase_CreateProjectiles) == 0x0000D8, "Wrong size on GA_RangedAttackBase_CreateProjectiles");
static_assert(offsetof(GA_RangedAttackBase_CreateProjectiles, EventTag) == 0x000000, "Member 'GA_RangedAttackBase_CreateProjectiles::EventTag' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_CreateProjectiles, EventData) == 0x000008, "Member 'GA_RangedAttackBase_CreateProjectiles::EventData' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_CreateProjectiles, FirePower) == 0x0000B8, "Member 'GA_RangedAttackBase_CreateProjectiles::FirePower' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_CreateProjectiles, StartLocation) == 0x0000C0, "Member 'GA_RangedAttackBase_CreateProjectiles::StartLocation' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_RangedAttackBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_EventReceived) == 0x000008, "Wrong alignment on GA_RangedAttackBase_EventReceived");
static_assert(sizeof(GA_RangedAttackBase_EventReceived) == 0x0000B8, "Wrong size on GA_RangedAttackBase_EventReceived");
static_assert(offsetof(GA_RangedAttackBase_EventReceived, EventTag) == 0x000000, "Member 'GA_RangedAttackBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_EventReceived, EventData) == 0x000008, "Member 'GA_RangedAttackBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.FireProjectile
// 0x00C0 (0x00C0 - 0x0000)
struct GA_RangedAttackBase_FireProjectile final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
	float                                         FirePower;                                         // 0x00B8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245F[0x4];                                     // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_RangedAttackBase_FireProjectile) == 0x000008, "Wrong alignment on GA_RangedAttackBase_FireProjectile");
static_assert(sizeof(GA_RangedAttackBase_FireProjectile) == 0x0000C0, "Wrong size on GA_RangedAttackBase_FireProjectile");
static_assert(offsetof(GA_RangedAttackBase_FireProjectile, EventTag) == 0x000000, "Member 'GA_RangedAttackBase_FireProjectile::EventTag' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_FireProjectile, EventData) == 0x000008, "Member 'GA_RangedAttackBase_FireProjectile::EventData' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_FireProjectile, FirePower) == 0x0000B8, "Member 'GA_RangedAttackBase_FireProjectile::FirePower' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.FireSocketSightBlocked
// 0x0028 (0x0028 - 0x0000)
struct GA_RangedAttackBase_FireSocketSightBlocked final
{
public:
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_FireSocketSightBlocked) == 0x000008, "Wrong alignment on GA_RangedAttackBase_FireSocketSightBlocked");
static_assert(sizeof(GA_RangedAttackBase_FireSocketSightBlocked) == 0x000028, "Wrong size on GA_RangedAttackBase_FireSocketSightBlocked");
static_assert(offsetof(GA_RangedAttackBase_FireSocketSightBlocked, InData) == 0x000000, "Member 'GA_RangedAttackBase_FireSocketSightBlocked::InData' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.FireSocketSightUnblocked
// 0x0028 (0x0028 - 0x0000)
struct GA_RangedAttackBase_FireSocketSightUnblocked final
{
public:
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_FireSocketSightUnblocked) == 0x000008, "Wrong alignment on GA_RangedAttackBase_FireSocketSightUnblocked");
static_assert(sizeof(GA_RangedAttackBase_FireSocketSightUnblocked) == 0x000028, "Wrong size on GA_RangedAttackBase_FireSocketSightUnblocked");
static_assert(offsetof(GA_RangedAttackBase_FireSocketSightUnblocked, InData) == 0x000000, "Member 'GA_RangedAttackBase_FireSocketSightUnblocked::InData' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.MultiFireProjectiles
// 0x00C0 (0x00C0 - 0x0000)
struct GA_RangedAttackBase_MultiFireProjectiles final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
	float                                         FirePower;                                         // 0x00B8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2460[0x4];                                     // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_RangedAttackBase_MultiFireProjectiles) == 0x000008, "Wrong alignment on GA_RangedAttackBase_MultiFireProjectiles");
static_assert(sizeof(GA_RangedAttackBase_MultiFireProjectiles) == 0x0000C0, "Wrong size on GA_RangedAttackBase_MultiFireProjectiles");
static_assert(offsetof(GA_RangedAttackBase_MultiFireProjectiles, EventTag) == 0x000000, "Member 'GA_RangedAttackBase_MultiFireProjectiles::EventTag' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_MultiFireProjectiles, EventData) == 0x000008, "Member 'GA_RangedAttackBase_MultiFireProjectiles::EventData' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_MultiFireProjectiles, FirePower) == 0x0000B8, "Member 'GA_RangedAttackBase_MultiFireProjectiles::FirePower' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_RangedAttackBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_OnCancelled) == 0x000008, "Wrong alignment on GA_RangedAttackBase_OnCancelled");
static_assert(sizeof(GA_RangedAttackBase_OnCancelled) == 0x0000B8, "Wrong size on GA_RangedAttackBase_OnCancelled");
static_assert(offsetof(GA_RangedAttackBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_RangedAttackBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_OnCancelled, EventData) == 0x000008, "Member 'GA_RangedAttackBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_RangedAttackBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_OnCompleted) == 0x000008, "Wrong alignment on GA_RangedAttackBase_OnCompleted");
static_assert(sizeof(GA_RangedAttackBase_OnCompleted) == 0x0000B8, "Wrong size on GA_RangedAttackBase_OnCompleted");
static_assert(offsetof(GA_RangedAttackBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_RangedAttackBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_OnCompleted, EventData) == 0x000008, "Member 'GA_RangedAttackBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_RangedAttackBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_RangedAttackBase_ReceivedEvent");
static_assert(sizeof(GA_RangedAttackBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_RangedAttackBase_ReceivedEvent");
static_assert(offsetof(GA_RangedAttackBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_RangedAttackBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_RangedAttackBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_RangedAttackBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.UpdatedRangedWeaponCrosshairs
// 0x0008 (0x0008 - 0x0000)
struct GA_RangedAttackBase_UpdatedRangedWeaponCrosshairs final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_UpdatedRangedWeaponCrosshairs) == 0x000008, "Wrong alignment on GA_RangedAttackBase_UpdatedRangedWeaponCrosshairs");
static_assert(sizeof(GA_RangedAttackBase_UpdatedRangedWeaponCrosshairs) == 0x000008, "Wrong size on GA_RangedAttackBase_UpdatedRangedWeaponCrosshairs");
static_assert(offsetof(GA_RangedAttackBase_UpdatedRangedWeaponCrosshairs, PlayerController) == 0x000000, "Member 'GA_RangedAttackBase_UpdatedRangedWeaponCrosshairs::PlayerController' has a wrong offset!");

// Function DungeonCrawler.GA_RangedAttackBase.GetProjectileActorClass
// 0x0008 (0x0008 - 0x0000)
struct GA_RangedAttackBase_GetProjectileActorClass final
{
public:
	TSubclassOf<class AProjectileActor>           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_RangedAttackBase_GetProjectileActorClass) == 0x000008, "Wrong alignment on GA_RangedAttackBase_GetProjectileActorClass");
static_assert(sizeof(GA_RangedAttackBase_GetProjectileActorClass) == 0x000008, "Wrong size on GA_RangedAttackBase_GetProjectileActorClass");
static_assert(offsetof(GA_RangedAttackBase_GetProjectileActorClass, ReturnValue) == 0x000000, "Member 'GA_RangedAttackBase_GetProjectileActorClass::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDrawbridge.InteractFailedWheel
// 0x0008 (0x0008 - 0x0000)
struct DCDrawbridge_InteractFailedWheel final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDrawbridge_InteractFailedWheel) == 0x000008, "Wrong alignment on DCDrawbridge_InteractFailedWheel");
static_assert(sizeof(DCDrawbridge_InteractFailedWheel) == 0x000008, "Wrong size on DCDrawbridge_InteractFailedWheel");
static_assert(offsetof(DCDrawbridge_InteractFailedWheel, Interacter) == 0x000000, "Member 'DCDrawbridge_InteractFailedWheel::Interacter' has a wrong offset!");

// Function DungeonCrawler.DCDrawbridge.InteractPlaybackWheel
// 0x0008 (0x0008 - 0x0000)
struct DCDrawbridge_InteractPlaybackWheel final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDrawbridge_InteractPlaybackWheel) == 0x000008, "Wrong alignment on DCDrawbridge_InteractPlaybackWheel");
static_assert(sizeof(DCDrawbridge_InteractPlaybackWheel) == 0x000008, "Wrong size on DCDrawbridge_InteractPlaybackWheel");
static_assert(offsetof(DCDrawbridge_InteractPlaybackWheel, Interacter) == 0x000000, "Member 'DCDrawbridge_InteractPlaybackWheel::Interacter' has a wrong offset!");

// Function DungeonCrawler.DCDrawbridge.InteractRewindWheel
// 0x0008 (0x0008 - 0x0000)
struct DCDrawbridge_InteractRewindWheel final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDrawbridge_InteractRewindWheel) == 0x000008, "Wrong alignment on DCDrawbridge_InteractRewindWheel");
static_assert(sizeof(DCDrawbridge_InteractRewindWheel) == 0x000008, "Wrong size on DCDrawbridge_InteractRewindWheel");
static_assert(offsetof(DCDrawbridge_InteractRewindWheel, Interacter) == 0x000000, "Member 'DCDrawbridge_InteractRewindWheel::Interacter' has a wrong offset!");

// Function DungeonCrawler.DCDrawbridge.SetPlaybackWheel
// 0x0008 (0x0008 - 0x0000)
struct DCDrawbridge_SetPlaybackWheel final
{
public:
	class APropsActorBase*                        InChildActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDrawbridge_SetPlaybackWheel) == 0x000008, "Wrong alignment on DCDrawbridge_SetPlaybackWheel");
static_assert(sizeof(DCDrawbridge_SetPlaybackWheel) == 0x000008, "Wrong size on DCDrawbridge_SetPlaybackWheel");
static_assert(offsetof(DCDrawbridge_SetPlaybackWheel, InChildActor) == 0x000000, "Member 'DCDrawbridge_SetPlaybackWheel::InChildActor' has a wrong offset!");

// Function DungeonCrawler.DCDrawbridge.SetRewindWheel
// 0x0008 (0x0008 - 0x0000)
struct DCDrawbridge_SetRewindWheel final
{
public:
	class APropsActorBase*                        InChildActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDrawbridge_SetRewindWheel) == 0x000008, "Wrong alignment on DCDrawbridge_SetRewindWheel");
static_assert(sizeof(DCDrawbridge_SetRewindWheel) == 0x000008, "Wrong size on DCDrawbridge_SetRewindWheel");
static_assert(offsetof(DCDrawbridge_SetRewindWheel, InChildActor) == 0x000000, "Member 'DCDrawbridge_SetRewindWheel::InChildActor' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_MeleeAttackBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_AbilityActivated");
static_assert(sizeof(GA_MeleeAttackBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_MeleeAttackBase_AbilityActivated");
static_assert(offsetof(GA_MeleeAttackBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_MeleeAttackBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.ClientReceivedTargetData
// 0x0038 (0x0038 - 0x0000)
struct GA_MeleeAttackBase_ClientReceivedTargetData final
{
public:
	struct FGameplayTag                           InEffectTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InChannelTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_ClientReceivedTargetData) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_ClientReceivedTargetData");
static_assert(sizeof(GA_MeleeAttackBase_ClientReceivedTargetData) == 0x000038, "Wrong size on GA_MeleeAttackBase_ClientReceivedTargetData");
static_assert(offsetof(GA_MeleeAttackBase_ClientReceivedTargetData, InEffectTag) == 0x000000, "Member 'GA_MeleeAttackBase_ClientReceivedTargetData::InEffectTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_ClientReceivedTargetData, InChannelTag) == 0x000008, "Member 'GA_MeleeAttackBase_ClientReceivedTargetData::InChannelTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_ClientReceivedTargetData, InData) == 0x000010, "Member 'GA_MeleeAttackBase_ClientReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.ClientTargetDataReceived
// 0x00C0 (0x00C0 - 0x0000)
struct GA_MeleeAttackBase_ClientTargetDataReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InChannelTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_ClientTargetDataReceived) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_ClientTargetDataReceived");
static_assert(sizeof(GA_MeleeAttackBase_ClientTargetDataReceived) == 0x0000C0, "Wrong size on GA_MeleeAttackBase_ClientTargetDataReceived");
static_assert(offsetof(GA_MeleeAttackBase_ClientTargetDataReceived, EventTag) == 0x000000, "Member 'GA_MeleeAttackBase_ClientTargetDataReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_ClientTargetDataReceived, InChannelTag) == 0x000008, "Member 'GA_MeleeAttackBase_ClientTargetDataReceived::InChannelTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_ClientTargetDataReceived, EventData) == 0x000010, "Member 'GA_MeleeAttackBase_ClientTargetDataReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_MeleeAttackBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_EventReceived) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_EventReceived");
static_assert(sizeof(GA_MeleeAttackBase_EventReceived) == 0x0000B8, "Wrong size on GA_MeleeAttackBase_EventReceived");
static_assert(offsetof(GA_MeleeAttackBase_EventReceived, EventTag) == 0x000000, "Member 'GA_MeleeAttackBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_EventReceived, EventData) == 0x000008, "Member 'GA_MeleeAttackBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.OnBlendOut
// 0x00B8 (0x00B8 - 0x0000)
struct GA_MeleeAttackBase_OnBlendOut final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_OnBlendOut) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_OnBlendOut");
static_assert(sizeof(GA_MeleeAttackBase_OnBlendOut) == 0x0000B8, "Wrong size on GA_MeleeAttackBase_OnBlendOut");
static_assert(offsetof(GA_MeleeAttackBase_OnBlendOut, EventTag) == 0x000000, "Member 'GA_MeleeAttackBase_OnBlendOut::EventTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_OnBlendOut, EventData) == 0x000008, "Member 'GA_MeleeAttackBase_OnBlendOut::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_MeleeAttackBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_OnCancelled) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_OnCancelled");
static_assert(sizeof(GA_MeleeAttackBase_OnCancelled) == 0x0000B8, "Wrong size on GA_MeleeAttackBase_OnCancelled");
static_assert(offsetof(GA_MeleeAttackBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_MeleeAttackBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_OnCancelled, EventData) == 0x000008, "Member 'GA_MeleeAttackBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_MeleeAttackBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_OnCompleted) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_OnCompleted");
static_assert(sizeof(GA_MeleeAttackBase_OnCompleted) == 0x0000B8, "Wrong size on GA_MeleeAttackBase_OnCompleted");
static_assert(offsetof(GA_MeleeAttackBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_MeleeAttackBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_OnCompleted, EventData) == 0x000008, "Member 'GA_MeleeAttackBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.OnInterrupted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_MeleeAttackBase_OnInterrupted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_OnInterrupted) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_OnInterrupted");
static_assert(sizeof(GA_MeleeAttackBase_OnInterrupted) == 0x0000B8, "Wrong size on GA_MeleeAttackBase_OnInterrupted");
static_assert(offsetof(GA_MeleeAttackBase_OnInterrupted, EventTag) == 0x000000, "Member 'GA_MeleeAttackBase_OnInterrupted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_OnInterrupted, EventData) == 0x000008, "Member 'GA_MeleeAttackBase_OnInterrupted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_MeleeAttackBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_ReceivedEvent");
static_assert(sizeof(GA_MeleeAttackBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_MeleeAttackBase_ReceivedEvent");
static_assert(offsetof(GA_MeleeAttackBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_MeleeAttackBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_MeleeAttackBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.ReceivedTargetData
// 0x0028 (0x0028 - 0x0000)
struct GA_MeleeAttackBase_ReceivedTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_ReceivedTargetData) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_ReceivedTargetData");
static_assert(sizeof(GA_MeleeAttackBase_ReceivedTargetData) == 0x000028, "Wrong size on GA_MeleeAttackBase_ReceivedTargetData");
static_assert(offsetof(GA_MeleeAttackBase_ReceivedTargetData, InData) == 0x000000, "Member 'GA_MeleeAttackBase_ReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.ServerTargetDataReceived
// 0x00C0 (0x00C0 - 0x0000)
struct GA_MeleeAttackBase_ServerTargetDataReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InChannelTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_ServerTargetDataReceived) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_ServerTargetDataReceived");
static_assert(sizeof(GA_MeleeAttackBase_ServerTargetDataReceived) == 0x0000C0, "Wrong size on GA_MeleeAttackBase_ServerTargetDataReceived");
static_assert(offsetof(GA_MeleeAttackBase_ServerTargetDataReceived, EventTag) == 0x000000, "Member 'GA_MeleeAttackBase_ServerTargetDataReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_ServerTargetDataReceived, InChannelTag) == 0x000008, "Member 'GA_MeleeAttackBase_ServerTargetDataReceived::InChannelTag' has a wrong offset!");
static_assert(offsetof(GA_MeleeAttackBase_ServerTargetDataReceived, EventData) == 0x000010, "Member 'GA_MeleeAttackBase_ServerTargetDataReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_MeleeAttackBase.GetMeleeAttackData
// 0x0008 (0x0008 - 0x0000)
struct GA_MeleeAttackBase_GetMeleeAttackData final
{
public:
	const class UDesignDataAssetMeleeAttack*      ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MeleeAttackBase_GetMeleeAttackData) == 0x000008, "Wrong alignment on GA_MeleeAttackBase_GetMeleeAttackData");
static_assert(sizeof(GA_MeleeAttackBase_GetMeleeAttackData) == 0x000008, "Wrong size on GA_MeleeAttackBase_GetMeleeAttackData");
static_assert(offsetof(GA_MeleeAttackBase_GetMeleeAttackData, ReturnValue) == 0x000000, "Member 'GA_MeleeAttackBase_GetMeleeAttackData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnBlockUserSlotData
// 0x0020 (0x0020 - 0x0000)
struct InvitePartyWidget_OnBlockUserSlotData final
{
public:
	struct FBlockUserSlotData                     NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FBlockUserSlotData                     OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnBlockUserSlotData) == 0x000008, "Wrong alignment on InvitePartyWidget_OnBlockUserSlotData");
static_assert(sizeof(InvitePartyWidget_OnBlockUserSlotData) == 0x000020, "Wrong size on InvitePartyWidget_OnBlockUserSlotData");
static_assert(offsetof(InvitePartyWidget_OnBlockUserSlotData, NewValue) == 0x000000, "Member 'InvitePartyWidget_OnBlockUserSlotData::NewValue' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnBlockUserSlotData, OldValue) == 0x000010, "Member 'InvitePartyWidget_OnBlockUserSlotData::OldValue' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnFriendLocateNumber
// 0x0010 (0x0010 - 0x0000)
struct InvitePartyWidget_OnFriendLocateNumber final
{
public:
	int32                                         LobbyCount;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DungeonCount;                                      // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfflineCount;                                      // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockCount;                                        // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnFriendLocateNumber) == 0x000004, "Wrong alignment on InvitePartyWidget_OnFriendLocateNumber");
static_assert(sizeof(InvitePartyWidget_OnFriendLocateNumber) == 0x000010, "Wrong size on InvitePartyWidget_OnFriendLocateNumber");
static_assert(offsetof(InvitePartyWidget_OnFriendLocateNumber, LobbyCount) == 0x000000, "Member 'InvitePartyWidget_OnFriendLocateNumber::LobbyCount' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnFriendLocateNumber, DungeonCount) == 0x000004, "Member 'InvitePartyWidget_OnFriendLocateNumber::DungeonCount' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnFriendLocateNumber, OfflineCount) == 0x000008, "Member 'InvitePartyWidget_OnFriendLocateNumber::OfflineCount' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnFriendLocateNumber, BlockCount) == 0x00000C, "Member 'InvitePartyWidget_OnFriendLocateNumber::BlockCount' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnFriendSlotData
// 0x0020 (0x0020 - 0x0000)
struct InvitePartyWidget_OnFriendSlotData final
{
public:
	struct FFriendSlotData                        NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FFriendSlotData                        OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnFriendSlotData) == 0x000008, "Wrong alignment on InvitePartyWidget_OnFriendSlotData");
static_assert(sizeof(InvitePartyWidget_OnFriendSlotData) == 0x000020, "Wrong size on InvitePartyWidget_OnFriendSlotData");
static_assert(offsetof(InvitePartyWidget_OnFriendSlotData, NewValue) == 0x000000, "Member 'InvitePartyWidget_OnFriendSlotData::NewValue' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnFriendSlotData, OldValue) == 0x000010, "Member 'InvitePartyWidget_OnFriendSlotData::OldValue' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnInvitePartyUserSlotData
// 0x0020 (0x0020 - 0x0000)
struct InvitePartyWidget_OnInvitePartyUserSlotData final
{
public:
	struct FInvitePartyUserSlotData               NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FInvitePartyUserSlotData               OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnInvitePartyUserSlotData) == 0x000008, "Wrong alignment on InvitePartyWidget_OnInvitePartyUserSlotData");
static_assert(sizeof(InvitePartyWidget_OnInvitePartyUserSlotData) == 0x000020, "Wrong size on InvitePartyWidget_OnInvitePartyUserSlotData");
static_assert(offsetof(InvitePartyWidget_OnInvitePartyUserSlotData, NewValue) == 0x000000, "Member 'InvitePartyWidget_OnInvitePartyUserSlotData::NewValue' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnInvitePartyUserSlotData, OldValue) == 0x000010, "Member 'InvitePartyWidget_OnInvitePartyUserSlotData::OldValue' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnPageNumber
// 0x0008 (0x0008 - 0x0000)
struct InvitePartyWidget_OnPageNumber final
{
public:
	int32                                         CurrentPage;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPage;                                           // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnPageNumber) == 0x000004, "Wrong alignment on InvitePartyWidget_OnPageNumber");
static_assert(sizeof(InvitePartyWidget_OnPageNumber) == 0x000008, "Wrong size on InvitePartyWidget_OnPageNumber");
static_assert(offsetof(InvitePartyWidget_OnPageNumber, CurrentPage) == 0x000000, "Member 'InvitePartyWidget_OnPageNumber::CurrentPage' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnPageNumber, MaxPage) == 0x000004, "Member 'InvitePartyWidget_OnPageNumber::MaxPage' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnPlayerLocateNumber
// 0x000C (0x000C - 0x0000)
struct InvitePartyWidget_OnPlayerLocateNumber final
{
public:
	int32                                         LobbyCount;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DungeonCount;                                      // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockCount;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnPlayerLocateNumber) == 0x000004, "Wrong alignment on InvitePartyWidget_OnPlayerLocateNumber");
static_assert(sizeof(InvitePartyWidget_OnPlayerLocateNumber) == 0x00000C, "Wrong size on InvitePartyWidget_OnPlayerLocateNumber");
static_assert(offsetof(InvitePartyWidget_OnPlayerLocateNumber, LobbyCount) == 0x000000, "Member 'InvitePartyWidget_OnPlayerLocateNumber::LobbyCount' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnPlayerLocateNumber, DungeonCount) == 0x000004, "Member 'InvitePartyWidget_OnPlayerLocateNumber::DungeonCount' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnPlayerLocateNumber, BlockCount) == 0x000008, "Member 'InvitePartyWidget_OnPlayerLocateNumber::BlockCount' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnPopupSWidgetFriendPartyInviteResult
// 0x00A0 (0x00A0 - 0x0000)
struct InvitePartyWidget_OnPopupSWidgetFriendPartyInviteResult final
{
public:
	EPopupResult                                  PopupResult;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2470[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCFriendInfo                          TargetUser;                                        // 0x0008(0x0098)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnPopupSWidgetFriendPartyInviteResult) == 0x000008, "Wrong alignment on InvitePartyWidget_OnPopupSWidgetFriendPartyInviteResult");
static_assert(sizeof(InvitePartyWidget_OnPopupSWidgetFriendPartyInviteResult) == 0x0000A0, "Wrong size on InvitePartyWidget_OnPopupSWidgetFriendPartyInviteResult");
static_assert(offsetof(InvitePartyWidget_OnPopupSWidgetFriendPartyInviteResult, PopupResult) == 0x000000, "Member 'InvitePartyWidget_OnPopupSWidgetFriendPartyInviteResult::PopupResult' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnPopupSWidgetFriendPartyInviteResult, TargetUser) == 0x000008, "Member 'InvitePartyWidget_OnPopupSWidgetFriendPartyInviteResult::TargetUser' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnPopupSWidgetPlayerPartyInviteResult
// 0x00A0 (0x00A0 - 0x0000)
struct InvitePartyWidget_OnPopupSWidgetPlayerPartyInviteResult final
{
public:
	EPopupResult                                  PopupResult;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2471[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInvitePartyUserSlot                   TargetUser;                                        // 0x0008(0x0098)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnPopupSWidgetPlayerPartyInviteResult) == 0x000008, "Wrong alignment on InvitePartyWidget_OnPopupSWidgetPlayerPartyInviteResult");
static_assert(sizeof(InvitePartyWidget_OnPopupSWidgetPlayerPartyInviteResult) == 0x0000A0, "Wrong size on InvitePartyWidget_OnPopupSWidgetPlayerPartyInviteResult");
static_assert(offsetof(InvitePartyWidget_OnPopupSWidgetPlayerPartyInviteResult, PopupResult) == 0x000000, "Member 'InvitePartyWidget_OnPopupSWidgetPlayerPartyInviteResult::PopupResult' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnPopupSWidgetPlayerPartyInviteResult, TargetUser) == 0x000008, "Member 'InvitePartyWidget_OnPopupSWidgetPlayerPartyInviteResult::TargetUser' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnReceivedInvitationSlotData
// 0x0020 (0x0020 - 0x0000)
struct InvitePartyWidget_OnReceivedInvitationSlotData final
{
public:
	struct FReceivedInvitationSlotData            NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FReceivedInvitationSlotData            OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnReceivedInvitationSlotData) == 0x000008, "Wrong alignment on InvitePartyWidget_OnReceivedInvitationSlotData");
static_assert(sizeof(InvitePartyWidget_OnReceivedInvitationSlotData) == 0x000020, "Wrong size on InvitePartyWidget_OnReceivedInvitationSlotData");
static_assert(offsetof(InvitePartyWidget_OnReceivedInvitationSlotData, NewValue) == 0x000000, "Member 'InvitePartyWidget_OnReceivedInvitationSlotData::NewValue' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnReceivedInvitationSlotData, OldValue) == 0x000010, "Member 'InvitePartyWidget_OnReceivedInvitationSlotData::OldValue' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnSentInvitationSlotData
// 0x0020 (0x0020 - 0x0000)
struct InvitePartyWidget_OnSentInvitationSlotData final
{
public:
	struct FSentInvitationSlotData                NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FSentInvitationSlotData                OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnSentInvitationSlotData) == 0x000008, "Wrong alignment on InvitePartyWidget_OnSentInvitationSlotData");
static_assert(sizeof(InvitePartyWidget_OnSentInvitationSlotData) == 0x000020, "Wrong size on InvitePartyWidget_OnSentInvitationSlotData");
static_assert(offsetof(InvitePartyWidget_OnSentInvitationSlotData, NewValue) == 0x000000, "Member 'InvitePartyWidget_OnSentInvitationSlotData::NewValue' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnSentInvitationSlotData, OldValue) == 0x000010, "Member 'InvitePartyWidget_OnSentInvitationSlotData::OldValue' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnTextChangedFindBlock
// 0x0020 (0x0020 - 0x0000)
struct InvitePartyWidget_OnTextChangedFindBlock final
{
public:
	class FText                                   AccountNickname;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2472[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InvitePartyWidget_OnTextChangedFindBlock) == 0x000008, "Wrong alignment on InvitePartyWidget_OnTextChangedFindBlock");
static_assert(sizeof(InvitePartyWidget_OnTextChangedFindBlock) == 0x000020, "Wrong size on InvitePartyWidget_OnTextChangedFindBlock");
static_assert(offsetof(InvitePartyWidget_OnTextChangedFindBlock, AccountNickname) == 0x000000, "Member 'InvitePartyWidget_OnTextChangedFindBlock::AccountNickname' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnTextChangedFindBlock, ReturnValue) == 0x000018, "Member 'InvitePartyWidget_OnTextChangedFindBlock::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnTextChangedFindFriend
// 0x0020 (0x0020 - 0x0000)
struct InvitePartyWidget_OnTextChangedFindFriend final
{
public:
	class FText                                   AccountNickname;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2473[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InvitePartyWidget_OnTextChangedFindFriend) == 0x000008, "Wrong alignment on InvitePartyWidget_OnTextChangedFindFriend");
static_assert(sizeof(InvitePartyWidget_OnTextChangedFindFriend) == 0x000020, "Wrong size on InvitePartyWidget_OnTextChangedFindFriend");
static_assert(offsetof(InvitePartyWidget_OnTextChangedFindFriend, AccountNickname) == 0x000000, "Member 'InvitePartyWidget_OnTextChangedFindFriend::AccountNickname' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnTextChangedFindFriend, ReturnValue) == 0x000018, "Member 'InvitePartyWidget_OnTextChangedFindFriend::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnTextChangedFindPlayer
// 0x0020 (0x0020 - 0x0000)
struct InvitePartyWidget_OnTextChangedFindPlayer final
{
public:
	class FText                                   AccountNickname;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2474[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InvitePartyWidget_OnTextChangedFindPlayer) == 0x000008, "Wrong alignment on InvitePartyWidget_OnTextChangedFindPlayer");
static_assert(sizeof(InvitePartyWidget_OnTextChangedFindPlayer) == 0x000020, "Wrong size on InvitePartyWidget_OnTextChangedFindPlayer");
static_assert(offsetof(InvitePartyWidget_OnTextChangedFindPlayer, AccountNickname) == 0x000000, "Member 'InvitePartyWidget_OnTextChangedFindPlayer::AccountNickname' has a wrong offset!");
static_assert(offsetof(InvitePartyWidget_OnTextChangedFindPlayer, ReturnValue) == 0x000018, "Member 'InvitePartyWidget_OnTextChangedFindPlayer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.OnUserListFindPlayerClicked
// 0x0018 (0x0018 - 0x0000)
struct InvitePartyWidget_OnUserListFindPlayerClicked final
{
public:
	class FText                                   AccountNickname;                                   // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_OnUserListFindPlayerClicked) == 0x000008, "Wrong alignment on InvitePartyWidget_OnUserListFindPlayerClicked");
static_assert(sizeof(InvitePartyWidget_OnUserListFindPlayerClicked) == 0x000018, "Wrong size on InvitePartyWidget_OnUserListFindPlayerClicked");
static_assert(offsetof(InvitePartyWidget_OnUserListFindPlayerClicked, AccountNickname) == 0x000000, "Member 'InvitePartyWidget_OnUserListFindPlayerClicked::AccountNickname' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.TryFriendRequestInviteParty
// 0x0008 (0x0008 - 0x0000)
struct InvitePartyWidget_TryFriendRequestInviteParty final
{
public:
	const class UFriendSlotWidgetData*            FriendSlotWidgetData;                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_TryFriendRequestInviteParty) == 0x000008, "Wrong alignment on InvitePartyWidget_TryFriendRequestInviteParty");
static_assert(sizeof(InvitePartyWidget_TryFriendRequestInviteParty) == 0x000008, "Wrong size on InvitePartyWidget_TryFriendRequestInviteParty");
static_assert(offsetof(InvitePartyWidget_TryFriendRequestInviteParty, FriendSlotWidgetData) == 0x000000, "Member 'InvitePartyWidget_TryFriendRequestInviteParty::FriendSlotWidgetData' has a wrong offset!");

// Function DungeonCrawler.InvitePartyWidget.TryPlayerRequestInviteParty
// 0x0008 (0x0008 - 0x0000)
struct InvitePartyWidget_TryPlayerRequestInviteParty final
{
public:
	const class UPlayerSlotWidgetData*            PlayerSlotWidgetData;                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InvitePartyWidget_TryPlayerRequestInviteParty) == 0x000008, "Wrong alignment on InvitePartyWidget_TryPlayerRequestInviteParty");
static_assert(sizeof(InvitePartyWidget_TryPlayerRequestInviteParty) == 0x000008, "Wrong size on InvitePartyWidget_TryPlayerRequestInviteParty");
static_assert(offsetof(InvitePartyWidget_TryPlayerRequestInviteParty, PlayerSlotWidgetData) == 0x000000, "Member 'InvitePartyWidget_TryPlayerRequestInviteParty::PlayerSlotWidgetData' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitForCharacterUnCrouch.WaitForCharacterUnCrouch
// 0x0010 (0x0010 - 0x0000)
struct DCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitForCharacterUnCrouch*         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch) == 0x000008, "Wrong alignment on DCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch");
static_assert(sizeof(DCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch) == 0x000010, "Wrong size on DCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch");
static_assert(offsetof(DCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch, OwningAbility) == 0x000000, "Member 'DCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch, ReturnValue) == 0x000008, "Member 'DCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.MusicSlotWidgetBase.OnMusicDataChanged
// 0x00F0 (0x00F0 - 0x0000)
struct MusicSlotWidgetBase_OnMusicDataChanged final
{
public:
	struct FMusicData                             InMusicData;                                       // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2477[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesignDataMusic                       InDesignDataMusic;                                 // 0x0028(0x00C8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicSlotWidgetBase_OnMusicDataChanged) == 0x000008, "Wrong alignment on MusicSlotWidgetBase_OnMusicDataChanged");
static_assert(sizeof(MusicSlotWidgetBase_OnMusicDataChanged) == 0x0000F0, "Wrong size on MusicSlotWidgetBase_OnMusicDataChanged");
static_assert(offsetof(MusicSlotWidgetBase_OnMusicDataChanged, InMusicData) == 0x000000, "Member 'MusicSlotWidgetBase_OnMusicDataChanged::InMusicData' has a wrong offset!");
static_assert(offsetof(MusicSlotWidgetBase_OnMusicDataChanged, InDesignDataMusic) == 0x000028, "Member 'MusicSlotWidgetBase_OnMusicDataChanged::InDesignDataMusic' has a wrong offset!");

// Function DungeonCrawler.MusicSlotWidgetBase.OnSetMusicArtData
// 0x0008 (0x0008 - 0x0000)
struct MusicSlotWidgetBase_OnSetMusicArtData final
{
public:
	const class UArtDataMusic*                    InArtMusicData;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicSlotWidgetBase_OnSetMusicArtData) == 0x000008, "Wrong alignment on MusicSlotWidgetBase_OnSetMusicArtData");
static_assert(sizeof(MusicSlotWidgetBase_OnSetMusicArtData) == 0x000008, "Wrong size on MusicSlotWidgetBase_OnSetMusicArtData");
static_assert(offsetof(MusicSlotWidgetBase_OnSetMusicArtData, InArtMusicData) == 0x000000, "Member 'MusicSlotWidgetBase_OnSetMusicArtData::InArtMusicData' has a wrong offset!");

// Function DungeonCrawler.MusicSlotWidgetBase.SetMusicData
// 0x00F0 (0x00F0 - 0x0000)
struct MusicSlotWidgetBase_SetMusicData final
{
public:
	struct FMusicData                             InMusicData;                                       // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2478[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesignDataMusic                       InDesignDataMusic;                                 // 0x0028(0x00C8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicSlotWidgetBase_SetMusicData) == 0x000008, "Wrong alignment on MusicSlotWidgetBase_SetMusicData");
static_assert(sizeof(MusicSlotWidgetBase_SetMusicData) == 0x0000F0, "Wrong size on MusicSlotWidgetBase_SetMusicData");
static_assert(offsetof(MusicSlotWidgetBase_SetMusicData, InMusicData) == 0x000000, "Member 'MusicSlotWidgetBase_SetMusicData::InMusicData' has a wrong offset!");
static_assert(offsetof(MusicSlotWidgetBase_SetMusicData, InDesignDataMusic) == 0x000028, "Member 'MusicSlotWidgetBase_SetMusicData::InDesignDataMusic' has a wrong offset!");

// Function DungeonCrawler.MusicCapacityWidgetBase.OnMusicCapacityChanged
// 0x0008 (0x0008 - 0x0000)
struct MusicCapacityWidgetBase_OnMusicCapacityChanged final
{
public:
	float                                         InMusicCurrentCapacity;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InMusicMaxCapacity;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicCapacityWidgetBase_OnMusicCapacityChanged) == 0x000004, "Wrong alignment on MusicCapacityWidgetBase_OnMusicCapacityChanged");
static_assert(sizeof(MusicCapacityWidgetBase_OnMusicCapacityChanged) == 0x000008, "Wrong size on MusicCapacityWidgetBase_OnMusicCapacityChanged");
static_assert(offsetof(MusicCapacityWidgetBase_OnMusicCapacityChanged, InMusicCurrentCapacity) == 0x000000, "Member 'MusicCapacityWidgetBase_OnMusicCapacityChanged::InMusicCurrentCapacity' has a wrong offset!");
static_assert(offsetof(MusicCapacityWidgetBase_OnMusicCapacityChanged, InMusicMaxCapacity) == 0x000004, "Member 'MusicCapacityWidgetBase_OnMusicCapacityChanged::InMusicMaxCapacity' has a wrong offset!");

// Function DungeonCrawler.ClassMusicCapacityWidget.OnMusicListChanged
// 0x0010 (0x0010 - 0x0000)
struct ClassMusicCapacityWidget_OnMusicListChanged final
{
public:
	TArray<struct FMusicData>                     InMusicDataArray;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassMusicCapacityWidget_OnMusicListChanged) == 0x000008, "Wrong alignment on ClassMusicCapacityWidget_OnMusicListChanged");
static_assert(sizeof(ClassMusicCapacityWidget_OnMusicListChanged) == 0x000010, "Wrong size on ClassMusicCapacityWidget_OnMusicListChanged");
static_assert(offsetof(ClassMusicCapacityWidget_OnMusicListChanged, InMusicDataArray) == 0x000000, "Member 'ClassMusicCapacityWidget_OnMusicListChanged::InMusicDataArray' has a wrong offset!");

// Function DungeonCrawler.DCDungeonResultWidget.SetGameResultInfo
// 0x0048 (0x0048 - 0x0000)
struct DCDungeonResultWidget_SetGameResultInfo final
{
public:
	struct FGameResultInfo                        InGameResultInfo;                                  // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonResultWidget_SetGameResultInfo) == 0x000008, "Wrong alignment on DCDungeonResultWidget_SetGameResultInfo");
static_assert(sizeof(DCDungeonResultWidget_SetGameResultInfo) == 0x000048, "Wrong size on DCDungeonResultWidget_SetGameResultInfo");
static_assert(offsetof(DCDungeonResultWidget_SetGameResultInfo, InGameResultInfo) == 0x000000, "Member 'DCDungeonResultWidget_SetGameResultInfo::InGameResultInfo' has a wrong offset!");

// Function DungeonCrawler.DCDungeonResultWidget.GetArenaBlueTeamWinCount
// 0x0004 (0x0004 - 0x0000)
struct DCDungeonResultWidget_GetArenaBlueTeamWinCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonResultWidget_GetArenaBlueTeamWinCount) == 0x000004, "Wrong alignment on DCDungeonResultWidget_GetArenaBlueTeamWinCount");
static_assert(sizeof(DCDungeonResultWidget_GetArenaBlueTeamWinCount) == 0x000004, "Wrong size on DCDungeonResultWidget_GetArenaBlueTeamWinCount");
static_assert(offsetof(DCDungeonResultWidget_GetArenaBlueTeamWinCount, ReturnValue) == 0x000000, "Member 'DCDungeonResultWidget_GetArenaBlueTeamWinCount::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDungeonResultWidget.GetArenaRedTeamWinCount
// 0x0004 (0x0004 - 0x0000)
struct DCDungeonResultWidget_GetArenaRedTeamWinCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonResultWidget_GetArenaRedTeamWinCount) == 0x000004, "Wrong alignment on DCDungeonResultWidget_GetArenaRedTeamWinCount");
static_assert(sizeof(DCDungeonResultWidget_GetArenaRedTeamWinCount) == 0x000004, "Wrong size on DCDungeonResultWidget_GetArenaRedTeamWinCount");
static_assert(offsetof(DCDungeonResultWidget_GetArenaRedTeamWinCount, ReturnValue) == 0x000000, "Member 'DCDungeonResultWidget_GetArenaRedTeamWinCount::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDungeonResultWidget.GetArenaRoundCount
// 0x0004 (0x0004 - 0x0000)
struct DCDungeonResultWidget_GetArenaRoundCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonResultWidget_GetArenaRoundCount) == 0x000004, "Wrong alignment on DCDungeonResultWidget_GetArenaRoundCount");
static_assert(sizeof(DCDungeonResultWidget_GetArenaRoundCount) == 0x000004, "Wrong size on DCDungeonResultWidget_GetArenaRoundCount");
static_assert(offsetof(DCDungeonResultWidget_GetArenaRoundCount, ReturnValue) == 0x000000, "Member 'DCDungeonResultWidget_GetArenaRoundCount::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDungeonResultWidget.GetForceResultReason
// 0x0018 (0x0018 - 0x0000)
struct DCDungeonResultWidget_GetForceResultReason final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonResultWidget_GetForceResultReason) == 0x000008, "Wrong alignment on DCDungeonResultWidget_GetForceResultReason");
static_assert(sizeof(DCDungeonResultWidget_GetForceResultReason) == 0x000018, "Wrong size on DCDungeonResultWidget_GetForceResultReason");
static_assert(offsetof(DCDungeonResultWidget_GetForceResultReason, ReturnValue) == 0x000000, "Member 'DCDungeonResultWidget_GetForceResultReason::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDungeonResultWidget.HasWinner
// 0x0001 (0x0001 - 0x0000)
struct DCDungeonResultWidget_HasWinner final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonResultWidget_HasWinner) == 0x000001, "Wrong alignment on DCDungeonResultWidget_HasWinner");
static_assert(sizeof(DCDungeonResultWidget_HasWinner) == 0x000001, "Wrong size on DCDungeonResultWidget_HasWinner");
static_assert(offsetof(DCDungeonResultWidget_HasWinner, ReturnValue) == 0x000000, "Member 'DCDungeonResultWidget_HasWinner::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDungeonResultWidget.IsWinner
// 0x0001 (0x0001 - 0x0000)
struct DCDungeonResultWidget_IsWinner final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonResultWidget_IsWinner) == 0x000001, "Wrong alignment on DCDungeonResultWidget_IsWinner");
static_assert(sizeof(DCDungeonResultWidget_IsWinner) == 0x000001, "Wrong size on DCDungeonResultWidget_IsWinner");
static_assert(offsetof(DCDungeonResultWidget_IsWinner, ReturnValue) == 0x000000, "Member 'DCDungeonResultWidget_IsWinner::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.NickNameWidgetBase.OnNickNameStr
// 0x0020 (0x0020 - 0x0000)
struct NickNameWidgetBase_OnNickNameStr final
{
public:
	class FString                                 NewValue;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OldValue;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NickNameWidgetBase_OnNickNameStr) == 0x000008, "Wrong alignment on NickNameWidgetBase_OnNickNameStr");
static_assert(sizeof(NickNameWidgetBase_OnNickNameStr) == 0x000020, "Wrong size on NickNameWidgetBase_OnNickNameStr");
static_assert(offsetof(NickNameWidgetBase_OnNickNameStr, NewValue) == 0x000000, "Member 'NickNameWidgetBase_OnNickNameStr::NewValue' has a wrong offset!");
static_assert(offsetof(NickNameWidgetBase_OnNickNameStr, OldValue) == 0x000010, "Member 'NickNameWidgetBase_OnNickNameStr::OldValue' has a wrong offset!");

// Function DungeonCrawler.NickNameWidgetBase.SetNickName
// 0x0040 (0x0040 - 0x0000)
struct NickNameWidgetBase_SetNickName final
{
public:
	struct FNickname                              InNickName;                                        // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(NickNameWidgetBase_SetNickName) == 0x000008, "Wrong alignment on NickNameWidgetBase_SetNickName");
static_assert(sizeof(NickNameWidgetBase_SetNickName) == 0x000040, "Wrong size on NickNameWidgetBase_SetNickName");
static_assert(offsetof(NickNameWidgetBase_SetNickName, InNickName) == 0x000000, "Member 'NickNameWidgetBase_SetNickName::InNickName' has a wrong offset!");

// Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.MoveWithInputVectorCurve
// 0x0038 (0x0038 - 0x0000)
struct DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestLocation;                                      // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           InVelocityVector;                                  // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceTolerance;                                 // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTeleportWhenFinished;                       // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2481[0x3];                                     // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_MoveWithInputVectorCurve*         ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve) == 0x000008, "Wrong alignment on DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve");
static_assert(sizeof(DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve) == 0x000038, "Wrong size on DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve");
static_assert(offsetof(DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve, OwningAbility) == 0x000000, "Member 'DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve, DestLocation) == 0x000008, "Member 'DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve::DestLocation' has a wrong offset!");
static_assert(offsetof(DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve, InVelocityVector) == 0x000020, "Member 'DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve::InVelocityVector' has a wrong offset!");
static_assert(offsetof(DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve, DistanceTolerance) == 0x000028, "Member 'DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve::DistanceTolerance' has a wrong offset!");
static_assert(offsetof(DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve, bShouldTeleportWhenFinished) == 0x00002C, "Member 'DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve::bShouldTeleportWhenFinished' has a wrong offset!");
static_assert(offsetof(DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve, ReturnValue) == 0x000030, "Member 'DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.HandleTimelineUpdate
// 0x0018 (0x0018 - 0x0000)
struct DCAT_MoveWithInputVectorCurve_HandleTimelineUpdate final
{
public:
	struct FVector                                InVector;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_MoveWithInputVectorCurve_HandleTimelineUpdate) == 0x000008, "Wrong alignment on DCAT_MoveWithInputVectorCurve_HandleTimelineUpdate");
static_assert(sizeof(DCAT_MoveWithInputVectorCurve_HandleTimelineUpdate) == 0x000018, "Wrong size on DCAT_MoveWithInputVectorCurve_HandleTimelineUpdate");
static_assert(offsetof(DCAT_MoveWithInputVectorCurve_HandleTimelineUpdate, InVector) == 0x000000, "Member 'DCAT_MoveWithInputVectorCurve_HandleTimelineUpdate::InVector' has a wrong offset!");

// Function DungeonCrawler.ClassPerkListWidgetBase.GetSelectedSlotIndex
// 0x0004 (0x0004 - 0x0000)
struct ClassPerkListWidgetBase_GetSelectedSlotIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassPerkListWidgetBase_GetSelectedSlotIndex) == 0x000004, "Wrong alignment on ClassPerkListWidgetBase_GetSelectedSlotIndex");
static_assert(sizeof(ClassPerkListWidgetBase_GetSelectedSlotIndex) == 0x000004, "Wrong size on ClassPerkListWidgetBase_GetSelectedSlotIndex");
static_assert(offsetof(ClassPerkListWidgetBase_GetSelectedSlotIndex, ReturnValue) == 0x000000, "Member 'ClassPerkListWidgetBase_GetSelectedSlotIndex::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ClassPerkListWidgetBase.GetSelectedSlotPerkId
// 0x0010 (0x0010 - 0x0000)
struct ClassPerkListWidgetBase_GetSelectedSlotPerkId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassPerkListWidgetBase_GetSelectedSlotPerkId) == 0x000004, "Wrong alignment on ClassPerkListWidgetBase_GetSelectedSlotPerkId");
static_assert(sizeof(ClassPerkListWidgetBase_GetSelectedSlotPerkId) == 0x000010, "Wrong size on ClassPerkListWidgetBase_GetSelectedSlotPerkId");
static_assert(offsetof(ClassPerkListWidgetBase_GetSelectedSlotPerkId, ReturnValue) == 0x000000, "Member 'ClassPerkListWidgetBase_GetSelectedSlotPerkId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint
// 0x0020 (0x0020 - 0x0000)
struct ClassPerkListWidgetBase_OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint final
{
public:
	struct FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassPerkListWidgetBase_OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint) == 0x000008, "Wrong alignment on ClassPerkListWidgetBase_OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint");
static_assert(sizeof(ClassPerkListWidgetBase_OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint) == 0x000020, "Wrong size on ClassPerkListWidgetBase_OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint");
static_assert(offsetof(ClassPerkListWidgetBase_OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint, InMsg) == 0x000000, "Member 'ClassPerkListWidgetBase_OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint
// 0x0080 (0x0080 - 0x0000)
struct ClassPerkListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint final
{
public:
	struct FMsgWidgetClassLevelNotify             InMsg;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassPerkListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint) == 0x000008, "Wrong alignment on ClassPerkListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint");
static_assert(sizeof(ClassPerkListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint) == 0x000080, "Wrong size on ClassPerkListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint");
static_assert(offsetof(ClassPerkListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint, InMsg) == 0x000000, "Member 'ClassPerkListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint
// 0x0038 (0x0038 - 0x0000)
struct ClassPerkListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint final
{
public:
	struct FMsgWidgetClassSlotUnLockLevelNotify   InMsg;                                             // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassPerkListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint) == 0x000008, "Wrong alignment on ClassPerkListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");
static_assert(sizeof(ClassPerkListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint) == 0x000038, "Wrong size on ClassPerkListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");
static_assert(offsetof(ClassPerkListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint, InMsg) == 0x000000, "Member 'ClassPerkListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClassPerkListWidgetBase.SetSelectedSlotIndex
// 0x0004 (0x0004 - 0x0000)
struct ClassPerkListWidgetBase_SetSelectedSlotIndex final
{
public:
	int32                                         InSlotIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassPerkListWidgetBase_SetSelectedSlotIndex) == 0x000004, "Wrong alignment on ClassPerkListWidgetBase_SetSelectedSlotIndex");
static_assert(sizeof(ClassPerkListWidgetBase_SetSelectedSlotIndex) == 0x000004, "Wrong size on ClassPerkListWidgetBase_SetSelectedSlotIndex");
static_assert(offsetof(ClassPerkListWidgetBase_SetSelectedSlotIndex, InSlotIndex) == 0x000000, "Member 'ClassPerkListWidgetBase_SetSelectedSlotIndex::InSlotIndex' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.AutoTeamRegisterSingle
// 0x0001 (0x0001 - 0x0000)
struct PlayWidget_AutoTeamRegisterSingle final
{
public:
	bool                                          IsRegister;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_AutoTeamRegisterSingle) == 0x000001, "Wrong alignment on PlayWidget_AutoTeamRegisterSingle");
static_assert(sizeof(PlayWidget_AutoTeamRegisterSingle) == 0x000001, "Wrong size on PlayWidget_AutoTeamRegisterSingle");
static_assert(offsetof(PlayWidget_AutoTeamRegisterSingle, IsRegister) == 0x000000, "Member 'PlayWidget_AutoTeamRegisterSingle::IsRegister' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnChangedMatchingState
// 0x0001 (0x0001 - 0x0000)
struct PlayWidget_OnChangedMatchingState final
{
public:
	bool                                          IsInMatching;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnChangedMatchingState) == 0x000001, "Wrong alignment on PlayWidget_OnChangedMatchingState");
static_assert(sizeof(PlayWidget_OnChangedMatchingState) == 0x000001, "Wrong size on PlayWidget_OnChangedMatchingState");
static_assert(offsetof(PlayWidget_OnChangedMatchingState, IsInMatching) == 0x000000, "Member 'PlayWidget_OnChangedMatchingState::IsInMatching' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnDungeonMatchEvent
// 0x0001 (0x0001 - 0x0000)
struct PlayWidget_OnDungeonMatchEvent final
{
public:
	EDungeonMatchState                            InDungeonMatchState;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnDungeonMatchEvent) == 0x000001, "Wrong alignment on PlayWidget_OnDungeonMatchEvent");
static_assert(sizeof(PlayWidget_OnDungeonMatchEvent) == 0x000001, "Wrong size on PlayWidget_OnDungeonMatchEvent");
static_assert(offsetof(PlayWidget_OnDungeonMatchEvent, InDungeonMatchState) == 0x000000, "Member 'PlayWidget_OnDungeonMatchEvent::InDungeonMatchState' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnDungeonSelect
// 0x0002 (0x0002 - 0x0000)
struct PlayWidget_OnDungeonSelect final
{
public:
	EMatchMode                                    InMatchMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     GameType;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnDungeonSelect) == 0x000001, "Wrong alignment on PlayWidget_OnDungeonSelect");
static_assert(sizeof(PlayWidget_OnDungeonSelect) == 0x000002, "Wrong size on PlayWidget_OnDungeonSelect");
static_assert(offsetof(PlayWidget_OnDungeonSelect, InMatchMode) == 0x000000, "Member 'PlayWidget_OnDungeonSelect::InMatchMode' has a wrong offset!");
static_assert(offsetof(PlayWidget_OnDungeonSelect, GameType) == 0x000001, "Member 'PlayWidget_OnDungeonSelect::GameType' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnDungeonSelectListPopupOpen
// 0x0030 (0x0030 - 0x0000)
struct PlayWidget_OnDungeonSelectListPopupOpen final
{
public:
	struct FDungeonSelectParam                    InDungeonSelectParam;                              // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnDungeonSelectListPopupOpen) == 0x000008, "Wrong alignment on PlayWidget_OnDungeonSelectListPopupOpen");
static_assert(sizeof(PlayWidget_OnDungeonSelectListPopupOpen) == 0x000030, "Wrong size on PlayWidget_OnDungeonSelectListPopupOpen");
static_assert(offsetof(PlayWidget_OnDungeonSelectListPopupOpen, InDungeonSelectParam) == 0x000000, "Member 'PlayWidget_OnDungeonSelectListPopupOpen::InDungeonSelectParam' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnGameUserSettingControlsChanged
// 0x0088 (0x0088 - 0x0000)
struct PlayWidget_OnGameUserSettingControlsChanged final
{
public:
	struct FGameUserSettingControls               InGameUserSettingControls;                         // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameUserSettingControls               InOldGameUserSettingControls;                      // 0x0040(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInForce;                                          // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2488[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayWidget_OnGameUserSettingControlsChanged) == 0x000008, "Wrong alignment on PlayWidget_OnGameUserSettingControlsChanged");
static_assert(sizeof(PlayWidget_OnGameUserSettingControlsChanged) == 0x000088, "Wrong size on PlayWidget_OnGameUserSettingControlsChanged");
static_assert(offsetof(PlayWidget_OnGameUserSettingControlsChanged, InGameUserSettingControls) == 0x000000, "Member 'PlayWidget_OnGameUserSettingControlsChanged::InGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(PlayWidget_OnGameUserSettingControlsChanged, InOldGameUserSettingControls) == 0x000040, "Member 'PlayWidget_OnGameUserSettingControlsChanged::InOldGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(PlayWidget_OnGameUserSettingControlsChanged, bInForce) == 0x000080, "Member 'PlayWidget_OnGameUserSettingControlsChanged::bInForce' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnInvitePartyButtonClicked
// 0x0001 (0x0001 - 0x0000)
struct PlayWidget_OnInvitePartyButtonClicked final
{
public:
	EWidgetPartyUserLocate                        UserLocate;                                        // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnInvitePartyButtonClicked) == 0x000001, "Wrong alignment on PlayWidget_OnInvitePartyButtonClicked");
static_assert(sizeof(PlayWidget_OnInvitePartyButtonClicked) == 0x000001, "Wrong size on PlayWidget_OnInvitePartyButtonClicked");
static_assert(offsetof(PlayWidget_OnInvitePartyButtonClicked, UserLocate) == 0x000000, "Member 'PlayWidget_OnInvitePartyButtonClicked::UserLocate' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnLeaderUpdated
// 0x0001 (0x0001 - 0x0000)
struct PlayWidget_OnLeaderUpdated final
{
public:
	bool                                          IsPartyLeader;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnLeaderUpdated) == 0x000001, "Wrong alignment on PlayWidget_OnLeaderUpdated");
static_assert(sizeof(PlayWidget_OnLeaderUpdated) == 0x000001, "Wrong size on PlayWidget_OnLeaderUpdated");
static_assert(offsetof(PlayWidget_OnLeaderUpdated, IsPartyLeader) == 0x000000, "Member 'PlayWidget_OnLeaderUpdated::IsPartyLeader' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnMatchStart
// 0x0008 (0x0008 - 0x0000)
struct PlayWidget_OnMatchStart final
{
public:
	bool                                          InbCanCancel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2489[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InMatchCancelDelayTimeSec;                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnMatchStart) == 0x000004, "Wrong alignment on PlayWidget_OnMatchStart");
static_assert(sizeof(PlayWidget_OnMatchStart) == 0x000008, "Wrong size on PlayWidget_OnMatchStart");
static_assert(offsetof(PlayWidget_OnMatchStart, InbCanCancel) == 0x000000, "Member 'PlayWidget_OnMatchStart::InbCanCancel' has a wrong offset!");
static_assert(offsetof(PlayWidget_OnMatchStart, InMatchCancelDelayTimeSec) == 0x000004, "Member 'PlayWidget_OnMatchStart::InMatchCancelDelayTimeSec' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnNotRandomPartyMemberChecked
// 0x0001 (0x0001 - 0x0000)
struct PlayWidget_OnNotRandomPartyMemberChecked final
{
public:
	bool                                          bInNotRandomPartyMember;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnNotRandomPartyMemberChecked) == 0x000001, "Wrong alignment on PlayWidget_OnNotRandomPartyMemberChecked");
static_assert(sizeof(PlayWidget_OnNotRandomPartyMemberChecked) == 0x000001, "Wrong size on PlayWidget_OnNotRandomPartyMemberChecked");
static_assert(offsetof(PlayWidget_OnNotRandomPartyMemberChecked, bInNotRandomPartyMember) == 0x000000, "Member 'PlayWidget_OnNotRandomPartyMemberChecked::bInNotRandomPartyMember' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnPartyReadyButtonClicked
// 0x0001 (0x0001 - 0x0000)
struct PlayWidget_OnPartyReadyButtonClicked final
{
public:
	bool                                          IsReady;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnPartyReadyButtonClicked) == 0x000001, "Wrong alignment on PlayWidget_OnPartyReadyButtonClicked");
static_assert(sizeof(PlayWidget_OnPartyReadyButtonClicked) == 0x000001, "Wrong size on PlayWidget_OnPartyReadyButtonClicked");
static_assert(offsetof(PlayWidget_OnPartyReadyButtonClicked, IsReady) == 0x000000, "Member 'PlayWidget_OnPartyReadyButtonClicked::IsReady' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnPlayPartyReadyStateChanged
// 0x0002 (0x0002 - 0x0000)
struct PlayWidget_OnPlayPartyReadyStateChanged final
{
public:
	bool                                          bMine;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReady;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnPlayPartyReadyStateChanged) == 0x000001, "Wrong alignment on PlayWidget_OnPlayPartyReadyStateChanged");
static_assert(sizeof(PlayWidget_OnPlayPartyReadyStateChanged) == 0x000002, "Wrong size on PlayWidget_OnPlayPartyReadyStateChanged");
static_assert(offsetof(PlayWidget_OnPlayPartyReadyStateChanged, bMine) == 0x000000, "Member 'PlayWidget_OnPlayPartyReadyStateChanged::bMine' has a wrong offset!");
static_assert(offsetof(PlayWidget_OnPlayPartyReadyStateChanged, bReady) == 0x000001, "Member 'PlayWidget_OnPlayPartyReadyStateChanged::bReady' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnPlayPartyUserInfo
// 0x00C0 (0x00C0 - 0x0000)
struct PlayWidget_OnPlayPartyUserInfo final
{
public:
	struct FPlayPartyUserInfo                     PlayPartyUserInfo;                                 // 0x0000(0x00C0)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnPlayPartyUserInfo) == 0x000008, "Wrong alignment on PlayWidget_OnPlayPartyUserInfo");
static_assert(sizeof(PlayWidget_OnPlayPartyUserInfo) == 0x0000C0, "Wrong size on PlayWidget_OnPlayPartyUserInfo");
static_assert(offsetof(PlayWidget_OnPlayPartyUserInfo, PlayPartyUserInfo) == 0x000000, "Member 'PlayWidget_OnPlayPartyUserInfo::PlayPartyUserInfo' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnPlayPartyUserInfoData
// 0x0020 (0x0020 - 0x0000)
struct PlayWidget_OnPlayPartyUserInfoData final
{
public:
	struct FPlayPartyUserInfoData                 NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FPlayPartyUserInfoData                 OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnPlayPartyUserInfoData) == 0x000008, "Wrong alignment on PlayWidget_OnPlayPartyUserInfoData");
static_assert(sizeof(PlayWidget_OnPlayPartyUserInfoData) == 0x000020, "Wrong size on PlayWidget_OnPlayPartyUserInfoData");
static_assert(offsetof(PlayWidget_OnPlayPartyUserInfoData, NewValue) == 0x000000, "Member 'PlayWidget_OnPlayPartyUserInfoData::NewValue' has a wrong offset!");
static_assert(offsetof(PlayWidget_OnPlayPartyUserInfoData, OldValue) == 0x000010, "Member 'PlayWidget_OnPlayPartyUserInfoData::OldValue' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnPopupSWidgetInvitePartyRequest
// 0x0018 (0x0018 - 0x0000)
struct PlayWidget_OnPopupSWidgetInvitePartyRequest final
{
public:
	class UPopupDataBase*                         PopupData;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnAccountID;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnPopupSWidgetInvitePartyRequest) == 0x000008, "Wrong alignment on PlayWidget_OnPopupSWidgetInvitePartyRequest");
static_assert(sizeof(PlayWidget_OnPopupSWidgetInvitePartyRequest) == 0x000018, "Wrong size on PlayWidget_OnPopupSWidgetInvitePartyRequest");
static_assert(offsetof(PlayWidget_OnPopupSWidgetInvitePartyRequest, PopupData) == 0x000000, "Member 'PlayWidget_OnPopupSWidgetInvitePartyRequest::PopupData' has a wrong offset!");
static_assert(offsetof(PlayWidget_OnPopupSWidgetInvitePartyRequest, ReturnAccountID) == 0x000008, "Member 'PlayWidget_OnPopupSWidgetInvitePartyRequest::ReturnAccountID' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnPopupSWidgetInvitePartyResponse
// 0x0018 (0x0018 - 0x0000)
struct PlayWidget_OnPopupSWidgetInvitePartyResponse final
{
public:
	EPopupResult                                  PopupResult;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248A[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnAccountID;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnPopupSWidgetInvitePartyResponse) == 0x000008, "Wrong alignment on PlayWidget_OnPopupSWidgetInvitePartyResponse");
static_assert(sizeof(PlayWidget_OnPopupSWidgetInvitePartyResponse) == 0x000018, "Wrong size on PlayWidget_OnPopupSWidgetInvitePartyResponse");
static_assert(offsetof(PlayWidget_OnPopupSWidgetInvitePartyResponse, PopupResult) == 0x000000, "Member 'PlayWidget_OnPopupSWidgetInvitePartyResponse::PopupResult' has a wrong offset!");
static_assert(offsetof(PlayWidget_OnPopupSWidgetInvitePartyResponse, ReturnAccountID) == 0x000008, "Member 'PlayWidget_OnPopupSWidgetInvitePartyResponse::ReturnAccountID' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnRegionDataSet
// 0x0004 (0x0004 - 0x0000)
struct PlayWidget_OnRegionDataSet final
{
public:
	int32                                         RegionIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnRegionDataSet) == 0x000004, "Wrong alignment on PlayWidget_OnRegionDataSet");
static_assert(sizeof(PlayWidget_OnRegionDataSet) == 0x000004, "Wrong size on PlayWidget_OnRegionDataSet");
static_assert(offsetof(PlayWidget_OnRegionDataSet, RegionIndex) == 0x000000, "Member 'PlayWidget_OnRegionDataSet::RegionIndex' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnRegionSelected
// 0x0004 (0x0004 - 0x0000)
struct PlayWidget_OnRegionSelected final
{
public:
	int32                                         RegionIndex;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnRegionSelected) == 0x000004, "Wrong alignment on PlayWidget_OnRegionSelected");
static_assert(sizeof(PlayWidget_OnRegionSelected) == 0x000004, "Wrong size on PlayWidget_OnRegionSelected");
static_assert(offsetof(PlayWidget_OnRegionSelected, RegionIndex) == 0x000000, "Member 'PlayWidget_OnRegionSelected::RegionIndex' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.OnUpdateLobbyCharacterData
// 0x00C8 (0x00C8 - 0x0000)
struct PlayWidget_OnUpdateLobbyCharacterData final
{
public:
	struct FLobbyCharacterInfo                    LobbyInfo;                                         // 0x0000(0x00C8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_OnUpdateLobbyCharacterData) == 0x000008, "Wrong alignment on PlayWidget_OnUpdateLobbyCharacterData");
static_assert(sizeof(PlayWidget_OnUpdateLobbyCharacterData) == 0x0000C8, "Wrong size on PlayWidget_OnUpdateLobbyCharacterData");
static_assert(offsetof(PlayWidget_OnUpdateLobbyCharacterData, LobbyInfo) == 0x000000, "Member 'PlayWidget_OnUpdateLobbyCharacterData::LobbyInfo' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.UpdateQuestLogAvailable
// 0x0001 (0x0001 - 0x0000)
struct PlayWidget_UpdateQuestLogAvailable final
{
public:
	bool                                          bIsAvailable;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_UpdateQuestLogAvailable) == 0x000001, "Wrong alignment on PlayWidget_UpdateQuestLogAvailable");
static_assert(sizeof(PlayWidget_UpdateQuestLogAvailable) == 0x000001, "Wrong size on PlayWidget_UpdateQuestLogAvailable");
static_assert(offsetof(PlayWidget_UpdateQuestLogAvailable, bIsAvailable) == 0x000000, "Member 'PlayWidget_UpdateQuestLogAvailable::bIsAvailable' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.IsDuo
// 0x0001 (0x0001 - 0x0000)
struct PlayWidget_IsDuo final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_IsDuo) == 0x000001, "Wrong alignment on PlayWidget_IsDuo");
static_assert(sizeof(PlayWidget_IsDuo) == 0x000001, "Wrong size on PlayWidget_IsDuo");
static_assert(offsetof(PlayWidget_IsDuo, ReturnValue) == 0x000000, "Member 'PlayWidget_IsDuo::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.PlayWidget.IsSolo
// 0x0001 (0x0001 - 0x0000)
struct PlayWidget_IsSolo final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayWidget_IsSolo) == 0x000001, "Wrong alignment on PlayWidget_IsSolo");
static_assert(sizeof(PlayWidget_IsSolo) == 0x000001, "Wrong size on PlayWidget_IsSolo");
static_assert(offsetof(PlayWidget_IsSolo, ReturnValue) == 0x000000, "Member 'PlayWidget_IsSolo::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemWidgetBase.IsSet
// 0x0001 (0x0001 - 0x0000)
struct DCItemWidgetBase_IsSet final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemWidgetBase_IsSet) == 0x000001, "Wrong alignment on DCItemWidgetBase_IsSet");
static_assert(sizeof(DCItemWidgetBase_IsSet) == 0x000001, "Wrong size on DCItemWidgetBase_IsSet");
static_assert(offsetof(DCItemWidgetBase_IsSet, ReturnValue) == 0x000000, "Member 'DCItemWidgetBase_IsSet::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemCommonWidget.GetTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCItemCommonWidget_GetTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemCommonWidget_GetTooltipWidget) == 0x000008, "Wrong alignment on DCItemCommonWidget_GetTooltipWidget");
static_assert(sizeof(DCItemCommonWidget_GetTooltipWidget) == 0x000008, "Wrong size on DCItemCommonWidget_GetTooltipWidget");
static_assert(offsetof(DCItemCommonWidget_GetTooltipWidget, ReturnValue) == 0x000000, "Member 'DCItemCommonWidget_GetTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemCommonWidget.OnDragDropFinished
// 0x0008 (0x0008 - 0x0000)
struct DCItemCommonWidget_OnDragDropFinished final
{
public:
	class UDragDropOperation*                     Operation;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemCommonWidget_OnDragDropFinished) == 0x000008, "Wrong alignment on DCItemCommonWidget_OnDragDropFinished");
static_assert(sizeof(DCItemCommonWidget_OnDragDropFinished) == 0x000008, "Wrong size on DCItemCommonWidget_OnDragDropFinished");
static_assert(offsetof(DCItemCommonWidget_OnDragDropFinished, Operation) == 0x000000, "Member 'DCItemCommonWidget_OnDragDropFinished::Operation' has a wrong offset!");

// Function DungeonCrawler.DCBagItemWidget.IsGold
// 0x0001 (0x0001 - 0x0000)
struct DCBagItemWidget_IsGold final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCBagItemWidget_IsGold) == 0x000001, "Wrong alignment on DCBagItemWidget_IsGold");
static_assert(sizeof(DCBagItemWidget_IsGold) == 0x000001, "Wrong size on DCBagItemWidget_IsGold");
static_assert(offsetof(DCBagItemWidget_IsGold, ReturnValue) == 0x000000, "Member 'DCBagItemWidget_IsGold::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ClassRankIconBase.SetClassIcon
// 0x0008 (0x0008 - 0x0000)
struct ClassRankIconBase_SetClassIcon final
{
public:
	const class UTexture2D*                       InClassIconTex;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassRankIconBase_SetClassIcon) == 0x000008, "Wrong alignment on ClassRankIconBase_SetClassIcon");
static_assert(sizeof(ClassRankIconBase_SetClassIcon) == 0x000008, "Wrong size on ClassRankIconBase_SetClassIcon");
static_assert(offsetof(ClassRankIconBase_SetClassIcon, InClassIconTex) == 0x000000, "Member 'ClassRankIconBase_SetClassIcon::InClassIconTex' has a wrong offset!");

// Function DungeonCrawler.ClassRankIconBase.SetRankData
// 0x0008 (0x0008 - 0x0000)
struct ClassRankIconBase_SetRankData final
{
public:
	const class UDCLeaderboardRankDataAsset*      InLeaderboardRankData;                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassRankIconBase_SetRankData) == 0x000008, "Wrong alignment on ClassRankIconBase_SetRankData");
static_assert(sizeof(ClassRankIconBase_SetRankData) == 0x000008, "Wrong size on ClassRankIconBase_SetRankData");
static_assert(offsetof(ClassRankIconBase_SetRankData, InLeaderboardRankData) == 0x000000, "Member 'ClassRankIconBase_SetRankData::InLeaderboardRankData' has a wrong offset!");

// Function DungeonCrawler.ClassRankIconBase.SetRankGroupData
// 0x0008 (0x0008 - 0x0000)
struct ClassRankIconBase_SetRankGroupData final
{
public:
	const class UDCLeaderboardRankGroupDataAsset* InLeaderboardRankGroupData;                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassRankIconBase_SetRankGroupData) == 0x000008, "Wrong alignment on ClassRankIconBase_SetRankGroupData");
static_assert(sizeof(ClassRankIconBase_SetRankGroupData) == 0x000008, "Wrong size on ClassRankIconBase_SetRankGroupData");
static_assert(offsetof(ClassRankIconBase_SetRankGroupData, InLeaderboardRankGroupData) == 0x000000, "Member 'ClassRankIconBase_SetRankGroupData::InLeaderboardRankGroupData' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitMovementModeChange.WaitMovementModeChange
// 0x0018 (0x0018 - 0x0000)
struct DCAT_WaitMovementModeChange_WaitMovementModeChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 NewMode;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTriggerOnce;                                  // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2494[0x6];                                     // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitMovementModeChange*           ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitMovementModeChange_WaitMovementModeChange) == 0x000008, "Wrong alignment on DCAT_WaitMovementModeChange_WaitMovementModeChange");
static_assert(sizeof(DCAT_WaitMovementModeChange_WaitMovementModeChange) == 0x000018, "Wrong size on DCAT_WaitMovementModeChange_WaitMovementModeChange");
static_assert(offsetof(DCAT_WaitMovementModeChange_WaitMovementModeChange, OwningAbility) == 0x000000, "Member 'DCAT_WaitMovementModeChange_WaitMovementModeChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitMovementModeChange_WaitMovementModeChange, NewMode) == 0x000008, "Member 'DCAT_WaitMovementModeChange_WaitMovementModeChange::NewMode' has a wrong offset!");
static_assert(offsetof(DCAT_WaitMovementModeChange_WaitMovementModeChange, bOnlyTriggerOnce) == 0x000009, "Member 'DCAT_WaitMovementModeChange_WaitMovementModeChange::bOnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitMovementModeChange_WaitMovementModeChange, ReturnValue) == 0x000010, "Member 'DCAT_WaitMovementModeChange_WaitMovementModeChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitMovementModeChange.OnMovementModeChange
// 0x0010 (0x0010 - 0x0000)
struct DCAT_WaitMovementModeChange_OnMovementModeChange final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2495[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAT_WaitMovementModeChange_OnMovementModeChange) == 0x000008, "Wrong alignment on DCAT_WaitMovementModeChange_OnMovementModeChange");
static_assert(sizeof(DCAT_WaitMovementModeChange_OnMovementModeChange) == 0x000010, "Wrong size on DCAT_WaitMovementModeChange_OnMovementModeChange");
static_assert(offsetof(DCAT_WaitMovementModeChange_OnMovementModeChange, Character) == 0x000000, "Member 'DCAT_WaitMovementModeChange_OnMovementModeChange::Character' has a wrong offset!");
static_assert(offsetof(DCAT_WaitMovementModeChange_OnMovementModeChange, PrevMovementMode) == 0x000008, "Member 'DCAT_WaitMovementModeChange_OnMovementModeChange::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(DCAT_WaitMovementModeChange_OnMovementModeChange, PreviousCustomMode) == 0x000009, "Member 'DCAT_WaitMovementModeChange_OnMovementModeChange::PreviousCustomMode' has a wrong offset!");

// Function DungeonCrawler.DCGiftCodePopupBase.GetWarningTextVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCGiftCodePopupBase_GetWarningTextVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGiftCodePopupBase_GetWarningTextVisibility) == 0x000001, "Wrong alignment on DCGiftCodePopupBase_GetWarningTextVisibility");
static_assert(sizeof(DCGiftCodePopupBase_GetWarningTextVisibility) == 0x000001, "Wrong size on DCGiftCodePopupBase_GetWarningTextVisibility");
static_assert(offsetof(DCGiftCodePopupBase_GetWarningTextVisibility, ReturnValue) == 0x000000, "Member 'DCGiftCodePopupBase_GetWarningTextVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGiftCodePopupBase.MoveToNextCodeBlock
// 0x0020 (0x0020 - 0x0000)
struct DCGiftCodePopupBase_MoveToNextCodeBlock final
{
public:
	class FText                                   InRemainText;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InCodeBlockIndex;                                  // 0x0018(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2498[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGiftCodePopupBase_MoveToNextCodeBlock) == 0x000008, "Wrong alignment on DCGiftCodePopupBase_MoveToNextCodeBlock");
static_assert(sizeof(DCGiftCodePopupBase_MoveToNextCodeBlock) == 0x000020, "Wrong size on DCGiftCodePopupBase_MoveToNextCodeBlock");
static_assert(offsetof(DCGiftCodePopupBase_MoveToNextCodeBlock, InRemainText) == 0x000000, "Member 'DCGiftCodePopupBase_MoveToNextCodeBlock::InRemainText' has a wrong offset!");
static_assert(offsetof(DCGiftCodePopupBase_MoveToNextCodeBlock, InCodeBlockIndex) == 0x000018, "Member 'DCGiftCodePopupBase_MoveToNextCodeBlock::InCodeBlockIndex' has a wrong offset!");

// Function DungeonCrawler.DCGiftCodePopupBase.MoveToPrevCodeBlock
// 0x0004 (0x0004 - 0x0000)
struct DCGiftCodePopupBase_MoveToPrevCodeBlock final
{
public:
	int32                                         InCodeBlockIndex;                                  // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGiftCodePopupBase_MoveToPrevCodeBlock) == 0x000004, "Wrong alignment on DCGiftCodePopupBase_MoveToPrevCodeBlock");
static_assert(sizeof(DCGiftCodePopupBase_MoveToPrevCodeBlock) == 0x000004, "Wrong size on DCGiftCodePopupBase_MoveToPrevCodeBlock");
static_assert(offsetof(DCGiftCodePopupBase_MoveToPrevCodeBlock, InCodeBlockIndex) == 0x000000, "Member 'DCGiftCodePopupBase_MoveToPrevCodeBlock::InCodeBlockIndex' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerChecklistSlotWidget.GetReportCheckBoxEnabled
// 0x0001 (0x0001 - 0x0000)
struct DCReportPlayerChecklistSlotWidget_GetReportCheckBoxEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerChecklistSlotWidget_GetReportCheckBoxEnabled) == 0x000001, "Wrong alignment on DCReportPlayerChecklistSlotWidget_GetReportCheckBoxEnabled");
static_assert(sizeof(DCReportPlayerChecklistSlotWidget_GetReportCheckBoxEnabled) == 0x000001, "Wrong size on DCReportPlayerChecklistSlotWidget_GetReportCheckBoxEnabled");
static_assert(offsetof(DCReportPlayerChecklistSlotWidget_GetReportCheckBoxEnabled, ReturnValue) == 0x000000, "Member 'DCReportPlayerChecklistSlotWidget_GetReportCheckBoxEnabled::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerChecklistSlotWidget.GetReportedCategoryVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCReportPlayerChecklistSlotWidget_GetReportedCategoryVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerChecklistSlotWidget_GetReportedCategoryVisibility) == 0x000001, "Wrong alignment on DCReportPlayerChecklistSlotWidget_GetReportedCategoryVisibility");
static_assert(sizeof(DCReportPlayerChecklistSlotWidget_GetReportedCategoryVisibility) == 0x000001, "Wrong size on DCReportPlayerChecklistSlotWidget_GetReportedCategoryVisibility");
static_assert(offsetof(DCReportPlayerChecklistSlotWidget_GetReportedCategoryVisibility, ReturnValue) == 0x000000, "Member 'DCReportPlayerChecklistSlotWidget_GetReportedCategoryVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerChecklistSlotWidget.HandleChangedCheckState
// 0x0001 (0x0001 - 0x0000)
struct DCReportPlayerChecklistSlotWidget_HandleChangedCheckState final
{
public:
	bool                                          bNewState;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerChecklistSlotWidget_HandleChangedCheckState) == 0x000001, "Wrong alignment on DCReportPlayerChecklistSlotWidget_HandleChangedCheckState");
static_assert(sizeof(DCReportPlayerChecklistSlotWidget_HandleChangedCheckState) == 0x000001, "Wrong size on DCReportPlayerChecklistSlotWidget_HandleChangedCheckState");
static_assert(offsetof(DCReportPlayerChecklistSlotWidget_HandleChangedCheckState, bNewState) == 0x000000, "Member 'DCReportPlayerChecklistSlotWidget_HandleChangedCheckState::bNewState' has a wrong offset!");

// Function DungeonCrawler.ComboBoxWidget.AddItem
// 0x0008 (0x0008 - 0x0000)
struct ComboBoxWidget_AddItem final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboBoxWidget_AddItem) == 0x000008, "Wrong alignment on ComboBoxWidget_AddItem");
static_assert(sizeof(ComboBoxWidget_AddItem) == 0x000008, "Wrong size on ComboBoxWidget_AddItem");
static_assert(offsetof(ComboBoxWidget_AddItem, InItem) == 0x000000, "Member 'ComboBoxWidget_AddItem::InItem' has a wrong offset!");

// Function DungeonCrawler.ComboBoxWidget.GetSelectedItem
// 0x0008 (0x0008 - 0x0000)
struct ComboBoxWidget_GetSelectedItem final
{
public:
	class UObject*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboBoxWidget_GetSelectedItem) == 0x000008, "Wrong alignment on ComboBoxWidget_GetSelectedItem");
static_assert(sizeof(ComboBoxWidget_GetSelectedItem) == 0x000008, "Wrong size on ComboBoxWidget_GetSelectedItem");
static_assert(offsetof(ComboBoxWidget_GetSelectedItem, ReturnValue) == 0x000000, "Member 'ComboBoxWidget_GetSelectedItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ComboBoxWidget.OnComboItemSelected
// 0x0008 (0x0008 - 0x0000)
struct ComboBoxWidget_OnComboItemSelected final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboBoxWidget_OnComboItemSelected) == 0x000008, "Wrong alignment on ComboBoxWidget_OnComboItemSelected");
static_assert(sizeof(ComboBoxWidget_OnComboItemSelected) == 0x000008, "Wrong size on ComboBoxWidget_OnComboItemSelected");
static_assert(offsetof(ComboBoxWidget_OnComboItemSelected, InItem) == 0x000000, "Member 'ComboBoxWidget_OnComboItemSelected::InItem' has a wrong offset!");

// Function DungeonCrawler.ComboBoxWidget.RemoveItem
// 0x0008 (0x0008 - 0x0000)
struct ComboBoxWidget_RemoveItem final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboBoxWidget_RemoveItem) == 0x000008, "Wrong alignment on ComboBoxWidget_RemoveItem");
static_assert(sizeof(ComboBoxWidget_RemoveItem) == 0x000008, "Wrong size on ComboBoxWidget_RemoveItem");
static_assert(offsetof(ComboBoxWidget_RemoveItem, InItem) == 0x000000, "Member 'ComboBoxWidget_RemoveItem::InItem' has a wrong offset!");

// Function DungeonCrawler.ComboBoxWidget.SetPlaceHolderText
// 0x0018 (0x0018 - 0x0000)
struct ComboBoxWidget_SetPlaceHolderText final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboBoxWidget_SetPlaceHolderText) == 0x000008, "Wrong alignment on ComboBoxWidget_SetPlaceHolderText");
static_assert(sizeof(ComboBoxWidget_SetPlaceHolderText) == 0x000018, "Wrong size on ComboBoxWidget_SetPlaceHolderText");
static_assert(offsetof(ComboBoxWidget_SetPlaceHolderText, InText) == 0x000000, "Member 'ComboBoxWidget_SetPlaceHolderText::InText' has a wrong offset!");

// Function DungeonCrawler.ComboBoxWidget.SetSelectedIndex
// 0x0004 (0x0004 - 0x0000)
struct ComboBoxWidget_SetSelectedIndex final
{
public:
	int32                                         InIndex;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboBoxWidget_SetSelectedIndex) == 0x000004, "Wrong alignment on ComboBoxWidget_SetSelectedIndex");
static_assert(sizeof(ComboBoxWidget_SetSelectedIndex) == 0x000004, "Wrong size on ComboBoxWidget_SetSelectedIndex");
static_assert(offsetof(ComboBoxWidget_SetSelectedIndex, InIndex) == 0x000000, "Member 'ComboBoxWidget_SetSelectedIndex::InIndex' has a wrong offset!");

// Function DungeonCrawler.ComboBoxWidget.GetIndexForItem
// 0x0010 (0x0010 - 0x0000)
struct ComboBoxWidget_GetIndexForItem final
{
public:
	const class UObject*                          InItem;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A3[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ComboBoxWidget_GetIndexForItem) == 0x000008, "Wrong alignment on ComboBoxWidget_GetIndexForItem");
static_assert(sizeof(ComboBoxWidget_GetIndexForItem) == 0x000010, "Wrong size on ComboBoxWidget_GetIndexForItem");
static_assert(offsetof(ComboBoxWidget_GetIndexForItem, InItem) == 0x000000, "Member 'ComboBoxWidget_GetIndexForItem::InItem' has a wrong offset!");
static_assert(offsetof(ComboBoxWidget_GetIndexForItem, ReturnValue) == 0x000008, "Member 'ComboBoxWidget_GetIndexForItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ComboBoxWidget.GetNumItems
// 0x0004 (0x0004 - 0x0000)
struct ComboBoxWidget_GetNumItems final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ComboBoxWidget_GetNumItems) == 0x000004, "Wrong alignment on ComboBoxWidget_GetNumItems");
static_assert(sizeof(ComboBoxWidget_GetNumItems) == 0x000004, "Wrong size on ComboBoxWidget_GetNumItems");
static_assert(offsetof(ComboBoxWidget_GetNumItems, ReturnValue) == 0x000000, "Member 'ComboBoxWidget_GetNumItems::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ComboBoxWidget.IsItemSelected
// 0x0010 (0x0010 - 0x0000)
struct ComboBoxWidget_IsItemSelected final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24A4[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ComboBoxWidget_IsItemSelected) == 0x000008, "Wrong alignment on ComboBoxWidget_IsItemSelected");
static_assert(sizeof(ComboBoxWidget_IsItemSelected) == 0x000010, "Wrong size on ComboBoxWidget_IsItemSelected");
static_assert(offsetof(ComboBoxWidget_IsItemSelected, InItem) == 0x000000, "Member 'ComboBoxWidget_IsItemSelected::InItem' has a wrong offset!");
static_assert(offsetof(ComboBoxWidget_IsItemSelected, ReturnValue) == 0x000008, "Member 'ComboBoxWidget_IsItemSelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCSearchableComboBoxWidget.RegenerateListItems
// 0x0018 (0x0018 - 0x0000)
struct DCSearchableComboBoxWidget_RegenerateListItems final
{
public:
	class FText                                   FindFilter;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSearchableComboBoxWidget_RegenerateListItems) == 0x000008, "Wrong alignment on DCSearchableComboBoxWidget_RegenerateListItems");
static_assert(sizeof(DCSearchableComboBoxWidget_RegenerateListItems) == 0x000018, "Wrong size on DCSearchableComboBoxWidget_RegenerateListItems");
static_assert(offsetof(DCSearchableComboBoxWidget_RegenerateListItems, FindFilter) == 0x000000, "Member 'DCSearchableComboBoxWidget_RegenerateListItems::FindFilter' has a wrong offset!");

// Function DungeonCrawler.DCSearchableComboBoxWidget.ResetSearchText
// 0x0008 (0x0008 - 0x0000)
struct DCSearchableComboBoxWidget_ResetSearchText final
{
public:
	class UObject*                                SelectedItem;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSearchableComboBoxWidget_ResetSearchText) == 0x000008, "Wrong alignment on DCSearchableComboBoxWidget_ResetSearchText");
static_assert(sizeof(DCSearchableComboBoxWidget_ResetSearchText) == 0x000008, "Wrong size on DCSearchableComboBoxWidget_ResetSearchText");
static_assert(offsetof(DCSearchableComboBoxWidget_ResetSearchText, SelectedItem) == 0x000000, "Member 'DCSearchableComboBoxWidget_ResetSearchText::SelectedItem' has a wrong offset!");

// Function DungeonCrawler.DCSearchableComboBoxWidget.UpdateFilterTitle
// 0x0008 (0x0008 - 0x0000)
struct DCSearchableComboBoxWidget_UpdateFilterTitle final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSearchableComboBoxWidget_UpdateFilterTitle) == 0x000008, "Wrong alignment on DCSearchableComboBoxWidget_UpdateFilterTitle");
static_assert(sizeof(DCSearchableComboBoxWidget_UpdateFilterTitle) == 0x000008, "Wrong size on DCSearchableComboBoxWidget_UpdateFilterTitle");
static_assert(offsetof(DCSearchableComboBoxWidget_UpdateFilterTitle, InItem) == 0x000000, "Member 'DCSearchableComboBoxWidget_UpdateFilterTitle::InItem' has a wrong offset!");

// Function DungeonCrawler.ClassSelectWidget.OnGenderClicked
// 0x0001 (0x0001 - 0x0000)
struct ClassSelectWidget_OnGenderClicked final
{
public:
	EDCGender                                     InGender;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassSelectWidget_OnGenderClicked) == 0x000001, "Wrong alignment on ClassSelectWidget_OnGenderClicked");
static_assert(sizeof(ClassSelectWidget_OnGenderClicked) == 0x000001, "Wrong size on ClassSelectWidget_OnGenderClicked");
static_assert(offsetof(ClassSelectWidget_OnGenderClicked, InGender) == 0x000000, "Member 'ClassSelectWidget_OnGenderClicked::InGender' has a wrong offset!");

// Function DungeonCrawler.ClassShapeShiftComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct ClassShapeShiftComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassShapeShiftComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on ClassShapeShiftComponent_BroadcastMsgBlueprint");
static_assert(sizeof(ClassShapeShiftComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on ClassShapeShiftComponent_BroadcastMsgBlueprint");
static_assert(offsetof(ClassShapeShiftComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'ClassShapeShiftComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClassShapeShiftComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct ClassShapeShiftComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassShapeShiftComponent_UnbindMsg) == 0x000008, "Wrong alignment on ClassShapeShiftComponent_UnbindMsg");
static_assert(sizeof(ClassShapeShiftComponent_UnbindMsg) == 0x000010, "Wrong size on ClassShapeShiftComponent_UnbindMsg");
static_assert(offsetof(ClassShapeShiftComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'ClassShapeShiftComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(ClassShapeShiftComponent_UnbindMsg, InObject) == 0x000008, "Member 'ClassShapeShiftComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.ClassShapeShiftComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct ClassShapeShiftComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassShapeShiftComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on ClassShapeShiftComponent_UnbindMsgAll");
static_assert(sizeof(ClassShapeShiftComponent_UnbindMsgAll) == 0x000008, "Wrong size on ClassShapeShiftComponent_UnbindMsgAll");
static_assert(offsetof(ClassShapeShiftComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'ClassShapeShiftComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCReligionWidget.OnReligionKillDataEvent
// 0x0010 (0x0010 - 0x0000)
struct DCReligionWidget_OnReligionKillDataEvent final
{
public:
	TArray<struct FDCReligionKillnfo>             Info;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionWidget_OnReligionKillDataEvent) == 0x000008, "Wrong alignment on DCReligionWidget_OnReligionKillDataEvent");
static_assert(sizeof(DCReligionWidget_OnReligionKillDataEvent) == 0x000010, "Wrong size on DCReligionWidget_OnReligionKillDataEvent");
static_assert(offsetof(DCReligionWidget_OnReligionKillDataEvent, Info) == 0x000000, "Member 'DCReligionWidget_OnReligionKillDataEvent::Info' has a wrong offset!");

// Function DungeonCrawler.DCReligionWidget.OnSeasonComboBoxSelected
// 0x0008 (0x0008 - 0x0000)
struct DCReligionWidget_OnSeasonComboBoxSelected final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionWidget_OnSeasonComboBoxSelected) == 0x000008, "Wrong alignment on DCReligionWidget_OnSeasonComboBoxSelected");
static_assert(sizeof(DCReligionWidget_OnSeasonComboBoxSelected) == 0x000008, "Wrong size on DCReligionWidget_OnSeasonComboBoxSelected");
static_assert(offsetof(DCReligionWidget_OnSeasonComboBoxSelected, InItem) == 0x000000, "Member 'DCReligionWidget_OnSeasonComboBoxSelected::InItem' has a wrong offset!");

// Function DungeonCrawler.DCReligionWidget.SetReligionTimer
// 0x0010 (0x0010 - 0x0000)
struct DCReligionWidget_SetReligionTimer final
{
public:
	struct FReligionRankTimerInfo                 Info;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionWidget_SetReligionTimer) == 0x000004, "Wrong alignment on DCReligionWidget_SetReligionTimer");
static_assert(sizeof(DCReligionWidget_SetReligionTimer) == 0x000010, "Wrong size on DCReligionWidget_SetReligionTimer");
static_assert(offsetof(DCReligionWidget_SetReligionTimer, Info) == 0x000000, "Member 'DCReligionWidget_SetReligionTimer::Info' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCCharacterBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCCharacterBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCCharacterBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCCharacterBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCCharacterBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCCharacterBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.GameplayTagUpdated
// 0x000C (0x000C - 0x0000)
struct DCCharacterBase_GameplayTagUpdated final
{
public:
	struct FGameplayTag                           InGameplayTag;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_GameplayTagUpdated) == 0x000004, "Wrong alignment on DCCharacterBase_GameplayTagUpdated");
static_assert(sizeof(DCCharacterBase_GameplayTagUpdated) == 0x00000C, "Wrong size on DCCharacterBase_GameplayTagUpdated");
static_assert(offsetof(DCCharacterBase_GameplayTagUpdated, InGameplayTag) == 0x000000, "Member 'DCCharacterBase_GameplayTagUpdated::InGameplayTag' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_GameplayTagUpdated, InCount) == 0x000008, "Member 'DCCharacterBase_GameplayTagUpdated::InCount' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.GetCameraComponent
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterBase_GetCameraComponent final
{
public:
	class UCameraComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_GetCameraComponent) == 0x000008, "Wrong alignment on DCCharacterBase_GetCameraComponent");
static_assert(sizeof(DCCharacterBase_GetCameraComponent) == 0x000008, "Wrong size on DCCharacterBase_GetCameraComponent");
static_assert(offsetof(DCCharacterBase_GetCameraComponent, ReturnValue) == 0x000000, "Member 'DCCharacterBase_GetCameraComponent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.GetCapsuleBottomLocation
// 0x0018 (0x0018 - 0x0000)
struct DCCharacterBase_GetCapsuleBottomLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_GetCapsuleBottomLocation) == 0x000008, "Wrong alignment on DCCharacterBase_GetCapsuleBottomLocation");
static_assert(sizeof(DCCharacterBase_GetCapsuleBottomLocation) == 0x000018, "Wrong size on DCCharacterBase_GetCapsuleBottomLocation");
static_assert(offsetof(DCCharacterBase_GetCapsuleBottomLocation, ReturnValue) == 0x000000, "Member 'DCCharacterBase_GetCapsuleBottomLocation::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.GetCapsuleTopLocation
// 0x0018 (0x0018 - 0x0000)
struct DCCharacterBase_GetCapsuleTopLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_GetCapsuleTopLocation) == 0x000008, "Wrong alignment on DCCharacterBase_GetCapsuleTopLocation");
static_assert(sizeof(DCCharacterBase_GetCapsuleTopLocation) == 0x000018, "Wrong size on DCCharacterBase_GetCapsuleTopLocation");
static_assert(offsetof(DCCharacterBase_GetCapsuleTopLocation, ReturnValue) == 0x000000, "Member 'DCCharacterBase_GetCapsuleTopLocation::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.GetPerspectiveCameraComponent
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterBase_GetPerspectiveCameraComponent final
{
public:
	bool                                          bFirstPersonPerspective;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24B8[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_GetPerspectiveCameraComponent) == 0x000008, "Wrong alignment on DCCharacterBase_GetPerspectiveCameraComponent");
static_assert(sizeof(DCCharacterBase_GetPerspectiveCameraComponent) == 0x000010, "Wrong size on DCCharacterBase_GetPerspectiveCameraComponent");
static_assert(offsetof(DCCharacterBase_GetPerspectiveCameraComponent, bFirstPersonPerspective) == 0x000000, "Member 'DCCharacterBase_GetPerspectiveCameraComponent::bFirstPersonPerspective' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_GetPerspectiveCameraComponent, ReturnValue) == 0x000008, "Member 'DCCharacterBase_GetPerspectiveCameraComponent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.InteractFound
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterBase_InteractFound final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    InteractPart;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_InteractFound) == 0x000008, "Wrong alignment on DCCharacterBase_InteractFound");
static_assert(sizeof(DCCharacterBase_InteractFound) == 0x000010, "Wrong size on DCCharacterBase_InteractFound");
static_assert(offsetof(DCCharacterBase_InteractFound, Interacter) == 0x000000, "Member 'DCCharacterBase_InteractFound::Interacter' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_InteractFound, InteractPart) == 0x000008, "Member 'DCCharacterBase_InteractFound::InteractPart' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.InteractLost
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterBase_InteractLost final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_InteractLost) == 0x000008, "Wrong alignment on DCCharacterBase_InteractLost");
static_assert(sizeof(DCCharacterBase_InteractLost) == 0x000008, "Wrong size on DCCharacterBase_InteractLost");
static_assert(offsetof(DCCharacterBase_InteractLost, Interacter) == 0x000000, "Member 'DCCharacterBase_InteractLost::Interacter' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.InteractSucceed
// 0x0100 (0x0100 - 0x0000)
struct DCCharacterBase_InteractSucceed final
{
public:
	class AActor*                                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StateTag;                                          // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TriggerTag;                                        // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0018(0x00E8)(Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_InteractSucceed) == 0x000008, "Wrong alignment on DCCharacterBase_InteractSucceed");
static_assert(sizeof(DCCharacterBase_InteractSucceed) == 0x000100, "Wrong size on DCCharacterBase_InteractSucceed");
static_assert(offsetof(DCCharacterBase_InteractSucceed, Interacter) == 0x000000, "Member 'DCCharacterBase_InteractSucceed::Interacter' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_InteractSucceed, StateTag) == 0x000008, "Member 'DCCharacterBase_InteractSucceed::StateTag' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_InteractSucceed, TriggerTag) == 0x000010, "Member 'DCCharacterBase_InteractSucceed::TriggerTag' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_InteractSucceed, HitResult) == 0x000018, "Member 'DCCharacterBase_InteractSucceed::HitResult' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.OnCharacterMoved
// 0x0038 (0x0038 - 0x0000)
struct DCCharacterBase_OnCharacterMoved final
{
public:
	float                                         InDeltaSeconds;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24B9[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InOldLocation;                                     // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InOldVelocity;                                     // 0x0020(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_OnCharacterMoved) == 0x000008, "Wrong alignment on DCCharacterBase_OnCharacterMoved");
static_assert(sizeof(DCCharacterBase_OnCharacterMoved) == 0x000038, "Wrong size on DCCharacterBase_OnCharacterMoved");
static_assert(offsetof(DCCharacterBase_OnCharacterMoved, InDeltaSeconds) == 0x000000, "Member 'DCCharacterBase_OnCharacterMoved::InDeltaSeconds' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_OnCharacterMoved, InOldLocation) == 0x000008, "Member 'DCCharacterBase_OnCharacterMoved::InOldLocation' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_OnCharacterMoved, InOldVelocity) == 0x000020, "Member 'DCCharacterBase_OnCharacterMoved::InOldVelocity' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.OnFMsgGASActorDieNotifyBlueprint
// 0x06E8 (0x06E8 - 0x0000)
struct DCCharacterBase_OnFMsgGASActorDieNotifyBlueprint final
{
public:
	struct FMsgGASActorDieNotify                  InMsg;                                             // 0x0000(0x06E8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_OnFMsgGASActorDieNotifyBlueprint) == 0x000008, "Wrong alignment on DCCharacterBase_OnFMsgGASActorDieNotifyBlueprint");
static_assert(sizeof(DCCharacterBase_OnFMsgGASActorDieNotifyBlueprint) == 0x0006E8, "Wrong size on DCCharacterBase_OnFMsgGASActorDieNotifyBlueprint");
static_assert(offsetof(DCCharacterBase_OnFMsgGASActorDieNotifyBlueprint, InMsg) == 0x000000, "Member 'DCCharacterBase_OnFMsgGASActorDieNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.OnGameState
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterBase_OnGameState final
{
public:
	struct FGameStateData                         InGameStateData;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_OnGameState) == 0x000004, "Wrong alignment on DCCharacterBase_OnGameState");
static_assert(sizeof(DCCharacterBase_OnGameState) == 0x000008, "Wrong size on DCCharacterBase_OnGameState");
static_assert(offsetof(DCCharacterBase_OnGameState, InGameStateData) == 0x000000, "Member 'DCCharacterBase_OnGameState::InGameStateData' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.OnRep_AccountId
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterBase_OnRep_AccountId final
{
public:
	class FString                                 OldAccountId;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_OnRep_AccountId) == 0x000008, "Wrong alignment on DCCharacterBase_OnRep_AccountId");
static_assert(sizeof(DCCharacterBase_OnRep_AccountId) == 0x000010, "Wrong size on DCCharacterBase_OnRep_AccountId");
static_assert(offsetof(DCCharacterBase_OnRep_AccountId, OldAccountId) == 0x000000, "Member 'DCCharacterBase_OnRep_AccountId::OldAccountId' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.OnSetPerspective
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterBase_OnSetPerspective final
{
public:
	class APlayerController*                      InPlayerController;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIsFirstPersonPerspective;                       // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24BA[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCCharacterBase_OnSetPerspective) == 0x000008, "Wrong alignment on DCCharacterBase_OnSetPerspective");
static_assert(sizeof(DCCharacterBase_OnSetPerspective) == 0x000010, "Wrong size on DCCharacterBase_OnSetPerspective");
static_assert(offsetof(DCCharacterBase_OnSetPerspective, InPlayerController) == 0x000000, "Member 'DCCharacterBase_OnSetPerspective::InPlayerController' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_OnSetPerspective, bInIsFirstPersonPerspective) == 0x000008, "Member 'DCCharacterBase_OnSetPerspective::bInIsFirstPersonPerspective' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.OnTarget
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterBase_OnTarget final
{
public:
	bool                                          bTarget;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_OnTarget) == 0x000001, "Wrong alignment on DCCharacterBase_OnTarget");
static_assert(sizeof(DCCharacterBase_OnTarget) == 0x000001, "Wrong size on DCCharacterBase_OnTarget");
static_assert(offsetof(DCCharacterBase_OnTarget, bTarget) == 0x000000, "Member 'DCCharacterBase_OnTarget::bTarget' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.OnUpdateTeammateState
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterBase_OnUpdateTeammateState final
{
public:
	bool                                          bIsTeammateWithLocalPlayer;                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_OnUpdateTeammateState) == 0x000001, "Wrong alignment on DCCharacterBase_OnUpdateTeammateState");
static_assert(sizeof(DCCharacterBase_OnUpdateTeammateState) == 0x000001, "Wrong size on DCCharacterBase_OnUpdateTeammateState");
static_assert(offsetof(DCCharacterBase_OnUpdateTeammateState, bIsTeammateWithLocalPlayer) == 0x000000, "Member 'DCCharacterBase_OnUpdateTeammateState::bIsTeammateWithLocalPlayer' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.ServerSetRemoteViewYaw
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterBase_ServerSetRemoteViewYaw final
{
public:
	uint8                                         InRemoteViewYaw;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_ServerSetRemoteViewYaw) == 0x000001, "Wrong alignment on DCCharacterBase_ServerSetRemoteViewYaw");
static_assert(sizeof(DCCharacterBase_ServerSetRemoteViewYaw) == 0x000001, "Wrong size on DCCharacterBase_ServerSetRemoteViewYaw");
static_assert(offsetof(DCCharacterBase_ServerSetRemoteViewYaw, InRemoteViewYaw) == 0x000000, "Member 'DCCharacterBase_ServerSetRemoteViewYaw::InRemoteViewYaw' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.SetForceHide
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterBase_SetForceHide final
{
public:
	bool                                          bInForceHide;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_SetForceHide) == 0x000001, "Wrong alignment on DCCharacterBase_SetForceHide");
static_assert(sizeof(DCCharacterBase_SetForceHide) == 0x000001, "Wrong size on DCCharacterBase_SetForceHide");
static_assert(offsetof(DCCharacterBase_SetForceHide, bInForceHide) == 0x000000, "Member 'DCCharacterBase_SetForceHide::bInForceHide' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.SetGenericTeamId
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterBase_SetGenericTeamId final
{
public:
	struct FGenericTeamId                         TeamID;                                            // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_SetGenericTeamId) == 0x000001, "Wrong alignment on DCCharacterBase_SetGenericTeamId");
static_assert(sizeof(DCCharacterBase_SetGenericTeamId) == 0x000001, "Wrong size on DCCharacterBase_SetGenericTeamId");
static_assert(offsetof(DCCharacterBase_SetGenericTeamId, TeamID) == 0x000000, "Member 'DCCharacterBase_SetGenericTeamId::TeamID' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.SetIsDead
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterBase_SetIsDead final
{
public:
	bool                                          IsDead;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_SetIsDead) == 0x000001, "Wrong alignment on DCCharacterBase_SetIsDead");
static_assert(sizeof(DCCharacterBase_SetIsDead) == 0x000001, "Wrong size on DCCharacterBase_SetIsDead");
static_assert(offsetof(DCCharacterBase_SetIsDead, IsDead) == 0x000000, "Member 'DCCharacterBase_SetIsDead::IsDead' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.StartInspecting
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterBase_StartInspecting final
{
public:
	class ADCCharacterBase*                       Inspector;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_StartInspecting) == 0x000008, "Wrong alignment on DCCharacterBase_StartInspecting");
static_assert(sizeof(DCCharacterBase_StartInspecting) == 0x000008, "Wrong size on DCCharacterBase_StartInspecting");
static_assert(offsetof(DCCharacterBase_StartInspecting, Inspector) == 0x000000, "Member 'DCCharacterBase_StartInspecting::Inspector' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.StartLooting
// 0x00F0 (0x00F0 - 0x0000)
struct DCCharacterBase_StartLooting final
{
public:
	class ADCPlayerCharacterBase*                 Looter;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0008(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_StartLooting) == 0x000008, "Wrong alignment on DCCharacterBase_StartLooting");
static_assert(sizeof(DCCharacterBase_StartLooting) == 0x0000F0, "Wrong size on DCCharacterBase_StartLooting");
static_assert(offsetof(DCCharacterBase_StartLooting, Looter) == 0x000000, "Member 'DCCharacterBase_StartLooting::Looter' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_StartLooting, HitResult) == 0x000008, "Member 'DCCharacterBase_StartLooting::HitResult' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_UnbindMsg) == 0x000008, "Wrong alignment on DCCharacterBase_UnbindMsg");
static_assert(sizeof(DCCharacterBase_UnbindMsg) == 0x000010, "Wrong size on DCCharacterBase_UnbindMsg");
static_assert(offsetof(DCCharacterBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCCharacterBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_UnbindMsg, InObject) == 0x000008, "Member 'DCCharacterBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCCharacterBase_UnbindMsgAll");
static_assert(sizeof(DCCharacterBase_UnbindMsgAll) == 0x000008, "Wrong size on DCCharacterBase_UnbindMsgAll");
static_assert(offsetof(DCCharacterBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCCharacterBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.GetAccountId
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterBase_GetAccountId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_GetAccountId) == 0x000008, "Wrong alignment on DCCharacterBase_GetAccountId");
static_assert(sizeof(DCCharacterBase_GetAccountId) == 0x000010, "Wrong size on DCCharacterBase_GetAccountId");
static_assert(offsetof(DCCharacterBase_GetAccountId, ReturnValue) == 0x000000, "Member 'DCCharacterBase_GetAccountId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.GetGenericTeamId
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterBase_GetGenericTeamId final
{
public:
	struct FGenericTeamId                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_GetGenericTeamId) == 0x000001, "Wrong alignment on DCCharacterBase_GetGenericTeamId");
static_assert(sizeof(DCCharacterBase_GetGenericTeamId) == 0x000001, "Wrong size on DCCharacterBase_GetGenericTeamId");
static_assert(offsetof(DCCharacterBase_GetGenericTeamId, ReturnValue) == 0x000000, "Member 'DCCharacterBase_GetGenericTeamId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.GetHitBoxLocation
// 0x0028 (0x0028 - 0x0000)
struct DCCharacterBase_GetHitBoxLocation final
{
public:
	EHitBoxType                                   HitBoxType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24BB[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24BC[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCCharacterBase_GetHitBoxLocation) == 0x000008, "Wrong alignment on DCCharacterBase_GetHitBoxLocation");
static_assert(sizeof(DCCharacterBase_GetHitBoxLocation) == 0x000028, "Wrong size on DCCharacterBase_GetHitBoxLocation");
static_assert(offsetof(DCCharacterBase_GetHitBoxLocation, HitBoxType) == 0x000000, "Member 'DCCharacterBase_GetHitBoxLocation::HitBoxType' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_GetHitBoxLocation, Location) == 0x000008, "Member 'DCCharacterBase_GetHitBoxLocation::Location' has a wrong offset!");
static_assert(offsetof(DCCharacterBase_GetHitBoxLocation, ReturnValue) == 0x000020, "Member 'DCCharacterBase_GetHitBoxLocation::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.GetNickNameCached
// 0x0040 (0x0040 - 0x0000)
struct DCCharacterBase_GetNickNameCached final
{
public:
	struct FNickname                              ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_GetNickNameCached) == 0x000008, "Wrong alignment on DCCharacterBase_GetNickNameCached");
static_assert(sizeof(DCCharacterBase_GetNickNameCached) == 0x000040, "Wrong size on DCCharacterBase_GetNickNameCached");
static_assert(offsetof(DCCharacterBase_GetNickNameCached, ReturnValue) == 0x000000, "Member 'DCCharacterBase_GetNickNameCached::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.GetPartyIdString
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterBase_GetPartyIdString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_GetPartyIdString) == 0x000008, "Wrong alignment on DCCharacterBase_GetPartyIdString");
static_assert(sizeof(DCCharacterBase_GetPartyIdString) == 0x000010, "Wrong size on DCCharacterBase_GetPartyIdString");
static_assert(offsetof(DCCharacterBase_GetPartyIdString, ReturnValue) == 0x000000, "Member 'DCCharacterBase_GetPartyIdString::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.IsDead
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterBase_IsDead final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_IsDead) == 0x000001, "Wrong alignment on DCCharacterBase_IsDead");
static_assert(sizeof(DCCharacterBase_IsDead) == 0x000001, "Wrong size on DCCharacterBase_IsDead");
static_assert(offsetof(DCCharacterBase_IsDead, ReturnValue) == 0x000000, "Member 'DCCharacterBase_IsDead::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterBase.IsInFirstPersonPerspective
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterBase_IsInFirstPersonPerspective final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterBase_IsInFirstPersonPerspective) == 0x000001, "Wrong alignment on DCCharacterBase_IsInFirstPersonPerspective");
static_assert(sizeof(DCCharacterBase_IsInFirstPersonPerspective) == 0x000001, "Wrong size on DCCharacterBase_IsInFirstPersonPerspective");
static_assert(offsetof(DCCharacterBase_IsInFirstPersonPerspective, ReturnValue) == 0x000000, "Member 'DCCharacterBase_IsInFirstPersonPerspective::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCClassTrainingWidgetBase.OnCanRedeemLearnTokenEnabled
// 0x0001 (0x0001 - 0x0000)
struct DCClassTrainingWidgetBase_OnCanRedeemLearnTokenEnabled final
{
public:
	bool                                          bCanRedeem;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCClassTrainingWidgetBase_OnCanRedeemLearnTokenEnabled) == 0x000001, "Wrong alignment on DCClassTrainingWidgetBase_OnCanRedeemLearnTokenEnabled");
static_assert(sizeof(DCClassTrainingWidgetBase_OnCanRedeemLearnTokenEnabled) == 0x000001, "Wrong size on DCClassTrainingWidgetBase_OnCanRedeemLearnTokenEnabled");
static_assert(offsetof(DCClassTrainingWidgetBase_OnCanRedeemLearnTokenEnabled, bCanRedeem) == 0x000000, "Member 'DCClassTrainingWidgetBase_OnCanRedeemLearnTokenEnabled::bCanRedeem' has a wrong offset!");

// Function DungeonCrawler.DCClassTrainingWidgetBase.OnTrainingStateUpdated
// 0x0001 (0x0001 - 0x0000)
struct DCClassTrainingWidgetBase_OnTrainingStateUpdated final
{
public:
	EDCTrainingState                              InTrainingState;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCClassTrainingWidgetBase_OnTrainingStateUpdated) == 0x000001, "Wrong alignment on DCClassTrainingWidgetBase_OnTrainingStateUpdated");
static_assert(sizeof(DCClassTrainingWidgetBase_OnTrainingStateUpdated) == 0x000001, "Wrong size on DCClassTrainingWidgetBase_OnTrainingStateUpdated");
static_assert(offsetof(DCClassTrainingWidgetBase_OnTrainingStateUpdated, InTrainingState) == 0x000000, "Member 'DCClassTrainingWidgetBase_OnTrainingStateUpdated::InTrainingState' has a wrong offset!");

// Function DungeonCrawler.ClassSkillListWidgetBase.GetSelectedSlotIndex
// 0x0004 (0x0004 - 0x0000)
struct ClassSkillListWidgetBase_GetSelectedSlotIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassSkillListWidgetBase_GetSelectedSlotIndex) == 0x000004, "Wrong alignment on ClassSkillListWidgetBase_GetSelectedSlotIndex");
static_assert(sizeof(ClassSkillListWidgetBase_GetSelectedSlotIndex) == 0x000004, "Wrong size on ClassSkillListWidgetBase_GetSelectedSlotIndex");
static_assert(offsetof(ClassSkillListWidgetBase_GetSelectedSlotIndex, ReturnValue) == 0x000000, "Member 'ClassSkillListWidgetBase_GetSelectedSlotIndex::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ClassSkillListWidgetBase.GetSelectedSlotSkillId
// 0x0010 (0x0010 - 0x0000)
struct ClassSkillListWidgetBase_GetSelectedSlotSkillId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassSkillListWidgetBase_GetSelectedSlotSkillId) == 0x000004, "Wrong alignment on ClassSkillListWidgetBase_GetSelectedSlotSkillId");
static_assert(sizeof(ClassSkillListWidgetBase_GetSelectedSlotSkillId) == 0x000010, "Wrong size on ClassSkillListWidgetBase_GetSelectedSlotSkillId");
static_assert(offsetof(ClassSkillListWidgetBase_GetSelectedSlotSkillId, ReturnValue) == 0x000000, "Member 'ClassSkillListWidgetBase_GetSelectedSlotSkillId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint
// 0x0020 (0x0020 - 0x0000)
struct ClassSkillListWidgetBase_OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint final
{
public:
	struct FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassSkillListWidgetBase_OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint) == 0x000008, "Wrong alignment on ClassSkillListWidgetBase_OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint");
static_assert(sizeof(ClassSkillListWidgetBase_OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint) == 0x000020, "Wrong size on ClassSkillListWidgetBase_OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint");
static_assert(offsetof(ClassSkillListWidgetBase_OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint, InMsg) == 0x000000, "Member 'ClassSkillListWidgetBase_OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint
// 0x0080 (0x0080 - 0x0000)
struct ClassSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint final
{
public:
	struct FMsgWidgetClassLevelNotify             InMsg;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint) == 0x000008, "Wrong alignment on ClassSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint");
static_assert(sizeof(ClassSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint) == 0x000080, "Wrong size on ClassSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint");
static_assert(offsetof(ClassSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint, InMsg) == 0x000000, "Member 'ClassSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint
// 0x0038 (0x0038 - 0x0000)
struct ClassSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint final
{
public:
	struct FMsgWidgetClassSlotUnLockLevelNotify   InMsg;                                             // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint) == 0x000008, "Wrong alignment on ClassSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");
static_assert(sizeof(ClassSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint) == 0x000038, "Wrong size on ClassSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");
static_assert(offsetof(ClassSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint, InMsg) == 0x000000, "Member 'ClassSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClassSkillListWidgetBase.SetSelectedSlotIndex
// 0x0004 (0x0004 - 0x0000)
struct ClassSkillListWidgetBase_SetSelectedSlotIndex final
{
public:
	int32                                         InSlotIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassSkillListWidgetBase_SetSelectedSlotIndex) == 0x000004, "Wrong alignment on ClassSkillListWidgetBase_SetSelectedSlotIndex");
static_assert(sizeof(ClassSkillListWidgetBase_SetSelectedSlotIndex) == 0x000004, "Wrong size on ClassSkillListWidgetBase_SetSelectedSlotIndex");
static_assert(offsetof(ClassSkillListWidgetBase_SetSelectedSlotIndex, InSlotIndex) == 0x000000, "Member 'ClassSkillListWidgetBase_SetSelectedSlotIndex::InSlotIndex' has a wrong offset!");

// Function DungeonCrawler.DCShopConfirmPurchasePopupBase.GetBluestoneShardVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCShopConfirmPurchasePopupBase_GetBluestoneShardVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopConfirmPurchasePopupBase_GetBluestoneShardVisibility) == 0x000001, "Wrong alignment on DCShopConfirmPurchasePopupBase_GetBluestoneShardVisibility");
static_assert(sizeof(DCShopConfirmPurchasePopupBase_GetBluestoneShardVisibility) == 0x000001, "Wrong size on DCShopConfirmPurchasePopupBase_GetBluestoneShardVisibility");
static_assert(offsetof(DCShopConfirmPurchasePopupBase_GetBluestoneShardVisibility, ReturnValue) == 0x000000, "Member 'DCShopConfirmPurchasePopupBase_GetBluestoneShardVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopConfirmPurchasePopupBase.GetRedstoneShardVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCShopConfirmPurchasePopupBase_GetRedstoneShardVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopConfirmPurchasePopupBase_GetRedstoneShardVisibility) == 0x000001, "Wrong alignment on DCShopConfirmPurchasePopupBase_GetRedstoneShardVisibility");
static_assert(sizeof(DCShopConfirmPurchasePopupBase_GetRedstoneShardVisibility) == 0x000001, "Wrong size on DCShopConfirmPurchasePopupBase_GetRedstoneShardVisibility");
static_assert(offsetof(DCShopConfirmPurchasePopupBase_GetRedstoneShardVisibility, ReturnValue) == 0x000000, "Member 'DCShopConfirmPurchasePopupBase_GetRedstoneShardVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SpellSlotWidgetBase.OnSetSpellArtData
// 0x0008 (0x0008 - 0x0000)
struct SpellSlotWidgetBase_OnSetSpellArtData final
{
public:
	const class UArtDataSpell*                    InArtSpellData;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellSlotWidgetBase_OnSetSpellArtData) == 0x000008, "Wrong alignment on SpellSlotWidgetBase_OnSetSpellArtData");
static_assert(sizeof(SpellSlotWidgetBase_OnSetSpellArtData) == 0x000008, "Wrong size on SpellSlotWidgetBase_OnSetSpellArtData");
static_assert(offsetof(SpellSlotWidgetBase_OnSetSpellArtData, InArtSpellData) == 0x000000, "Member 'SpellSlotWidgetBase_OnSetSpellArtData::InArtSpellData' has a wrong offset!");

// Function DungeonCrawler.SpellSlotWidgetBase.OnSpellDataChanged
// 0x0118 (0x0118 - 0x0000)
struct SpellSlotWidgetBase_OnSpellDataChanged final
{
public:
	struct FSpellData                             InSpellData;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDesignDataSpell                       InDesignDataSpell;                                 // 0x0040(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellSlotWidgetBase_OnSpellDataChanged) == 0x000008, "Wrong alignment on SpellSlotWidgetBase_OnSpellDataChanged");
static_assert(sizeof(SpellSlotWidgetBase_OnSpellDataChanged) == 0x000118, "Wrong size on SpellSlotWidgetBase_OnSpellDataChanged");
static_assert(offsetof(SpellSlotWidgetBase_OnSpellDataChanged, InSpellData) == 0x000000, "Member 'SpellSlotWidgetBase_OnSpellDataChanged::InSpellData' has a wrong offset!");
static_assert(offsetof(SpellSlotWidgetBase_OnSpellDataChanged, InDesignDataSpell) == 0x000040, "Member 'SpellSlotWidgetBase_OnSpellDataChanged::InDesignDataSpell' has a wrong offset!");

// Function DungeonCrawler.SpellSlotWidgetBase.SetSpellData
// 0x0118 (0x0118 - 0x0000)
struct SpellSlotWidgetBase_SetSpellData final
{
public:
	struct FSpellData                             InSpellData;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDesignDataSpell                       InDesignDataSpell;                                 // 0x0040(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellSlotWidgetBase_SetSpellData) == 0x000008, "Wrong alignment on SpellSlotWidgetBase_SetSpellData");
static_assert(sizeof(SpellSlotWidgetBase_SetSpellData) == 0x000118, "Wrong size on SpellSlotWidgetBase_SetSpellData");
static_assert(offsetof(SpellSlotWidgetBase_SetSpellData, InSpellData) == 0x000000, "Member 'SpellSlotWidgetBase_SetSpellData::InSpellData' has a wrong offset!");
static_assert(offsetof(SpellSlotWidgetBase_SetSpellData, InDesignDataSpell) == 0x000040, "Member 'SpellSlotWidgetBase_SetSpellData::InDesignDataSpell' has a wrong offset!");

// Function DungeonCrawler.SkillActor.OnRep_SkillData
// 0x0030 (0x0030 - 0x0000)
struct SkillActor_OnRep_SkillData final
{
public:
	struct FSkillData                             OldSkillData;                                      // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillActor_OnRep_SkillData) == 0x000004, "Wrong alignment on SkillActor_OnRep_SkillData");
static_assert(sizeof(SkillActor_OnRep_SkillData) == 0x000030, "Wrong size on SkillActor_OnRep_SkillData");
static_assert(offsetof(SkillActor_OnRep_SkillData, OldSkillData) == 0x000000, "Member 'SkillActor_OnRep_SkillData::OldSkillData' has a wrong offset!");

// Function DungeonCrawler.SkillActor.GetArtDataSkill
// 0x0008 (0x0008 - 0x0000)
struct SkillActor_GetArtDataSkill final
{
public:
	class UArtDataSkill*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillActor_GetArtDataSkill) == 0x000008, "Wrong alignment on SkillActor_GetArtDataSkill");
static_assert(sizeof(SkillActor_GetArtDataSkill) == 0x000008, "Wrong size on SkillActor_GetArtDataSkill");
static_assert(offsetof(SkillActor_GetArtDataSkill, ReturnValue) == 0x000000, "Member 'SkillActor_GetArtDataSkill::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SkillActor.GetDesignDataSkill
// 0x00E0 (0x00E0 - 0x0000)
struct SkillActor_GetDesignDataSkill final
{
public:
	struct FDesignDataSkill                       ReturnValue;                                       // 0x0000(0x00E0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillActor_GetDesignDataSkill) == 0x000008, "Wrong alignment on SkillActor_GetDesignDataSkill");
static_assert(sizeof(SkillActor_GetDesignDataSkill) == 0x0000E0, "Wrong size on SkillActor_GetDesignDataSkill");
static_assert(offsetof(SkillActor_GetDesignDataSkill, ReturnValue) == 0x000000, "Member 'SkillActor_GetDesignDataSkill::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SkillActor.GetSkillData
// 0x0030 (0x0030 - 0x0000)
struct SkillActor_GetSkillData final
{
public:
	struct FSkillData                             ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillActor_GetSkillData) == 0x000004, "Wrong alignment on SkillActor_GetSkillData");
static_assert(sizeof(SkillActor_GetSkillData) == 0x000030, "Wrong size on SkillActor_GetSkillData");
static_assert(offsetof(SkillActor_GetSkillData, ReturnValue) == 0x000000, "Member 'SkillActor_GetSkillData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SkillActor.GetSoundDataSkill
// 0x0008 (0x0008 - 0x0000)
struct SkillActor_GetSoundDataSkill final
{
public:
	class USoundData*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillActor_GetSoundDataSkill) == 0x000008, "Wrong alignment on SkillActor_GetSoundDataSkill");
static_assert(sizeof(SkillActor_GetSoundDataSkill) == 0x000008, "Wrong size on SkillActor_GetSoundDataSkill");
static_assert(offsetof(SkillActor_GetSoundDataSkill, ReturnValue) == 0x000000, "Member 'SkillActor_GetSoundDataSkill::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCSessionRuleComponent.OnBlizzardData
// 0x0040 (0x0040 - 0x0000)
struct DCSessionRuleComponent_OnBlizzardData final
{
public:
	struct FGameBlizzardData                      InBlizzardData;                                    // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSessionRuleComponent_OnBlizzardData) == 0x000008, "Wrong alignment on DCSessionRuleComponent_OnBlizzardData");
static_assert(sizeof(DCSessionRuleComponent_OnBlizzardData) == 0x000040, "Wrong size on DCSessionRuleComponent_OnBlizzardData");
static_assert(offsetof(DCSessionRuleComponent_OnBlizzardData, InBlizzardData) == 0x000000, "Member 'DCSessionRuleComponent_OnBlizzardData::InBlizzardData' has a wrong offset!");

// Function DungeonCrawler.DCSessionRuleComponent.OnDeathSwarmData
// 0x0080 (0x0080 - 0x0000)
struct DCSessionRuleComponent_OnDeathSwarmData final
{
public:
	struct FGameDeathSwarmData                    InDeathSwarmData;                                  // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSessionRuleComponent_OnDeathSwarmData) == 0x000008, "Wrong alignment on DCSessionRuleComponent_OnDeathSwarmData");
static_assert(sizeof(DCSessionRuleComponent_OnDeathSwarmData) == 0x000080, "Wrong size on DCSessionRuleComponent_OnDeathSwarmData");
static_assert(offsetof(DCSessionRuleComponent_OnDeathSwarmData, InDeathSwarmData) == 0x000000, "Member 'DCSessionRuleComponent_OnDeathSwarmData::InDeathSwarmData' has a wrong offset!");

// Function DungeonCrawler.DCSessionRuleComponent.OnFloorRuleActorRegistered
// 0x0008 (0x0008 - 0x0000)
struct DCSessionRuleComponent_OnFloorRuleActorRegistered final
{
public:
	class AActor*                                 InFloorRuleActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSessionRuleComponent_OnFloorRuleActorRegistered) == 0x000008, "Wrong alignment on DCSessionRuleComponent_OnFloorRuleActorRegistered");
static_assert(sizeof(DCSessionRuleComponent_OnFloorRuleActorRegistered) == 0x000008, "Wrong size on DCSessionRuleComponent_OnFloorRuleActorRegistered");
static_assert(offsetof(DCSessionRuleComponent_OnFloorRuleActorRegistered, InFloorRuleActor) == 0x000000, "Member 'DCSessionRuleComponent_OnFloorRuleActorRegistered::InFloorRuleActor' has a wrong offset!");

// Function DungeonCrawler.DCSessionRuleComponent.OnFloorRuleData
// 0x0040 (0x0040 - 0x0000)
struct DCSessionRuleComponent_OnFloorRuleData final
{
public:
	struct FGameFloorRuleData                     InFloorRuleData;                                   // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSessionRuleComponent_OnFloorRuleData) == 0x000008, "Wrong alignment on DCSessionRuleComponent_OnFloorRuleData");
static_assert(sizeof(DCSessionRuleComponent_OnFloorRuleData) == 0x000040, "Wrong size on DCSessionRuleComponent_OnFloorRuleData");
static_assert(offsetof(DCSessionRuleComponent_OnFloorRuleData, InFloorRuleData) == 0x000000, "Member 'DCSessionRuleComponent_OnFloorRuleData::InFloorRuleData' has a wrong offset!");

// Function DungeonCrawler.DCSessionRuleComponent.LogHandleBlizzardData
// 0x0048 (0x0048 - 0x0000)
struct DCSessionRuleComponent_LogHandleBlizzardData final
{
public:
	const class UObject*                          InHandler;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameBlizzardData                      InBlizzardData;                                    // 0x0008(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSessionRuleComponent_LogHandleBlizzardData) == 0x000008, "Wrong alignment on DCSessionRuleComponent_LogHandleBlizzardData");
static_assert(sizeof(DCSessionRuleComponent_LogHandleBlizzardData) == 0x000048, "Wrong size on DCSessionRuleComponent_LogHandleBlizzardData");
static_assert(offsetof(DCSessionRuleComponent_LogHandleBlizzardData, InHandler) == 0x000000, "Member 'DCSessionRuleComponent_LogHandleBlizzardData::InHandler' has a wrong offset!");
static_assert(offsetof(DCSessionRuleComponent_LogHandleBlizzardData, InBlizzardData) == 0x000008, "Member 'DCSessionRuleComponent_LogHandleBlizzardData::InBlizzardData' has a wrong offset!");

// Function DungeonCrawler.DCSessionRuleComponent.LogHandleDeathSwarmData
// 0x0088 (0x0088 - 0x0000)
struct DCSessionRuleComponent_LogHandleDeathSwarmData final
{
public:
	const class UObject*                          InHandler;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameDeathSwarmData                    InDeathSwarmData;                                  // 0x0008(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSessionRuleComponent_LogHandleDeathSwarmData) == 0x000008, "Wrong alignment on DCSessionRuleComponent_LogHandleDeathSwarmData");
static_assert(sizeof(DCSessionRuleComponent_LogHandleDeathSwarmData) == 0x000088, "Wrong size on DCSessionRuleComponent_LogHandleDeathSwarmData");
static_assert(offsetof(DCSessionRuleComponent_LogHandleDeathSwarmData, InHandler) == 0x000000, "Member 'DCSessionRuleComponent_LogHandleDeathSwarmData::InHandler' has a wrong offset!");
static_assert(offsetof(DCSessionRuleComponent_LogHandleDeathSwarmData, InDeathSwarmData) == 0x000008, "Member 'DCSessionRuleComponent_LogHandleDeathSwarmData::InDeathSwarmData' has a wrong offset!");

// Function DungeonCrawler.DCSessionRuleComponent.LogHandleFloorRuleData
// 0x0048 (0x0048 - 0x0000)
struct DCSessionRuleComponent_LogHandleFloorRuleData final
{
public:
	const class UObject*                          InHandler;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameFloorRuleData                     InFloorRuleData;                                   // 0x0008(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSessionRuleComponent_LogHandleFloorRuleData) == 0x000008, "Wrong alignment on DCSessionRuleComponent_LogHandleFloorRuleData");
static_assert(sizeof(DCSessionRuleComponent_LogHandleFloorRuleData) == 0x000048, "Wrong size on DCSessionRuleComponent_LogHandleFloorRuleData");
static_assert(offsetof(DCSessionRuleComponent_LogHandleFloorRuleData, InHandler) == 0x000000, "Member 'DCSessionRuleComponent_LogHandleFloorRuleData::InHandler' has a wrong offset!");
static_assert(offsetof(DCSessionRuleComponent_LogHandleFloorRuleData, InFloorRuleData) == 0x000008, "Member 'DCSessionRuleComponent_LogHandleFloorRuleData::InFloorRuleData' has a wrong offset!");

// Function DungeonCrawler.SpellCapacityWidgetBase.OnSpellCapacityChanged
// 0x0008 (0x0008 - 0x0000)
struct SpellCapacityWidgetBase_OnSpellCapacityChanged final
{
public:
	float                                         InSpellCurrentCapacity;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InSpellMaxCapacity;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellCapacityWidgetBase_OnSpellCapacityChanged) == 0x000004, "Wrong alignment on SpellCapacityWidgetBase_OnSpellCapacityChanged");
static_assert(sizeof(SpellCapacityWidgetBase_OnSpellCapacityChanged) == 0x000008, "Wrong size on SpellCapacityWidgetBase_OnSpellCapacityChanged");
static_assert(offsetof(SpellCapacityWidgetBase_OnSpellCapacityChanged, InSpellCurrentCapacity) == 0x000000, "Member 'SpellCapacityWidgetBase_OnSpellCapacityChanged::InSpellCurrentCapacity' has a wrong offset!");
static_assert(offsetof(SpellCapacityWidgetBase_OnSpellCapacityChanged, InSpellMaxCapacity) == 0x000004, "Member 'SpellCapacityWidgetBase_OnSpellCapacityChanged::InSpellMaxCapacity' has a wrong offset!");

// Function DungeonCrawler.ClassSpellCapacityWidget.OnSpellListChanged
// 0x0010 (0x0010 - 0x0000)
struct ClassSpellCapacityWidget_OnSpellListChanged final
{
public:
	TArray<struct FSpellData>                     InSpellDataArray;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassSpellCapacityWidget_OnSpellListChanged) == 0x000008, "Wrong alignment on ClassSpellCapacityWidget_OnSpellListChanged");
static_assert(sizeof(ClassSpellCapacityWidget_OnSpellListChanged) == 0x000010, "Wrong size on ClassSpellCapacityWidget_OnSpellListChanged");
static_assert(offsetof(ClassSpellCapacityWidget_OnSpellListChanged, InSpellDataArray) == 0x000000, "Member 'ClassSpellCapacityWidget_OnSpellListChanged::InSpellDataArray' has a wrong offset!");

// Function DungeonCrawler.DCInventoryMsgWrapperComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCInventoryMsgWrapperComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInventoryMsgWrapperComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCInventoryMsgWrapperComponent_BroadcastMsgBlueprint");
static_assert(sizeof(DCInventoryMsgWrapperComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCInventoryMsgWrapperComponent_BroadcastMsgBlueprint");
static_assert(offsetof(DCInventoryMsgWrapperComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCInventoryMsgWrapperComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCInventoryMsgWrapperComponent.ClientShowMessage
// 0x0018 (0x0018 - 0x0000)
struct DCInventoryMsgWrapperComponent_ClientShowMessage final
{
public:
	class FText                                   Msg;                                               // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInventoryMsgWrapperComponent_ClientShowMessage) == 0x000008, "Wrong alignment on DCInventoryMsgWrapperComponent_ClientShowMessage");
static_assert(sizeof(DCInventoryMsgWrapperComponent_ClientShowMessage) == 0x000018, "Wrong size on DCInventoryMsgWrapperComponent_ClientShowMessage");
static_assert(offsetof(DCInventoryMsgWrapperComponent_ClientShowMessage, Msg) == 0x000000, "Member 'DCInventoryMsgWrapperComponent_ClientShowMessage::Msg' has a wrong offset!");

// Function DungeonCrawler.DCInventoryMsgWrapperComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCInventoryMsgWrapperComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInventoryMsgWrapperComponent_UnbindMsg) == 0x000008, "Wrong alignment on DCInventoryMsgWrapperComponent_UnbindMsg");
static_assert(sizeof(DCInventoryMsgWrapperComponent_UnbindMsg) == 0x000010, "Wrong size on DCInventoryMsgWrapperComponent_UnbindMsg");
static_assert(offsetof(DCInventoryMsgWrapperComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'DCInventoryMsgWrapperComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCInventoryMsgWrapperComponent_UnbindMsg, InObject) == 0x000008, "Member 'DCInventoryMsgWrapperComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCInventoryMsgWrapperComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCInventoryMsgWrapperComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInventoryMsgWrapperComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on DCInventoryMsgWrapperComponent_UnbindMsgAll");
static_assert(sizeof(DCInventoryMsgWrapperComponent_UnbindMsgAll) == 0x000008, "Wrong size on DCInventoryMsgWrapperComponent_UnbindMsgAll");
static_assert(offsetof(DCInventoryMsgWrapperComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'DCInventoryMsgWrapperComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCGiftCodeEditableText.OnCodeTextChanged
// 0x0018 (0x0018 - 0x0000)
struct DCGiftCodeEditableText_OnCodeTextChanged final
{
public:
	class FText                                   InCodeText;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGiftCodeEditableText_OnCodeTextChanged) == 0x000008, "Wrong alignment on DCGiftCodeEditableText_OnCodeTextChanged");
static_assert(sizeof(DCGiftCodeEditableText_OnCodeTextChanged) == 0x000018, "Wrong size on DCGiftCodeEditableText_OnCodeTextChanged");
static_assert(offsetof(DCGiftCodeEditableText_OnCodeTextChanged, InCodeText) == 0x000000, "Member 'DCGiftCodeEditableText_OnCodeTextChanged::InCodeText' has a wrong offset!");

// Function DungeonCrawler.DCGiftCodeEditableText.OnCodeTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct DCGiftCodeEditableText_OnCodeTextCommitted final
{
public:
	class FText                                   InCodeText;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitType;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24CF[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGiftCodeEditableText_OnCodeTextCommitted) == 0x000008, "Wrong alignment on DCGiftCodeEditableText_OnCodeTextCommitted");
static_assert(sizeof(DCGiftCodeEditableText_OnCodeTextCommitted) == 0x000020, "Wrong size on DCGiftCodeEditableText_OnCodeTextCommitted");
static_assert(offsetof(DCGiftCodeEditableText_OnCodeTextCommitted, InCodeText) == 0x000000, "Member 'DCGiftCodeEditableText_OnCodeTextCommitted::InCodeText' has a wrong offset!");
static_assert(offsetof(DCGiftCodeEditableText_OnCodeTextCommitted, CommitType) == 0x000018, "Member 'DCGiftCodeEditableText_OnCodeTextCommitted::CommitType' has a wrong offset!");

// DelegateFunction DungeonCrawler.DCGiftCodeEditableText.OnGiftCodeFilledEvent__DelegateSignature
// 0x0020 (0x0020 - 0x0000)
struct DCGiftCodeEditableText_OnGiftCodeFilledEvent__DelegateSignature final
{
public:
	class FText                                   RemainText;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0018(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D0[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGiftCodeEditableText_OnGiftCodeFilledEvent__DelegateSignature) == 0x000008, "Wrong alignment on DCGiftCodeEditableText_OnGiftCodeFilledEvent__DelegateSignature");
static_assert(sizeof(DCGiftCodeEditableText_OnGiftCodeFilledEvent__DelegateSignature) == 0x000020, "Wrong size on DCGiftCodeEditableText_OnGiftCodeFilledEvent__DelegateSignature");
static_assert(offsetof(DCGiftCodeEditableText_OnGiftCodeFilledEvent__DelegateSignature, RemainText) == 0x000000, "Member 'DCGiftCodeEditableText_OnGiftCodeFilledEvent__DelegateSignature::RemainText' has a wrong offset!");
static_assert(offsetof(DCGiftCodeEditableText_OnGiftCodeFilledEvent__DelegateSignature, Param_Index) == 0x000018, "Member 'DCGiftCodeEditableText_OnGiftCodeFilledEvent__DelegateSignature::Param_Index' has a wrong offset!");

// DelegateFunction DungeonCrawler.DCGiftCodeEditableText.OnGiftCodeWipedEvent__DelegateSignature
// 0x0004 (0x0004 - 0x0000)
struct DCGiftCodeEditableText_OnGiftCodeWipedEvent__DelegateSignature final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGiftCodeEditableText_OnGiftCodeWipedEvent__DelegateSignature) == 0x000004, "Wrong alignment on DCGiftCodeEditableText_OnGiftCodeWipedEvent__DelegateSignature");
static_assert(sizeof(DCGiftCodeEditableText_OnGiftCodeWipedEvent__DelegateSignature) == 0x000004, "Wrong size on DCGiftCodeEditableText_OnGiftCodeWipedEvent__DelegateSignature");
static_assert(offsetof(DCGiftCodeEditableText_OnGiftCodeWipedEvent__DelegateSignature, Param_Index) == 0x000000, "Member 'DCGiftCodeEditableText_OnGiftCodeWipedEvent__DelegateSignature::Param_Index' has a wrong offset!");

// Function DungeonCrawler.DCRewardItemWidget.GetTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCRewardItemWidget_GetTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCRewardItemWidget_GetTooltipWidget) == 0x000008, "Wrong alignment on DCRewardItemWidget_GetTooltipWidget");
static_assert(sizeof(DCRewardItemWidget_GetTooltipWidget) == 0x000008, "Wrong size on DCRewardItemWidget_GetTooltipWidget");
static_assert(offsetof(DCRewardItemWidget_GetTooltipWidget, ReturnValue) == 0x000000, "Member 'DCRewardItemWidget_GetTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCRewardItemWidget.SetRewardItem
// 0x0020 (0x0020 - 0x0000)
struct DCRewardItemWidget_SetRewardItem final
{
public:
	struct FDCRewardInfo                          Info;                                              // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCRewardItemWidget_SetRewardItem) == 0x000008, "Wrong alignment on DCRewardItemWidget_SetRewardItem");
static_assert(sizeof(DCRewardItemWidget_SetRewardItem) == 0x000020, "Wrong size on DCRewardItemWidget_SetRewardItem");
static_assert(offsetof(DCRewardItemWidget_SetRewardItem, Info) == 0x000000, "Member 'DCRewardItemWidget_SetRewardItem::Info' has a wrong offset!");

// Function DungeonCrawler.DCGameSession.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCGameSession_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSession_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCGameSession_BroadcastMsgBlueprint");
static_assert(sizeof(DCGameSession_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCGameSession_BroadcastMsgBlueprint");
static_assert(offsetof(DCGameSession_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCGameSession_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCGameSession.CharacterResurrection
// 0x0038 (0x0038 - 0x0000)
struct DCGameSession_CharacterResurrection final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADCCharacterBase>           DCCharacterClass;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectData>          InInitGameplayEffectDataArray;                     // 0x0018(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsRemoveAllItem;                                  // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D4[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             ResurrectionCharacter;                             // 0x0030(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSession_CharacterResurrection) == 0x000008, "Wrong alignment on DCGameSession_CharacterResurrection");
static_assert(sizeof(DCGameSession_CharacterResurrection) == 0x000038, "Wrong size on DCGameSession_CharacterResurrection");
static_assert(offsetof(DCGameSession_CharacterResurrection, AccountId) == 0x000000, "Member 'DCGameSession_CharacterResurrection::AccountId' has a wrong offset!");
static_assert(offsetof(DCGameSession_CharacterResurrection, DCCharacterClass) == 0x000010, "Member 'DCGameSession_CharacterResurrection::DCCharacterClass' has a wrong offset!");
static_assert(offsetof(DCGameSession_CharacterResurrection, InInitGameplayEffectDataArray) == 0x000018, "Member 'DCGameSession_CharacterResurrection::InInitGameplayEffectDataArray' has a wrong offset!");
static_assert(offsetof(DCGameSession_CharacterResurrection, bIsRemoveAllItem) == 0x000028, "Member 'DCGameSession_CharacterResurrection::bIsRemoveAllItem' has a wrong offset!");
static_assert(offsetof(DCGameSession_CharacterResurrection, ResurrectionCharacter) == 0x000030, "Member 'DCGameSession_CharacterResurrection::ResurrectionCharacter' has a wrong offset!");

// Function DungeonCrawler.DCGameSession.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCGameSession_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSession_UnbindMsg) == 0x000008, "Wrong alignment on DCGameSession_UnbindMsg");
static_assert(sizeof(DCGameSession_UnbindMsg) == 0x000010, "Wrong size on DCGameSession_UnbindMsg");
static_assert(offsetof(DCGameSession_UnbindMsg, InMsgType) == 0x000000, "Member 'DCGameSession_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCGameSession_UnbindMsg, InObject) == 0x000008, "Member 'DCGameSession_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCGameSession.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCGameSession_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSession_UnbindMsgAll) == 0x000008, "Wrong alignment on DCGameSession_UnbindMsgAll");
static_assert(sizeof(DCGameSession_UnbindMsgAll) == 0x000008, "Wrong size on DCGameSession_UnbindMsgAll");
static_assert(offsetof(DCGameSession_UnbindMsgAll, InObject) == 0x000000, "Member 'DCGameSession_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.ClassSpellSkillListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint
// 0x0080 (0x0080 - 0x0000)
struct ClassSpellSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint final
{
public:
	struct FMsgWidgetClassLevelNotify             InMsg;                                             // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassSpellSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint) == 0x000008, "Wrong alignment on ClassSpellSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint");
static_assert(sizeof(ClassSpellSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint) == 0x000080, "Wrong size on ClassSpellSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint");
static_assert(offsetof(ClassSpellSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint, InMsg) == 0x000000, "Member 'ClassSpellSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClassSpellSkillListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint
// 0x0038 (0x0038 - 0x0000)
struct ClassSpellSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint final
{
public:
	struct FMsgWidgetClassSlotUnLockLevelNotify   InMsg;                                             // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassSpellSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint) == 0x000008, "Wrong alignment on ClassSpellSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");
static_assert(sizeof(ClassSpellSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint) == 0x000038, "Wrong size on ClassSpellSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");
static_assert(offsetof(ClassSpellSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint, InMsg) == 0x000000, "Member 'ClassSpellSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCAT_InteractionSkillCheck.InteractionSkillCheck
// 0x0030 (0x0030 - 0x0000)
struct DCAT_InteractionSkillCheck_InteractionSkillCheck final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SucceedSectionStartTime;                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SucceedSectionEndTime;                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectSucceedSectionStartTime;                    // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectSucceedSectionEndTime;                      // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24D6[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_InteractionSkillCheck*            ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_InteractionSkillCheck_InteractionSkillCheck) == 0x000008, "Wrong alignment on DCAT_InteractionSkillCheck_InteractionSkillCheck");
static_assert(sizeof(DCAT_InteractionSkillCheck_InteractionSkillCheck) == 0x000030, "Wrong size on DCAT_InteractionSkillCheck_InteractionSkillCheck");
static_assert(offsetof(DCAT_InteractionSkillCheck_InteractionSkillCheck, OwningAbility) == 0x000000, "Member 'DCAT_InteractionSkillCheck_InteractionSkillCheck::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_InteractionSkillCheck_InteractionSkillCheck, TaskInstanceName) == 0x000008, "Member 'DCAT_InteractionSkillCheck_InteractionSkillCheck::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(DCAT_InteractionSkillCheck_InteractionSkillCheck, Duration) == 0x000010, "Member 'DCAT_InteractionSkillCheck_InteractionSkillCheck::Duration' has a wrong offset!");
static_assert(offsetof(DCAT_InteractionSkillCheck_InteractionSkillCheck, SucceedSectionStartTime) == 0x000014, "Member 'DCAT_InteractionSkillCheck_InteractionSkillCheck::SucceedSectionStartTime' has a wrong offset!");
static_assert(offsetof(DCAT_InteractionSkillCheck_InteractionSkillCheck, SucceedSectionEndTime) == 0x000018, "Member 'DCAT_InteractionSkillCheck_InteractionSkillCheck::SucceedSectionEndTime' has a wrong offset!");
static_assert(offsetof(DCAT_InteractionSkillCheck_InteractionSkillCheck, PerfectSucceedSectionStartTime) == 0x00001C, "Member 'DCAT_InteractionSkillCheck_InteractionSkillCheck::PerfectSucceedSectionStartTime' has a wrong offset!");
static_assert(offsetof(DCAT_InteractionSkillCheck_InteractionSkillCheck, PerfectSucceedSectionEndTime) == 0x000020, "Member 'DCAT_InteractionSkillCheck_InteractionSkillCheck::PerfectSucceedSectionEndTime' has a wrong offset!");
static_assert(offsetof(DCAT_InteractionSkillCheck_InteractionSkillCheck, ReturnValue) == 0x000028, "Member 'DCAT_InteractionSkillCheck_InteractionSkillCheck::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ClassTabMenuWidget.OnSkillClassAbilitiesUpdated_BP
// 0x0010 (0x0010 - 0x0000)
struct ClassTabMenuWidget_OnSkillClassAbilitiesUpdated_BP final
{
public:
	TArray<EDCSkillClassAbility>                  SkillClassAbilities;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassTabMenuWidget_OnSkillClassAbilitiesUpdated_BP) == 0x000008, "Wrong alignment on ClassTabMenuWidget_OnSkillClassAbilitiesUpdated_BP");
static_assert(sizeof(ClassTabMenuWidget_OnSkillClassAbilitiesUpdated_BP) == 0x000010, "Wrong size on ClassTabMenuWidget_OnSkillClassAbilitiesUpdated_BP");
static_assert(offsetof(ClassTabMenuWidget_OnSkillClassAbilitiesUpdated_BP, SkillClassAbilities) == 0x000000, "Member 'ClassTabMenuWidget_OnSkillClassAbilitiesUpdated_BP::SkillClassAbilities' has a wrong offset!");

// Function DungeonCrawler.DCShopCurrencyTypeSelectPopupBase.IsBluestoneShardSelected
// 0x0001 (0x0001 - 0x0000)
struct DCShopCurrencyTypeSelectPopupBase_IsBluestoneShardSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopCurrencyTypeSelectPopupBase_IsBluestoneShardSelected) == 0x000001, "Wrong alignment on DCShopCurrencyTypeSelectPopupBase_IsBluestoneShardSelected");
static_assert(sizeof(DCShopCurrencyTypeSelectPopupBase_IsBluestoneShardSelected) == 0x000001, "Wrong size on DCShopCurrencyTypeSelectPopupBase_IsBluestoneShardSelected");
static_assert(offsetof(DCShopCurrencyTypeSelectPopupBase_IsBluestoneShardSelected, ReturnValue) == 0x000000, "Member 'DCShopCurrencyTypeSelectPopupBase_IsBluestoneShardSelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopCurrencyTypeSelectPopupBase.IsRedstoneShardSelected
// 0x0001 (0x0001 - 0x0000)
struct DCShopCurrencyTypeSelectPopupBase_IsRedstoneShardSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopCurrencyTypeSelectPopupBase_IsRedstoneShardSelected) == 0x000001, "Wrong alignment on DCShopCurrencyTypeSelectPopupBase_IsRedstoneShardSelected");
static_assert(sizeof(DCShopCurrencyTypeSelectPopupBase_IsRedstoneShardSelected) == 0x000001, "Wrong size on DCShopCurrencyTypeSelectPopupBase_IsRedstoneShardSelected");
static_assert(offsetof(DCShopCurrencyTypeSelectPopupBase_IsRedstoneShardSelected, ReturnValue) == 0x000000, "Member 'DCShopCurrencyTypeSelectPopupBase_IsRedstoneShardSelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopCurrencyTypeSelectPopupBase.OnCurrencySelected
// 0x0001 (0x0001 - 0x0000)
struct DCShopCurrencyTypeSelectPopupBase_OnCurrencySelected final
{
public:
	EDCShopCurrencyType                           CurrencyType;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopCurrencyTypeSelectPopupBase_OnCurrencySelected) == 0x000001, "Wrong alignment on DCShopCurrencyTypeSelectPopupBase_OnCurrencySelected");
static_assert(sizeof(DCShopCurrencyTypeSelectPopupBase_OnCurrencySelected) == 0x000001, "Wrong size on DCShopCurrencyTypeSelectPopupBase_OnCurrencySelected");
static_assert(offsetof(DCShopCurrencyTypeSelectPopupBase_OnCurrencySelected, CurrencyType) == 0x000000, "Member 'DCShopCurrencyTypeSelectPopupBase_OnCurrencySelected::CurrencyType' has a wrong offset!");

// Function DungeonCrawler.DCTrainingTokenRedeemResultWidgetBase.IsEnableReceiveButton
// 0x0001 (0x0001 - 0x0000)
struct DCTrainingTokenRedeemResultWidgetBase_IsEnableReceiveButton final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTrainingTokenRedeemResultWidgetBase_IsEnableReceiveButton) == 0x000001, "Wrong alignment on DCTrainingTokenRedeemResultWidgetBase_IsEnableReceiveButton");
static_assert(sizeof(DCTrainingTokenRedeemResultWidgetBase_IsEnableReceiveButton) == 0x000001, "Wrong size on DCTrainingTokenRedeemResultWidgetBase_IsEnableReceiveButton");
static_assert(offsetof(DCTrainingTokenRedeemResultWidgetBase_IsEnableReceiveButton, ReturnValue) == 0x000000, "Member 'DCTrainingTokenRedeemResultWidgetBase_IsEnableReceiveButton::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitVelocityChange.WaitVelocityChange
// 0x0018 (0x0018 - 0x0000)
struct DCAT_WaitVelocityChange_WaitVelocityChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumMagnitude;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E2[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitVelocityChange*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitVelocityChange_WaitVelocityChange) == 0x000008, "Wrong alignment on DCAT_WaitVelocityChange_WaitVelocityChange");
static_assert(sizeof(DCAT_WaitVelocityChange_WaitVelocityChange) == 0x000018, "Wrong size on DCAT_WaitVelocityChange_WaitVelocityChange");
static_assert(offsetof(DCAT_WaitVelocityChange_WaitVelocityChange, OwningAbility) == 0x000000, "Member 'DCAT_WaitVelocityChange_WaitVelocityChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitVelocityChange_WaitVelocityChange, MinimumMagnitude) == 0x000008, "Member 'DCAT_WaitVelocityChange_WaitVelocityChange::MinimumMagnitude' has a wrong offset!");
static_assert(offsetof(DCAT_WaitVelocityChange_WaitVelocityChange, ReturnValue) == 0x000010, "Member 'DCAT_WaitVelocityChange_WaitVelocityChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.GetSelectedPerkId
// 0x0010 (0x0010 - 0x0000)
struct ClassUnEquipmentPerkandSkillListWidget_GetSelectedPerkId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassUnEquipmentPerkandSkillListWidget_GetSelectedPerkId) == 0x000004, "Wrong alignment on ClassUnEquipmentPerkandSkillListWidget_GetSelectedPerkId");
static_assert(sizeof(ClassUnEquipmentPerkandSkillListWidget_GetSelectedPerkId) == 0x000010, "Wrong size on ClassUnEquipmentPerkandSkillListWidget_GetSelectedPerkId");
static_assert(offsetof(ClassUnEquipmentPerkandSkillListWidget_GetSelectedPerkId, ReturnValue) == 0x000000, "Member 'ClassUnEquipmentPerkandSkillListWidget_GetSelectedPerkId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.GetSelectedSkillId
// 0x0010 (0x0010 - 0x0000)
struct ClassUnEquipmentPerkandSkillListWidget_GetSelectedSkillId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClassUnEquipmentPerkandSkillListWidget_GetSelectedSkillId) == 0x000004, "Wrong alignment on ClassUnEquipmentPerkandSkillListWidget_GetSelectedSkillId");
static_assert(sizeof(ClassUnEquipmentPerkandSkillListWidget_GetSelectedSkillId) == 0x000010, "Wrong size on ClassUnEquipmentPerkandSkillListWidget_GetSelectedSkillId");
static_assert(offsetof(ClassUnEquipmentPerkandSkillListWidget_GetSelectedSkillId, ReturnValue) == 0x000000, "Member 'ClassUnEquipmentPerkandSkillListWidget_GetSelectedSkillId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InjectionItemSelectedPropertyWidgetBase.OnPropertyValueChanged
// 0x0018 (0x0018 - 0x0000)
struct InjectionItemSelectedPropertyWidgetBase_OnPropertyValueChanged final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InjectionItemSelectedPropertyWidgetBase_OnPropertyValueChanged) == 0x000008, "Wrong alignment on InjectionItemSelectedPropertyWidgetBase_OnPropertyValueChanged");
static_assert(sizeof(InjectionItemSelectedPropertyWidgetBase_OnPropertyValueChanged) == 0x000018, "Wrong size on InjectionItemSelectedPropertyWidgetBase_OnPropertyValueChanged");
static_assert(offsetof(InjectionItemSelectedPropertyWidgetBase_OnPropertyValueChanged, Text) == 0x000000, "Member 'InjectionItemSelectedPropertyWidgetBase_OnPropertyValueChanged::Text' has a wrong offset!");

// Function DungeonCrawler.InjectionItemSelectedPropertyWidgetBase.OnPropertyValueSet
// 0x0020 (0x0020 - 0x0000)
struct InjectionItemSelectedPropertyWidgetBase_OnPropertyValueSet final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24E6[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InjectionItemSelectedPropertyWidgetBase_OnPropertyValueSet) == 0x000008, "Wrong alignment on InjectionItemSelectedPropertyWidgetBase_OnPropertyValueSet");
static_assert(sizeof(InjectionItemSelectedPropertyWidgetBase_OnPropertyValueSet) == 0x000020, "Wrong size on InjectionItemSelectedPropertyWidgetBase_OnPropertyValueSet");
static_assert(offsetof(InjectionItemSelectedPropertyWidgetBase_OnPropertyValueSet, Text) == 0x000000, "Member 'InjectionItemSelectedPropertyWidgetBase_OnPropertyValueSet::Text' has a wrong offset!");
static_assert(offsetof(InjectionItemSelectedPropertyWidgetBase_OnPropertyValueSet, CommitMethod) == 0x000018, "Member 'InjectionItemSelectedPropertyWidgetBase_OnPropertyValueSet::CommitMethod' has a wrong offset!");

// DelegateFunction DungeonCrawler.InjectionItemSelectedPropertyWidgetBase.OnSelectedPropertyValueChanged__DelegateSignature
// 0x0014 (0x0014 - 0x0000)
struct InjectionItemSelectedPropertyWidgetBase_OnSelectedPropertyValueChanged__DelegateSignature final
{
public:
	struct FPrimaryAssetId                        PropertyTypeAssetId;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_PropertyValue;                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InjectionItemSelectedPropertyWidgetBase_OnSelectedPropertyValueChanged__DelegateSignature) == 0x000004, "Wrong alignment on InjectionItemSelectedPropertyWidgetBase_OnSelectedPropertyValueChanged__DelegateSignature");
static_assert(sizeof(InjectionItemSelectedPropertyWidgetBase_OnSelectedPropertyValueChanged__DelegateSignature) == 0x000014, "Wrong size on InjectionItemSelectedPropertyWidgetBase_OnSelectedPropertyValueChanged__DelegateSignature");
static_assert(offsetof(InjectionItemSelectedPropertyWidgetBase_OnSelectedPropertyValueChanged__DelegateSignature, PropertyTypeAssetId) == 0x000000, "Member 'InjectionItemSelectedPropertyWidgetBase_OnSelectedPropertyValueChanged__DelegateSignature::PropertyTypeAssetId' has a wrong offset!");
static_assert(offsetof(InjectionItemSelectedPropertyWidgetBase_OnSelectedPropertyValueChanged__DelegateSignature, Param_PropertyValue) == 0x000010, "Member 'InjectionItemSelectedPropertyWidgetBase_OnSelectedPropertyValueChanged__DelegateSignature::Param_PropertyValue' has a wrong offset!");

// Function DungeonCrawler.DCActionSkinWidget.GetActionSkinTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCActionSkinWidget_GetActionSkinTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActionSkinWidget_GetActionSkinTooltipWidget) == 0x000008, "Wrong alignment on DCActionSkinWidget_GetActionSkinTooltipWidget");
static_assert(sizeof(DCActionSkinWidget_GetActionSkinTooltipWidget) == 0x000008, "Wrong size on DCActionSkinWidget_GetActionSkinTooltipWidget");
static_assert(offsetof(DCActionSkinWidget_GetActionSkinTooltipWidget, ReturnValue) == 0x000000, "Member 'DCActionSkinWidget_GetActionSkinTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_OverlapActorsInRadius.OverlapActorsInRadius
// 0x0028 (0x0028 - 0x0000)
struct DCAT_OverlapActorsInRadius_OverlapActorsInRadius final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionProfileName;                              // 0x000C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24EE[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 OverlapTargetClass;                                // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_OverlapActorsInRadius*            ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_OverlapActorsInRadius_OverlapActorsInRadius) == 0x000008, "Wrong alignment on DCAT_OverlapActorsInRadius_OverlapActorsInRadius");
static_assert(sizeof(DCAT_OverlapActorsInRadius_OverlapActorsInRadius) == 0x000028, "Wrong size on DCAT_OverlapActorsInRadius_OverlapActorsInRadius");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OverlapActorsInRadius, OwningAbility) == 0x000000, "Member 'DCAT_OverlapActorsInRadius_OverlapActorsInRadius::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OverlapActorsInRadius, Radius) == 0x000008, "Member 'DCAT_OverlapActorsInRadius_OverlapActorsInRadius::Radius' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OverlapActorsInRadius, CollisionProfileName) == 0x00000C, "Member 'DCAT_OverlapActorsInRadius_OverlapActorsInRadius::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OverlapActorsInRadius, OverlapTargetClass) == 0x000018, "Member 'DCAT_OverlapActorsInRadius_OverlapActorsInRadius::OverlapTargetClass' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OverlapActorsInRadius, ReturnValue) == 0x000020, "Member 'DCAT_OverlapActorsInRadius_OverlapActorsInRadius::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_OverlapActorsInRadius.OnOverlapBegin
// 0x0108 (0x0108 - 0x0000)
struct DCAT_OverlapActorsInRadius_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24EF[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_OverlapActorsInRadius_OnOverlapBegin) == 0x000008, "Wrong alignment on DCAT_OverlapActorsInRadius_OnOverlapBegin");
static_assert(sizeof(DCAT_OverlapActorsInRadius_OnOverlapBegin) == 0x000108, "Wrong size on DCAT_OverlapActorsInRadius_OnOverlapBegin");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OnOverlapBegin, OverlappedComponent) == 0x000000, "Member 'DCAT_OverlapActorsInRadius_OnOverlapBegin::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OnOverlapBegin, OtherActor) == 0x000008, "Member 'DCAT_OverlapActorsInRadius_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OnOverlapBegin, OtherComp) == 0x000010, "Member 'DCAT_OverlapActorsInRadius_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'DCAT_OverlapActorsInRadius_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'DCAT_OverlapActorsInRadius_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OnOverlapBegin, SweepResult) == 0x000020, "Member 'DCAT_OverlapActorsInRadius_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function DungeonCrawler.DCAT_OverlapActorsInRadius.OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct DCAT_OverlapActorsInRadius_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24F0[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAT_OverlapActorsInRadius_OnOverlapEnd) == 0x000008, "Wrong alignment on DCAT_OverlapActorsInRadius_OnOverlapEnd");
static_assert(sizeof(DCAT_OverlapActorsInRadius_OnOverlapEnd) == 0x000020, "Wrong size on DCAT_OverlapActorsInRadius_OnOverlapEnd");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OnOverlapEnd, OverlappedComponent) == 0x000000, "Member 'DCAT_OverlapActorsInRadius_OnOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OnOverlapEnd, OtherActor) == 0x000008, "Member 'DCAT_OverlapActorsInRadius_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OnOverlapEnd, OtherComp) == 0x000010, "Member 'DCAT_OverlapActorsInRadius_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInRadius_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'DCAT_OverlapActorsInRadius_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DungeonCrawler.DCBagWidget.OnDragCanceled
// 0x0008 (0x0008 - 0x0000)
struct DCBagWidget_OnDragCanceled final
{
public:
	class UDragDropOperation*                     Operation;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCBagWidget_OnDragCanceled) == 0x000008, "Wrong alignment on DCBagWidget_OnDragCanceled");
static_assert(sizeof(DCBagWidget_OnDragCanceled) == 0x000008, "Wrong size on DCBagWidget_OnDragCanceled");
static_assert(offsetof(DCBagWidget_OnDragCanceled, Operation) == 0x000000, "Member 'DCBagWidget_OnDragCanceled::Operation' has a wrong offset!");

// Function DungeonCrawler.DCBagWidget.GetGoldAmount
// 0x0004 (0x0004 - 0x0000)
struct DCBagWidget_GetGoldAmount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCBagWidget_GetGoldAmount) == 0x000004, "Wrong alignment on DCBagWidget_GetGoldAmount");
static_assert(sizeof(DCBagWidget_GetGoldAmount) == 0x000004, "Wrong size on DCBagWidget_GetGoldAmount");
static_assert(offsetof(DCBagWidget_GetGoldAmount, ReturnValue) == 0x000000, "Member 'DCBagWidget_GetGoldAmount::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCBagWidget.GetInventoryName
// 0x0018 (0x0018 - 0x0000)
struct DCBagWidget_GetInventoryName final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCBagWidget_GetInventoryName) == 0x000008, "Wrong alignment on DCBagWidget_GetInventoryName");
static_assert(sizeof(DCBagWidget_GetInventoryName) == 0x000018, "Wrong size on DCBagWidget_GetInventoryName");
static_assert(offsetof(DCBagWidget_GetInventoryName, ReturnValue) == 0x000000, "Member 'DCBagWidget_GetInventoryName::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCBagWidget.GetItemWidgets
// 0x0050 (0x0050 - 0x0000)
struct DCBagWidget_GetItemWidgets final
{
public:
	TMap<struct FDCItemId, class UDCBagItemWidget*> ReturnValue;                                       // 0x0000(0x0050)(ConstParm, ExportObject, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCBagWidget_GetItemWidgets) == 0x000008, "Wrong alignment on DCBagWidget_GetItemWidgets");
static_assert(sizeof(DCBagWidget_GetItemWidgets) == 0x000050, "Wrong size on DCBagWidget_GetItemWidgets");
static_assert(offsetof(DCBagWidget_GetItemWidgets, ReturnValue) == 0x000000, "Member 'DCBagWidget_GetItemWidgets::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitDelayRestartable.WaitDelay
// 0x0018 (0x0018 - 0x0000)
struct DCAT_WaitDelayRestartable_WaitDelay final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24FA[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitDelayRestartable*             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitDelayRestartable_WaitDelay) == 0x000008, "Wrong alignment on DCAT_WaitDelayRestartable_WaitDelay");
static_assert(sizeof(DCAT_WaitDelayRestartable_WaitDelay) == 0x000018, "Wrong size on DCAT_WaitDelayRestartable_WaitDelay");
static_assert(offsetof(DCAT_WaitDelayRestartable_WaitDelay, OwningAbility) == 0x000000, "Member 'DCAT_WaitDelayRestartable_WaitDelay::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDelayRestartable_WaitDelay, Time) == 0x000008, "Member 'DCAT_WaitDelayRestartable_WaitDelay::Time' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDelayRestartable_WaitDelay, ReturnValue) == 0x000010, "Member 'DCAT_WaitDelayRestartable_WaitDelay::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ClientAccountSubsystem.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct ClientAccountSubsystem_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientAccountSubsystem_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on ClientAccountSubsystem_BroadcastMsgBlueprint");
static_assert(sizeof(ClientAccountSubsystem_BroadcastMsgBlueprint) == 0x000004, "Wrong size on ClientAccountSubsystem_BroadcastMsgBlueprint");
static_assert(offsetof(ClientAccountSubsystem_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'ClientAccountSubsystem_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClientAccountSubsystem.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct ClientAccountSubsystem_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientAccountSubsystem_UnbindMsg) == 0x000008, "Wrong alignment on ClientAccountSubsystem_UnbindMsg");
static_assert(sizeof(ClientAccountSubsystem_UnbindMsg) == 0x000010, "Wrong size on ClientAccountSubsystem_UnbindMsg");
static_assert(offsetof(ClientAccountSubsystem_UnbindMsg, InMsgType) == 0x000000, "Member 'ClientAccountSubsystem_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(ClientAccountSubsystem_UnbindMsg, InObject) == 0x000008, "Member 'ClientAccountSubsystem_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.ClientAccountSubsystem.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct ClientAccountSubsystem_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientAccountSubsystem_UnbindMsgAll) == 0x000008, "Wrong alignment on ClientAccountSubsystem_UnbindMsgAll");
static_assert(sizeof(ClientAccountSubsystem_UnbindMsgAll) == 0x000008, "Wrong size on ClientAccountSubsystem_UnbindMsgAll");
static_assert(offsetof(ClientAccountSubsystem_UnbindMsgAll, InObject) == 0x000000, "Member 'ClientAccountSubsystem_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ActionSpeed
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ActionSpeed final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ActionSpeed) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ActionSpeed");
static_assert(sizeof(DCAttributeSet_OnRep_ActionSpeed) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ActionSpeed");
static_assert(offsetof(DCAttributeSet_OnRep_ActionSpeed, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ActionSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Agility
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Agility final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Agility) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Agility");
static_assert(sizeof(DCAttributeSet_OnRep_Agility) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Agility");
static_assert(offsetof(DCAttributeSet_OnRep_Agility, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Agility::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_AgilityBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_AgilityBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_AgilityBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_AgilityBase");
static_assert(sizeof(DCAttributeSet_OnRep_AgilityBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_AgilityBase");
static_assert(offsetof(DCAttributeSet_OnRep_AgilityBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_AgilityBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_AgilityMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_AgilityMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_AgilityMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_AgilityMod");
static_assert(sizeof(DCAttributeSet_OnRep_AgilityMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_AgilityMod");
static_assert(offsetof(DCAttributeSet_OnRep_AgilityMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_AgilityMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_AirMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_AirMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_AirMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_AirMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_AirMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_AirMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_AirMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_AirMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_AirMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_AirMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_AirMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_AirMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_AirMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_AirMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_AirMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_AirMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_AirMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_AirMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_AirMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_AirMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_AirMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_AirMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_AirMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_AirMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ArcaneMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ArcaneMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ArcaneMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ArcaneMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_ArcaneMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ArcaneMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_ArcaneMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ArcaneMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ArcaneMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ArcaneMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ArcaneMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ArcaneMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_ArcaneMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ArcaneMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_ArcaneMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ArcaneMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ArcaneMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ArcaneMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ArcaneMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ArcaneMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_ArcaneMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ArcaneMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_ArcaneMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ArcaneMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ArmorPenetration
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ArmorPenetration final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ArmorPenetration) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ArmorPenetration");
static_assert(sizeof(DCAttributeSet_OnRep_ArmorPenetration) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ArmorPenetration");
static_assert(offsetof(DCAttributeSet_OnRep_ArmorPenetration, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ArmorPenetration::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ArmorRating
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ArmorRating final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ArmorRating) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ArmorRating");
static_assert(sizeof(DCAttributeSet_OnRep_ArmorRating) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ArmorRating");
static_assert(offsetof(DCAttributeSet_OnRep_ArmorRating, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ArmorRating::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_BuffDurationMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_BuffDurationMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_BuffDurationMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_BuffDurationMod");
static_assert(sizeof(DCAttributeSet_OnRep_BuffDurationMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_BuffDurationMod");
static_assert(offsetof(DCAttributeSet_OnRep_BuffDurationMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_BuffDurationMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Coldness
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Coldness final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Coldness) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Coldness");
static_assert(sizeof(DCAttributeSet_OnRep_Coldness) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Coldness");
static_assert(offsetof(DCAttributeSet_OnRep_Coldness, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Coldness::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_CooldownReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_CooldownReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_CooldownReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_CooldownReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_CooldownReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_CooldownReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_CooldownReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_CooldownReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_DarkMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_DarkMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_DarkMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_DarkMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_DarkMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_DarkMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_DarkMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_DarkMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_DarkMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_DarkMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_DarkMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_DarkMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_DarkMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_DarkMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_DarkMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_DarkMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_DarkMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_DarkMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_DarkMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_DarkMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_DarkMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_DarkMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_DarkMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_DarkMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_DebuffDurationMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_DebuffDurationMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_DebuffDurationMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_DebuffDurationMod");
static_assert(sizeof(DCAttributeSet_OnRep_DebuffDurationMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_DebuffDurationMod");
static_assert(offsetof(DCAttributeSet_OnRep_DebuffDurationMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_DebuffDurationMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_DemonReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_DemonReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_DemonReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_DemonReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_DemonReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_DemonReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_DemonReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_DemonReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Dexterity
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Dexterity final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Dexterity) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Dexterity");
static_assert(sizeof(DCAttributeSet_OnRep_Dexterity) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Dexterity");
static_assert(offsetof(DCAttributeSet_OnRep_Dexterity, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Dexterity::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_DexterityBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_DexterityBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_DexterityBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_DexterityBase");
static_assert(sizeof(DCAttributeSet_OnRep_DexterityBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_DexterityBase");
static_assert(offsetof(DCAttributeSet_OnRep_DexterityBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_DexterityBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_DexterityMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_DexterityMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_DexterityMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_DexterityMod");
static_assert(sizeof(DCAttributeSet_OnRep_DexterityMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_DexterityMod");
static_assert(offsetof(DCAttributeSet_OnRep_DexterityMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_DexterityMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_DivineMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_DivineMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_DivineMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_DivineMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_DivineMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_DivineMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_DivineMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_DivineMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_DivineMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_DivineMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_DivineMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_DivineMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_DivineMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_DivineMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_DivineMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_DivineMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_DivineMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_DivineMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_DivineMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_DivineMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_DivineMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_DivineMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_DivineMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_DivineMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_EarthMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_EarthMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_EarthMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_EarthMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_EarthMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_EarthMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_EarthMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_EarthMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_EarthMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_EarthMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_EarthMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_EarthMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_EarthMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_EarthMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_EarthMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_EarthMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_EarthMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_EarthMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_EarthMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_EarthMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_EarthMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_EarthMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_EarthMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_EarthMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_EvilMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_EvilMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_EvilMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_EvilMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_EvilMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_EvilMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_EvilMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_EvilMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_EvilMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_EvilMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_EvilMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_EvilMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_EvilMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_EvilMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_EvilMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_EvilMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_EvilMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_EvilMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_EvilMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_EvilMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_EvilMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_EvilMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_EvilMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_EvilMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_FireMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_FireMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_FireMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_FireMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_FireMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_FireMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_FireMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_FireMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_FireMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_FireMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_FireMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_FireMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_FireMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_FireMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_FireMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_FireMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_FireMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_FireMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_FireMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_FireMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_FireMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_FireMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_FireMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_FireMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_HeadshotReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_HeadshotReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_HeadshotReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_HeadshotReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_HeadshotReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_HeadshotReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_HeadshotReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_HeadshotReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Health
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Health final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Health) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Health");
static_assert(sizeof(DCAttributeSet_OnRep_Health) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Health");
static_assert(offsetof(DCAttributeSet_OnRep_Health, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Health::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_HealthRecoveryMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_HealthRecoveryMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_HealthRecoveryMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_HealthRecoveryMod");
static_assert(sizeof(DCAttributeSet_OnRep_HealthRecoveryMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_HealthRecoveryMod");
static_assert(offsetof(DCAttributeSet_OnRep_HealthRecoveryMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_HealthRecoveryMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_IceMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_IceMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_IceMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_IceMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_IceMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_IceMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_IceMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_IceMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_IceMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_IceMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_IceMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_IceMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_IceMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_IceMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_IceMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_IceMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_IceMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_IceMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_IceMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_IceMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_IceMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_IceMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_IceMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_IceMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ImpactEndurance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ImpactEndurance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ImpactEndurance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ImpactEndurance");
static_assert(sizeof(DCAttributeSet_OnRep_ImpactEndurance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ImpactEndurance");
static_assert(offsetof(DCAttributeSet_OnRep_ImpactEndurance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ImpactEndurance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ImpactPower
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ImpactPower final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ImpactPower) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ImpactPower");
static_assert(sizeof(DCAttributeSet_OnRep_ImpactPower) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ImpactPower");
static_assert(offsetof(DCAttributeSet_OnRep_ImpactPower, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ImpactPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ImpactResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ImpactResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ImpactResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ImpactResistance");
static_assert(sizeof(DCAttributeSet_OnRep_ImpactResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ImpactResistance");
static_assert(offsetof(DCAttributeSet_OnRep_ImpactResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ImpactResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ItemArmorRating
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ItemArmorRating final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ItemArmorRating) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ItemArmorRating");
static_assert(sizeof(DCAttributeSet_OnRep_ItemArmorRating) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ItemArmorRating");
static_assert(offsetof(DCAttributeSet_OnRep_ItemArmorRating, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ItemArmorRating::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ItemArmorRatingMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ItemArmorRatingMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ItemArmorRatingMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ItemArmorRatingMod");
static_assert(sizeof(DCAttributeSet_OnRep_ItemArmorRatingMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ItemArmorRatingMod");
static_assert(offsetof(DCAttributeSet_OnRep_ItemArmorRatingMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ItemArmorRatingMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ItemEquipSpeed
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ItemEquipSpeed final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ItemEquipSpeed) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ItemEquipSpeed");
static_assert(sizeof(DCAttributeSet_OnRep_ItemEquipSpeed) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ItemEquipSpeed");
static_assert(offsetof(DCAttributeSet_OnRep_ItemEquipSpeed, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ItemEquipSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Knowledge
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Knowledge final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Knowledge) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Knowledge");
static_assert(sizeof(DCAttributeSet_OnRep_Knowledge) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Knowledge");
static_assert(offsetof(DCAttributeSet_OnRep_Knowledge, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Knowledge::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_KnowledgeBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_KnowledgeBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_KnowledgeBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_KnowledgeBase");
static_assert(sizeof(DCAttributeSet_OnRep_KnowledgeBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_KnowledgeBase");
static_assert(offsetof(DCAttributeSet_OnRep_KnowledgeBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_KnowledgeBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_KnowledgeMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_KnowledgeMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_KnowledgeMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_KnowledgeMod");
static_assert(sizeof(DCAttributeSet_OnRep_KnowledgeMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_KnowledgeMod");
static_assert(offsetof(DCAttributeSet_OnRep_KnowledgeMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_KnowledgeMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_LightMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_LightMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_LightMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_LightMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_LightMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_LightMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_LightMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_LightMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_LightMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_LightMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_LightMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_LightMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_LightMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_LightMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_LightMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_LightMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_LightMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_LightMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_LightMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_LightMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_LightMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_LightMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_LightMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_LightMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_LightningMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_LightningMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_LightningMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_LightningMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_LightningMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_LightningMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_LightningMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_LightningMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_LightningMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_LightningMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_LightningMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_LightningMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_LightningMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_LightningMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_LightningMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_LightningMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_LightningMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_LightningMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_LightningMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_LightningMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_LightningMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_LightningMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_LightningMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_LightningMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Luck
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Luck final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Luck) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Luck");
static_assert(sizeof(DCAttributeSet_OnRep_Luck) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Luck");
static_assert(offsetof(DCAttributeSet_OnRep_Luck, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Luck::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalAbsoluteReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalAbsoluteReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalAbsoluteReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalAbsoluteReduction");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalAbsoluteReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalAbsoluteReduction");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalAbsoluteReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalAbsoluteReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalArcaneDamageAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalArcaneDamageAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalArcaneDamageAdd");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalArcaneDamageAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalArcaneDamageAdd");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalArcaneDamageAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalArcaneDamageAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalArcaneDamageBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalArcaneDamageBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalArcaneDamageBase");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalArcaneDamageBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalArcaneDamageBase");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalArcaneDamageBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalArcaneDamageBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalArcaneDamageMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalArcaneDamageMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalArcaneDamageMod");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalArcaneDamageMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalArcaneDamageMod");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalArcaneDamageMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalArcaneDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDamageAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDamageAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDamageAdd");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDamageAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDamageAdd");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDamageAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDamageAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDamageBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDamageBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDamageBase");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDamageBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDamageBase");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDamageBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDamageBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDamageMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDamageMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDamageMod");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDamageMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDamageMod");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDamageMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageTrue
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDamageTrue final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDamageTrue) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDamageTrue");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDamageTrue) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDamageTrue");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDamageTrue, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDamageTrue::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageWeaponPrimary
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDamageWeaponPrimary final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDamageWeaponPrimary) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDamageWeaponPrimary");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDamageWeaponPrimary) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDamageWeaponPrimary");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDamageWeaponPrimary, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDamageWeaponPrimary::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageWeaponSecondary
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDamageWeaponSecondary final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDamageWeaponSecondary) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDamageWeaponSecondary");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDamageWeaponSecondary) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDamageWeaponSecondary");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDamageWeaponSecondary, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDamageWeaponSecondary::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDarkDamageAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDarkDamageAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDarkDamageAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDarkDamageAdd");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDarkDamageAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDarkDamageAdd");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDarkDamageAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDarkDamageAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDarkDamageBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDarkDamageBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDarkDamageBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDarkDamageBase");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDarkDamageBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDarkDamageBase");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDarkDamageBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDarkDamageBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDarkDamageMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDarkDamageMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDarkDamageMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDarkDamageMod");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDarkDamageMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDarkDamageMod");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDarkDamageMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDarkDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDivineDamageAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDivineDamageAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDivineDamageAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDivineDamageAdd");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDivineDamageAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDivineDamageAdd");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDivineDamageAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDivineDamageAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDivineDamageBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDivineDamageBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDivineDamageBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDivineDamageBase");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDivineDamageBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDivineDamageBase");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDivineDamageBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDivineDamageBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDivineDamageMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalDivineDamageMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalDivineDamageMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalDivineDamageMod");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalDivineDamageMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalDivineDamageMod");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalDivineDamageMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalDivineDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalFireDamageAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalFireDamageAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalFireDamageAdd");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalFireDamageAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalFireDamageAdd");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalFireDamageAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalFireDamageAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalFireDamageBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalFireDamageBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalFireDamageBase");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalFireDamageBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalFireDamageBase");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalFireDamageBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalFireDamageBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalFireDamageMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalFireDamageMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalFireDamageMod");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalFireDamageMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalFireDamageMod");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalFireDamageMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalFireDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalHealBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalHealBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalHealBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalHealBase");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalHealBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalHealBase");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalHealBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalHealBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalHealingReceiveMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalHealingReceiveMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalHealingReceiveMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalHealingReceiveMod");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalHealingReceiveMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalHealingReceiveMod");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalHealingReceiveMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalHealingReceiveMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalHealMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalHealMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalHealMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalHealMod");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalHealMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalHealMod");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalHealMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalHealMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalIceDamageAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalIceDamageAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalIceDamageAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalIceDamageAdd");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalIceDamageAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalIceDamageAdd");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalIceDamageAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalIceDamageAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalIceDamageBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalIceDamageBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalIceDamageBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalIceDamageBase");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalIceDamageBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalIceDamageBase");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalIceDamageBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalIceDamageBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalIceDamageMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalIceDamageMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalIceDamageMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalIceDamageMod");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalIceDamageMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalIceDamageMod");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalIceDamageMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalIceDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalInteractionSpeed
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalInteractionSpeed final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalInteractionSpeed) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalInteractionSpeed");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalInteractionSpeed) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalInteractionSpeed");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalInteractionSpeed, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalInteractionSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalPower
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalPower final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalPower) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalPower");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalPower) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalPower");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalPower, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalShield
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalShield final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalShield) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalShield");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalShield) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalShield");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalShield, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalShield::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalSpiritDamageAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalSpiritDamageAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalSpiritDamageAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalSpiritDamageAdd");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalSpiritDamageAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalSpiritDamageAdd");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalSpiritDamageAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalSpiritDamageAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalSpiritDamageBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalSpiritDamageBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalSpiritDamageBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalSpiritDamageBase");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalSpiritDamageBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalSpiritDamageBase");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalSpiritDamageBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalSpiritDamageBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalSpiritDamageMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicalSpiritDamageMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicalSpiritDamageMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicalSpiritDamageMod");
static_assert(sizeof(DCAttributeSet_OnRep_MagicalSpiritDamageMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicalSpiritDamageMod");
static_assert(offsetof(DCAttributeSet_OnRep_MagicalSpiritDamageMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicalSpiritDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicPenetration
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicPenetration final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicPenetration) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicPenetration");
static_assert(sizeof(DCAttributeSet_OnRep_MagicPenetration) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicPenetration");
static_assert(offsetof(DCAttributeSet_OnRep_MagicPenetration, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicPenetration::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_MagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_MagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ManualDexterity
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ManualDexterity final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ManualDexterity) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ManualDexterity");
static_assert(sizeof(DCAttributeSet_OnRep_ManualDexterity) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ManualDexterity");
static_assert(offsetof(DCAttributeSet_OnRep_ManualDexterity, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ManualDexterity::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealth
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MaxHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MaxHealth) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MaxHealth");
static_assert(sizeof(DCAttributeSet_OnRep_MaxHealth) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MaxHealth");
static_assert(offsetof(DCAttributeSet_OnRep_MaxHealth, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MaxHealth::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MaxHealthAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MaxHealthAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MaxHealthAdd");
static_assert(sizeof(DCAttributeSet_OnRep_MaxHealthAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MaxHealthAdd");
static_assert(offsetof(DCAttributeSet_OnRep_MaxHealthAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MaxHealthAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MaxHealthBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MaxHealthBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MaxHealthBase");
static_assert(sizeof(DCAttributeSet_OnRep_MaxHealthBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MaxHealthBase");
static_assert(offsetof(DCAttributeSet_OnRep_MaxHealthBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MaxHealthBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MaxHealthMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MaxHealthMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MaxHealthMod");
static_assert(sizeof(DCAttributeSet_OnRep_MaxHealthMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MaxHealthMod");
static_assert(offsetof(DCAttributeSet_OnRep_MaxHealthMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MaxHealthMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MaxImpactEndurance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MaxImpactEndurance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MaxImpactEndurance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MaxImpactEndurance");
static_assert(sizeof(DCAttributeSet_OnRep_MaxImpactEndurance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MaxImpactEndurance");
static_assert(offsetof(DCAttributeSet_OnRep_MaxImpactEndurance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MaxImpactEndurance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MaxMagicalShield
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MaxMagicalShield final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MaxMagicalShield) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MaxMagicalShield");
static_assert(sizeof(DCAttributeSet_OnRep_MaxMagicalShield) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MaxMagicalShield");
static_assert(offsetof(DCAttributeSet_OnRep_MaxMagicalShield, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MaxMagicalShield::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MaxPhysicalShield
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MaxPhysicalShield final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MaxPhysicalShield) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MaxPhysicalShield");
static_assert(sizeof(DCAttributeSet_OnRep_MaxPhysicalShield) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MaxPhysicalShield");
static_assert(offsetof(DCAttributeSet_OnRep_MaxPhysicalShield, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MaxPhysicalShield::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MaxSpellCountMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MaxSpellCountMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MaxSpellCountMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MaxSpellCountMod");
static_assert(sizeof(DCAttributeSet_OnRep_MaxSpellCountMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MaxSpellCountMod");
static_assert(offsetof(DCAttributeSet_OnRep_MaxSpellCountMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MaxSpellCountMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MaxTotalShield
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MaxTotalShield final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MaxTotalShield) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MaxTotalShield");
static_assert(sizeof(DCAttributeSet_OnRep_MaxTotalShield) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MaxTotalShield");
static_assert(offsetof(DCAttributeSet_OnRep_MaxTotalShield, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MaxTotalShield::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryCapacity
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MemoryCapacity final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MemoryCapacity) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MemoryCapacity");
static_assert(sizeof(DCAttributeSet_OnRep_MemoryCapacity) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MemoryCapacity");
static_assert(offsetof(DCAttributeSet_OnRep_MemoryCapacity, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MemoryCapacity::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryCapacityAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MemoryCapacityAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MemoryCapacityAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MemoryCapacityAdd");
static_assert(sizeof(DCAttributeSet_OnRep_MemoryCapacityAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MemoryCapacityAdd");
static_assert(offsetof(DCAttributeSet_OnRep_MemoryCapacityAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MemoryCapacityAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryCapacityBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MemoryCapacityBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MemoryCapacityBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MemoryCapacityBase");
static_assert(sizeof(DCAttributeSet_OnRep_MemoryCapacityBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MemoryCapacityBase");
static_assert(offsetof(DCAttributeSet_OnRep_MemoryCapacityBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MemoryCapacityBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryCapacityMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MemoryCapacityMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MemoryCapacityMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MemoryCapacityMod");
static_assert(sizeof(DCAttributeSet_OnRep_MemoryCapacityMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MemoryCapacityMod");
static_assert(offsetof(DCAttributeSet_OnRep_MemoryCapacityMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MemoryCapacityMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryMusicPayload
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MemoryMusicPayload final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MemoryMusicPayload) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MemoryMusicPayload");
static_assert(sizeof(DCAttributeSet_OnRep_MemoryMusicPayload) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MemoryMusicPayload");
static_assert(offsetof(DCAttributeSet_OnRep_MemoryMusicPayload, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MemoryMusicPayload::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryRecoveryMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MemoryRecoveryMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MemoryRecoveryMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MemoryRecoveryMod");
static_assert(sizeof(DCAttributeSet_OnRep_MemoryRecoveryMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MemoryRecoveryMod");
static_assert(offsetof(DCAttributeSet_OnRep_MemoryRecoveryMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MemoryRecoveryMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MemorySpellPayload
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MemorySpellPayload final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MemorySpellPayload) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MemorySpellPayload");
static_assert(sizeof(DCAttributeSet_OnRep_MemorySpellPayload) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MemorySpellPayload");
static_assert(offsetof(DCAttributeSet_OnRep_MemorySpellPayload, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MemorySpellPayload::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeed
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MoveSpeed final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MoveSpeed) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MoveSpeed");
static_assert(sizeof(DCAttributeSet_OnRep_MoveSpeed) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MoveSpeed");
static_assert(offsetof(DCAttributeSet_OnRep_MoveSpeed, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MoveSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MoveSpeedAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MoveSpeedAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MoveSpeedAdd");
static_assert(sizeof(DCAttributeSet_OnRep_MoveSpeedAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MoveSpeedAdd");
static_assert(offsetof(DCAttributeSet_OnRep_MoveSpeedAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MoveSpeedAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedArmorPenalty
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MoveSpeedArmorPenalty final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MoveSpeedArmorPenalty) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MoveSpeedArmorPenalty");
static_assert(sizeof(DCAttributeSet_OnRep_MoveSpeedArmorPenalty) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MoveSpeedArmorPenalty");
static_assert(offsetof(DCAttributeSet_OnRep_MoveSpeedArmorPenalty, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MoveSpeedArmorPenalty::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedArmorPenaltyMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MoveSpeedArmorPenaltyMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MoveSpeedArmorPenaltyMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MoveSpeedArmorPenaltyMod");
static_assert(sizeof(DCAttributeSet_OnRep_MoveSpeedArmorPenaltyMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MoveSpeedArmorPenaltyMod");
static_assert(offsetof(DCAttributeSet_OnRep_MoveSpeedArmorPenaltyMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MoveSpeedArmorPenaltyMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MoveSpeedBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MoveSpeedBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MoveSpeedBase");
static_assert(sizeof(DCAttributeSet_OnRep_MoveSpeedBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MoveSpeedBase");
static_assert(offsetof(DCAttributeSet_OnRep_MoveSpeedBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MoveSpeedBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MoveSpeedMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MoveSpeedMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MoveSpeedMod");
static_assert(sizeof(DCAttributeSet_OnRep_MoveSpeedMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MoveSpeedMod");
static_assert(offsetof(DCAttributeSet_OnRep_MoveSpeedMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MoveSpeedMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedWithModifier
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_MoveSpeedWithModifier final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_MoveSpeedWithModifier) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_MoveSpeedWithModifier");
static_assert(sizeof(DCAttributeSet_OnRep_MoveSpeedWithModifier) == 0x000010, "Wrong size on DCAttributeSet_OnRep_MoveSpeedWithModifier");
static_assert(offsetof(DCAttributeSet_OnRep_MoveSpeedWithModifier, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_MoveSpeedWithModifier::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_OverhealedHealth
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_OverhealedHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_OverhealedHealth) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_OverhealedHealth");
static_assert(sizeof(DCAttributeSet_OnRep_OverhealedHealth) == 0x000010, "Wrong size on DCAttributeSet_OnRep_OverhealedHealth");
static_assert(offsetof(DCAttributeSet_OnRep_OverhealedHealth, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_OverhealedHealth::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Persuasiveness
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Persuasiveness final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Persuasiveness) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Persuasiveness");
static_assert(sizeof(DCAttributeSet_OnRep_Persuasiveness) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Persuasiveness");
static_assert(offsetof(DCAttributeSet_OnRep_Persuasiveness, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Persuasiveness::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalAbsoluteReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalAbsoluteReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalAbsoluteReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalAbsoluteReduction");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalAbsoluteReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalAbsoluteReduction");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalAbsoluteReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalAbsoluteReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalBackstabPower
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalBackstabPower final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalBackstabPower) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalBackstabPower");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalBackstabPower) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalBackstabPower");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalBackstabPower, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalBackstabPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalDamageAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalDamageAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalDamageAdd");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalDamageAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalDamageAdd");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalDamageAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalDamageAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalDamageBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalDamageBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalDamageBase");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalDamageBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalDamageBase");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalDamageBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalDamageBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalDamageMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalDamageMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalDamageMod");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalDamageMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalDamageMod");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalDamageMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageTrue
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalDamageTrue final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalDamageTrue) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalDamageTrue");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalDamageTrue) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalDamageTrue");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalDamageTrue, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalDamageTrue::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageWeaponPrimary
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalDamageWeaponPrimary final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalDamageWeaponPrimary) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalDamageWeaponPrimary");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalDamageWeaponPrimary) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalDamageWeaponPrimary");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalDamageWeaponPrimary, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalDamageWeaponPrimary::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageWeaponSecondary
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalDamageWeaponSecondary final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalDamageWeaponSecondary) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalDamageWeaponSecondary");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalDamageWeaponSecondary) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalDamageWeaponSecondary");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalDamageWeaponSecondary, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalDamageWeaponSecondary::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHeadshotPenetration
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalHeadshotPenetration final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalHeadshotPenetration) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalHeadshotPenetration");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalHeadshotPenetration) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalHeadshotPenetration");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalHeadshotPenetration, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalHeadshotPenetration::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHeadshotPower
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalHeadshotPower final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalHeadshotPower) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalHeadshotPower");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalHeadshotPower) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalHeadshotPower");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalHeadshotPower, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalHeadshotPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHealBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalHealBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalHealBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalHealBase");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalHealBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalHealBase");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalHealBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalHealBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHealingReceiveMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalHealingReceiveMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalHealingReceiveMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalHealingReceiveMod");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalHealingReceiveMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalHealingReceiveMod");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalHealingReceiveMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalHealingReceiveMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHealMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalHealMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalHealMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalHealMod");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalHealMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalHealMod");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalHealMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalHealMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalPower
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalPower final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalPower) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalPower");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalPower) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalPower");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalPower, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalPower::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalShield
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_PhysicalShield final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_PhysicalShield) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_PhysicalShield");
static_assert(sizeof(DCAttributeSet_OnRep_PhysicalShield) == 0x000010, "Wrong size on DCAttributeSet_OnRep_PhysicalShield");
static_assert(offsetof(DCAttributeSet_OnRep_PhysicalShield, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_PhysicalShield::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ProjectileReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ProjectileReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ProjectileReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ProjectileReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_ProjectileReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ProjectileReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_ProjectileReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ProjectileReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_RecoverableHealth
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_RecoverableHealth final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_RecoverableHealth) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_RecoverableHealth");
static_assert(sizeof(DCAttributeSet_OnRep_RecoverableHealth) == 0x000010, "Wrong size on DCAttributeSet_OnRep_RecoverableHealth");
static_assert(offsetof(DCAttributeSet_OnRep_RecoverableHealth, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_RecoverableHealth::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_RegularInteractionSpeed
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_RegularInteractionSpeed final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_RegularInteractionSpeed) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_RegularInteractionSpeed");
static_assert(sizeof(DCAttributeSet_OnRep_RegularInteractionSpeed) == 0x000010, "Wrong size on DCAttributeSet_OnRep_RegularInteractionSpeed");
static_assert(offsetof(DCAttributeSet_OnRep_RegularInteractionSpeed, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_RegularInteractionSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_RegularInteractionSpeedBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_RegularInteractionSpeedBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_RegularInteractionSpeedBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_RegularInteractionSpeedBase");
static_assert(sizeof(DCAttributeSet_OnRep_RegularInteractionSpeedBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_RegularInteractionSpeedBase");
static_assert(offsetof(DCAttributeSet_OnRep_RegularInteractionSpeedBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_RegularInteractionSpeedBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Resourcefulness
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Resourcefulness final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Resourcefulness) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Resourcefulness");
static_assert(sizeof(DCAttributeSet_OnRep_Resourcefulness) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Resourcefulness");
static_assert(offsetof(DCAttributeSet_OnRep_Resourcefulness, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Resourcefulness::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ResourcefulnessBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ResourcefulnessBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ResourcefulnessBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ResourcefulnessBase");
static_assert(sizeof(DCAttributeSet_OnRep_ResourcefulnessBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ResourcefulnessBase");
static_assert(offsetof(DCAttributeSet_OnRep_ResourcefulnessBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ResourcefulnessBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_ResourcefulnessMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_ResourcefulnessMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_ResourcefulnessMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_ResourcefulnessMod");
static_assert(sizeof(DCAttributeSet_OnRep_ResourcefulnessMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_ResourcefulnessMod");
static_assert(offsetof(DCAttributeSet_OnRep_ResourcefulnessMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_ResourcefulnessMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Rigidity
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Rigidity final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Rigidity) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Rigidity");
static_assert(sizeof(DCAttributeSet_OnRep_Rigidity) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Rigidity");
static_assert(offsetof(DCAttributeSet_OnRep_Rigidity, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Rigidity::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_SpellCastingSpeed
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_SpellCastingSpeed final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_SpellCastingSpeed) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_SpellCastingSpeed");
static_assert(sizeof(DCAttributeSet_OnRep_SpellCastingSpeed) == 0x000010, "Wrong size on DCAttributeSet_OnRep_SpellCastingSpeed");
static_assert(offsetof(DCAttributeSet_OnRep_SpellCastingSpeed, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_SpellCastingSpeed::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_SpiritMagicalReduction
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_SpiritMagicalReduction final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_SpiritMagicalReduction) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_SpiritMagicalReduction");
static_assert(sizeof(DCAttributeSet_OnRep_SpiritMagicalReduction) == 0x000010, "Wrong size on DCAttributeSet_OnRep_SpiritMagicalReduction");
static_assert(offsetof(DCAttributeSet_OnRep_SpiritMagicalReduction, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_SpiritMagicalReduction::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_SpiritMagicalReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_SpiritMagicalReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_SpiritMagicalReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_SpiritMagicalReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_SpiritMagicalReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_SpiritMagicalReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_SpiritMagicalReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_SpiritMagicalReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_SpiritMagicResistance
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_SpiritMagicResistance final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_SpiritMagicResistance) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_SpiritMagicResistance");
static_assert(sizeof(DCAttributeSet_OnRep_SpiritMagicResistance) == 0x000010, "Wrong size on DCAttributeSet_OnRep_SpiritMagicResistance");
static_assert(offsetof(DCAttributeSet_OnRep_SpiritMagicResistance, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_SpiritMagicResistance::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Strength
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Strength final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Strength) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Strength");
static_assert(sizeof(DCAttributeSet_OnRep_Strength) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Strength");
static_assert(offsetof(DCAttributeSet_OnRep_Strength, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Strength::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_StrengthBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_StrengthBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_StrengthBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_StrengthBase");
static_assert(sizeof(DCAttributeSet_OnRep_StrengthBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_StrengthBase");
static_assert(offsetof(DCAttributeSet_OnRep_StrengthBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_StrengthBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_StrengthMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_StrengthMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_StrengthMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_StrengthMod");
static_assert(sizeof(DCAttributeSet_OnRep_StrengthMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_StrengthMod");
static_assert(offsetof(DCAttributeSet_OnRep_StrengthMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_StrengthMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_TotalShield
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_TotalShield final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_TotalShield) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_TotalShield");
static_assert(sizeof(DCAttributeSet_OnRep_TotalShield) == 0x000010, "Wrong size on DCAttributeSet_OnRep_TotalShield");
static_assert(offsetof(DCAttributeSet_OnRep_TotalShield, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_TotalShield::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_UndeadDamageMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_UndeadDamageMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_UndeadDamageMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_UndeadDamageMod");
static_assert(sizeof(DCAttributeSet_OnRep_UndeadDamageMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_UndeadDamageMod");
static_assert(offsetof(DCAttributeSet_OnRep_UndeadDamageMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_UndeadDamageMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_UndeadReductionMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_UndeadReductionMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_UndeadReductionMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_UndeadReductionMod");
static_assert(sizeof(DCAttributeSet_OnRep_UndeadReductionMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_UndeadReductionMod");
static_assert(offsetof(DCAttributeSet_OnRep_UndeadReductionMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_UndeadReductionMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectiveness
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_UtilityEffectiveness final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_UtilityEffectiveness) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_UtilityEffectiveness");
static_assert(sizeof(DCAttributeSet_OnRep_UtilityEffectiveness) == 0x000010, "Wrong size on DCAttributeSet_OnRep_UtilityEffectiveness");
static_assert(offsetof(DCAttributeSet_OnRep_UtilityEffectiveness, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_UtilityEffectiveness::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_UtilityEffectivenessAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_UtilityEffectivenessAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_UtilityEffectivenessAdd");
static_assert(sizeof(DCAttributeSet_OnRep_UtilityEffectivenessAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_UtilityEffectivenessAdd");
static_assert(offsetof(DCAttributeSet_OnRep_UtilityEffectivenessAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_UtilityEffectivenessAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_UtilityEffectivenessBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_UtilityEffectivenessBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_UtilityEffectivenessBase");
static_assert(sizeof(DCAttributeSet_OnRep_UtilityEffectivenessBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_UtilityEffectivenessBase");
static_assert(offsetof(DCAttributeSet_OnRep_UtilityEffectivenessBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_UtilityEffectivenessBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_UtilityEffectivenessMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_UtilityEffectivenessMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_UtilityEffectivenessMod");
static_assert(sizeof(DCAttributeSet_OnRep_UtilityEffectivenessMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_UtilityEffectivenessMod");
static_assert(offsetof(DCAttributeSet_OnRep_UtilityEffectivenessMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_UtilityEffectivenessMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Vigor
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Vigor final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Vigor) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Vigor");
static_assert(sizeof(DCAttributeSet_OnRep_Vigor) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Vigor");
static_assert(offsetof(DCAttributeSet_OnRep_Vigor, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Vigor::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_VigorBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_VigorBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_VigorBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_VigorBase");
static_assert(sizeof(DCAttributeSet_OnRep_VigorBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_VigorBase");
static_assert(offsetof(DCAttributeSet_OnRep_VigorBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_VigorBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_VigorMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_VigorMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_VigorMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_VigorMod");
static_assert(sizeof(DCAttributeSet_OnRep_VigorMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_VigorMod");
static_assert(offsetof(DCAttributeSet_OnRep_VigorMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_VigorMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Weight
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Weight final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Weight) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Weight");
static_assert(sizeof(DCAttributeSet_OnRep_Weight) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Weight");
static_assert(offsetof(DCAttributeSet_OnRep_Weight, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Weight::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimit
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_WeightLimit final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_WeightLimit) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_WeightLimit");
static_assert(sizeof(DCAttributeSet_OnRep_WeightLimit) == 0x000010, "Wrong size on DCAttributeSet_OnRep_WeightLimit");
static_assert(offsetof(DCAttributeSet_OnRep_WeightLimit, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_WeightLimit::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitAdd
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_WeightLimitAdd final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_WeightLimitAdd) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_WeightLimitAdd");
static_assert(sizeof(DCAttributeSet_OnRep_WeightLimitAdd) == 0x000010, "Wrong size on DCAttributeSet_OnRep_WeightLimitAdd");
static_assert(offsetof(DCAttributeSet_OnRep_WeightLimitAdd, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_WeightLimitAdd::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_WeightLimitBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_WeightLimitBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_WeightLimitBase");
static_assert(sizeof(DCAttributeSet_OnRep_WeightLimitBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_WeightLimitBase");
static_assert(offsetof(DCAttributeSet_OnRep_WeightLimitBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_WeightLimitBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_WeightLimitMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_WeightLimitMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_WeightLimitMod");
static_assert(sizeof(DCAttributeSet_OnRep_WeightLimitMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_WeightLimitMod");
static_assert(offsetof(DCAttributeSet_OnRep_WeightLimitMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_WeightLimitMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_Will
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_Will final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_Will) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_Will");
static_assert(sizeof(DCAttributeSet_OnRep_Will) == 0x000010, "Wrong size on DCAttributeSet_OnRep_Will");
static_assert(offsetof(DCAttributeSet_OnRep_Will, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_Will::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_WillBase
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_WillBase final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_WillBase) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_WillBase");
static_assert(sizeof(DCAttributeSet_OnRep_WillBase) == 0x000010, "Wrong size on DCAttributeSet_OnRep_WillBase");
static_assert(offsetof(DCAttributeSet_OnRep_WillBase, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_WillBase::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAttributeSet.OnRep_WillMod
// 0x0010 (0x0010 - 0x0000)
struct DCAttributeSet_OnRep_WillMod final
{
public:
	struct FGameplayAttributeData                 OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAttributeSet_OnRep_WillMod) == 0x000008, "Wrong alignment on DCAttributeSet_OnRep_WillMod");
static_assert(sizeof(DCAttributeSet_OnRep_WillMod) == 0x000010, "Wrong size on DCAttributeSet_OnRep_WillMod");
static_assert(offsetof(DCAttributeSet_OnRep_WillMod, OldValue) == 0x000000, "Member 'DCAttributeSet_OnRep_WillMod::OldValue' has a wrong offset!");

// Function DungeonCrawler.ClientPartySubsystem.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct ClientPartySubsystem_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientPartySubsystem_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on ClientPartySubsystem_BroadcastMsgBlueprint");
static_assert(sizeof(ClientPartySubsystem_BroadcastMsgBlueprint) == 0x000004, "Wrong size on ClientPartySubsystem_BroadcastMsgBlueprint");
static_assert(offsetof(ClientPartySubsystem_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'ClientPartySubsystem_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClientPartySubsystem.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct ClientPartySubsystem_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientPartySubsystem_UnbindMsg) == 0x000008, "Wrong alignment on ClientPartySubsystem_UnbindMsg");
static_assert(sizeof(ClientPartySubsystem_UnbindMsg) == 0x000010, "Wrong size on ClientPartySubsystem_UnbindMsg");
static_assert(offsetof(ClientPartySubsystem_UnbindMsg, InMsgType) == 0x000000, "Member 'ClientPartySubsystem_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(ClientPartySubsystem_UnbindMsg, InObject) == 0x000008, "Member 'ClientPartySubsystem_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.ClientPartySubsystem.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct ClientPartySubsystem_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientPartySubsystem_UnbindMsgAll) == 0x000008, "Wrong alignment on ClientPartySubsystem_UnbindMsgAll");
static_assert(sizeof(ClientPartySubsystem_UnbindMsgAll) == 0x000008, "Wrong size on ClientPartySubsystem_UnbindMsgAll");
static_assert(offsetof(ClientPartySubsystem_UnbindMsgAll, InObject) == 0x000000, "Member 'ClientPartySubsystem_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.ClientShopSubsystem.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct ClientShopSubsystem_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientShopSubsystem_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on ClientShopSubsystem_BroadcastMsgBlueprint");
static_assert(sizeof(ClientShopSubsystem_BroadcastMsgBlueprint) == 0x000004, "Wrong size on ClientShopSubsystem_BroadcastMsgBlueprint");
static_assert(offsetof(ClientShopSubsystem_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'ClientShopSubsystem_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ClientShopSubsystem.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct ClientShopSubsystem_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientShopSubsystem_UnbindMsg) == 0x000008, "Wrong alignment on ClientShopSubsystem_UnbindMsg");
static_assert(sizeof(ClientShopSubsystem_UnbindMsg) == 0x000010, "Wrong size on ClientShopSubsystem_UnbindMsg");
static_assert(offsetof(ClientShopSubsystem_UnbindMsg, InMsgType) == 0x000000, "Member 'ClientShopSubsystem_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(ClientShopSubsystem_UnbindMsg, InObject) == 0x000008, "Member 'ClientShopSubsystem_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.ClientShopSubsystem.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct ClientShopSubsystem_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientShopSubsystem_UnbindMsgAll) == 0x000008, "Wrong alignment on ClientShopSubsystem_UnbindMsgAll");
static_assert(sizeof(ClientShopSubsystem_UnbindMsgAll) == 0x000008, "Wrong size on ClientShopSubsystem_UnbindMsgAll");
static_assert(offsetof(ClientShopSubsystem_UnbindMsgAll, InObject) == 0x000000, "Member 'ClientShopSubsystem_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitAimDirChangedFromLoc.WaitAimDirectionChangedFromLocation
// 0x0028 (0x0028 - 0x0000)
struct DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialAimTargetLocation;                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitAimDirChangedFromLoc*         ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation) == 0x000008, "Wrong alignment on DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation");
static_assert(sizeof(DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation) == 0x000028, "Wrong size on DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation");
static_assert(offsetof(DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation, OwningAbility) == 0x000000, "Member 'DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation, InitialAimTargetLocation) == 0x000008, "Member 'DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation::InitialAimTargetLocation' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation, ReturnValue) == 0x000020, "Member 'DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CommemorativePlaqueTextWidget.SetCommemorativePlaqueText
// 0x0028 (0x0028 - 0x0000)
struct CommemorativePlaqueTextWidget_SetCommemorativePlaqueText final
{
public:
	struct FPrimaryAssetId                        ScriptId;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommemorativePlaqueTextWidget_SetCommemorativePlaqueText) == 0x000008, "Wrong alignment on CommemorativePlaqueTextWidget_SetCommemorativePlaqueText");
static_assert(sizeof(CommemorativePlaqueTextWidget_SetCommemorativePlaqueText) == 0x000028, "Wrong size on CommemorativePlaqueTextWidget_SetCommemorativePlaqueText");
static_assert(offsetof(CommemorativePlaqueTextWidget_SetCommemorativePlaqueText, ScriptId) == 0x000000, "Member 'CommemorativePlaqueTextWidget_SetCommemorativePlaqueText::ScriptId' has a wrong offset!");
static_assert(offsetof(CommemorativePlaqueTextWidget_SetCommemorativePlaqueText, Location) == 0x000010, "Member 'CommemorativePlaqueTextWidget_SetCommemorativePlaqueText::Location' has a wrong offset!");

// Function DungeonCrawler.CommemorativePlaqueTextWidget.UpdateCommenorativePlaqueText
// 0x0028 (0x0028 - 0x0000)
struct CommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText final
{
public:
	TArray<class FText>                           InText;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText) == 0x000008, "Wrong alignment on CommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText");
static_assert(sizeof(CommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText) == 0x000028, "Wrong size on CommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText");
static_assert(offsetof(CommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText, InText) == 0x000000, "Member 'CommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText::InText' has a wrong offset!");
static_assert(offsetof(CommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText, Location) == 0x000010, "Member 'CommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText::Location' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGameplayEffectAdd.WaitGameplayEffectAdded
// 0x0018 (0x0018 - 0x0000)
struct DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250D[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitGameplayEffectAdd*            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded) == 0x000008, "Wrong alignment on DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded");
static_assert(sizeof(DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded) == 0x000018, "Wrong size on DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded");
static_assert(offsetof(DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded, OwningAbility) == 0x000000, "Member 'DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded, TriggerOnce) == 0x000008, "Member 'DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded::TriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded, ReturnValue) == 0x000010, "Member 'DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGameplayEffectAdd.OnApplyGameplayEffectCallback
// 0x02A8 (0x02A8 - 0x0000)
struct DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback final
{
public:
	class UAbilitySystemComponent*                Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    SpecApplied;                                       // 0x0008(0x0298)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            ActiveHandle;                                      // 0x02A0(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback) == 0x000008, "Wrong alignment on DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback");
static_assert(sizeof(DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback) == 0x0002A8, "Wrong size on DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback");
static_assert(offsetof(DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback, Target) == 0x000000, "Member 'DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback::Target' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback, SpecApplied) == 0x000008, "Member 'DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback::SpecApplied' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback, ActiveHandle) == 0x0002A0, "Member 'DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback::ActiveHandle' has a wrong offset!");

// Function DungeonCrawler.PopupDataSWidget.Cancel
// 0x0001 (0x0001 - 0x0000)
struct PopupDataSWidget_Cancel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PopupDataSWidget_Cancel) == 0x000001, "Wrong alignment on PopupDataSWidget_Cancel");
static_assert(sizeof(PopupDataSWidget_Cancel) == 0x000001, "Wrong size on PopupDataSWidget_Cancel");
static_assert(offsetof(PopupDataSWidget_Cancel, ReturnValue) == 0x000000, "Member 'PopupDataSWidget_Cancel::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CommonPopupSWidget.CheckBanAppealVisibleType
// 0x0001 (0x0001 - 0x0000)
struct CommonPopupSWidget_CheckBanAppealVisibleType final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommonPopupSWidget_CheckBanAppealVisibleType) == 0x000001, "Wrong alignment on CommonPopupSWidget_CheckBanAppealVisibleType");
static_assert(sizeof(CommonPopupSWidget_CheckBanAppealVisibleType) == 0x000001, "Wrong size on CommonPopupSWidget_CheckBanAppealVisibleType");
static_assert(offsetof(CommonPopupSWidget_CheckBanAppealVisibleType, ReturnValue) == 0x000000, "Member 'CommonPopupSWidget_CheckBanAppealVisibleType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.CommonPopupSWidget.OnCreatePopup
// 0x0020 (0x0020 - 0x0000)
struct CommonPopupSWidget_OnCreatePopup final
{
public:
	struct FPopupSWidgetData                      PopupSWidgetData;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CommonPopupSWidget_OnCreatePopup) == 0x000008, "Wrong alignment on CommonPopupSWidget_OnCreatePopup");
static_assert(sizeof(CommonPopupSWidget_OnCreatePopup) == 0x000020, "Wrong size on CommonPopupSWidget_OnCreatePopup");
static_assert(offsetof(CommonPopupSWidget_OnCreatePopup, PopupSWidgetData) == 0x000000, "Member 'CommonPopupSWidget_OnCreatePopup::PopupSWidgetData' has a wrong offset!");

// Function DungeonCrawler.DCAnimInstanceBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCAnimInstanceBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAnimInstanceBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCAnimInstanceBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCAnimInstanceBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCAnimInstanceBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCAnimInstanceBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCAnimInstanceBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCAnimInstanceBase.EventMontageStarted
// 0x0008 (0x0008 - 0x0000)
struct DCAnimInstanceBase_EventMontageStarted final
{
public:
	class UAnimMontage*                           InMontage;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAnimInstanceBase_EventMontageStarted) == 0x000008, "Wrong alignment on DCAnimInstanceBase_EventMontageStarted");
static_assert(sizeof(DCAnimInstanceBase_EventMontageStarted) == 0x000008, "Wrong size on DCAnimInstanceBase_EventMontageStarted");
static_assert(offsetof(DCAnimInstanceBase_EventMontageStarted, InMontage) == 0x000000, "Member 'DCAnimInstanceBase_EventMontageStarted::InMontage' has a wrong offset!");

// Function DungeonCrawler.DCAnimInstanceBase.GetOriginActor
// 0x0008 (0x0008 - 0x0000)
struct DCAnimInstanceBase_GetOriginActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAnimInstanceBase_GetOriginActor) == 0x000008, "Wrong alignment on DCAnimInstanceBase_GetOriginActor");
static_assert(sizeof(DCAnimInstanceBase_GetOriginActor) == 0x000008, "Wrong size on DCAnimInstanceBase_GetOriginActor");
static_assert(offsetof(DCAnimInstanceBase_GetOriginActor, ReturnValue) == 0x000000, "Member 'DCAnimInstanceBase_GetOriginActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAnimInstanceBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCAnimInstanceBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAnimInstanceBase_UnbindMsg) == 0x000008, "Wrong alignment on DCAnimInstanceBase_UnbindMsg");
static_assert(sizeof(DCAnimInstanceBase_UnbindMsg) == 0x000010, "Wrong size on DCAnimInstanceBase_UnbindMsg");
static_assert(offsetof(DCAnimInstanceBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCAnimInstanceBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCAnimInstanceBase_UnbindMsg, InObject) == 0x000008, "Member 'DCAnimInstanceBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAnimInstanceBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCAnimInstanceBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAnimInstanceBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCAnimInstanceBase_UnbindMsgAll");
static_assert(sizeof(DCAnimInstanceBase_UnbindMsgAll) == 0x000008, "Wrong size on DCAnimInstanceBase_UnbindMsgAll");
static_assert(offsetof(DCAnimInstanceBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCAnimInstanceBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.ContainerInventoryGroupWidget.OnItemDropDetected
// 0x0118 (0x0118 - 0x0000)
struct ContainerInventoryGroupWidget_OnItemDropDetected final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector2D                              DropScreenPos;                                     // 0x0100(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OldOwnerActor;                                     // 0x0110(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContainerInventoryGroupWidget_OnItemDropDetected) == 0x000008, "Wrong alignment on ContainerInventoryGroupWidget_OnItemDropDetected");
static_assert(sizeof(ContainerInventoryGroupWidget_OnItemDropDetected) == 0x000118, "Wrong size on ContainerInventoryGroupWidget_OnItemDropDetected");
static_assert(offsetof(ContainerInventoryGroupWidget_OnItemDropDetected, ItemData) == 0x000000, "Member 'ContainerInventoryGroupWidget_OnItemDropDetected::ItemData' has a wrong offset!");
static_assert(offsetof(ContainerInventoryGroupWidget_OnItemDropDetected, DropScreenPos) == 0x000100, "Member 'ContainerInventoryGroupWidget_OnItemDropDetected::DropScreenPos' has a wrong offset!");
static_assert(offsetof(ContainerInventoryGroupWidget_OnItemDropDetected, OldOwnerActor) == 0x000110, "Member 'ContainerInventoryGroupWidget_OnItemDropDetected::OldOwnerActor' has a wrong offset!");

// Function DungeonCrawler.ContainerInventoryGroupWidget.OnPopItemSelectWidget
// 0x0118 (0x0118 - 0x0000)
struct ContainerInventoryGroupWidget_OnPopItemSelectWidget final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector2D                              DropScreenPos;                                     // 0x0100(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OldOwnerActor;                                     // 0x0110(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContainerInventoryGroupWidget_OnPopItemSelectWidget) == 0x000008, "Wrong alignment on ContainerInventoryGroupWidget_OnPopItemSelectWidget");
static_assert(sizeof(ContainerInventoryGroupWidget_OnPopItemSelectWidget) == 0x000118, "Wrong size on ContainerInventoryGroupWidget_OnPopItemSelectWidget");
static_assert(offsetof(ContainerInventoryGroupWidget_OnPopItemSelectWidget, ItemData) == 0x000000, "Member 'ContainerInventoryGroupWidget_OnPopItemSelectWidget::ItemData' has a wrong offset!");
static_assert(offsetof(ContainerInventoryGroupWidget_OnPopItemSelectWidget, DropScreenPos) == 0x000100, "Member 'ContainerInventoryGroupWidget_OnPopItemSelectWidget::DropScreenPos' has a wrong offset!");
static_assert(offsetof(ContainerInventoryGroupWidget_OnPopItemSelectWidget, OldOwnerActor) == 0x000110, "Member 'ContainerInventoryGroupWidget_OnPopItemSelectWidget::OldOwnerActor' has a wrong offset!");

// Function DungeonCrawler.ContainerInventoryWidget.CanSetItemAt
// 0x0108 (0x0108 - 0x0000)
struct ContainerInventoryWidget_CanSetItemAt final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         SlotId;                                            // 0x0100(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0104(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251B[0x3];                                     // 0x0105(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ContainerInventoryWidget_CanSetItemAt) == 0x000008, "Wrong alignment on ContainerInventoryWidget_CanSetItemAt");
static_assert(sizeof(ContainerInventoryWidget_CanSetItemAt) == 0x000108, "Wrong size on ContainerInventoryWidget_CanSetItemAt");
static_assert(offsetof(ContainerInventoryWidget_CanSetItemAt, ItemData) == 0x000000, "Member 'ContainerInventoryWidget_CanSetItemAt::ItemData' has a wrong offset!");
static_assert(offsetof(ContainerInventoryWidget_CanSetItemAt, SlotId) == 0x000100, "Member 'ContainerInventoryWidget_CanSetItemAt::SlotId' has a wrong offset!");
static_assert(offsetof(ContainerInventoryWidget_CanSetItemAt, ReturnValue) == 0x000104, "Member 'ContainerInventoryWidget_CanSetItemAt::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ContainerInventoryWidget.GetSlotIdByScreenPosition
// 0x0018 (0x0018 - 0x0000)
struct ContainerInventoryWidget_GetSlotIdByScreenPosition final
{
public:
	struct FVector2D                              ScreenPos;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251C[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ContainerInventoryWidget_GetSlotIdByScreenPosition) == 0x000008, "Wrong alignment on ContainerInventoryWidget_GetSlotIdByScreenPosition");
static_assert(sizeof(ContainerInventoryWidget_GetSlotIdByScreenPosition) == 0x000018, "Wrong size on ContainerInventoryWidget_GetSlotIdByScreenPosition");
static_assert(offsetof(ContainerInventoryWidget_GetSlotIdByScreenPosition, ScreenPos) == 0x000000, "Member 'ContainerInventoryWidget_GetSlotIdByScreenPosition::ScreenPos' has a wrong offset!");
static_assert(offsetof(ContainerInventoryWidget_GetSlotIdByScreenPosition, ReturnValue) == 0x000010, "Member 'ContainerInventoryWidget_GetSlotIdByScreenPosition::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ContainerInventoryWidget.OnAddItem
// 0x0108 (0x0108 - 0x0000)
struct ContainerInventoryWidget_OnAddItem final
{
public:
	struct FItemData                              InItemData;                                        // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UItemWidget*                            ReturnValue;                                       // 0x0100(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContainerInventoryWidget_OnAddItem) == 0x000008, "Wrong alignment on ContainerInventoryWidget_OnAddItem");
static_assert(sizeof(ContainerInventoryWidget_OnAddItem) == 0x000108, "Wrong size on ContainerInventoryWidget_OnAddItem");
static_assert(offsetof(ContainerInventoryWidget_OnAddItem, InItemData) == 0x000000, "Member 'ContainerInventoryWidget_OnAddItem::InItemData' has a wrong offset!");
static_assert(offsetof(ContainerInventoryWidget_OnAddItem, ReturnValue) == 0x000100, "Member 'ContainerInventoryWidget_OnAddItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ContainerInventoryWidget.OnItemDragDetected
// 0x0110 (0x0110 - 0x0000)
struct ContainerInventoryWidget_OnItemDragDetected final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector2D                              DragScreenPos;                                     // 0x0100(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContainerInventoryWidget_OnItemDragDetected) == 0x000008, "Wrong alignment on ContainerInventoryWidget_OnItemDragDetected");
static_assert(sizeof(ContainerInventoryWidget_OnItemDragDetected) == 0x000110, "Wrong size on ContainerInventoryWidget_OnItemDragDetected");
static_assert(offsetof(ContainerInventoryWidget_OnItemDragDetected, ItemData) == 0x000000, "Member 'ContainerInventoryWidget_OnItemDragDetected::ItemData' has a wrong offset!");
static_assert(offsetof(ContainerInventoryWidget_OnItemDragDetected, DragScreenPos) == 0x000100, "Member 'ContainerInventoryWidget_OnItemDragDetected::DragScreenPos' has a wrong offset!");

// Function DungeonCrawler.ContainerInventoryWidget.OnMoveItem
// 0x0200 (0x0200 - 0x0000)
struct ContainerInventoryWidget_OnMoveItem final
{
public:
	struct FItemData                              OldItemData;                                       // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FItemData                              NewItemData;                                       // 0x0100(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContainerInventoryWidget_OnMoveItem) == 0x000008, "Wrong alignment on ContainerInventoryWidget_OnMoveItem");
static_assert(sizeof(ContainerInventoryWidget_OnMoveItem) == 0x000200, "Wrong size on ContainerInventoryWidget_OnMoveItem");
static_assert(offsetof(ContainerInventoryWidget_OnMoveItem, OldItemData) == 0x000000, "Member 'ContainerInventoryWidget_OnMoveItem::OldItemData' has a wrong offset!");
static_assert(offsetof(ContainerInventoryWidget_OnMoveItem, NewItemData) == 0x000100, "Member 'ContainerInventoryWidget_OnMoveItem::NewItemData' has a wrong offset!");

// Function DungeonCrawler.ContainerInventoryWidget.OnRemoveItem
// 0x0100 (0x0100 - 0x0000)
struct ContainerInventoryWidget_OnRemoveItem final
{
public:
	struct FItemData                              InItemData;                                        // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContainerInventoryWidget_OnRemoveItem) == 0x000008, "Wrong alignment on ContainerInventoryWidget_OnRemoveItem");
static_assert(sizeof(ContainerInventoryWidget_OnRemoveItem) == 0x000100, "Wrong size on ContainerInventoryWidget_OnRemoveItem");
static_assert(offsetof(ContainerInventoryWidget_OnRemoveItem, InItemData) == 0x000000, "Member 'ContainerInventoryWidget_OnRemoveItem::InItemData' has a wrong offset!");

// Function DungeonCrawler.ContainerInventoryWidget.UpdateItemCanBeSet
// 0x0108 (0x0108 - 0x0000)
struct ContainerInventoryWidget_UpdateItemCanBeSet final
{
public:
	struct FItemData                              InItemData;                                        // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         SlotId;                                            // 0x0100(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251D[0x4];                                     // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ContainerInventoryWidget_UpdateItemCanBeSet) == 0x000008, "Wrong alignment on ContainerInventoryWidget_UpdateItemCanBeSet");
static_assert(sizeof(ContainerInventoryWidget_UpdateItemCanBeSet) == 0x000108, "Wrong size on ContainerInventoryWidget_UpdateItemCanBeSet");
static_assert(offsetof(ContainerInventoryWidget_UpdateItemCanBeSet, InItemData) == 0x000000, "Member 'ContainerInventoryWidget_UpdateItemCanBeSet::InItemData' has a wrong offset!");
static_assert(offsetof(ContainerInventoryWidget_UpdateItemCanBeSet, SlotId) == 0x000100, "Member 'ContainerInventoryWidget_UpdateItemCanBeSet::SlotId' has a wrong offset!");

// Function DungeonCrawler.DCReligionConvertPopUp.SetReligionImageEvent
// 0x00D0 (0x00D0 - 0x0000)
struct DCReligionConvertPopUp_SetReligionImageEvent final
{
public:
	struct FSlateBrush                            Bursh;                                             // 0x0000(0x00D0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionConvertPopUp_SetReligionImageEvent) == 0x000010, "Wrong alignment on DCReligionConvertPopUp_SetReligionImageEvent");
static_assert(sizeof(DCReligionConvertPopUp_SetReligionImageEvent) == 0x0000D0, "Wrong size on DCReligionConvertPopUp_SetReligionImageEvent");
static_assert(offsetof(DCReligionConvertPopUp_SetReligionImageEvent, Bursh) == 0x000000, "Member 'DCReligionConvertPopUp_SetReligionImageEvent::Bursh' has a wrong offset!");

// Function DungeonCrawler.ContainerSlotWidget.OnOverlapItemWidget
// 0x0001 (0x0001 - 0x0000)
struct ContainerSlotWidget_OnOverlapItemWidget final
{
public:
	bool                                          bCanSetItem;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContainerSlotWidget_OnOverlapItemWidget) == 0x000001, "Wrong alignment on ContainerSlotWidget_OnOverlapItemWidget");
static_assert(sizeof(ContainerSlotWidget_OnOverlapItemWidget) == 0x000001, "Wrong size on ContainerSlotWidget_OnOverlapItemWidget");
static_assert(offsetof(ContainerSlotWidget_OnOverlapItemWidget, bCanSetItem) == 0x000000, "Member 'ContainerSlotWidget_OnOverlapItemWidget::bCanSetItem' has a wrong offset!");

// Function DungeonCrawler.ContainerSlotWidget.OnSetNewItem
// 0x0001 (0x0001 - 0x0000)
struct ContainerSlotWidget_OnSetNewItem final
{
public:
	bool                                          bFullfilledAll;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ContainerSlotWidget_OnSetNewItem) == 0x000001, "Wrong alignment on ContainerSlotWidget_OnSetNewItem");
static_assert(sizeof(ContainerSlotWidget_OnSetNewItem) == 0x000001, "Wrong size on ContainerSlotWidget_OnSetNewItem");
static_assert(offsetof(ContainerSlotWidget_OnSetNewItem, bFullfilledAll) == 0x000000, "Member 'ContainerSlotWidget_OnSetNewItem::bFullfilledAll' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitTargetData.DCWaitTargetData
// 0x0028 (0x0028 - 0x0000)
struct DCAT_WaitTargetData_DCWaitTargetData final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayTargetingConfirmation                ConfirmationType;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2520[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AGameplayAbilityTargetActor*            InTargetActor;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitTargetData*                   ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitTargetData_DCWaitTargetData) == 0x000008, "Wrong alignment on DCAT_WaitTargetData_DCWaitTargetData");
static_assert(sizeof(DCAT_WaitTargetData_DCWaitTargetData) == 0x000028, "Wrong size on DCAT_WaitTargetData_DCWaitTargetData");
static_assert(offsetof(DCAT_WaitTargetData_DCWaitTargetData, OwningAbility) == 0x000000, "Member 'DCAT_WaitTargetData_DCWaitTargetData::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitTargetData_DCWaitTargetData, TaskInstanceName) == 0x000008, "Member 'DCAT_WaitTargetData_DCWaitTargetData::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(DCAT_WaitTargetData_DCWaitTargetData, ConfirmationType) == 0x000010, "Member 'DCAT_WaitTargetData_DCWaitTargetData::ConfirmationType' has a wrong offset!");
static_assert(offsetof(DCAT_WaitTargetData_DCWaitTargetData, InTargetActor) == 0x000018, "Member 'DCAT_WaitTargetData_DCWaitTargetData::InTargetActor' has a wrong offset!");
static_assert(offsetof(DCAT_WaitTargetData_DCWaitTargetData, ReturnValue) == 0x000020, "Member 'DCAT_WaitTargetData_DCWaitTargetData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitForInputAction.WaitForInputAction
// 0x0020 (0x0020 - 0x0000)
struct DCAT_WaitForInputAction_WaitForInputAction final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInputAction*                     InInputAction;                                     // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTriggerOnce;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2527[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitForInputAction*               ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitForInputAction_WaitForInputAction) == 0x000008, "Wrong alignment on DCAT_WaitForInputAction_WaitForInputAction");
static_assert(sizeof(DCAT_WaitForInputAction_WaitForInputAction) == 0x000020, "Wrong size on DCAT_WaitForInputAction_WaitForInputAction");
static_assert(offsetof(DCAT_WaitForInputAction_WaitForInputAction, OwningAbility) == 0x000000, "Member 'DCAT_WaitForInputAction_WaitForInputAction::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitForInputAction_WaitForInputAction, InInputAction) == 0x000008, "Member 'DCAT_WaitForInputAction_WaitForInputAction::InInputAction' has a wrong offset!");
static_assert(offsetof(DCAT_WaitForInputAction_WaitForInputAction, bOnlyTriggerOnce) == 0x000010, "Member 'DCAT_WaitForInputAction_WaitForInputAction::bOnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitForInputAction_WaitForInputAction, ReturnValue) == 0x000018, "Member 'DCAT_WaitForInputAction_WaitForInputAction::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardRankRecordMineWidget.OnFMsgWidgetStreamingModeNotifyBlueprint
// 0x0020 (0x0020 - 0x0000)
struct LeaderboardRankRecordMineWidget_OnFMsgWidgetStreamingModeNotifyBlueprint final
{
public:
	struct FMsgWidgetStreamingModeNotify          InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardRankRecordMineWidget_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000008, "Wrong alignment on LeaderboardRankRecordMineWidget_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(sizeof(LeaderboardRankRecordMineWidget_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000020, "Wrong size on LeaderboardRankRecordMineWidget_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(offsetof(LeaderboardRankRecordMineWidget_OnFMsgWidgetStreamingModeNotifyBlueprint, InMsg) == 0x000000, "Member 'LeaderboardRankRecordMineWidget_OnFMsgWidgetStreamingModeNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.LeaderboardRankRecordMineWidget.OnLeaderboardRankRecordMineData
// 0x0100 (0x0100 - 0x0000)
struct LeaderboardRankRecordMineWidget_OnLeaderboardRankRecordMineData final
{
public:
	struct FLeaderboardRankRecordMineData         NewValue;                                          // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FLeaderboardRankRecordMineData         OldValue;                                          // 0x0080(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardRankRecordMineWidget_OnLeaderboardRankRecordMineData) == 0x000008, "Wrong alignment on LeaderboardRankRecordMineWidget_OnLeaderboardRankRecordMineData");
static_assert(sizeof(LeaderboardRankRecordMineWidget_OnLeaderboardRankRecordMineData) == 0x000100, "Wrong size on LeaderboardRankRecordMineWidget_OnLeaderboardRankRecordMineData");
static_assert(offsetof(LeaderboardRankRecordMineWidget_OnLeaderboardRankRecordMineData, NewValue) == 0x000000, "Member 'LeaderboardRankRecordMineWidget_OnLeaderboardRankRecordMineData::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardRankRecordMineWidget_OnLeaderboardRankRecordMineData, OldValue) == 0x000080, "Member 'LeaderboardRankRecordMineWidget_OnLeaderboardRankRecordMineData::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.AddDamageTransferLink
// 0x0008 (0x0008 - 0x0000)
struct DCAbilitySystemComponent_AddDamageTransferLink final
{
public:
	class UDCAbilitySystemComponent*              InAbilitySystemComponent;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_AddDamageTransferLink) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_AddDamageTransferLink");
static_assert(sizeof(DCAbilitySystemComponent_AddDamageTransferLink) == 0x000008, "Wrong size on DCAbilitySystemComponent_AddDamageTransferLink");
static_assert(offsetof(DCAbilitySystemComponent_AddDamageTransferLink, InAbilitySystemComponent) == 0x000000, "Member 'DCAbilitySystemComponent_AddDamageTransferLink::InAbilitySystemComponent' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.AddGameplayCueLocal
// 0x00E0 (0x00E0 - 0x0000)
struct DCAbilitySystemComponent_AddGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0008(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_AddGameplayCueLocal) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_AddGameplayCueLocal");
static_assert(sizeof(DCAbilitySystemComponent_AddGameplayCueLocal) == 0x0000E0, "Wrong size on DCAbilitySystemComponent_AddGameplayCueLocal");
static_assert(offsetof(DCAbilitySystemComponent_AddGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'DCAbilitySystemComponent_AddGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemComponent_AddGameplayCueLocal, GameplayCueParameters) == 0x000008, "Member 'DCAbilitySystemComponent_AddGameplayCueLocal::GameplayCueParameters' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCAbilitySystemComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCAbilitySystemComponent_BroadcastMsgBlueprint");
static_assert(sizeof(DCAbilitySystemComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCAbilitySystemComponent_BroadcastMsgBlueprint");
static_assert(offsetof(DCAbilitySystemComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCAbilitySystemComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.ExecuteGameplayCueLocal
// 0x00E0 (0x00E0 - 0x0000)
struct DCAbilitySystemComponent_ExecuteGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 GameplayCueParameters;                             // 0x0008(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_ExecuteGameplayCueLocal) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_ExecuteGameplayCueLocal");
static_assert(sizeof(DCAbilitySystemComponent_ExecuteGameplayCueLocal) == 0x0000E0, "Wrong size on DCAbilitySystemComponent_ExecuteGameplayCueLocal");
static_assert(offsetof(DCAbilitySystemComponent_ExecuteGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'DCAbilitySystemComponent_ExecuteGameplayCueLocal::GameplayCueTag' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemComponent_ExecuteGameplayCueLocal, GameplayCueParameters) == 0x000008, "Member 'DCAbilitySystemComponent_ExecuteGameplayCueLocal::GameplayCueParameters' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.GetContainerSpecArray
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemComponent_GetContainerSpecArray final
{
public:
	TArray<struct FDCGameplayEffectContainerSpec> ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_GetContainerSpecArray) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_GetContainerSpecArray");
static_assert(sizeof(DCAbilitySystemComponent_GetContainerSpecArray) == 0x000010, "Wrong size on DCAbilitySystemComponent_GetContainerSpecArray");
static_assert(offsetof(DCAbilitySystemComponent_GetContainerSpecArray, ReturnValue) == 0x000000, "Member 'DCAbilitySystemComponent_GetContainerSpecArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.OnRep_AbilityHandleDataArray
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemComponent_OnRep_AbilityHandleDataArray final
{
public:
	TArray<struct FDCGameplayAbilityHandleData>   InOldAbilityHandleDataArray;                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_OnRep_AbilityHandleDataArray) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_OnRep_AbilityHandleDataArray");
static_assert(sizeof(DCAbilitySystemComponent_OnRep_AbilityHandleDataArray) == 0x000010, "Wrong size on DCAbilitySystemComponent_OnRep_AbilityHandleDataArray");
static_assert(offsetof(DCAbilitySystemComponent_OnRep_AbilityHandleDataArray, InOldAbilityHandleDataArray) == 0x000000, "Member 'DCAbilitySystemComponent_OnRep_AbilityHandleDataArray::InOldAbilityHandleDataArray' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.OnRep_ActorDieData
// 0x06D0 (0x06D0 - 0x0000)
struct DCAbilitySystemComponent_OnRep_ActorDieData final
{
public:
	struct FActorDieData                          InOldActorDieData;                                 // 0x0000(0x06D0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_OnRep_ActorDieData) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_OnRep_ActorDieData");
static_assert(sizeof(DCAbilitySystemComponent_OnRep_ActorDieData) == 0x0006D0, "Wrong size on DCAbilitySystemComponent_OnRep_ActorDieData");
static_assert(offsetof(DCAbilitySystemComponent_OnRep_ActorDieData, InOldActorDieData) == 0x000000, "Member 'DCAbilitySystemComponent_OnRep_ActorDieData::InOldActorDieData' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.OnRep_ActorRigidData
// 0x0040 (0x0040 - 0x0000)
struct DCAbilitySystemComponent_OnRep_ActorRigidData final
{
public:
	struct FActorRigidData                        OldActorRigidData;                                 // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_OnRep_ActorRigidData) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_OnRep_ActorRigidData");
static_assert(sizeof(DCAbilitySystemComponent_OnRep_ActorRigidData) == 0x000040, "Wrong size on DCAbilitySystemComponent_OnRep_ActorRigidData");
static_assert(offsetof(DCAbilitySystemComponent_OnRep_ActorRigidData, OldActorRigidData) == 0x000000, "Member 'DCAbilitySystemComponent_OnRep_ActorRigidData::OldActorRigidData' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.OnRep_ImpactEnduranceExhaustedData
// 0x06C8 (0x06C8 - 0x0000)
struct DCAbilitySystemComponent_OnRep_ImpactEnduranceExhaustedData final
{
public:
	struct FImpactEnduranceExhaustedData          OldImpactEnduranceExhaustedData;                   // 0x0000(0x06C8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_OnRep_ImpactEnduranceExhaustedData) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_OnRep_ImpactEnduranceExhaustedData");
static_assert(sizeof(DCAbilitySystemComponent_OnRep_ImpactEnduranceExhaustedData) == 0x0006C8, "Wrong size on DCAbilitySystemComponent_OnRep_ImpactEnduranceExhaustedData");
static_assert(offsetof(DCAbilitySystemComponent_OnRep_ImpactEnduranceExhaustedData, OldImpactEnduranceExhaustedData) == 0x000000, "Member 'DCAbilitySystemComponent_OnRep_ImpactEnduranceExhaustedData::OldImpactEnduranceExhaustedData' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.PlayMontageOnSourceObject
// 0x0040 (0x0040 - 0x0000)
struct DCAbilitySystemComponent_PlayMontageOnSourceObject final
{
public:
	class UGameplayAbility*                       InAnimatingAbility;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityActivationInfo         ActivationInfo;                                    // 0x0008(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           NewAnimMontage;                                    // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlayRate;                                        // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSectionName;                                  // 0x0034(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTimeSeconds;                                  // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_PlayMontageOnSourceObject) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_PlayMontageOnSourceObject");
static_assert(sizeof(DCAbilitySystemComponent_PlayMontageOnSourceObject) == 0x000040, "Wrong size on DCAbilitySystemComponent_PlayMontageOnSourceObject");
static_assert(offsetof(DCAbilitySystemComponent_PlayMontageOnSourceObject, InAnimatingAbility) == 0x000000, "Member 'DCAbilitySystemComponent_PlayMontageOnSourceObject::InAnimatingAbility' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemComponent_PlayMontageOnSourceObject, ActivationInfo) == 0x000008, "Member 'DCAbilitySystemComponent_PlayMontageOnSourceObject::ActivationInfo' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemComponent_PlayMontageOnSourceObject, NewAnimMontage) == 0x000028, "Member 'DCAbilitySystemComponent_PlayMontageOnSourceObject::NewAnimMontage' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemComponent_PlayMontageOnSourceObject, InPlayRate) == 0x000030, "Member 'DCAbilitySystemComponent_PlayMontageOnSourceObject::InPlayRate' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemComponent_PlayMontageOnSourceObject, StartSectionName) == 0x000034, "Member 'DCAbilitySystemComponent_PlayMontageOnSourceObject::StartSectionName' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemComponent_PlayMontageOnSourceObject, StartTimeSeconds) == 0x00003C, "Member 'DCAbilitySystemComponent_PlayMontageOnSourceObject::StartTimeSeconds' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.RemoveDamageTransferLink
// 0x0008 (0x0008 - 0x0000)
struct DCAbilitySystemComponent_RemoveDamageTransferLink final
{
public:
	class UDCAbilitySystemComponent*              InAbilitySystemComponent;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_RemoveDamageTransferLink) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_RemoveDamageTransferLink");
static_assert(sizeof(DCAbilitySystemComponent_RemoveDamageTransferLink) == 0x000008, "Wrong size on DCAbilitySystemComponent_RemoveDamageTransferLink");
static_assert(offsetof(DCAbilitySystemComponent_RemoveDamageTransferLink, InAbilitySystemComponent) == 0x000000, "Member 'DCAbilitySystemComponent_RemoveDamageTransferLink::InAbilitySystemComponent' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.RemoveGameplayCueLocal
// 0x0008 (0x0008 - 0x0000)
struct DCAbilitySystemComponent_RemoveGameplayCueLocal final
{
public:
	struct FGameplayTag                           GameplayCueTag;                                    // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_RemoveGameplayCueLocal) == 0x000004, "Wrong alignment on DCAbilitySystemComponent_RemoveGameplayCueLocal");
static_assert(sizeof(DCAbilitySystemComponent_RemoveGameplayCueLocal) == 0x000008, "Wrong size on DCAbilitySystemComponent_RemoveGameplayCueLocal");
static_assert(offsetof(DCAbilitySystemComponent_RemoveGameplayCueLocal, GameplayCueTag) == 0x000000, "Member 'DCAbilitySystemComponent_RemoveGameplayCueLocal::GameplayCueTag' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.SendInventoryEventData_Server
// 0x01A0 (0x01A0 - 0x0000)
struct DCAbilitySystemComponent_SendInventoryEventData_Server final
{
public:
	struct FPredictionKey                         PredictionKey;                                     // 0x0000(0x0018)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCInventoryEventData                  EventData;                                         // 0x0018(0x0188)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_SendInventoryEventData_Server) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_SendInventoryEventData_Server");
static_assert(sizeof(DCAbilitySystemComponent_SendInventoryEventData_Server) == 0x0001A0, "Wrong size on DCAbilitySystemComponent_SendInventoryEventData_Server");
static_assert(offsetof(DCAbilitySystemComponent_SendInventoryEventData_Server, PredictionKey) == 0x000000, "Member 'DCAbilitySystemComponent_SendInventoryEventData_Server::PredictionKey' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemComponent_SendInventoryEventData_Server, EventData) == 0x000018, "Member 'DCAbilitySystemComponent_SendInventoryEventData_Server::EventData' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.SetTagQueryData
// 0x0020 (0x0020 - 0x0000)
struct DCAbilitySystemComponent_SetTagQueryData final
{
public:
	TArray<struct FPrimaryAssetId>                InHitTagQueryDataIdArray;                          // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                InBeHitTagQueryDataIdArray;                        // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_SetTagQueryData) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_SetTagQueryData");
static_assert(sizeof(DCAbilitySystemComponent_SetTagQueryData) == 0x000020, "Wrong size on DCAbilitySystemComponent_SetTagQueryData");
static_assert(offsetof(DCAbilitySystemComponent_SetTagQueryData, InHitTagQueryDataIdArray) == 0x000000, "Member 'DCAbilitySystemComponent_SetTagQueryData::InHitTagQueryDataIdArray' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemComponent_SetTagQueryData, InBeHitTagQueryDataIdArray) == 0x000010, "Member 'DCAbilitySystemComponent_SetTagQueryData::InBeHitTagQueryDataIdArray' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCAbilitySystemComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_UnbindMsg) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_UnbindMsg");
static_assert(sizeof(DCAbilitySystemComponent_UnbindMsg) == 0x000010, "Wrong size on DCAbilitySystemComponent_UnbindMsg");
static_assert(offsetof(DCAbilitySystemComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'DCAbilitySystemComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCAbilitySystemComponent_UnbindMsg, InObject) == 0x000008, "Member 'DCAbilitySystemComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAbilitySystemComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCAbilitySystemComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAbilitySystemComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on DCAbilitySystemComponent_UnbindMsgAll");
static_assert(sizeof(DCAbilitySystemComponent_UnbindMsgAll) == 0x000008, "Wrong size on DCAbilitySystemComponent_UnbindMsgAll");
static_assert(offsetof(DCAbilitySystemComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'DCAbilitySystemComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAccountNameChangeShopWidget.OnSetShopInfo
// 0x0018 (0x0018 - 0x0000)
struct DCAccountNameChangeShopWidget_OnSetShopInfo final
{
public:
	struct FDCAccountNameChangeShopInfo           InShopInfo;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAccountNameChangeShopWidget_OnSetShopInfo) == 0x000008, "Wrong alignment on DCAccountNameChangeShopWidget_OnSetShopInfo");
static_assert(sizeof(DCAccountNameChangeShopWidget_OnSetShopInfo) == 0x000018, "Wrong size on DCAccountNameChangeShopWidget_OnSetShopInfo");
static_assert(offsetof(DCAccountNameChangeShopWidget_OnSetShopInfo, InShopInfo) == 0x000000, "Member 'DCAccountNameChangeShopWidget_OnSetShopInfo::InShopInfo' has a wrong offset!");

// Function DungeonCrawler.DCAccountNameChangeShopWidget.OnTextChangedNewAccountName
// 0x0018 (0x0018 - 0x0000)
struct DCAccountNameChangeShopWidget_OnTextChangedNewAccountName final
{
public:
	class FText                                   InAccountName;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAccountNameChangeShopWidget_OnTextChangedNewAccountName) == 0x000008, "Wrong alignment on DCAccountNameChangeShopWidget_OnTextChangedNewAccountName");
static_assert(sizeof(DCAccountNameChangeShopWidget_OnTextChangedNewAccountName) == 0x000018, "Wrong size on DCAccountNameChangeShopWidget_OnTextChangedNewAccountName");
static_assert(offsetof(DCAccountNameChangeShopWidget_OnTextChangedNewAccountName, InAccountName) == 0x000000, "Member 'DCAccountNameChangeShopWidget_OnTextChangedNewAccountName::InAccountName' has a wrong offset!");

// Function DungeonCrawler.DCAccountNameChangeShopWidget.OnTextChangedOldAccountName
// 0x0018 (0x0018 - 0x0000)
struct DCAccountNameChangeShopWidget_OnTextChangedOldAccountName final
{
public:
	class FText                                   InAccountName;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAccountNameChangeShopWidget_OnTextChangedOldAccountName) == 0x000008, "Wrong alignment on DCAccountNameChangeShopWidget_OnTextChangedOldAccountName");
static_assert(sizeof(DCAccountNameChangeShopWidget_OnTextChangedOldAccountName) == 0x000018, "Wrong size on DCAccountNameChangeShopWidget_OnTextChangedOldAccountName");
static_assert(offsetof(DCAccountNameChangeShopWidget_OnTextChangedOldAccountName, InAccountName) == 0x000000, "Member 'DCAccountNameChangeShopWidget_OnTextChangedOldAccountName::InAccountName' has a wrong offset!");

// Function DungeonCrawler.DCAccountStatusWidget.OnAccountStatusUpdated
// 0x0001 (0x0001 - 0x0000)
struct DCAccountStatusWidget_OnAccountStatusUpdated final
{
public:
	EDCAccountStatus                              InAccountStatus;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAccountStatusWidget_OnAccountStatusUpdated) == 0x000001, "Wrong alignment on DCAccountStatusWidget_OnAccountStatusUpdated");
static_assert(sizeof(DCAccountStatusWidget_OnAccountStatusUpdated) == 0x000001, "Wrong size on DCAccountStatusWidget_OnAccountStatusUpdated");
static_assert(offsetof(DCAccountStatusWidget_OnAccountStatusUpdated, InAccountStatus) == 0x000000, "Member 'DCAccountStatusWidget_OnAccountStatusUpdated::InAccountStatus' has a wrong offset!");

// Function DungeonCrawler.DCActionSkinComponent.OnRep_Datas
// 0x0010 (0x0010 - 0x0000)
struct DCActionSkinComponent_OnRep_Datas final
{
public:
	TArray<class UDCActionSkinDataAsset*>         OldDatas;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActionSkinComponent_OnRep_Datas) == 0x000008, "Wrong alignment on DCActionSkinComponent_OnRep_Datas");
static_assert(sizeof(DCActionSkinComponent_OnRep_Datas) == 0x000010, "Wrong size on DCActionSkinComponent_OnRep_Datas");
static_assert(offsetof(DCActionSkinComponent_OnRep_Datas, OldDatas) == 0x000000, "Member 'DCActionSkinComponent_OnRep_Datas::OldDatas' has a wrong offset!");

// Function DungeonCrawler.DCActorStatusComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCActorStatusComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActorStatusComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCActorStatusComponent_BroadcastMsgBlueprint");
static_assert(sizeof(DCActorStatusComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCActorStatusComponent_BroadcastMsgBlueprint");
static_assert(offsetof(DCActorStatusComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCActorStatusComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCActorStatusComponent.GameplayEffectDurationChanged
// 0x0018 (0x0018 - 0x0000)
struct DCActorStatusComponent_GameplayEffectDurationChanged final
{
public:
	struct FGameplayTag                           EffectGameplayTag;                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewStartWorldTime;                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewDuration;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActorStatusComponent_GameplayEffectDurationChanged) == 0x000004, "Wrong alignment on DCActorStatusComponent_GameplayEffectDurationChanged");
static_assert(sizeof(DCActorStatusComponent_GameplayEffectDurationChanged) == 0x000018, "Wrong size on DCActorStatusComponent_GameplayEffectDurationChanged");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectDurationChanged, EffectGameplayTag) == 0x000000, "Member 'DCActorStatusComponent_GameplayEffectDurationChanged::EffectGameplayTag' has a wrong offset!");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectDurationChanged, EffectHandle) == 0x000008, "Member 'DCActorStatusComponent_GameplayEffectDurationChanged::EffectHandle' has a wrong offset!");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectDurationChanged, NewStartWorldTime) == 0x000010, "Member 'DCActorStatusComponent_GameplayEffectDurationChanged::NewStartWorldTime' has a wrong offset!");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectDurationChanged, NewDuration) == 0x000014, "Member 'DCActorStatusComponent_GameplayEffectDurationChanged::NewDuration' has a wrong offset!");

// Function DungeonCrawler.DCActorStatusComponent.GameplayEffectInhibitChanged
// 0x0014 (0x0014 - 0x0000)
struct DCActorStatusComponent_GameplayEffectInhibitChanged final
{
public:
	struct FGameplayTag                           EffectGameplayTag;                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInhibited;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2535[0x3];                                     // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCActorStatusComponent_GameplayEffectInhibitChanged) == 0x000004, "Wrong alignment on DCActorStatusComponent_GameplayEffectInhibitChanged");
static_assert(sizeof(DCActorStatusComponent_GameplayEffectInhibitChanged) == 0x000014, "Wrong size on DCActorStatusComponent_GameplayEffectInhibitChanged");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectInhibitChanged, EffectGameplayTag) == 0x000000, "Member 'DCActorStatusComponent_GameplayEffectInhibitChanged::EffectGameplayTag' has a wrong offset!");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectInhibitChanged, EffectHandle) == 0x000008, "Member 'DCActorStatusComponent_GameplayEffectInhibitChanged::EffectHandle' has a wrong offset!");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectInhibitChanged, bIsInhibited) == 0x000010, "Member 'DCActorStatusComponent_GameplayEffectInhibitChanged::bIsInhibited' has a wrong offset!");

// Function DungeonCrawler.DCActorStatusComponent.GameplayEffectStackChanged
// 0x0018 (0x0018 - 0x0000)
struct DCActorStatusComponent_GameplayEffectStackChanged final
{
public:
	struct FGameplayTag                           EffectGameplayTag;                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStackCount;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousStackCount;                                // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActorStatusComponent_GameplayEffectStackChanged) == 0x000004, "Wrong alignment on DCActorStatusComponent_GameplayEffectStackChanged");
static_assert(sizeof(DCActorStatusComponent_GameplayEffectStackChanged) == 0x000018, "Wrong size on DCActorStatusComponent_GameplayEffectStackChanged");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectStackChanged, EffectGameplayTag) == 0x000000, "Member 'DCActorStatusComponent_GameplayEffectStackChanged::EffectGameplayTag' has a wrong offset!");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectStackChanged, EffectHandle) == 0x000008, "Member 'DCActorStatusComponent_GameplayEffectStackChanged::EffectHandle' has a wrong offset!");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectStackChanged, NewStackCount) == 0x000010, "Member 'DCActorStatusComponent_GameplayEffectStackChanged::NewStackCount' has a wrong offset!");
static_assert(offsetof(DCActorStatusComponent_GameplayEffectStackChanged, PreviousStackCount) == 0x000014, "Member 'DCActorStatusComponent_GameplayEffectStackChanged::PreviousStackCount' has a wrong offset!");

// Function DungeonCrawler.DCActorStatusComponent.OnRep_ActorStatusDatas
// 0x0010 (0x0010 - 0x0000)
struct DCActorStatusComponent_OnRep_ActorStatusDatas final
{
public:
	TArray<struct FActorStatusData>               OldActorStatusDatas;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActorStatusComponent_OnRep_ActorStatusDatas) == 0x000008, "Wrong alignment on DCActorStatusComponent_OnRep_ActorStatusDatas");
static_assert(sizeof(DCActorStatusComponent_OnRep_ActorStatusDatas) == 0x000010, "Wrong size on DCActorStatusComponent_OnRep_ActorStatusDatas");
static_assert(offsetof(DCActorStatusComponent_OnRep_ActorStatusDatas, OldActorStatusDatas) == 0x000000, "Member 'DCActorStatusComponent_OnRep_ActorStatusDatas::OldActorStatusDatas' has a wrong offset!");

// Function DungeonCrawler.DCActorStatusComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCActorStatusComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActorStatusComponent_UnbindMsg) == 0x000008, "Wrong alignment on DCActorStatusComponent_UnbindMsg");
static_assert(sizeof(DCActorStatusComponent_UnbindMsg) == 0x000010, "Wrong size on DCActorStatusComponent_UnbindMsg");
static_assert(offsetof(DCActorStatusComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'DCActorStatusComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCActorStatusComponent_UnbindMsg, InObject) == 0x000008, "Member 'DCActorStatusComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCActorStatusComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCActorStatusComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCActorStatusComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on DCActorStatusComponent_UnbindMsgAll");
static_assert(sizeof(DCActorStatusComponent_UnbindMsgAll) == 0x000008, "Wrong size on DCActorStatusComponent_UnbindMsgAll");
static_assert(offsetof(DCActorStatusComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'DCActorStatusComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAkSpatialAudioVolume.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCAkSpatialAudioVolume_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAkSpatialAudioVolume_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCAkSpatialAudioVolume_BroadcastMsgBlueprint");
static_assert(sizeof(DCAkSpatialAudioVolume_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCAkSpatialAudioVolume_BroadcastMsgBlueprint");
static_assert(offsetof(DCAkSpatialAudioVolume_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCAkSpatialAudioVolume_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCAkSpatialAudioVolume.OnOverlapBegin
// 0x0108 (0x0108 - 0x0000)
struct DCAkSpatialAudioVolume_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_253A[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAkSpatialAudioVolume_OnOverlapBegin) == 0x000008, "Wrong alignment on DCAkSpatialAudioVolume_OnOverlapBegin");
static_assert(sizeof(DCAkSpatialAudioVolume_OnOverlapBegin) == 0x000108, "Wrong size on DCAkSpatialAudioVolume_OnOverlapBegin");
static_assert(offsetof(DCAkSpatialAudioVolume_OnOverlapBegin, OverlappedComp) == 0x000000, "Member 'DCAkSpatialAudioVolume_OnOverlapBegin::OverlappedComp' has a wrong offset!");
static_assert(offsetof(DCAkSpatialAudioVolume_OnOverlapBegin, OtherActor) == 0x000008, "Member 'DCAkSpatialAudioVolume_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(DCAkSpatialAudioVolume_OnOverlapBegin, OtherComp) == 0x000010, "Member 'DCAkSpatialAudioVolume_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(DCAkSpatialAudioVolume_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'DCAkSpatialAudioVolume_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(DCAkSpatialAudioVolume_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'DCAkSpatialAudioVolume_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(DCAkSpatialAudioVolume_OnOverlapBegin, SweepResult) == 0x000020, "Member 'DCAkSpatialAudioVolume_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function DungeonCrawler.DCAkSpatialAudioVolume.OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct DCAkSpatialAudioVolume_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_253B[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAkSpatialAudioVolume_OnOverlapEnd) == 0x000008, "Wrong alignment on DCAkSpatialAudioVolume_OnOverlapEnd");
static_assert(sizeof(DCAkSpatialAudioVolume_OnOverlapEnd) == 0x000020, "Wrong size on DCAkSpatialAudioVolume_OnOverlapEnd");
static_assert(offsetof(DCAkSpatialAudioVolume_OnOverlapEnd, OverlappedComp) == 0x000000, "Member 'DCAkSpatialAudioVolume_OnOverlapEnd::OverlappedComp' has a wrong offset!");
static_assert(offsetof(DCAkSpatialAudioVolume_OnOverlapEnd, OtherActor) == 0x000008, "Member 'DCAkSpatialAudioVolume_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(DCAkSpatialAudioVolume_OnOverlapEnd, OtherComp) == 0x000010, "Member 'DCAkSpatialAudioVolume_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(DCAkSpatialAudioVolume_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'DCAkSpatialAudioVolume_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DungeonCrawler.DCAkSpatialAudioVolume.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCAkSpatialAudioVolume_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAkSpatialAudioVolume_UnbindMsg) == 0x000008, "Wrong alignment on DCAkSpatialAudioVolume_UnbindMsg");
static_assert(sizeof(DCAkSpatialAudioVolume_UnbindMsg) == 0x000010, "Wrong size on DCAkSpatialAudioVolume_UnbindMsg");
static_assert(offsetof(DCAkSpatialAudioVolume_UnbindMsg, InMsgType) == 0x000000, "Member 'DCAkSpatialAudioVolume_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCAkSpatialAudioVolume_UnbindMsg, InObject) == 0x000008, "Member 'DCAkSpatialAudioVolume_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAkSpatialAudioVolume.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCAkSpatialAudioVolume_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAkSpatialAudioVolume_UnbindMsgAll) == 0x000008, "Wrong alignment on DCAkSpatialAudioVolume_UnbindMsgAll");
static_assert(sizeof(DCAkSpatialAudioVolume_UnbindMsgAll) == 0x000008, "Wrong size on DCAkSpatialAudioVolume_UnbindMsgAll");
static_assert(offsetof(DCAkSpatialAudioVolume_UnbindMsgAll, InObject) == 0x000000, "Member 'DCAkSpatialAudioVolume_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAnimInstanceV2.GetIdleAnim
// 0x0008 (0x0008 - 0x0000)
struct DCAnimInstanceV2_GetIdleAnim final
{
public:
	class UAnimSequence*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAnimInstanceV2_GetIdleAnim) == 0x000008, "Wrong alignment on DCAnimInstanceV2_GetIdleAnim");
static_assert(sizeof(DCAnimInstanceV2_GetIdleAnim) == 0x000008, "Wrong size on DCAnimInstanceV2_GetIdleAnim");
static_assert(offsetof(DCAnimInstanceV2_GetIdleAnim, ReturnValue) == 0x000000, "Member 'DCAnimInstanceV2_GetIdleAnim::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeAIControllerBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCAoeAIControllerBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeAIControllerBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCAoeAIControllerBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCAoeAIControllerBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCAoeAIControllerBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCAoeAIControllerBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCAoeAIControllerBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCAoeAIControllerBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCAoeAIControllerBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeAIControllerBase_UnbindMsg) == 0x000008, "Wrong alignment on DCAoeAIControllerBase_UnbindMsg");
static_assert(sizeof(DCAoeAIControllerBase_UnbindMsg) == 0x000010, "Wrong size on DCAoeAIControllerBase_UnbindMsg");
static_assert(offsetof(DCAoeAIControllerBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCAoeAIControllerBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCAoeAIControllerBase_UnbindMsg, InObject) == 0x000008, "Member 'DCAoeAIControllerBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAoeAIControllerBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCAoeAIControllerBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeAIControllerBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCAoeAIControllerBase_UnbindMsgAll");
static_assert(sizeof(DCAoeAIControllerBase_UnbindMsgAll) == 0x000008, "Wrong size on DCAoeAIControllerBase_UnbindMsgAll");
static_assert(offsetof(DCAoeAIControllerBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCAoeAIControllerBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.GA_MusicBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_MusicBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MusicBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_MusicBase_AbilityActivated");
static_assert(sizeof(GA_MusicBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_MusicBase_AbilityActivated");
static_assert(offsetof(GA_MusicBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_MusicBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_MusicBase.ApplyToTarget
// 0x00E8 (0x00E8 - 0x0000)
struct GA_MusicBase_ApplyToTarget final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MusicBase_ApplyToTarget) == 0x000008, "Wrong alignment on GA_MusicBase_ApplyToTarget");
static_assert(sizeof(GA_MusicBase_ApplyToTarget) == 0x0000E8, "Wrong size on GA_MusicBase_ApplyToTarget");
static_assert(offsetof(GA_MusicBase_ApplyToTarget, HitResult) == 0x000000, "Member 'GA_MusicBase_ApplyToTarget::HitResult' has a wrong offset!");

// Function DungeonCrawler.GA_MusicBase.OnApplied
// 0x0008 (0x0008 - 0x0000)
struct GA_MusicBase_OnApplied final
{
public:
	class AActor*                                 InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MusicBase_OnApplied) == 0x000008, "Wrong alignment on GA_MusicBase_OnApplied");
static_assert(sizeof(GA_MusicBase_OnApplied) == 0x000008, "Wrong size on GA_MusicBase_OnApplied");
static_assert(offsetof(GA_MusicBase_OnApplied, InTarget) == 0x000000, "Member 'GA_MusicBase_OnApplied::InTarget' has a wrong offset!");

// Function DungeonCrawler.GA_MusicBase.GetRange
// 0x0004 (0x0004 - 0x0000)
struct GA_MusicBase_GetRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MusicBase_GetRange) == 0x000004, "Wrong alignment on GA_MusicBase_GetRange");
static_assert(sizeof(GA_MusicBase_GetRange) == 0x000004, "Wrong size on GA_MusicBase_GetRange");
static_assert(offsetof(GA_MusicBase_GetRange, ReturnValue) == 0x000000, "Member 'GA_MusicBase_GetRange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_MusicChannelingBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_MusicChannelingBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MusicChannelingBase_EventReceived) == 0x000008, "Wrong alignment on GA_MusicChannelingBase_EventReceived");
static_assert(sizeof(GA_MusicChannelingBase_EventReceived) == 0x0000B8, "Wrong size on GA_MusicChannelingBase_EventReceived");
static_assert(offsetof(GA_MusicChannelingBase_EventReceived, EventTag) == 0x000000, "Member 'GA_MusicChannelingBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_MusicChannelingBase_EventReceived, EventData) == 0x000008, "Member 'GA_MusicChannelingBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_MusicChannelingBase.OnTargetActorBeginOverlap
// 0x0008 (0x0008 - 0x0000)
struct GA_MusicChannelingBase_OnTargetActorBeginOverlap final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MusicChannelingBase_OnTargetActorBeginOverlap) == 0x000008, "Wrong alignment on GA_MusicChannelingBase_OnTargetActorBeginOverlap");
static_assert(sizeof(GA_MusicChannelingBase_OnTargetActorBeginOverlap) == 0x000008, "Wrong size on GA_MusicChannelingBase_OnTargetActorBeginOverlap");
static_assert(offsetof(GA_MusicChannelingBase_OnTargetActorBeginOverlap, Target) == 0x000000, "Member 'GA_MusicChannelingBase_OnTargetActorBeginOverlap::Target' has a wrong offset!");

// Function DungeonCrawler.GA_MusicChannelingBase.OnTargetActorEndOverlap
// 0x0008 (0x0008 - 0x0000)
struct GA_MusicChannelingBase_OnTargetActorEndOverlap final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MusicChannelingBase_OnTargetActorEndOverlap) == 0x000008, "Wrong alignment on GA_MusicChannelingBase_OnTargetActorEndOverlap");
static_assert(sizeof(GA_MusicChannelingBase_OnTargetActorEndOverlap) == 0x000008, "Wrong size on GA_MusicChannelingBase_OnTargetActorEndOverlap");
static_assert(offsetof(GA_MusicChannelingBase_OnTargetActorEndOverlap, Target) == 0x000000, "Member 'GA_MusicChannelingBase_OnTargetActorEndOverlap::Target' has a wrong offset!");

// Function DungeonCrawler.DCAoeBase.AddBeginOverlapActor
// 0x0008 (0x0008 - 0x0000)
struct DCAoeBase_AddBeginOverlapActor final
{
public:
	class ADCCharacterBase*                       CharacterBase;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeBase_AddBeginOverlapActor) == 0x000008, "Wrong alignment on DCAoeBase_AddBeginOverlapActor");
static_assert(sizeof(DCAoeBase_AddBeginOverlapActor) == 0x000008, "Wrong size on DCAoeBase_AddBeginOverlapActor");
static_assert(offsetof(DCAoeBase_AddBeginOverlapActor, CharacterBase) == 0x000000, "Member 'DCAoeBase_AddBeginOverlapActor::CharacterBase' has a wrong offset!");

// Function DungeonCrawler.DCAoeBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCAoeBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCAoeBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCAoeBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCAoeBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCAoeBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCAoeBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCAoeBase.RemoveEndOverlapActor
// 0x0008 (0x0008 - 0x0000)
struct DCAoeBase_RemoveEndOverlapActor final
{
public:
	class ADCCharacterBase*                       CharacterBase;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeBase_RemoveEndOverlapActor) == 0x000008, "Wrong alignment on DCAoeBase_RemoveEndOverlapActor");
static_assert(sizeof(DCAoeBase_RemoveEndOverlapActor) == 0x000008, "Wrong size on DCAoeBase_RemoveEndOverlapActor");
static_assert(offsetof(DCAoeBase_RemoveEndOverlapActor, CharacterBase) == 0x000000, "Member 'DCAoeBase_RemoveEndOverlapActor::CharacterBase' has a wrong offset!");

// Function DungeonCrawler.DCAoeBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCAoeBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeBase_UnbindMsg) == 0x000008, "Wrong alignment on DCAoeBase_UnbindMsg");
static_assert(sizeof(DCAoeBase_UnbindMsg) == 0x000010, "Wrong size on DCAoeBase_UnbindMsg");
static_assert(offsetof(DCAoeBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCAoeBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCAoeBase_UnbindMsg, InObject) == 0x000008, "Member 'DCAoeBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAoeBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCAoeBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCAoeBase_UnbindMsgAll");
static_assert(sizeof(DCAoeBase_UnbindMsgAll) == 0x000008, "Wrong size on DCAoeBase_UnbindMsgAll");
static_assert(offsetof(DCAoeBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCAoeBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DeferredAoeFinish
// 0x0130 (0x0130 - 0x0000)
struct DCAoeSystemBlueprintLibrary_DeferredAoeFinish final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCAoeBase*                             Aoe;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0070(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          bSuccessfully;                                     // 0x0120(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2545[0xF];                                     // 0x0121(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_DeferredAoeFinish) == 0x000010, "Wrong alignment on DCAoeSystemBlueprintLibrary_DeferredAoeFinish");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_DeferredAoeFinish) == 0x000130, "Wrong size on DCAoeSystemBlueprintLibrary_DeferredAoeFinish");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DeferredAoeFinish, DCCharacterBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_DeferredAoeFinish::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DeferredAoeFinish, Aoe) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_DeferredAoeFinish::Aoe' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DeferredAoeFinish, Transform) == 0x000010, "Member 'DCAoeSystemBlueprintLibrary_DeferredAoeFinish::Transform' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DeferredAoeFinish, EventData) == 0x000070, "Member 'DCAoeSystemBlueprintLibrary_DeferredAoeFinish::EventData' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DeferredAoeFinish, bSuccessfully) == 0x000120, "Member 'DCAoeSystemBlueprintLibrary_DeferredAoeFinish::bSuccessfully' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeAll
// 0x0008 (0x0008 - 0x0000)
struct DCAoeSystemBlueprintLibrary_DespawnAoeAll final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_DespawnAoeAll) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_DespawnAoeAll");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_DespawnAoeAll) == 0x000008, "Wrong size on DCAoeSystemBlueprintLibrary_DespawnAoeAll");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DespawnAoeAll, DCCharacterBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_DespawnAoeAll::DCCharacterBase' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeByPrimaryAssetId
// 0x0018 (0x0018 - 0x0000)
struct DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0008(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId) == 0x000018, "Wrong size on DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId, DCCharacterBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId, PrimaryAssetId) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId::PrimaryAssetId' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeByPrimaryAssetIdWithinDistance
// 0x0038 (0x0038 - 0x0000)
struct DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0008(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2546[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance) == 0x000038, "Wrong size on DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance, DCCharacterBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance, PrimaryAssetId) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance, Location) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance::Location' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance, Distance) == 0x000030, "Member 'DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance::Distance' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeWithinDistance
// 0x0028 (0x0028 - 0x0000)
struct DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2547[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance) == 0x000028, "Wrong size on DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance, DCCharacterBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance, Location) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance::Location' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance, Distance) == 0x000020, "Member 'DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance::Distance' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterMonsterTargets
// 0x0010 (0x0010 - 0x0000)
struct DCAoeSystemBlueprintLibrary_FilterMonsterTargets final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_FilterMonsterTargets) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_FilterMonsterTargets");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_FilterMonsterTargets) == 0x000010, "Wrong size on DCAoeSystemBlueprintLibrary_FilterMonsterTargets");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterMonsterTargets, TargetArray) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_FilterMonsterTargets::TargetArray' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterPlayerCharacterTargets
// 0x0010 (0x0010 - 0x0000)
struct DCAoeSystemBlueprintLibrary_FilterPlayerCharacterTargets final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_FilterPlayerCharacterTargets) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_FilterPlayerCharacterTargets");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_FilterPlayerCharacterTargets) == 0x000010, "Wrong size on DCAoeSystemBlueprintLibrary_FilterPlayerCharacterTargets");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterPlayerCharacterTargets, TargetArray) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_FilterPlayerCharacterTargets::TargetArray' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTagedTargets
// 0x0020 (0x0020 - 0x0000)
struct DCAoeSystemBlueprintLibrary_FilterTagedTargets final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2548[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_FilterTagedTargets) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_FilterTagedTargets");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_FilterTagedTargets) == 0x000020, "Wrong size on DCAoeSystemBlueprintLibrary_FilterTagedTargets");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTagedTargets, TargetArray) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_FilterTagedTargets::TargetArray' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTagedTargets, GameplayTag) == 0x000010, "Member 'DCAoeSystemBlueprintLibrary_FilterTagedTargets::GameplayTag' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTagedTargets, ReturnValue) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_FilterTagedTargets::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTargetsOverDistance
// 0x0020 (0x0020 - 0x0000)
struct DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance final
{
public:
	class ADCAoeBase*                             DCAoeBase;                                         // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2549[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance) == 0x000020, "Wrong size on DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance, DCAoeBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance::DCAoeBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance, TargetArray) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance::TargetArray' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance, Distance) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance::Distance' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance, ReturnValue) == 0x00001C, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTargetsWithinDirectionAngleAndAllowedAngle
// 0x0028 (0x0028 - 0x0000)
struct DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle final
{
public:
	class ADCAoeBase*                             DCAoeBase;                                         // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         DirectionalAngle;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedAngle;                                      // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254A[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle) == 0x000028, "Wrong size on DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle, DCAoeBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle::DCAoeBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle, TargetArray) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle::TargetArray' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle, DirectionalAngle) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle::DirectionalAngle' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle, AllowedAngle) == 0x00001C, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle::AllowedAngle' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle, ReturnValue) == 0x000020, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTargetsWithinDistance
// 0x0020 (0x0020 - 0x0000)
struct DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance final
{
public:
	class ADCAoeBase*                             DCAoeBase;                                         // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254B[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance) == 0x000020, "Wrong size on DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance, DCAoeBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance::DCAoeBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance, TargetArray) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance::TargetArray' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance, Distance) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance::Distance' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance, ReturnValue) == 0x00001C, "Member 'DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterUnTagedTargets
// 0x0020 (0x0020 - 0x0000)
struct DCAoeSystemBlueprintLibrary_FilterUnTagedTargets final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254C[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_FilterUnTagedTargets) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_FilterUnTagedTargets");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_FilterUnTagedTargets) == 0x000020, "Wrong size on DCAoeSystemBlueprintLibrary_FilterUnTagedTargets");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterUnTagedTargets, TargetArray) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_FilterUnTagedTargets::TargetArray' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterUnTagedTargets, GameplayTag) == 0x000010, "Member 'DCAoeSystemBlueprintLibrary_FilterUnTagedTargets::GameplayTag' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_FilterUnTagedTargets, ReturnValue) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_FilterUnTagedTargets::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.GetAoeArrayByClass
// 0x0020 (0x0020 - 0x0000)
struct DCAoeSystemBlueprintLibrary_GetAoeArrayByClass final
{
public:
	const class AActor*                           InActor;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADCAoeBase>                 InAoeClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCAoeBase*>                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_GetAoeArrayByClass) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_GetAoeArrayByClass");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_GetAoeArrayByClass) == 0x000020, "Wrong size on DCAoeSystemBlueprintLibrary_GetAoeArrayByClass");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetAoeArrayByClass, InActor) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_GetAoeArrayByClass::InActor' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetAoeArrayByClass, InAoeClass) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_GetAoeArrayByClass::InAoeClass' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetAoeArrayByClass, ReturnValue) == 0x000010, "Member 'DCAoeSystemBlueprintLibrary_GetAoeArrayByClass::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.GetAoeCountByClass
// 0x0018 (0x0018 - 0x0000)
struct DCAoeSystemBlueprintLibrary_GetAoeCountByClass final
{
public:
	const class AActor*                           InActor;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADCAoeBase>                 InAoeClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254D[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_GetAoeCountByClass) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_GetAoeCountByClass");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_GetAoeCountByClass) == 0x000018, "Wrong size on DCAoeSystemBlueprintLibrary_GetAoeCountByClass");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetAoeCountByClass, InActor) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_GetAoeCountByClass::InActor' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetAoeCountByClass, InAoeClass) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_GetAoeCountByClass::InAoeClass' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetAoeCountByClass, ReturnValue) == 0x000010, "Member 'DCAoeSystemBlueprintLibrary_GetAoeCountByClass::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.GetCircularLocations
// 0x0048 (0x0048 - 0x0000)
struct DCAoeSystemBlueprintLibrary_GetCircularLocations final
{
public:
	struct FVector                                InPivotLocation;                                   // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InOffsetLocation;                                  // 0x0018(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0030(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDistance;                                        // 0x0034(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_GetCircularLocations) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_GetCircularLocations");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_GetCircularLocations) == 0x000048, "Wrong size on DCAoeSystemBlueprintLibrary_GetCircularLocations");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetCircularLocations, InPivotLocation) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_GetCircularLocations::InPivotLocation' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetCircularLocations, InOffsetLocation) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_GetCircularLocations::InOffsetLocation' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetCircularLocations, InCount) == 0x000030, "Member 'DCAoeSystemBlueprintLibrary_GetCircularLocations::InCount' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetCircularLocations, InDistance) == 0x000034, "Member 'DCAoeSystemBlueprintLibrary_GetCircularLocations::InDistance' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetCircularLocations, ReturnValue) == 0x000038, "Member 'DCAoeSystemBlueprintLibrary_GetCircularLocations::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.GetTargetArray
// 0x0020 (0x0020 - 0x0000)
struct DCAoeSystemBlueprintLibrary_GetTargetArray final
{
public:
	class ADCAoeBase*                             DCAoeBase;                                         // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254E[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_GetTargetArray) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_GetTargetArray");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_GetTargetArray) == 0x000020, "Wrong size on DCAoeSystemBlueprintLibrary_GetTargetArray");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetTargetArray, DCAoeBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_GetTargetArray::DCAoeBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetTargetArray, TargetArray) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_GetTargetArray::TargetArray' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_GetTargetArray, ReturnValue) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_GetTargetArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.PickRandomTarget
// 0x0018 (0x0018 - 0x0000)
struct DCAoeSystemBlueprintLibrary_PickRandomTarget final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_PickRandomTarget) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_PickRandomTarget");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_PickRandomTarget) == 0x000018, "Wrong size on DCAoeSystemBlueprintLibrary_PickRandomTarget");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_PickRandomTarget, TargetArray) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_PickRandomTarget::TargetArray' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_PickRandomTarget, ReturnValue) == 0x000010, "Member 'DCAoeSystemBlueprintLibrary_PickRandomTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.PickTarget
// 0x0020 (0x0020 - 0x0000)
struct DCAoeSystemBlueprintLibrary_PickTarget final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254F[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCCharacterBase*                       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_PickTarget) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_PickTarget");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_PickTarget) == 0x000020, "Wrong size on DCAoeSystemBlueprintLibrary_PickTarget");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_PickTarget, TargetArray) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_PickTarget::TargetArray' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_PickTarget, Param_Index) == 0x000010, "Member 'DCAoeSystemBlueprintLibrary_PickTarget::Param_Index' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_PickTarget, ReturnValue) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_PickTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SortTargetsByDistance
// 0x0020 (0x0020 - 0x0000)
struct DCAoeSystemBlueprintLibrary_SortTargetsByDistance final
{
public:
	class ADCAoeBase*                             DCAoeBase;                                         // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EAoeFilterSortingType                         AoeFilterSortingType;                              // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2550[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_SortTargetsByDistance) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_SortTargetsByDistance");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_SortTargetsByDistance) == 0x000020, "Wrong size on DCAoeSystemBlueprintLibrary_SortTargetsByDistance");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SortTargetsByDistance, DCAoeBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_SortTargetsByDistance::DCAoeBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SortTargetsByDistance, TargetArray) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_SortTargetsByDistance::TargetArray' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SortTargetsByDistance, AoeFilterSortingType) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_SortTargetsByDistance::AoeFilterSortingType' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SortTargetsByDistance, ReturnValue) == 0x000019, "Member 'DCAoeSystemBlueprintLibrary_SortTargetsByDistance::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SortTargetsByDistanceAndPickTarget
// 0x0028 (0x0028 - 0x0000)
struct DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget final
{
public:
	class ADCAoeBase*                             DCAoeBase;                                         // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EAoeFilterSortingType                         AoeFilterSortingType;                              // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2551[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Param_Index;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget) == 0x000028, "Wrong size on DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget, DCAoeBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget::DCAoeBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget, TargetArray) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget::TargetArray' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget, AoeFilterSortingType) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget::AoeFilterSortingType' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget, Param_Index) == 0x00001C, "Member 'DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget::Param_Index' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget, ReturnValue) == 0x000020, "Member 'DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SpawnAoe
// 0x00F0 (0x00F0 - 0x0000)
struct DCAoeSystemBlueprintLibrary_SpawnAoe final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADCAoeBase>                 AoeClass;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCGameplayAbilityBase*                 DCGameplayAbilityBase;                             // 0x0028(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0030(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          bSuccessfully;                                     // 0x00E0(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2552[0x7];                                     // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCAoeBase*                             ReturnValue;                                       // 0x00E8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_SpawnAoe) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_SpawnAoe");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_SpawnAoe) == 0x0000F0, "Wrong size on DCAoeSystemBlueprintLibrary_SpawnAoe");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoe, DCCharacterBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoe::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoe, AoeClass) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoe::AoeClass' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoe, Location) == 0x000010, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoe::Location' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoe, DCGameplayAbilityBase) == 0x000028, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoe::DCGameplayAbilityBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoe, EventData) == 0x000030, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoe::EventData' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoe, bSuccessfully) == 0x0000E0, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoe::bSuccessfully' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoe, ReturnValue) == 0x0000E8, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoe::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SpawnAoeDeferred
// 0x00D8 (0x00D8 - 0x0000)
struct DCAoeSystemBlueprintLibrary_SpawnAoeDeferred final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADCAoeBase>                 AoeClass;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCGameplayAbilityBase*                 DCGameplayAbilityBase;                             // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0018(0x00B0)(Parm, NativeAccessSpecifierPublic)
	bool                                          bSuccessfully;                                     // 0x00C8(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2553[0x7];                                     // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCAoeBase*                             ReturnValue;                                       // 0x00D0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAoeSystemBlueprintLibrary_SpawnAoeDeferred) == 0x000008, "Wrong alignment on DCAoeSystemBlueprintLibrary_SpawnAoeDeferred");
static_assert(sizeof(DCAoeSystemBlueprintLibrary_SpawnAoeDeferred) == 0x0000D8, "Wrong size on DCAoeSystemBlueprintLibrary_SpawnAoeDeferred");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoeDeferred, DCCharacterBase) == 0x000000, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoeDeferred::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoeDeferred, AoeClass) == 0x000008, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoeDeferred::AoeClass' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoeDeferred, DCGameplayAbilityBase) == 0x000010, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoeDeferred::DCGameplayAbilityBase' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoeDeferred, EventData) == 0x000018, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoeDeferred::EventData' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoeDeferred, bSuccessfully) == 0x0000C8, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoeDeferred::bSuccessfully' has a wrong offset!");
static_assert(offsetof(DCAoeSystemBlueprintLibrary_SpawnAoeDeferred, ReturnValue) == 0x0000D0, "Member 'DCAoeSystemBlueprintLibrary_SpawnAoeDeferred::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCGameStateBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCGameStateBase_BroadcastMsgBlueprint");
static_assert(sizeof(DCGameStateBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCGameStateBase_BroadcastMsgBlueprint");
static_assert(offsetof(DCGameStateBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCGameStateBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.OnGameInfoSet
// 0x0040 (0x0040 - 0x0000)
struct DCGameStateBase_OnGameInfoSet final
{
public:
	struct FDCGameInfo                            OldGameInfo;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_OnGameInfoSet) == 0x000008, "Wrong alignment on DCGameStateBase_OnGameInfoSet");
static_assert(sizeof(DCGameStateBase_OnGameInfoSet) == 0x000040, "Wrong size on DCGameStateBase_OnGameInfoSet");
static_assert(offsetof(DCGameStateBase_OnGameInfoSet, OldGameInfo) == 0x000000, "Member 'DCGameStateBase_OnGameInfoSet::OldGameInfo' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.OnRep_AccountDataReplicationArray
// 0x0010 (0x0010 - 0x0000)
struct DCGameStateBase_OnRep_AccountDataReplicationArray final
{
public:
	TArray<struct FAccountDataReplication>        OldAccountDataReplicationArray;                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_OnRep_AccountDataReplicationArray) == 0x000008, "Wrong alignment on DCGameStateBase_OnRep_AccountDataReplicationArray");
static_assert(sizeof(DCGameStateBase_OnRep_AccountDataReplicationArray) == 0x000010, "Wrong size on DCGameStateBase_OnRep_AccountDataReplicationArray");
static_assert(offsetof(DCGameStateBase_OnRep_AccountDataReplicationArray, OldAccountDataReplicationArray) == 0x000000, "Member 'DCGameStateBase_OnRep_AccountDataReplicationArray::OldAccountDataReplicationArray' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.OnRep_GameInfo
// 0x0040 (0x0040 - 0x0000)
struct DCGameStateBase_OnRep_GameInfo final
{
public:
	struct FDCGameInfo                            OldGameInfo;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_OnRep_GameInfo) == 0x000008, "Wrong alignment on DCGameStateBase_OnRep_GameInfo");
static_assert(sizeof(DCGameStateBase_OnRep_GameInfo) == 0x000040, "Wrong size on DCGameStateBase_OnRep_GameInfo");
static_assert(offsetof(DCGameStateBase_OnRep_GameInfo, OldGameInfo) == 0x000000, "Member 'DCGameStateBase_OnRep_GameInfo::OldGameInfo' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.OnRep_GameStateDataArray
// 0x0010 (0x0010 - 0x0000)
struct DCGameStateBase_OnRep_GameStateDataArray final
{
public:
	TArray<struct FGameStateData>                 OldGameStateDataArray;                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_OnRep_GameStateDataArray) == 0x000008, "Wrong alignment on DCGameStateBase_OnRep_GameStateDataArray");
static_assert(sizeof(DCGameStateBase_OnRep_GameStateDataArray) == 0x000010, "Wrong size on DCGameStateBase_OnRep_GameStateDataArray");
static_assert(offsetof(DCGameStateBase_OnRep_GameStateDataArray, OldGameStateDataArray) == 0x000000, "Member 'DCGameStateBase_OnRep_GameStateDataArray::OldGameStateDataArray' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.OnRep_PartyDataArray
// 0x0010 (0x0010 - 0x0000)
struct DCGameStateBase_OnRep_PartyDataArray final
{
public:
	TArray<struct FPartyData>                     OldPartyDataArray;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_OnRep_PartyDataArray) == 0x000008, "Wrong alignment on DCGameStateBase_OnRep_PartyDataArray");
static_assert(sizeof(DCGameStateBase_OnRep_PartyDataArray) == 0x000010, "Wrong size on DCGameStateBase_OnRep_PartyDataArray");
static_assert(offsetof(DCGameStateBase_OnRep_PartyDataArray, OldPartyDataArray) == 0x000000, "Member 'DCGameStateBase_OnRep_PartyDataArray::OldPartyDataArray' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.OnRep_State
// 0x0001 (0x0001 - 0x0000)
struct DCGameStateBase_OnRep_State final
{
public:
	EGameStateType                                OldState;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_OnRep_State) == 0x000001, "Wrong alignment on DCGameStateBase_OnRep_State");
static_assert(sizeof(DCGameStateBase_OnRep_State) == 0x000001, "Wrong size on DCGameStateBase_OnRep_State");
static_assert(offsetof(DCGameStateBase_OnRep_State, OldState) == 0x000000, "Member 'DCGameStateBase_OnRep_State::OldState' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCGameStateBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_UnbindMsg) == 0x000008, "Wrong alignment on DCGameStateBase_UnbindMsg");
static_assert(sizeof(DCGameStateBase_UnbindMsg) == 0x000010, "Wrong size on DCGameStateBase_UnbindMsg");
static_assert(offsetof(DCGameStateBase_UnbindMsg, InMsgType) == 0x000000, "Member 'DCGameStateBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCGameStateBase_UnbindMsg, InObject) == 0x000008, "Member 'DCGameStateBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCGameStateBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_UnbindMsgAll) == 0x000008, "Wrong alignment on DCGameStateBase_UnbindMsgAll");
static_assert(sizeof(DCGameStateBase_UnbindMsgAll) == 0x000008, "Wrong size on DCGameStateBase_UnbindMsgAll");
static_assert(offsetof(DCGameStateBase_UnbindMsgAll, InObject) == 0x000000, "Member 'DCGameStateBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.GetFloorRuleActor
// 0x0008 (0x0008 - 0x0000)
struct DCGameStateBase_GetFloorRuleActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_GetFloorRuleActor) == 0x000008, "Wrong alignment on DCGameStateBase_GetFloorRuleActor");
static_assert(sizeof(DCGameStateBase_GetFloorRuleActor) == 0x000008, "Wrong size on DCGameStateBase_GetFloorRuleActor");
static_assert(offsetof(DCGameStateBase_GetFloorRuleActor, ReturnValue) == 0x000000, "Member 'DCGameStateBase_GetFloorRuleActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameStateBase.GetGameInfo
// 0x0040 (0x0040 - 0x0000)
struct DCGameStateBase_GetGameInfo final
{
public:
	struct FDCGameInfo                            ReturnValue;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameStateBase_GetGameInfo) == 0x000008, "Wrong alignment on DCGameStateBase_GetGameInfo");
static_assert(sizeof(DCGameStateBase_GetGameInfo) == 0x000040, "Wrong size on DCGameStateBase_GetGameInfo");
static_assert(offsetof(DCGameStateBase_GetGameInfo, ReturnValue) == 0x000000, "Member 'DCGameStateBase_GetGameInfo::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCArmorSkinComponent.AddArmorSkinForDebug_Server
// 0x0008 (0x0008 - 0x0000)
struct DCArmorSkinComponent_AddArmorSkinForDebug_Server final
{
public:
	const class UDCArmorSkinDataAsset*            ArmorSkin;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArmorSkinComponent_AddArmorSkinForDebug_Server) == 0x000008, "Wrong alignment on DCArmorSkinComponent_AddArmorSkinForDebug_Server");
static_assert(sizeof(DCArmorSkinComponent_AddArmorSkinForDebug_Server) == 0x000008, "Wrong size on DCArmorSkinComponent_AddArmorSkinForDebug_Server");
static_assert(offsetof(DCArmorSkinComponent_AddArmorSkinForDebug_Server, ArmorSkin) == 0x000000, "Member 'DCArmorSkinComponent_AddArmorSkinForDebug_Server::ArmorSkin' has a wrong offset!");

// Function DungeonCrawler.DCArmorSkinComponent.RemoveArmorSkinForDebug_Server
// 0x0008 (0x0008 - 0x0000)
struct DCArmorSkinComponent_RemoveArmorSkinForDebug_Server final
{
public:
	const class UDCArmorSkinDataAsset*            ArmorSkin;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCArmorSkinComponent_RemoveArmorSkinForDebug_Server) == 0x000008, "Wrong alignment on DCArmorSkinComponent_RemoveArmorSkinForDebug_Server");
static_assert(sizeof(DCArmorSkinComponent_RemoveArmorSkinForDebug_Server) == 0x000008, "Wrong size on DCArmorSkinComponent_RemoveArmorSkinForDebug_Server");
static_assert(offsetof(DCArmorSkinComponent_RemoveArmorSkinForDebug_Server, ArmorSkin) == 0x000000, "Member 'DCArmorSkinComponent_RemoveArmorSkinForDebug_Server::ArmorSkin' has a wrong offset!");

// Function DungeonCrawler.LeaderboardContentWidget.OnContentDesc
// 0x0030 (0x0030 - 0x0000)
struct LeaderboardContentWidget_OnContentDesc final
{
public:
	class FText                                   NewValue;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   OldValue;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardContentWidget_OnContentDesc) == 0x000008, "Wrong alignment on LeaderboardContentWidget_OnContentDesc");
static_assert(sizeof(LeaderboardContentWidget_OnContentDesc) == 0x000030, "Wrong size on LeaderboardContentWidget_OnContentDesc");
static_assert(offsetof(LeaderboardContentWidget_OnContentDesc, NewValue) == 0x000000, "Member 'LeaderboardContentWidget_OnContentDesc::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardContentWidget_OnContentDesc, OldValue) == 0x000018, "Member 'LeaderboardContentWidget_OnContentDesc::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardContentWidget.OnContentName
// 0x0030 (0x0030 - 0x0000)
struct LeaderboardContentWidget_OnContentName final
{
public:
	class FText                                   NewValue;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   OldValue;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardContentWidget_OnContentName) == 0x000008, "Wrong alignment on LeaderboardContentWidget_OnContentName");
static_assert(sizeof(LeaderboardContentWidget_OnContentName) == 0x000030, "Wrong size on LeaderboardContentWidget_OnContentName");
static_assert(offsetof(LeaderboardContentWidget_OnContentName, NewValue) == 0x000000, "Member 'LeaderboardContentWidget_OnContentName::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardContentWidget_OnContentName, OldValue) == 0x000018, "Member 'LeaderboardContentWidget_OnContentName::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardContentWidget.OnContentScoreName
// 0x0030 (0x0030 - 0x0000)
struct LeaderboardContentWidget_OnContentScoreName final
{
public:
	class FText                                   NewValue;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   OldValue;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardContentWidget_OnContentScoreName) == 0x000008, "Wrong alignment on LeaderboardContentWidget_OnContentScoreName");
static_assert(sizeof(LeaderboardContentWidget_OnContentScoreName) == 0x000030, "Wrong size on LeaderboardContentWidget_OnContentScoreName");
static_assert(offsetof(LeaderboardContentWidget_OnContentScoreName, NewValue) == 0x000000, "Member 'LeaderboardContentWidget_OnContentScoreName::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardContentWidget_OnContentScoreName, OldValue) == 0x000018, "Member 'LeaderboardContentWidget_OnContentScoreName::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_DashToLocation.DashToLocation
// 0x0038 (0x0038 - 0x0000)
struct DCAT_DashToLocation_DashToLocation final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DestLocation;                                      // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedDistance;                                   // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Teleport;                                          // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_256C[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_DashToLocation*                   ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_DashToLocation_DashToLocation) == 0x000008, "Wrong alignment on DCAT_DashToLocation_DashToLocation");
static_assert(sizeof(DCAT_DashToLocation_DashToLocation) == 0x000038, "Wrong size on DCAT_DashToLocation_DashToLocation");
static_assert(offsetof(DCAT_DashToLocation_DashToLocation, OwningAbility) == 0x000000, "Member 'DCAT_DashToLocation_DashToLocation::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_DashToLocation_DashToLocation, DestLocation) == 0x000008, "Member 'DCAT_DashToLocation_DashToLocation::DestLocation' has a wrong offset!");
static_assert(offsetof(DCAT_DashToLocation_DashToLocation, AllowedDistance) == 0x000020, "Member 'DCAT_DashToLocation_DashToLocation::AllowedDistance' has a wrong offset!");
static_assert(offsetof(DCAT_DashToLocation_DashToLocation, Speed) == 0x000024, "Member 'DCAT_DashToLocation_DashToLocation::Speed' has a wrong offset!");
static_assert(offsetof(DCAT_DashToLocation_DashToLocation, Teleport) == 0x000028, "Member 'DCAT_DashToLocation_DashToLocation::Teleport' has a wrong offset!");
static_assert(offsetof(DCAT_DashToLocation_DashToLocation, ReturnValue) == 0x000030, "Member 'DCAT_DashToLocation_DashToLocation::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_JudgeMusicPlay.JudgeMusicPlay
// 0x0038 (0x0038 - 0x0000)
struct DCAT_JudgeMusicPlay_JudgeMusicPlay final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInputAction*                     InInputAction;                                     // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoodSectionStartTime;                              // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoodSectionEndTime;                                // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectSectionStartTime;                           // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectSectionEndTime;                             // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_256E[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_JudgeMusicPlay*                   ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_JudgeMusicPlay_JudgeMusicPlay) == 0x000008, "Wrong alignment on DCAT_JudgeMusicPlay_JudgeMusicPlay");
static_assert(sizeof(DCAT_JudgeMusicPlay_JudgeMusicPlay) == 0x000038, "Wrong size on DCAT_JudgeMusicPlay_JudgeMusicPlay");
static_assert(offsetof(DCAT_JudgeMusicPlay_JudgeMusicPlay, OwningAbility) == 0x000000, "Member 'DCAT_JudgeMusicPlay_JudgeMusicPlay::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_JudgeMusicPlay_JudgeMusicPlay, TaskInstanceName) == 0x000008, "Member 'DCAT_JudgeMusicPlay_JudgeMusicPlay::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(DCAT_JudgeMusicPlay_JudgeMusicPlay, InInputAction) == 0x000010, "Member 'DCAT_JudgeMusicPlay_JudgeMusicPlay::InInputAction' has a wrong offset!");
static_assert(offsetof(DCAT_JudgeMusicPlay_JudgeMusicPlay, Duration) == 0x000018, "Member 'DCAT_JudgeMusicPlay_JudgeMusicPlay::Duration' has a wrong offset!");
static_assert(offsetof(DCAT_JudgeMusicPlay_JudgeMusicPlay, GoodSectionStartTime) == 0x00001C, "Member 'DCAT_JudgeMusicPlay_JudgeMusicPlay::GoodSectionStartTime' has a wrong offset!");
static_assert(offsetof(DCAT_JudgeMusicPlay_JudgeMusicPlay, GoodSectionEndTime) == 0x000020, "Member 'DCAT_JudgeMusicPlay_JudgeMusicPlay::GoodSectionEndTime' has a wrong offset!");
static_assert(offsetof(DCAT_JudgeMusicPlay_JudgeMusicPlay, PerfectSectionStartTime) == 0x000024, "Member 'DCAT_JudgeMusicPlay_JudgeMusicPlay::PerfectSectionStartTime' has a wrong offset!");
static_assert(offsetof(DCAT_JudgeMusicPlay_JudgeMusicPlay, PerfectSectionEndTime) == 0x000028, "Member 'DCAT_JudgeMusicPlay_JudgeMusicPlay::PerfectSectionEndTime' has a wrong offset!");
static_assert(offsetof(DCAT_JudgeMusicPlay_JudgeMusicPlay, ReturnValue) == 0x000030, "Member 'DCAT_JudgeMusicPlay_JudgeMusicPlay::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_OverlapActorsInComponent.OverlapActorsInComponent
// 0x0028 (0x0028 - 0x0000)
struct DCAT_OverlapActorsInComponent_OverlapActorsInComponent final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OverlapPrimitiveComponent;                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 OverlapTargetClass;                                // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InIgnoreActor;                                     // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_OverlapActorsInComponent*         ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_OverlapActorsInComponent_OverlapActorsInComponent) == 0x000008, "Wrong alignment on DCAT_OverlapActorsInComponent_OverlapActorsInComponent");
static_assert(sizeof(DCAT_OverlapActorsInComponent_OverlapActorsInComponent) == 0x000028, "Wrong size on DCAT_OverlapActorsInComponent_OverlapActorsInComponent");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OverlapActorsInComponent, OwningAbility) == 0x000000, "Member 'DCAT_OverlapActorsInComponent_OverlapActorsInComponent::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OverlapActorsInComponent, OverlapPrimitiveComponent) == 0x000008, "Member 'DCAT_OverlapActorsInComponent_OverlapActorsInComponent::OverlapPrimitiveComponent' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OverlapActorsInComponent, OverlapTargetClass) == 0x000010, "Member 'DCAT_OverlapActorsInComponent_OverlapActorsInComponent::OverlapTargetClass' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OverlapActorsInComponent, InIgnoreActor) == 0x000018, "Member 'DCAT_OverlapActorsInComponent_OverlapActorsInComponent::InIgnoreActor' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OverlapActorsInComponent, ReturnValue) == 0x000020, "Member 'DCAT_OverlapActorsInComponent_OverlapActorsInComponent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_OverlapActorsInComponent.AddIgnoreActors
// 0x0010 (0x0010 - 0x0000)
struct DCAT_OverlapActorsInComponent_AddIgnoreActors final
{
public:
	TArray<class AActor*>                         InAddIgnoreActors;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_OverlapActorsInComponent_AddIgnoreActors) == 0x000008, "Wrong alignment on DCAT_OverlapActorsInComponent_AddIgnoreActors");
static_assert(sizeof(DCAT_OverlapActorsInComponent_AddIgnoreActors) == 0x000010, "Wrong size on DCAT_OverlapActorsInComponent_AddIgnoreActors");
static_assert(offsetof(DCAT_OverlapActorsInComponent_AddIgnoreActors, InAddIgnoreActors) == 0x000000, "Member 'DCAT_OverlapActorsInComponent_AddIgnoreActors::InAddIgnoreActors' has a wrong offset!");

// Function DungeonCrawler.DCAT_OverlapActorsInComponent.GetTargetList
// 0x0010 (0x0010 - 0x0000)
struct DCAT_OverlapActorsInComponent_GetTargetList final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_OverlapActorsInComponent_GetTargetList) == 0x000008, "Wrong alignment on DCAT_OverlapActorsInComponent_GetTargetList");
static_assert(sizeof(DCAT_OverlapActorsInComponent_GetTargetList) == 0x000010, "Wrong size on DCAT_OverlapActorsInComponent_GetTargetList");
static_assert(offsetof(DCAT_OverlapActorsInComponent_GetTargetList, ReturnValue) == 0x000000, "Member 'DCAT_OverlapActorsInComponent_GetTargetList::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_OverlapActorsInComponent.OnOverlapBegin
// 0x0108 (0x0108 - 0x0000)
struct DCAT_OverlapActorsInComponent_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2570[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_OverlapActorsInComponent_OnOverlapBegin) == 0x000008, "Wrong alignment on DCAT_OverlapActorsInComponent_OnOverlapBegin");
static_assert(sizeof(DCAT_OverlapActorsInComponent_OnOverlapBegin) == 0x000108, "Wrong size on DCAT_OverlapActorsInComponent_OnOverlapBegin");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OnOverlapBegin, OverlappedComponent) == 0x000000, "Member 'DCAT_OverlapActorsInComponent_OnOverlapBegin::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OnOverlapBegin, OtherActor) == 0x000008, "Member 'DCAT_OverlapActorsInComponent_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OnOverlapBegin, OtherComp) == 0x000010, "Member 'DCAT_OverlapActorsInComponent_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'DCAT_OverlapActorsInComponent_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'DCAT_OverlapActorsInComponent_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OnOverlapBegin, SweepResult) == 0x000020, "Member 'DCAT_OverlapActorsInComponent_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function DungeonCrawler.DCAT_OverlapActorsInComponent.OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct DCAT_OverlapActorsInComponent_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2571[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCAT_OverlapActorsInComponent_OnOverlapEnd) == 0x000008, "Wrong alignment on DCAT_OverlapActorsInComponent_OnOverlapEnd");
static_assert(sizeof(DCAT_OverlapActorsInComponent_OnOverlapEnd) == 0x000020, "Wrong size on DCAT_OverlapActorsInComponent_OnOverlapEnd");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OnOverlapEnd, OverlappedComponent) == 0x000000, "Member 'DCAT_OverlapActorsInComponent_OnOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OnOverlapEnd, OtherActor) == 0x000008, "Member 'DCAT_OverlapActorsInComponent_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OnOverlapEnd, OtherComp) == 0x000010, "Member 'DCAT_OverlapActorsInComponent_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(DCAT_OverlapActorsInComponent_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'DCAT_OverlapActorsInComponent_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DungeonCrawler.DCAT_PlayMontageAndWaitForEvent.PlayMontageAndWaitForEvent
// 0x0058 (0x0058 - 0x0000)
struct DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Param_MontageToPlay;                               // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  Param_EventTags;                                   // 0x0018(0x0020)(Parm, NativeAccessSpecifierPublic)
	float                                         Param_Rate;                                        // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Param_StartSection;                                // 0x003C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Param_bStopWhenAbilityEnds;                        // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2573[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Param_AnimRootMotionTranslationScale;              // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param_StartTimeSeconds;                            // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_PlayMontageAndWaitForEvent*       ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent) == 0x000008, "Wrong alignment on DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent");
static_assert(sizeof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent) == 0x000058, "Wrong size on DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent");
static_assert(offsetof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, OwningAbility) == 0x000000, "Member 'DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, TaskInstanceName) == 0x000008, "Member 'DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_MontageToPlay) == 0x000010, "Member 'DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_MontageToPlay' has a wrong offset!");
static_assert(offsetof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_EventTags) == 0x000018, "Member 'DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_EventTags' has a wrong offset!");
static_assert(offsetof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_Rate) == 0x000038, "Member 'DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_Rate' has a wrong offset!");
static_assert(offsetof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_StartSection) == 0x00003C, "Member 'DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_StartSection' has a wrong offset!");
static_assert(offsetof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_bStopWhenAbilityEnds) == 0x000044, "Member 'DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_bStopWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_AnimRootMotionTranslationScale) == 0x000048, "Member 'DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, Param_StartTimeSeconds) == 0x00004C, "Member 'DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::Param_StartTimeSeconds' has a wrong offset!");
static_assert(offsetof(DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent, ReturnValue) == 0x000050, "Member 'DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_RotateToActor.RotateToActor
// 0x0028 (0x0028 - 0x0000)
struct DCAT_RotateToActor_RotateToActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitBoxType                                   HitBox;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2575[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WithoutPitch;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WithoutRoll;                                       // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2576[0x6];                                     // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_RotateToActor*                    ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_RotateToActor_RotateToActor) == 0x000008, "Wrong alignment on DCAT_RotateToActor_RotateToActor");
static_assert(sizeof(DCAT_RotateToActor_RotateToActor) == 0x000028, "Wrong size on DCAT_RotateToActor_RotateToActor");
static_assert(offsetof(DCAT_RotateToActor_RotateToActor, OwningAbility) == 0x000000, "Member 'DCAT_RotateToActor_RotateToActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_RotateToActor_RotateToActor, Actor) == 0x000008, "Member 'DCAT_RotateToActor_RotateToActor::Actor' has a wrong offset!");
static_assert(offsetof(DCAT_RotateToActor_RotateToActor, HitBox) == 0x000010, "Member 'DCAT_RotateToActor_RotateToActor::HitBox' has a wrong offset!");
static_assert(offsetof(DCAT_RotateToActor_RotateToActor, Speed) == 0x000014, "Member 'DCAT_RotateToActor_RotateToActor::Speed' has a wrong offset!");
static_assert(offsetof(DCAT_RotateToActor_RotateToActor, WithoutPitch) == 0x000018, "Member 'DCAT_RotateToActor_RotateToActor::WithoutPitch' has a wrong offset!");
static_assert(offsetof(DCAT_RotateToActor_RotateToActor, WithoutRoll) == 0x000019, "Member 'DCAT_RotateToActor_RotateToActor::WithoutRoll' has a wrong offset!");
static_assert(offsetof(DCAT_RotateToActor_RotateToActor, ReturnValue) == 0x000020, "Member 'DCAT_RotateToActor_RotateToActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_ServerWaitClientTargetData.ServerWaitForClientTargetData
// 0x0020 (0x0020 - 0x0000)
struct DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2578[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_ServerWaitClientTargetData*       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData) == 0x000008, "Wrong alignment on DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData");
static_assert(sizeof(DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData) == 0x000020, "Wrong size on DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData");
static_assert(offsetof(DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData, OwningAbility) == 0x000000, "Member 'DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData, TaskInstanceName) == 0x000008, "Member 'DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData, TriggerOnce) == 0x000010, "Member 'DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData::TriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData, ReturnValue) == 0x000018, "Member 'DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_ServerWaitClientTargetData.OnTargetDataReplicatedCallback
// 0x0030 (0x0030 - 0x0000)
struct DCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActivationTag;                                     // 0x0028(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback) == 0x000008, "Wrong alignment on DCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback");
static_assert(sizeof(DCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback) == 0x000030, "Wrong size on DCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback");
static_assert(offsetof(DCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback, Data) == 0x000000, "Member 'DCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback::Data' has a wrong offset!");
static_assert(offsetof(DCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback, ActivationTag) == 0x000028, "Member 'DCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback::ActivationTag' has a wrong offset!");

// Function DungeonCrawler.MailBoxWidgetBase.IsFriendPrivacyOn
// 0x0001 (0x0001 - 0x0000)
struct MailBoxWidgetBase_IsFriendPrivacyOn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MailBoxWidgetBase_IsFriendPrivacyOn) == 0x000001, "Wrong alignment on MailBoxWidgetBase_IsFriendPrivacyOn");
static_assert(sizeof(MailBoxWidgetBase_IsFriendPrivacyOn) == 0x000001, "Wrong size on MailBoxWidgetBase_IsFriendPrivacyOn");
static_assert(offsetof(MailBoxWidgetBase_IsFriendPrivacyOn, ReturnValue) == 0x000000, "Member 'MailBoxWidgetBase_IsFriendPrivacyOn::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.MailBoxWidgetBase.IsPartyPrivacyOn
// 0x0001 (0x0001 - 0x0000)
struct MailBoxWidgetBase_IsPartyPrivacyOn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MailBoxWidgetBase_IsPartyPrivacyOn) == 0x000001, "Wrong alignment on MailBoxWidgetBase_IsPartyPrivacyOn");
static_assert(sizeof(MailBoxWidgetBase_IsPartyPrivacyOn) == 0x000001, "Wrong size on MailBoxWidgetBase_IsPartyPrivacyOn");
static_assert(offsetof(MailBoxWidgetBase_IsPartyPrivacyOn, ReturnValue) == 0x000000, "Member 'MailBoxWidgetBase_IsPartyPrivacyOn::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.MailBoxWidgetBase.OnFMsgWidgetStreamingModeNotifyBlueprint
// 0x0020 (0x0020 - 0x0000)
struct MailBoxWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint final
{
public:
	struct FMsgWidgetStreamingModeNotify          InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MailBoxWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000008, "Wrong alignment on MailBoxWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(sizeof(MailBoxWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000020, "Wrong size on MailBoxWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(offsetof(MailBoxWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint, InMsg) == 0x000000, "Member 'MailBoxWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.MailBoxWidgetBase.OnSetFriendPrivacy
// 0x0001 (0x0001 - 0x0000)
struct MailBoxWidgetBase_OnSetFriendPrivacy final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MailBoxWidgetBase_OnSetFriendPrivacy) == 0x000001, "Wrong alignment on MailBoxWidgetBase_OnSetFriendPrivacy");
static_assert(sizeof(MailBoxWidgetBase_OnSetFriendPrivacy) == 0x000001, "Wrong size on MailBoxWidgetBase_OnSetFriendPrivacy");
static_assert(offsetof(MailBoxWidgetBase_OnSetFriendPrivacy, bOn) == 0x000000, "Member 'MailBoxWidgetBase_OnSetFriendPrivacy::bOn' has a wrong offset!");

// Function DungeonCrawler.MailBoxWidgetBase.OnSetPartyPrivacy
// 0x0001 (0x0001 - 0x0000)
struct MailBoxWidgetBase_OnSetPartyPrivacy final
{
public:
	bool                                          bOn;                                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MailBoxWidgetBase_OnSetPartyPrivacy) == 0x000001, "Wrong alignment on MailBoxWidgetBase_OnSetPartyPrivacy");
static_assert(sizeof(MailBoxWidgetBase_OnSetPartyPrivacy) == 0x000001, "Wrong size on MailBoxWidgetBase_OnSetPartyPrivacy");
static_assert(offsetof(MailBoxWidgetBase_OnSetPartyPrivacy, bOn) == 0x000000, "Member 'MailBoxWidgetBase_OnSetPartyPrivacy::bOn' has a wrong offset!");

// Function DungeonCrawler.DCAT_SpawnProjectile.SpawnProjectile
// 0x0080 (0x0080 - 0x0000)
struct DCAT_SpawnProjectile_SpawnProjectile final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirePower;                                         // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_257B[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_SpawnProjectile*                  ReturnValue;                                       // 0x0078(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_SpawnProjectile_SpawnProjectile) == 0x000010, "Wrong alignment on DCAT_SpawnProjectile_SpawnProjectile");
static_assert(sizeof(DCAT_SpawnProjectile_SpawnProjectile) == 0x000080, "Wrong size on DCAT_SpawnProjectile_SpawnProjectile");
static_assert(offsetof(DCAT_SpawnProjectile_SpawnProjectile, OwningAbility) == 0x000000, "Member 'DCAT_SpawnProjectile_SpawnProjectile::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_SpawnProjectile_SpawnProjectile, SpawnClass) == 0x000008, "Member 'DCAT_SpawnProjectile_SpawnProjectile::SpawnClass' has a wrong offset!");
static_assert(offsetof(DCAT_SpawnProjectile_SpawnProjectile, SpawnTransform) == 0x000010, "Member 'DCAT_SpawnProjectile_SpawnProjectile::SpawnTransform' has a wrong offset!");
static_assert(offsetof(DCAT_SpawnProjectile_SpawnProjectile, FirePower) == 0x000070, "Member 'DCAT_SpawnProjectile_SpawnProjectile::FirePower' has a wrong offset!");
static_assert(offsetof(DCAT_SpawnProjectile_SpawnProjectile, ReturnValue) == 0x000078, "Member 'DCAT_SpawnProjectile_SpawnProjectile::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_TargetActorRadius.TargetActorRadius
// 0x0020 (0x0020 - 0x0000)
struct DCAT_TargetActorRadius_TargetActorRadius final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_257D[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 TargetingClass;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_TargetActorRadius*                ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_TargetActorRadius_TargetActorRadius) == 0x000008, "Wrong alignment on DCAT_TargetActorRadius_TargetActorRadius");
static_assert(sizeof(DCAT_TargetActorRadius_TargetActorRadius) == 0x000020, "Wrong size on DCAT_TargetActorRadius_TargetActorRadius");
static_assert(offsetof(DCAT_TargetActorRadius_TargetActorRadius, OwningAbility) == 0x000000, "Member 'DCAT_TargetActorRadius_TargetActorRadius::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_TargetActorRadius_TargetActorRadius, Radius) == 0x000008, "Member 'DCAT_TargetActorRadius_TargetActorRadius::Radius' has a wrong offset!");
static_assert(offsetof(DCAT_TargetActorRadius_TargetActorRadius, CollisionChannel) == 0x00000C, "Member 'DCAT_TargetActorRadius_TargetActorRadius::CollisionChannel' has a wrong offset!");
static_assert(offsetof(DCAT_TargetActorRadius_TargetActorRadius, TargetingClass) == 0x000010, "Member 'DCAT_TargetActorRadius_TargetActorRadius::TargetingClass' has a wrong offset!");
static_assert(offsetof(DCAT_TargetActorRadius_TargetActorRadius, ReturnValue) == 0x000018, "Member 'DCAT_TargetActorRadius_TargetActorRadius::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitAimDirChangedFromActor.WaitAimDirectionChangedFromActor
// 0x0018 (0x0018 - 0x0000)
struct DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InTargetActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitAimDirChangedFromActor*       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor) == 0x000008, "Wrong alignment on DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor");
static_assert(sizeof(DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor) == 0x000018, "Wrong size on DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor");
static_assert(offsetof(DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor, OwningAbility) == 0x000000, "Member 'DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor, InTargetActor) == 0x000008, "Member 'DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor::InTargetActor' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor, ReturnValue) == 0x000010, "Member 'DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ShapeShiftSlotWidgetBase.OnSetShapeShiftArtData
// 0x0008 (0x0008 - 0x0000)
struct ShapeShiftSlotWidgetBase_OnSetShapeShiftArtData final
{
public:
	const class UDCCharacterShapeShiftArtData*    InShapeShiftArtData;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShapeShiftSlotWidgetBase_OnSetShapeShiftArtData) == 0x000008, "Wrong alignment on ShapeShiftSlotWidgetBase_OnSetShapeShiftArtData");
static_assert(sizeof(ShapeShiftSlotWidgetBase_OnSetShapeShiftArtData) == 0x000008, "Wrong size on ShapeShiftSlotWidgetBase_OnSetShapeShiftArtData");
static_assert(offsetof(ShapeShiftSlotWidgetBase_OnSetShapeShiftArtData, InShapeShiftArtData) == 0x000000, "Member 'ShapeShiftSlotWidgetBase_OnSetShapeShiftArtData::InShapeShiftArtData' has a wrong offset!");

// Function DungeonCrawler.ShapeShiftSlotWidgetBase.OnShapeShiftDataChanged
// 0x0020 (0x0020 - 0x0000)
struct ShapeShiftSlotWidgetBase_OnShapeShiftDataChanged final
{
public:
	struct FShapeShiftData                        InShapeShiftData;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShapeShiftSlotWidgetBase_OnShapeShiftDataChanged) == 0x000004, "Wrong alignment on ShapeShiftSlotWidgetBase_OnShapeShiftDataChanged");
static_assert(sizeof(ShapeShiftSlotWidgetBase_OnShapeShiftDataChanged) == 0x000020, "Wrong size on ShapeShiftSlotWidgetBase_OnShapeShiftDataChanged");
static_assert(offsetof(ShapeShiftSlotWidgetBase_OnShapeShiftDataChanged, InShapeShiftData) == 0x000000, "Member 'ShapeShiftSlotWidgetBase_OnShapeShiftDataChanged::InShapeShiftData' has a wrong offset!");

// Function DungeonCrawler.ShapeShiftSlotWidgetBase.SetShapeShiftData
// 0x0028 (0x0028 - 0x0000)
struct ShapeShiftSlotWidgetBase_SetShapeShiftData final
{
public:
	struct FShapeShiftData                        InShapeShiftData;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	const class UDCShapeShiftDataAsset*           InShapeShiftDataAsset;                             // 0x0020(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShapeShiftSlotWidgetBase_SetShapeShiftData) == 0x000008, "Wrong alignment on ShapeShiftSlotWidgetBase_SetShapeShiftData");
static_assert(sizeof(ShapeShiftSlotWidgetBase_SetShapeShiftData) == 0x000028, "Wrong size on ShapeShiftSlotWidgetBase_SetShapeShiftData");
static_assert(offsetof(ShapeShiftSlotWidgetBase_SetShapeShiftData, InShapeShiftData) == 0x000000, "Member 'ShapeShiftSlotWidgetBase_SetShapeShiftData::InShapeShiftData' has a wrong offset!");
static_assert(offsetof(ShapeShiftSlotWidgetBase_SetShapeShiftData, InShapeShiftDataAsset) == 0x000020, "Member 'ShapeShiftSlotWidgetBase_SetShapeShiftData::InShapeShiftDataAsset' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitAimDirectionChanged.WaitAimDirectionChanged
// 0x0010 (0x0010 - 0x0000)
struct DCAT_WaitAimDirectionChanged_WaitAimDirectionChanged final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitAimDirectionChanged*          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitAimDirectionChanged_WaitAimDirectionChanged) == 0x000008, "Wrong alignment on DCAT_WaitAimDirectionChanged_WaitAimDirectionChanged");
static_assert(sizeof(DCAT_WaitAimDirectionChanged_WaitAimDirectionChanged) == 0x000010, "Wrong size on DCAT_WaitAimDirectionChanged_WaitAimDirectionChanged");
static_assert(offsetof(DCAT_WaitAimDirectionChanged_WaitAimDirectionChanged, OwningAbility) == 0x000000, "Member 'DCAT_WaitAimDirectionChanged_WaitAimDirectionChanged::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAimDirectionChanged_WaitAimDirectionChanged, ReturnValue) == 0x000008, "Member 'DCAT_WaitAimDirectionChanged_WaitAimDirectionChanged::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitAttributeChangeByExecution.WaitForAttributeChange
// 0x0058 (0x0058 - 0x0000)
struct DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0008(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2582[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OptionalExternalOwner;                             // 0x0048(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitAttributeChangeByExecution*   ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange) == 0x000008, "Wrong alignment on DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange");
static_assert(sizeof(DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange) == 0x000058, "Wrong size on DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange");
static_assert(offsetof(DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange, OwningAbility) == 0x000000, "Member 'DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange, Attribute) == 0x000008, "Member 'DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange::Attribute' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange, TriggerOnce) == 0x000040, "Member 'DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange::TriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange, OptionalExternalOwner) == 0x000048, "Member 'DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange::OptionalExternalOwner' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange, ReturnValue) == 0x000050, "Member 'DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitAttributeChangeByExecution.WaitForAttributesChange
// 0x0030 (0x0030 - 0x0000)
struct DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayAttribute>             Attributes;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          TriggerOnce;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2583[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OptionalExternalOwner;                             // 0x0020(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitAttributeChangeByExecution*   ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange) == 0x000008, "Wrong alignment on DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange");
static_assert(sizeof(DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange) == 0x000030, "Wrong size on DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange");
static_assert(offsetof(DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange, OwningAbility) == 0x000000, "Member 'DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange, Attributes) == 0x000008, "Member 'DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange::Attributes' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange, TriggerOnce) == 0x000018, "Member 'DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange::TriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange, OptionalExternalOwner) == 0x000020, "Member 'DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange::OptionalExternalOwner' has a wrong offset!");
static_assert(offsetof(DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange, ReturnValue) == 0x000028, "Member 'DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitDelayPausable.WaitDelay
// 0x0018 (0x0018 - 0x0000)
struct DCAT_WaitDelayPausable_WaitDelay final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2585[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitDelayPausable*                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitDelayPausable_WaitDelay) == 0x000008, "Wrong alignment on DCAT_WaitDelayPausable_WaitDelay");
static_assert(sizeof(DCAT_WaitDelayPausable_WaitDelay) == 0x000018, "Wrong size on DCAT_WaitDelayPausable_WaitDelay");
static_assert(offsetof(DCAT_WaitDelayPausable_WaitDelay, OwningAbility) == 0x000000, "Member 'DCAT_WaitDelayPausable_WaitDelay::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDelayPausable_WaitDelay, Duration) == 0x000008, "Member 'DCAT_WaitDelayPausable_WaitDelay::Duration' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDelayPausable_WaitDelay, ReturnValue) == 0x000010, "Member 'DCAT_WaitDelayPausable_WaitDelay::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitDelayPausable.AddTimerElapsedTimeRatio
// 0x0004 (0x0004 - 0x0000)
struct DCAT_WaitDelayPausable_AddTimerElapsedTimeRatio final
{
public:
	float                                         AdditionalRatio;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitDelayPausable_AddTimerElapsedTimeRatio) == 0x000004, "Wrong alignment on DCAT_WaitDelayPausable_AddTimerElapsedTimeRatio");
static_assert(sizeof(DCAT_WaitDelayPausable_AddTimerElapsedTimeRatio) == 0x000004, "Wrong size on DCAT_WaitDelayPausable_AddTimerElapsedTimeRatio");
static_assert(offsetof(DCAT_WaitDelayPausable_AddTimerElapsedTimeRatio, AdditionalRatio) == 0x000000, "Member 'DCAT_WaitDelayPausable_AddTimerElapsedTimeRatio::AdditionalRatio' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitDelayPausable.GetElapsedTime
// 0x0004 (0x0004 - 0x0000)
struct DCAT_WaitDelayPausable_GetElapsedTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitDelayPausable_GetElapsedTime) == 0x000004, "Wrong alignment on DCAT_WaitDelayPausable_GetElapsedTime");
static_assert(sizeof(DCAT_WaitDelayPausable_GetElapsedTime) == 0x000004, "Wrong size on DCAT_WaitDelayPausable_GetElapsedTime");
static_assert(offsetof(DCAT_WaitDelayPausable_GetElapsedTime, ReturnValue) == 0x000000, "Member 'DCAT_WaitDelayPausable_GetElapsedTime::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitDistChangeFromActor.WaitDistanceChange
// 0x0020 (0x0020 - 0x0000)
struct DCAT_WaitDistChangeFromActor_WaitDistanceChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistance;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2587[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitDistChangeFromActor*          ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitDistChangeFromActor_WaitDistanceChange) == 0x000008, "Wrong alignment on DCAT_WaitDistChangeFromActor_WaitDistanceChange");
static_assert(sizeof(DCAT_WaitDistChangeFromActor_WaitDistanceChange) == 0x000020, "Wrong size on DCAT_WaitDistChangeFromActor_WaitDistanceChange");
static_assert(offsetof(DCAT_WaitDistChangeFromActor_WaitDistanceChange, OwningAbility) == 0x000000, "Member 'DCAT_WaitDistChangeFromActor_WaitDistanceChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromActor_WaitDistanceChange, TargetActor) == 0x000008, "Member 'DCAT_WaitDistChangeFromActor_WaitDistanceChange::TargetActor' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromActor_WaitDistanceChange, MaximumDistance) == 0x000010, "Member 'DCAT_WaitDistChangeFromActor_WaitDistanceChange::MaximumDistance' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromActor_WaitDistanceChange, ReturnValue) == 0x000018, "Member 'DCAT_WaitDistChangeFromActor_WaitDistanceChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitDistChangeFromView.WaitDistanceChange
// 0x0040 (0x0040 - 0x0000)
struct DCAT_WaitDistChangeFromView_WaitDistanceChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDistance;                                   // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2589[0x7];                                     // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitDistChangeFromView*           ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitDistChangeFromView_WaitDistanceChange) == 0x000008, "Wrong alignment on DCAT_WaitDistChangeFromView_WaitDistanceChange");
static_assert(sizeof(DCAT_WaitDistChangeFromView_WaitDistanceChange) == 0x000040, "Wrong size on DCAT_WaitDistChangeFromView_WaitDistanceChange");
static_assert(offsetof(DCAT_WaitDistChangeFromView_WaitDistanceChange, OwningAbility) == 0x000000, "Member 'DCAT_WaitDistChangeFromView_WaitDistanceChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromView_WaitDistanceChange, TargetActor) == 0x000008, "Member 'DCAT_WaitDistChangeFromView_WaitDistanceChange::TargetActor' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromView_WaitDistanceChange, TargetLocation) == 0x000010, "Member 'DCAT_WaitDistChangeFromView_WaitDistanceChange::TargetLocation' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromView_WaitDistanceChange, MaximumDistance) == 0x000028, "Member 'DCAT_WaitDistChangeFromView_WaitDistanceChange::MaximumDistance' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromView_WaitDistanceChange, CollisionRadius) == 0x00002C, "Member 'DCAT_WaitDistChangeFromView_WaitDistanceChange::CollisionRadius' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromView_WaitDistanceChange, CollisionChannel) == 0x000030, "Member 'DCAT_WaitDistChangeFromView_WaitDistanceChange::CollisionChannel' has a wrong offset!");
static_assert(offsetof(DCAT_WaitDistChangeFromView_WaitDistanceChange, ReturnValue) == 0x000038, "Member 'DCAT_WaitDistChangeFromView_WaitDistanceChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitForGameplayEvents.WaitForGameplayEvents
// 0x0030 (0x0030 - 0x0000)
struct DCAT_WaitForGameplayEvents_WaitForGameplayEvents final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InEventTags;                                       // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	class UDCAT_WaitForGameplayEvents*            ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitForGameplayEvents_WaitForGameplayEvents) == 0x000008, "Wrong alignment on DCAT_WaitForGameplayEvents_WaitForGameplayEvents");
static_assert(sizeof(DCAT_WaitForGameplayEvents_WaitForGameplayEvents) == 0x000030, "Wrong size on DCAT_WaitForGameplayEvents_WaitForGameplayEvents");
static_assert(offsetof(DCAT_WaitForGameplayEvents_WaitForGameplayEvents, OwningAbility) == 0x000000, "Member 'DCAT_WaitForGameplayEvents_WaitForGameplayEvents::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitForGameplayEvents_WaitForGameplayEvents, InEventTags) == 0x000008, "Member 'DCAT_WaitForGameplayEvents_WaitForGameplayEvents::InEventTags' has a wrong offset!");
static_assert(offsetof(DCAT_WaitForGameplayEvents_WaitForGameplayEvents, ReturnValue) == 0x000028, "Member 'DCAT_WaitForGameplayEvents_WaitForGameplayEvents::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEnd
// 0x0030 (0x0030 - 0x0000)
struct DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithTag;                                           // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WithoutTag;                                        // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InOptionalExternalTarget;                          // 0x0018(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnce;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258D[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitGameplayAbilityActivateOrEnd* ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd) == 0x000008, "Wrong alignment on DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd");
static_assert(sizeof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd) == 0x000030, "Wrong size on DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd, OwningAbility) == 0x000000, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd, WithTag) == 0x000008, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd::WithTag' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd, WithoutTag) == 0x000010, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd::WithoutTag' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd, InOptionalExternalTarget) == 0x000018, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd::InOptionalExternalTarget' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd, bTriggerOnce) == 0x000020, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd::bTriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd, ReturnValue) == 0x000028, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEnd_Query
// 0x0068 (0x0068 - 0x0000)
struct DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      Query;                                             // 0x0008(0x0048)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 InOptionalExternalTarget;                          // 0x0050(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnce;                                      // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258E[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitGameplayAbilityActivateOrEnd* ReturnValue;                                       // 0x0060(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query) == 0x000008, "Wrong alignment on DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query");
static_assert(sizeof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query) == 0x000068, "Wrong size on DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query, OwningAbility) == 0x000000, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query, Query) == 0x000008, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query::Query' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query, InOptionalExternalTarget) == 0x000050, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query::InOptionalExternalTarget' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query, bTriggerOnce) == 0x000058, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query::bTriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query, ReturnValue) == 0x000060, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEndWithTagRequirements
// 0x00A8 (0x00A8 - 0x0000)
struct DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagRequirements               TagRequirements;                                   // 0x0008(0x0088)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 InOptionalExternalTarget;                          // 0x0090(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnce;                                      // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258F[0x7];                                     // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitGameplayAbilityActivateOrEnd* ReturnValue;                                       // 0x00A0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements) == 0x000008, "Wrong alignment on DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements");
static_assert(sizeof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements) == 0x0000A8, "Wrong size on DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements, OwningAbility) == 0x000000, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements, TagRequirements) == 0x000008, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements::TagRequirements' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements, InOptionalExternalTarget) == 0x000090, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements::InOptionalExternalTarget' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements, bTriggerOnce) == 0x000098, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements::bTriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements, ReturnValue) == 0x0000A0, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.OnAbilityActivate
// 0x0008 (0x0008 - 0x0000)
struct DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityActivate final
{
public:
	class UGameplayAbility*                       ActivatedAbility;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityActivate) == 0x000008, "Wrong alignment on DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityActivate");
static_assert(sizeof(DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityActivate) == 0x000008, "Wrong size on DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityActivate");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityActivate, ActivatedAbility) == 0x000000, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityActivate::ActivatedAbility' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.OnAbilityEnd
// 0x0010 (0x0010 - 0x0000)
struct DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityEnd final
{
public:
	struct FAbilityEndedData                      AbilityEndedData;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityEnd) == 0x000008, "Wrong alignment on DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityEnd");
static_assert(sizeof(DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityEnd) == 0x000010, "Wrong size on DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityEnd");
static_assert(offsetof(DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityEnd, AbilityEndedData) == 0x000000, "Member 'DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityEnd::AbilityEndedData' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitGameplayTagsRemoved.WaitGameplayTagsRemoved
// 0x0048 (0x0048 - 0x0000)
struct DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  TagContainer;                                      // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
	bool                                          bIsWaitAnyTag;                                     // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2591[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 InOptionalExternalTarget;                          // 0x0030(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnlyTriggerOnce;                                // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBroadcastImmediately;                       // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2592[0x6];                                     // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitGameplayTagsRemoved*          ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved) == 0x000008, "Wrong alignment on DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved");
static_assert(sizeof(DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved) == 0x000048, "Wrong size on DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved");
static_assert(offsetof(DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved, OwningAbility) == 0x000000, "Member 'DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved, TagContainer) == 0x000008, "Member 'DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved::TagContainer' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved, bIsWaitAnyTag) == 0x000028, "Member 'DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved::bIsWaitAnyTag' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved, InOptionalExternalTarget) == 0x000030, "Member 'DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved::InOptionalExternalTarget' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved, bIsOnlyTriggerOnce) == 0x000038, "Member 'DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved::bIsOnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved, bShouldBroadcastImmediately) == 0x000039, "Member 'DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved::bShouldBroadcastImmediately' has a wrong offset!");
static_assert(offsetof(DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved, ReturnValue) == 0x000040, "Member 'DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitInteractableTarget.WaitInteractableTarget
// 0x0020 (0x0020 - 0x0000)
struct DCAT_WaitInteractableTarget_WaitInteractableTarget final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCGATA_LineTraceInteractable*          InTargetActor;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitInteractableTarget*           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitInteractableTarget_WaitInteractableTarget) == 0x000008, "Wrong alignment on DCAT_WaitInteractableTarget_WaitInteractableTarget");
static_assert(sizeof(DCAT_WaitInteractableTarget_WaitInteractableTarget) == 0x000020, "Wrong size on DCAT_WaitInteractableTarget_WaitInteractableTarget");
static_assert(offsetof(DCAT_WaitInteractableTarget_WaitInteractableTarget, OwningAbility) == 0x000000, "Member 'DCAT_WaitInteractableTarget_WaitInteractableTarget::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitInteractableTarget_WaitInteractableTarget, TaskInstanceName) == 0x000008, "Member 'DCAT_WaitInteractableTarget_WaitInteractableTarget::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(DCAT_WaitInteractableTarget_WaitInteractableTarget, InTargetActor) == 0x000010, "Member 'DCAT_WaitInteractableTarget_WaitInteractableTarget::InTargetActor' has a wrong offset!");
static_assert(offsetof(DCAT_WaitInteractableTarget_WaitInteractableTarget, ReturnValue) == 0x000018, "Member 'DCAT_WaitInteractableTarget_WaitInteractableTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitInteractableTarget.OnFoundNewInteractableTarget
// 0x0028 (0x0028 - 0x0000)
struct DCAT_WaitInteractableTarget_OnFoundNewInteractableTarget final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitInteractableTarget_OnFoundNewInteractableTarget) == 0x000008, "Wrong alignment on DCAT_WaitInteractableTarget_OnFoundNewInteractableTarget");
static_assert(sizeof(DCAT_WaitInteractableTarget_OnFoundNewInteractableTarget) == 0x000028, "Wrong size on DCAT_WaitInteractableTarget_OnFoundNewInteractableTarget");
static_assert(offsetof(DCAT_WaitInteractableTarget_OnFoundNewInteractableTarget, Data) == 0x000000, "Member 'DCAT_WaitInteractableTarget_OnFoundNewInteractableTarget::Data' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitInteractableTarget.OnLostInteractableTarget
// 0x0028 (0x0028 - 0x0000)
struct DCAT_WaitInteractableTarget_OnLostInteractableTarget final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitInteractableTarget_OnLostInteractableTarget) == 0x000008, "Wrong alignment on DCAT_WaitInteractableTarget_OnLostInteractableTarget");
static_assert(sizeof(DCAT_WaitInteractableTarget_OnLostInteractableTarget) == 0x000028, "Wrong size on DCAT_WaitInteractableTarget_OnLostInteractableTarget");
static_assert(offsetof(DCAT_WaitInteractableTarget_OnLostInteractableTarget, Data) == 0x000000, "Member 'DCAT_WaitInteractableTarget_OnLostInteractableTarget::Data' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.WaitSocketBlockedStateChange
// 0x0020 (0x0020 - 0x0000)
struct DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TaskInstanceName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCGATA_AimTraceToSocket*               InTargetActor;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitSocketBlockedStateChange*     ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange) == 0x000008, "Wrong alignment on DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange");
static_assert(sizeof(DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange) == 0x000020, "Wrong size on DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange");
static_assert(offsetof(DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange, OwningAbility) == 0x000000, "Member 'DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange, TaskInstanceName) == 0x000008, "Member 'DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange::TaskInstanceName' has a wrong offset!");
static_assert(offsetof(DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange, InTargetActor) == 0x000010, "Member 'DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange::InTargetActor' has a wrong offset!");
static_assert(offsetof(DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange, ReturnValue) == 0x000018, "Member 'DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.OnSocketSightBlocked
// 0x0028 (0x0028 - 0x0000)
struct DCAT_WaitSocketBlockedStateChange_OnSocketSightBlocked final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitSocketBlockedStateChange_OnSocketSightBlocked) == 0x000008, "Wrong alignment on DCAT_WaitSocketBlockedStateChange_OnSocketSightBlocked");
static_assert(sizeof(DCAT_WaitSocketBlockedStateChange_OnSocketSightBlocked) == 0x000028, "Wrong size on DCAT_WaitSocketBlockedStateChange_OnSocketSightBlocked");
static_assert(offsetof(DCAT_WaitSocketBlockedStateChange_OnSocketSightBlocked, Data) == 0x000000, "Member 'DCAT_WaitSocketBlockedStateChange_OnSocketSightBlocked::Data' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.OnSocketSightUnblocked
// 0x0028 (0x0028 - 0x0000)
struct DCAT_WaitSocketBlockedStateChange_OnSocketSightUnblocked final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitSocketBlockedStateChange_OnSocketSightUnblocked) == 0x000008, "Wrong alignment on DCAT_WaitSocketBlockedStateChange_OnSocketSightUnblocked");
static_assert(sizeof(DCAT_WaitSocketBlockedStateChange_OnSocketSightUnblocked) == 0x000028, "Wrong size on DCAT_WaitSocketBlockedStateChange_OnSocketSightUnblocked");
static_assert(offsetof(DCAT_WaitSocketBlockedStateChange_OnSocketSightUnblocked, Data) == 0x000000, "Member 'DCAT_WaitSocketBlockedStateChange_OnSocketSightUnblocked::Data' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitTargetGameplayTagEvent.WaitTargetGameplayTagEvent
// 0x0020 (0x0020 - 0x0000)
struct DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InTargetTag;                                       // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InOptionalExternalTarget;                          // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitTargetGameplayTagEvent*       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent) == 0x000008, "Wrong alignment on DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent");
static_assert(sizeof(DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent) == 0x000020, "Wrong size on DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent");
static_assert(offsetof(DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent, OwningAbility) == 0x000000, "Member 'DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent, InTargetTag) == 0x000008, "Member 'DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent::InTargetTag' has a wrong offset!");
static_assert(offsetof(DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent, InOptionalExternalTarget) == 0x000010, "Member 'DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent::InOptionalExternalTarget' has a wrong offset!");
static_assert(offsetof(DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent, ReturnValue) == 0x000018, "Member 'DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitVelocityZero.WaitVelocityZero
// 0x0010 (0x0010 - 0x0000)
struct DCAT_WaitVelocityZero_WaitVelocityZero final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAT_WaitVelocityZero*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitVelocityZero_WaitVelocityZero) == 0x000008, "Wrong alignment on DCAT_WaitVelocityZero_WaitVelocityZero");
static_assert(sizeof(DCAT_WaitVelocityZero_WaitVelocityZero) == 0x000010, "Wrong size on DCAT_WaitVelocityZero_WaitVelocityZero");
static_assert(offsetof(DCAT_WaitVelocityZero_WaitVelocityZero, OwningAbility) == 0x000000, "Member 'DCAT_WaitVelocityZero_WaitVelocityZero::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitVelocityZero_WaitVelocityZero, ReturnValue) == 0x000008, "Member 'DCAT_WaitVelocityZero_WaitVelocityZero::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCInventoryContainerComponent.OnRep_InventoryList
// 0x0010 (0x0010 - 0x0000)
struct DCInventoryContainerComponent_OnRep_InventoryList final
{
public:
	TArray<class UDCInventoryBase*>               OldInventoryList;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInventoryContainerComponent_OnRep_InventoryList) == 0x000008, "Wrong alignment on DCInventoryContainerComponent_OnRep_InventoryList");
static_assert(sizeof(DCInventoryContainerComponent_OnRep_InventoryList) == 0x000010, "Wrong size on DCInventoryContainerComponent_OnRep_InventoryList");
static_assert(offsetof(DCInventoryContainerComponent_OnRep_InventoryList, OldInventoryList) == 0x000000, "Member 'DCInventoryContainerComponent_OnRep_InventoryList::OldInventoryList' has a wrong offset!");

// Function DungeonCrawler.DCButtonNumberSetterWidget.OnInputTextChanged
// 0x0018 (0x0018 - 0x0000)
struct DCButtonNumberSetterWidget_OnInputTextChanged final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCButtonNumberSetterWidget_OnInputTextChanged) == 0x000008, "Wrong alignment on DCButtonNumberSetterWidget_OnInputTextChanged");
static_assert(sizeof(DCButtonNumberSetterWidget_OnInputTextChanged) == 0x000018, "Wrong size on DCButtonNumberSetterWidget_OnInputTextChanged");
static_assert(offsetof(DCButtonNumberSetterWidget_OnInputTextChanged, InText) == 0x000000, "Member 'DCButtonNumberSetterWidget_OnInputTextChanged::InText' has a wrong offset!");

// Function DungeonCrawler.DCButtonNumberSetterWidget.OnInputTextCommitted
// 0x0020 (0x0020 - 0x0000)
struct DCButtonNumberSetterWidget_OnInputTextCommitted final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   InCommitType;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2599[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCButtonNumberSetterWidget_OnInputTextCommitted) == 0x000008, "Wrong alignment on DCButtonNumberSetterWidget_OnInputTextCommitted");
static_assert(sizeof(DCButtonNumberSetterWidget_OnInputTextCommitted) == 0x000020, "Wrong size on DCButtonNumberSetterWidget_OnInputTextCommitted");
static_assert(offsetof(DCButtonNumberSetterWidget_OnInputTextCommitted, InText) == 0x000000, "Member 'DCButtonNumberSetterWidget_OnInputTextCommitted::InText' has a wrong offset!");
static_assert(offsetof(DCButtonNumberSetterWidget_OnInputTextCommitted, InCommitType) == 0x000018, "Member 'DCButtonNumberSetterWidget_OnInputTextCommitted::InCommitType' has a wrong offset!");

// Function DungeonCrawler.DCCameraPostProcessTimelineData.HandleTimelineUpdate
// 0x0004 (0x0004 - 0x0000)
struct DCCameraPostProcessTimelineData_HandleTimelineUpdate final
{
public:
	float                                         UpdateValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCameraPostProcessTimelineData_HandleTimelineUpdate) == 0x000004, "Wrong alignment on DCCameraPostProcessTimelineData_HandleTimelineUpdate");
static_assert(sizeof(DCCameraPostProcessTimelineData_HandleTimelineUpdate) == 0x000004, "Wrong size on DCCameraPostProcessTimelineData_HandleTimelineUpdate");
static_assert(offsetof(DCCameraPostProcessTimelineData_HandleTimelineUpdate, UpdateValue) == 0x000000, "Member 'DCCameraPostProcessTimelineData_HandleTimelineUpdate::UpdateValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.CalculateProjectileHitNiagaraTransform
// 0x0150 (0x0150 - 0x0000)
struct DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform final
{
public:
	const class UObject*                          InSourceObject;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             InHitResult;                                       // 0x0008(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FTransform                             ReturnValue;                                       // 0x00F0(0x0060)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform) == 0x000010, "Wrong alignment on DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform");
static_assert(sizeof(DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform) == 0x000150, "Wrong size on DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform, InSourceObject) == 0x000000, "Member 'DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform::InSourceObject' has a wrong offset!");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform, InHitResult) == 0x000008, "Member 'DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform::InHitResult' has a wrong offset!");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform, ReturnValue) == 0x0000F0, "Member 'DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.GetProjectileDefaultNiagaraSystem
// 0x0010 (0x0010 - 0x0000)
struct DCGameplayCueBlueprintLibrary_GetProjectileDefaultNiagaraSystem final
{
public:
	const class UObject*                          InSourceObject;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayCueBlueprintLibrary_GetProjectileDefaultNiagaraSystem) == 0x000008, "Wrong alignment on DCGameplayCueBlueprintLibrary_GetProjectileDefaultNiagaraSystem");
static_assert(sizeof(DCGameplayCueBlueprintLibrary_GetProjectileDefaultNiagaraSystem) == 0x000010, "Wrong size on DCGameplayCueBlueprintLibrary_GetProjectileDefaultNiagaraSystem");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_GetProjectileDefaultNiagaraSystem, InSourceObject) == 0x000000, "Member 'DCGameplayCueBlueprintLibrary_GetProjectileDefaultNiagaraSystem::InSourceObject' has a wrong offset!");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_GetProjectileDefaultNiagaraSystem, ReturnValue) == 0x000008, "Member 'DCGameplayCueBlueprintLibrary_GetProjectileDefaultNiagaraSystem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.GetProjectileHitCharacterNiagaraSystem
// 0x0010 (0x0010 - 0x0000)
struct DCGameplayCueBlueprintLibrary_GetProjectileHitCharacterNiagaraSystem final
{
public:
	const class UObject*                          InSourceObject;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayCueBlueprintLibrary_GetProjectileHitCharacterNiagaraSystem) == 0x000008, "Wrong alignment on DCGameplayCueBlueprintLibrary_GetProjectileHitCharacterNiagaraSystem");
static_assert(sizeof(DCGameplayCueBlueprintLibrary_GetProjectileHitCharacterNiagaraSystem) == 0x000010, "Wrong size on DCGameplayCueBlueprintLibrary_GetProjectileHitCharacterNiagaraSystem");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_GetProjectileHitCharacterNiagaraSystem, InSourceObject) == 0x000000, "Member 'DCGameplayCueBlueprintLibrary_GetProjectileHitCharacterNiagaraSystem::InSourceObject' has a wrong offset!");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_GetProjectileHitCharacterNiagaraSystem, ReturnValue) == 0x000008, "Member 'DCGameplayCueBlueprintLibrary_GetProjectileHitCharacterNiagaraSystem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.GetProjectileHitNiagaraSystemScale
// 0x0010 (0x0010 - 0x0000)
struct DCGameplayCueBlueprintLibrary_GetProjectileHitNiagaraSystemScale final
{
public:
	const class UObject*                          InSourceObject;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259B[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGameplayCueBlueprintLibrary_GetProjectileHitNiagaraSystemScale) == 0x000008, "Wrong alignment on DCGameplayCueBlueprintLibrary_GetProjectileHitNiagaraSystemScale");
static_assert(sizeof(DCGameplayCueBlueprintLibrary_GetProjectileHitNiagaraSystemScale) == 0x000010, "Wrong size on DCGameplayCueBlueprintLibrary_GetProjectileHitNiagaraSystemScale");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_GetProjectileHitNiagaraSystemScale, InSourceObject) == 0x000000, "Member 'DCGameplayCueBlueprintLibrary_GetProjectileHitNiagaraSystemScale::InSourceObject' has a wrong offset!");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_GetProjectileHitNiagaraSystemScale, ReturnValue) == 0x000008, "Member 'DCGameplayCueBlueprintLibrary_GetProjectileHitNiagaraSystemScale::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.GetProjectileHitObjectNiagaraSystem
// 0x0010 (0x0010 - 0x0000)
struct DCGameplayCueBlueprintLibrary_GetProjectileHitObjectNiagaraSystem final
{
public:
	const class UObject*                          InSourceObject;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayCueBlueprintLibrary_GetProjectileHitObjectNiagaraSystem) == 0x000008, "Wrong alignment on DCGameplayCueBlueprintLibrary_GetProjectileHitObjectNiagaraSystem");
static_assert(sizeof(DCGameplayCueBlueprintLibrary_GetProjectileHitObjectNiagaraSystem) == 0x000010, "Wrong size on DCGameplayCueBlueprintLibrary_GetProjectileHitObjectNiagaraSystem");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_GetProjectileHitObjectNiagaraSystem, InSourceObject) == 0x000000, "Member 'DCGameplayCueBlueprintLibrary_GetProjectileHitObjectNiagaraSystem::InSourceObject' has a wrong offset!");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_GetProjectileHitObjectNiagaraSystem, ReturnValue) == 0x000008, "Member 'DCGameplayCueBlueprintLibrary_GetProjectileHitObjectNiagaraSystem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.GetProjectileHitShieldNiagaraSystem
// 0x0010 (0x0010 - 0x0000)
struct DCGameplayCueBlueprintLibrary_GetProjectileHitShieldNiagaraSystem final
{
public:
	const class UObject*                          InSourceObject;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayCueBlueprintLibrary_GetProjectileHitShieldNiagaraSystem) == 0x000008, "Wrong alignment on DCGameplayCueBlueprintLibrary_GetProjectileHitShieldNiagaraSystem");
static_assert(sizeof(DCGameplayCueBlueprintLibrary_GetProjectileHitShieldNiagaraSystem) == 0x000010, "Wrong size on DCGameplayCueBlueprintLibrary_GetProjectileHitShieldNiagaraSystem");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_GetProjectileHitShieldNiagaraSystem, InSourceObject) == 0x000000, "Member 'DCGameplayCueBlueprintLibrary_GetProjectileHitShieldNiagaraSystem::InSourceObject' has a wrong offset!");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_GetProjectileHitShieldNiagaraSystem, ReturnValue) == 0x000008, "Member 'DCGameplayCueBlueprintLibrary_GetProjectileHitShieldNiagaraSystem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.PlayHitDirectionWidget
// 0x0010 (0x0010 - 0x0000)
struct DCGameplayCueBlueprintLibrary_PlayHitDirectionWidget final
{
public:
	class AActor*                                 InHitActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           InInstigator;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayCueBlueprintLibrary_PlayHitDirectionWidget) == 0x000008, "Wrong alignment on DCGameplayCueBlueprintLibrary_PlayHitDirectionWidget");
static_assert(sizeof(DCGameplayCueBlueprintLibrary_PlayHitDirectionWidget) == 0x000010, "Wrong size on DCGameplayCueBlueprintLibrary_PlayHitDirectionWidget");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_PlayHitDirectionWidget, InHitActor) == 0x000000, "Member 'DCGameplayCueBlueprintLibrary_PlayHitDirectionWidget::InHitActor' has a wrong offset!");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_PlayHitDirectionWidget, InInstigator) == 0x000008, "Member 'DCGameplayCueBlueprintLibrary_PlayHitDirectionWidget::InInstigator' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.PlayHitDirectionWidgetWithParams
// 0x00D8 (0x00D8 - 0x0000)
struct DCGameplayCueBlueprintLibrary_PlayHitDirectionWidgetWithParams final
{
public:
	struct FGameplayCueParameters                 InCueParams;                                       // 0x0000(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayCueBlueprintLibrary_PlayHitDirectionWidgetWithParams) == 0x000008, "Wrong alignment on DCGameplayCueBlueprintLibrary_PlayHitDirectionWidgetWithParams");
static_assert(sizeof(DCGameplayCueBlueprintLibrary_PlayHitDirectionWidgetWithParams) == 0x0000D8, "Wrong size on DCGameplayCueBlueprintLibrary_PlayHitDirectionWidgetWithParams");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_PlayHitDirectionWidgetWithParams, InCueParams) == 0x000000, "Member 'DCGameplayCueBlueprintLibrary_PlayHitDirectionWidgetWithParams::InCueParams' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.PlayHitReactionAnimation
// 0x0010 (0x0010 - 0x0000)
struct DCGameplayCueBlueprintLibrary_PlayHitReactionAnimation final
{
public:
	class AActor*                                 InHitActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           InInstigator;                                      // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayCueBlueprintLibrary_PlayHitReactionAnimation) == 0x000008, "Wrong alignment on DCGameplayCueBlueprintLibrary_PlayHitReactionAnimation");
static_assert(sizeof(DCGameplayCueBlueprintLibrary_PlayHitReactionAnimation) == 0x000010, "Wrong size on DCGameplayCueBlueprintLibrary_PlayHitReactionAnimation");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_PlayHitReactionAnimation, InHitActor) == 0x000000, "Member 'DCGameplayCueBlueprintLibrary_PlayHitReactionAnimation::InHitActor' has a wrong offset!");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_PlayHitReactionAnimation, InInstigator) == 0x000008, "Member 'DCGameplayCueBlueprintLibrary_PlayHitReactionAnimation::InInstigator' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.PlayHitReactionAnimationWithParams
// 0x00D8 (0x00D8 - 0x0000)
struct DCGameplayCueBlueprintLibrary_PlayHitReactionAnimationWithParams final
{
public:
	struct FGameplayCueParameters                 InCueParams;                                       // 0x0000(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayCueBlueprintLibrary_PlayHitReactionAnimationWithParams) == 0x000008, "Wrong alignment on DCGameplayCueBlueprintLibrary_PlayHitReactionAnimationWithParams");
static_assert(sizeof(DCGameplayCueBlueprintLibrary_PlayHitReactionAnimationWithParams) == 0x0000D8, "Wrong size on DCGameplayCueBlueprintLibrary_PlayHitReactionAnimationWithParams");
static_assert(offsetof(DCGameplayCueBlueprintLibrary_PlayHitReactionAnimationWithParams, InCueParams) == 0x000000, "Member 'DCGameplayCueBlueprintLibrary_PlayHitReactionAnimationWithParams::InCueParams' has a wrong offset!");

// Function DungeonCrawler.VoipUserWidget.OnAccountId
// 0x0020 (0x0020 - 0x0000)
struct VoipUserWidget_OnAccountId final
{
public:
	struct FDCAccountId                           NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCAccountId                           OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipUserWidget_OnAccountId) == 0x000008, "Wrong alignment on VoipUserWidget_OnAccountId");
static_assert(sizeof(VoipUserWidget_OnAccountId) == 0x000020, "Wrong size on VoipUserWidget_OnAccountId");
static_assert(offsetof(VoipUserWidget_OnAccountId, NewValue) == 0x000000, "Member 'VoipUserWidget_OnAccountId::NewValue' has a wrong offset!");
static_assert(offsetof(VoipUserWidget_OnAccountId, OldValue) == 0x000010, "Member 'VoipUserWidget_OnAccountId::OldValue' has a wrong offset!");

// Function DungeonCrawler.VoipUserWidget.OnbVoipForceParty
// 0x0002 (0x0002 - 0x0000)
struct VoipUserWidget_OnbVoipForceParty final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipUserWidget_OnbVoipForceParty) == 0x000001, "Wrong alignment on VoipUserWidget_OnbVoipForceParty");
static_assert(sizeof(VoipUserWidget_OnbVoipForceParty) == 0x000002, "Wrong size on VoipUserWidget_OnbVoipForceParty");
static_assert(offsetof(VoipUserWidget_OnbVoipForceParty, NewValue) == 0x000000, "Member 'VoipUserWidget_OnbVoipForceParty::NewValue' has a wrong offset!");
static_assert(offsetof(VoipUserWidget_OnbVoipForceParty, OldValue) == 0x000001, "Member 'VoipUserWidget_OnbVoipForceParty::OldValue' has a wrong offset!");

// Function DungeonCrawler.VoipUserWidget.OnVoipPartyData
// 0x0040 (0x0040 - 0x0000)
struct VoipUserWidget_OnVoipPartyData final
{
public:
	struct FVoipPartyData                         NewValue;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVoipPartyData                         OldValue;                                          // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipUserWidget_OnVoipPartyData) == 0x000008, "Wrong alignment on VoipUserWidget_OnVoipPartyData");
static_assert(sizeof(VoipUserWidget_OnVoipPartyData) == 0x000040, "Wrong size on VoipUserWidget_OnVoipPartyData");
static_assert(offsetof(VoipUserWidget_OnVoipPartyData, NewValue) == 0x000000, "Member 'VoipUserWidget_OnVoipPartyData::NewValue' has a wrong offset!");
static_assert(offsetof(VoipUserWidget_OnVoipPartyData, OldValue) == 0x000020, "Member 'VoipUserWidget_OnVoipPartyData::OldValue' has a wrong offset!");

// Function DungeonCrawler.VoipUserWidget.OnVoipUserData
// 0x0010 (0x0010 - 0x0000)
struct VoipUserWidget_OnVoipUserData final
{
public:
	struct FVoipUserData                          NewValue;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVoipUserData                          OldValue;                                          // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipUserWidget_OnVoipUserData) == 0x000004, "Wrong alignment on VoipUserWidget_OnVoipUserData");
static_assert(sizeof(VoipUserWidget_OnVoipUserData) == 0x000010, "Wrong size on VoipUserWidget_OnVoipUserData");
static_assert(offsetof(VoipUserWidget_OnVoipUserData, NewValue) == 0x000000, "Member 'VoipUserWidget_OnVoipUserData::NewValue' has a wrong offset!");
static_assert(offsetof(VoipUserWidget_OnVoipUserData, OldValue) == 0x000008, "Member 'VoipUserWidget_OnVoipUserData::OldValue' has a wrong offset!");

// Function DungeonCrawler.VoipUserWidget.OnVoipVolumeChanged
// 0x0004 (0x0004 - 0x0000)
struct VoipUserWidget_OnVoipVolumeChanged final
{
public:
	float                                         InVoipVolume;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipUserWidget_OnVoipVolumeChanged) == 0x000004, "Wrong alignment on VoipUserWidget_OnVoipVolumeChanged");
static_assert(sizeof(VoipUserWidget_OnVoipVolumeChanged) == 0x000004, "Wrong size on VoipUserWidget_OnVoipVolumeChanged");
static_assert(offsetof(VoipUserWidget_OnVoipVolumeChanged, InVoipVolume) == 0x000000, "Member 'VoipUserWidget_OnVoipVolumeChanged::InVoipVolume' has a wrong offset!");

// Function DungeonCrawler.VoipUserWidget.SetAccountId
// 0x0010 (0x0010 - 0x0000)
struct VoipUserWidget_SetAccountId final
{
public:
	struct FDCAccountId                           InAccountId;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipUserWidget_SetAccountId) == 0x000008, "Wrong alignment on VoipUserWidget_SetAccountId");
static_assert(sizeof(VoipUserWidget_SetAccountId) == 0x000010, "Wrong size on VoipUserWidget_SetAccountId");
static_assert(offsetof(VoipUserWidget_SetAccountId, InAccountId) == 0x000000, "Member 'VoipUserWidget_SetAccountId::InAccountId' has a wrong offset!");

// Function DungeonCrawler.VoipUserWidget.SetVoipForceParty
// 0x0001 (0x0001 - 0x0000)
struct VoipUserWidget_SetVoipForceParty final
{
public:
	bool                                          bInVoipForceParty;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipUserWidget_SetVoipForceParty) == 0x000001, "Wrong alignment on VoipUserWidget_SetVoipForceParty");
static_assert(sizeof(VoipUserWidget_SetVoipForceParty) == 0x000001, "Wrong size on VoipUserWidget_SetVoipForceParty");
static_assert(offsetof(VoipUserWidget_SetVoipForceParty, bInVoipForceParty) == 0x000000, "Member 'VoipUserWidget_SetVoipForceParty::bInVoipForceParty' has a wrong offset!");

// Function DungeonCrawler.VoipUserWidget.SetVoipPartyData
// 0x0020 (0x0020 - 0x0000)
struct VoipUserWidget_SetVoipPartyData final
{
public:
	struct FVoipPartyData                         InVoipPartyData;                                   // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipUserWidget_SetVoipPartyData) == 0x000008, "Wrong alignment on VoipUserWidget_SetVoipPartyData");
static_assert(sizeof(VoipUserWidget_SetVoipPartyData) == 0x000020, "Wrong size on VoipUserWidget_SetVoipPartyData");
static_assert(offsetof(VoipUserWidget_SetVoipPartyData, InVoipPartyData) == 0x000000, "Member 'VoipUserWidget_SetVoipPartyData::InVoipPartyData' has a wrong offset!");

// Function DungeonCrawler.VoipUserWidget.SetVoipUserData
// 0x0008 (0x0008 - 0x0000)
struct VoipUserWidget_SetVoipUserData final
{
public:
	struct FVoipUserData                          InVoipUserData;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipUserWidget_SetVoipUserData) == 0x000004, "Wrong alignment on VoipUserWidget_SetVoipUserData");
static_assert(sizeof(VoipUserWidget_SetVoipUserData) == 0x000008, "Wrong size on VoipUserWidget_SetVoipUserData");
static_assert(offsetof(VoipUserWidget_SetVoipUserData, InVoipUserData) == 0x000000, "Member 'VoipUserWidget_SetVoipUserData::InVoipUserData' has a wrong offset!");

// Function DungeonCrawler.DCInteractTargetInterface.InteractTargetInfoName
// 0x0018 (0x0018 - 0x0000)
struct DCInteractTargetInterface_InteractTargetInfoName final
{
public:
	class FText                                   Param_Name;                                        // 0x0000(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInteractTargetInterface_InteractTargetInfoName) == 0x000008, "Wrong alignment on DCInteractTargetInterface_InteractTargetInfoName");
static_assert(sizeof(DCInteractTargetInterface_InteractTargetInfoName) == 0x000018, "Wrong size on DCInteractTargetInterface_InteractTargetInfoName");
static_assert(offsetof(DCInteractTargetInterface_InteractTargetInfoName, Param_Name) == 0x000000, "Member 'DCInteractTargetInterface_InteractTargetInfoName::Param_Name' has a wrong offset!");

// Function DungeonCrawler.DCInteractTargetInterface.InteractTargetInfoRarity
// 0x0008 (0x0008 - 0x0000)
struct DCInteractTargetInterface_InteractTargetInfoRarity final
{
public:
	struct FGameplayTag                           RarityTag;                                         // 0x0000(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInteractTargetInterface_InteractTargetInfoRarity) == 0x000004, "Wrong alignment on DCInteractTargetInterface_InteractTargetInfoRarity");
static_assert(sizeof(DCInteractTargetInterface_InteractTargetInfoRarity) == 0x000008, "Wrong size on DCInteractTargetInterface_InteractTargetInfoRarity");
static_assert(offsetof(DCInteractTargetInterface_InteractTargetInfoRarity, RarityTag) == 0x000000, "Member 'DCInteractTargetInterface_InteractTargetInfoRarity::RarityTag' has a wrong offset!");

// Function DungeonCrawler.DCChannelPlayerListWidget.OnSearchTextChanged
// 0x0018 (0x0018 - 0x0000)
struct DCChannelPlayerListWidget_OnSearchTextChanged final
{
public:
	class FText                                   Keyword;                                           // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCChannelPlayerListWidget_OnSearchTextChanged) == 0x000008, "Wrong alignment on DCChannelPlayerListWidget_OnSearchTextChanged");
static_assert(sizeof(DCChannelPlayerListWidget_OnSearchTextChanged) == 0x000018, "Wrong size on DCChannelPlayerListWidget_OnSearchTextChanged");
static_assert(offsetof(DCChannelPlayerListWidget_OnSearchTextChanged, Keyword) == 0x000000, "Member 'DCChannelPlayerListWidget_OnSearchTextChanged::Keyword' has a wrong offset!");

// Function DungeonCrawler.DCGameplayCueNotify_Actor.SetAkComponentRTPCValue
// 0x0020 (0x0020 - 0x0000)
struct DCGameplayCueNotify_Actor_SetAkComponentRTPCValue final
{
public:
	class UAkComponent*                           AkComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAkRtpc*                          RtpcValue;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTickValue;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTotalValue;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InMaxRTPCValue;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25A2[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGameplayCueNotify_Actor_SetAkComponentRTPCValue) == 0x000008, "Wrong alignment on DCGameplayCueNotify_Actor_SetAkComponentRTPCValue");
static_assert(sizeof(DCGameplayCueNotify_Actor_SetAkComponentRTPCValue) == 0x000020, "Wrong size on DCGameplayCueNotify_Actor_SetAkComponentRTPCValue");
static_assert(offsetof(DCGameplayCueNotify_Actor_SetAkComponentRTPCValue, AkComponent) == 0x000000, "Member 'DCGameplayCueNotify_Actor_SetAkComponentRTPCValue::AkComponent' has a wrong offset!");
static_assert(offsetof(DCGameplayCueNotify_Actor_SetAkComponentRTPCValue, RtpcValue) == 0x000008, "Member 'DCGameplayCueNotify_Actor_SetAkComponentRTPCValue::RtpcValue' has a wrong offset!");
static_assert(offsetof(DCGameplayCueNotify_Actor_SetAkComponentRTPCValue, InTickValue) == 0x000010, "Member 'DCGameplayCueNotify_Actor_SetAkComponentRTPCValue::InTickValue' has a wrong offset!");
static_assert(offsetof(DCGameplayCueNotify_Actor_SetAkComponentRTPCValue, InTotalValue) == 0x000014, "Member 'DCGameplayCueNotify_Actor_SetAkComponentRTPCValue::InTotalValue' has a wrong offset!");
static_assert(offsetof(DCGameplayCueNotify_Actor_SetAkComponentRTPCValue, InMaxRTPCValue) == 0x000018, "Member 'DCGameplayCueNotify_Actor_SetAkComponentRTPCValue::InMaxRTPCValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterInfoWidget.SetLevelAndFame
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterInfoWidget_SetLevelAndFame final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Fame;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterInfoWidget_SetLevelAndFame) == 0x000004, "Wrong alignment on DCCharacterInfoWidget_SetLevelAndFame");
static_assert(sizeof(DCCharacterInfoWidget_SetLevelAndFame) == 0x000008, "Wrong size on DCCharacterInfoWidget_SetLevelAndFame");
static_assert(offsetof(DCCharacterInfoWidget_SetLevelAndFame, Level) == 0x000000, "Member 'DCCharacterInfoWidget_SetLevelAndFame::Level' has a wrong offset!");
static_assert(offsetof(DCCharacterInfoWidget_SetLevelAndFame, Fame) == 0x000004, "Member 'DCCharacterInfoWidget_SetLevelAndFame::Fame' has a wrong offset!");

// Function DungeonCrawler.DCCharacterV2.GetPartHeadComponent
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterV2_GetPartHeadComponent final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterV2_GetPartHeadComponent) == 0x000008, "Wrong alignment on DCCharacterV2_GetPartHeadComponent");
static_assert(sizeof(DCCharacterV2_GetPartHeadComponent) == 0x000008, "Wrong size on DCCharacterV2_GetPartHeadComponent");
static_assert(offsetof(DCCharacterV2_GetPartHeadComponent, ReturnValue) == 0x000000, "Member 'DCCharacterV2_GetPartHeadComponent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterV2.GetPerkDataComponent
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterV2_GetPerkDataComponent final
{
public:
	class UDCPerkDataComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterV2_GetPerkDataComponent) == 0x000008, "Wrong alignment on DCCharacterV2_GetPerkDataComponent");
static_assert(sizeof(DCCharacterV2_GetPerkDataComponent) == 0x000008, "Wrong size on DCCharacterV2_GetPerkDataComponent");
static_assert(offsetof(DCCharacterV2_GetPerkDataComponent, ReturnValue) == 0x000000, "Member 'DCCharacterV2_GetPerkDataComponent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterV2.OnRep_AccountId
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerCharacterV2_OnRep_AccountId final
{
public:
	struct FDCAccountId                           OldAccountId;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterV2_OnRep_AccountId) == 0x000008, "Wrong alignment on DCPlayerCharacterV2_OnRep_AccountId");
static_assert(sizeof(DCPlayerCharacterV2_OnRep_AccountId) == 0x000010, "Wrong size on DCPlayerCharacterV2_OnRep_AccountId");
static_assert(offsetof(DCPlayerCharacterV2_OnRep_AccountId, OldAccountId) == 0x000000, "Member 'DCPlayerCharacterV2_OnRep_AccountId::OldAccountId' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterV2.OnRep_PartyId
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerCharacterV2_OnRep_PartyId final
{
public:
	struct FDCPartyId                             OldPartyId;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterV2_OnRep_PartyId) == 0x000008, "Wrong alignment on DCPlayerCharacterV2_OnRep_PartyId");
static_assert(sizeof(DCPlayerCharacterV2_OnRep_PartyId) == 0x000010, "Wrong size on DCPlayerCharacterV2_OnRep_PartyId");
static_assert(offsetof(DCPlayerCharacterV2_OnRep_PartyId, OldPartyId) == 0x000000, "Member 'DCPlayerCharacterV2_OnRep_PartyId::OldPartyId' has a wrong offset!");

// Function DungeonCrawler.DCCharacterLobbyCapture.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCCharacterLobbyCapture_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterLobbyCapture_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCCharacterLobbyCapture_BroadcastMsgBlueprint");
static_assert(sizeof(DCCharacterLobbyCapture_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCCharacterLobbyCapture_BroadcastMsgBlueprint");
static_assert(offsetof(DCCharacterLobbyCapture_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCCharacterLobbyCapture_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCCharacterLobbyCapture.GetNickname
// 0x0040 (0x0040 - 0x0000)
struct DCCharacterLobbyCapture_GetNickname final
{
public:
	struct FNickname                              ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterLobbyCapture_GetNickname) == 0x000008, "Wrong alignment on DCCharacterLobbyCapture_GetNickname");
static_assert(sizeof(DCCharacterLobbyCapture_GetNickname) == 0x000040, "Wrong size on DCCharacterLobbyCapture_GetNickname");
static_assert(offsetof(DCCharacterLobbyCapture_GetNickname, ReturnValue) == 0x000000, "Member 'DCCharacterLobbyCapture_GetNickname::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterLobbyCapture.OnLobbyPoseSkinChanged
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterLobbyCapture_OnLobbyPoseSkinChanged final
{
public:
	const class UDCActionSkinDataAsset*           ActionSkinData;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquipped;                                       // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B0[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCCharacterLobbyCapture_OnLobbyPoseSkinChanged) == 0x000008, "Wrong alignment on DCCharacterLobbyCapture_OnLobbyPoseSkinChanged");
static_assert(sizeof(DCCharacterLobbyCapture_OnLobbyPoseSkinChanged) == 0x000010, "Wrong size on DCCharacterLobbyCapture_OnLobbyPoseSkinChanged");
static_assert(offsetof(DCCharacterLobbyCapture_OnLobbyPoseSkinChanged, ActionSkinData) == 0x000000, "Member 'DCCharacterLobbyCapture_OnLobbyPoseSkinChanged::ActionSkinData' has a wrong offset!");
static_assert(offsetof(DCCharacterLobbyCapture_OnLobbyPoseSkinChanged, bIsEquipped) == 0x000008, "Member 'DCCharacterLobbyCapture_OnLobbyPoseSkinChanged::bIsEquipped' has a wrong offset!");

// Function DungeonCrawler.DCCharacterLobbyCapture.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterLobbyCapture_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterLobbyCapture_UnbindMsg) == 0x000008, "Wrong alignment on DCCharacterLobbyCapture_UnbindMsg");
static_assert(sizeof(DCCharacterLobbyCapture_UnbindMsg) == 0x000010, "Wrong size on DCCharacterLobbyCapture_UnbindMsg");
static_assert(offsetof(DCCharacterLobbyCapture_UnbindMsg, InMsgType) == 0x000000, "Member 'DCCharacterLobbyCapture_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCCharacterLobbyCapture_UnbindMsg, InObject) == 0x000008, "Member 'DCCharacterLobbyCapture_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCCharacterLobbyCapture.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterLobbyCapture_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterLobbyCapture_UnbindMsgAll) == 0x000008, "Wrong alignment on DCCharacterLobbyCapture_UnbindMsgAll");
static_assert(sizeof(DCCharacterLobbyCapture_UnbindMsgAll) == 0x000008, "Wrong size on DCCharacterLobbyCapture_UnbindMsgAll");
static_assert(offsetof(DCCharacterLobbyCapture_UnbindMsgAll, InObject) == 0x000000, "Member 'DCCharacterLobbyCapture_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCCharacterLobbyCapture.GetPartyLocation
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterLobbyCapture_GetPartyLocation final
{
public:
	EWidgetPartyUserLocate                        ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterLobbyCapture_GetPartyLocation) == 0x000001, "Wrong alignment on DCCharacterLobbyCapture_GetPartyLocation");
static_assert(sizeof(DCCharacterLobbyCapture_GetPartyLocation) == 0x000001, "Wrong size on DCCharacterLobbyCapture_GetPartyLocation");
static_assert(offsetof(DCCharacterLobbyCapture_GetPartyLocation, ReturnValue) == 0x000000, "Member 'DCCharacterLobbyCapture_GetPartyLocation::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftCastBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftCastBase_EventReceived) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftCastBase_EventReceived");
static_assert(sizeof(GA_PlayerShapeShiftCastBase_EventReceived) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftCastBase_EventReceived");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_EventReceived, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftCastBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_EventReceived, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftCastBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnBlendOut
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftCastBase_OnBlendOut final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftCastBase_OnBlendOut) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftCastBase_OnBlendOut");
static_assert(sizeof(GA_PlayerShapeShiftCastBase_OnBlendOut) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftCastBase_OnBlendOut");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_OnBlendOut, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftCastBase_OnBlendOut::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_OnBlendOut, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftCastBase_OnBlendOut::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftCastBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftCastBase_OnCancelled) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftCastBase_OnCancelled");
static_assert(sizeof(GA_PlayerShapeShiftCastBase_OnCancelled) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftCastBase_OnCancelled");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftCastBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_OnCancelled, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftCastBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftCastBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftCastBase_OnCompleted) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftCastBase_OnCompleted");
static_assert(sizeof(GA_PlayerShapeShiftCastBase_OnCompleted) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftCastBase_OnCompleted");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftCastBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_OnCompleted, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftCastBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnInterrupted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftCastBase_OnInterrupted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftCastBase_OnInterrupted) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftCastBase_OnInterrupted");
static_assert(sizeof(GA_PlayerShapeShiftCastBase_OnInterrupted) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftCastBase_OnInterrupted");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_OnInterrupted, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftCastBase_OnInterrupted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_OnInterrupted, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftCastBase_OnInterrupted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.SendActivateShapeShiftCrossHairNotify
// 0x0001 (0x0001 - 0x0000)
struct GA_PlayerShapeShiftCastBase_SendActivateShapeShiftCrossHairNotify final
{
public:
	bool                                          IsActivate;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftCastBase_SendActivateShapeShiftCrossHairNotify) == 0x000001, "Wrong alignment on GA_PlayerShapeShiftCastBase_SendActivateShapeShiftCrossHairNotify");
static_assert(sizeof(GA_PlayerShapeShiftCastBase_SendActivateShapeShiftCrossHairNotify) == 0x000001, "Wrong size on GA_PlayerShapeShiftCastBase_SendActivateShapeShiftCrossHairNotify");
static_assert(offsetof(GA_PlayerShapeShiftCastBase_SendActivateShapeShiftCrossHairNotify, IsActivate) == 0x000000, "Member 'GA_PlayerShapeShiftCastBase_SendActivateShapeShiftCrossHairNotify::IsActivate' has a wrong offset!");

// Function DungeonCrawler.DCCharacterMovementComponent.AddMovementModifier
// 0x0018 (0x0018 - 0x0000)
struct DCCharacterMovementComponent_AddMovementModifier final
{
public:
	struct FDesignDataMovementModifier            MovementModifier;                                  // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterMovementComponent_AddMovementModifier) == 0x000004, "Wrong alignment on DCCharacterMovementComponent_AddMovementModifier");
static_assert(sizeof(DCCharacterMovementComponent_AddMovementModifier) == 0x000018, "Wrong size on DCCharacterMovementComponent_AddMovementModifier");
static_assert(offsetof(DCCharacterMovementComponent_AddMovementModifier, MovementModifier) == 0x000000, "Member 'DCCharacterMovementComponent_AddMovementModifier::MovementModifier' has a wrong offset!");

// Function DungeonCrawler.DCCharacterMovementComponent.AddMovementModifiers
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterMovementComponent_AddMovementModifiers final
{
public:
	TArray<struct FDesignDataMovementModifier>    MovementModifiers;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterMovementComponent_AddMovementModifiers) == 0x000008, "Wrong alignment on DCCharacterMovementComponent_AddMovementModifiers");
static_assert(sizeof(DCCharacterMovementComponent_AddMovementModifiers) == 0x000010, "Wrong size on DCCharacterMovementComponent_AddMovementModifiers");
static_assert(offsetof(DCCharacterMovementComponent_AddMovementModifiers, MovementModifiers) == 0x000000, "Member 'DCCharacterMovementComponent_AddMovementModifiers::MovementModifiers' has a wrong offset!");

// Function DungeonCrawler.DCCharacterMovementComponent.IsInputProcessing
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterMovementComponent_IsInputProcessing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterMovementComponent_IsInputProcessing) == 0x000001, "Wrong alignment on DCCharacterMovementComponent_IsInputProcessing");
static_assert(sizeof(DCCharacterMovementComponent_IsInputProcessing) == 0x000001, "Wrong size on DCCharacterMovementComponent_IsInputProcessing");
static_assert(offsetof(DCCharacterMovementComponent_IsInputProcessing, ReturnValue) == 0x000000, "Member 'DCCharacterMovementComponent_IsInputProcessing::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterMovementComponent.RemoveMovementModifier
// 0x0018 (0x0018 - 0x0000)
struct DCCharacterMovementComponent_RemoveMovementModifier final
{
public:
	struct FDesignDataMovementModifier            MovementModifier;                                  // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterMovementComponent_RemoveMovementModifier) == 0x000004, "Wrong alignment on DCCharacterMovementComponent_RemoveMovementModifier");
static_assert(sizeof(DCCharacterMovementComponent_RemoveMovementModifier) == 0x000018, "Wrong size on DCCharacterMovementComponent_RemoveMovementModifier");
static_assert(offsetof(DCCharacterMovementComponent_RemoveMovementModifier, MovementModifier) == 0x000000, "Member 'DCCharacterMovementComponent_RemoveMovementModifier::MovementModifier' has a wrong offset!");

// Function DungeonCrawler.DCCharacterMovementComponent.RemoveMovementModifiers
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterMovementComponent_RemoveMovementModifiers final
{
public:
	TArray<struct FDesignDataMovementModifier>    MovementModifiers;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterMovementComponent_RemoveMovementModifiers) == 0x000008, "Wrong alignment on DCCharacterMovementComponent_RemoveMovementModifiers");
static_assert(sizeof(DCCharacterMovementComponent_RemoveMovementModifiers) == 0x000010, "Wrong size on DCCharacterMovementComponent_RemoveMovementModifiers");
static_assert(offsetof(DCCharacterMovementComponent_RemoveMovementModifiers, MovementModifiers) == 0x000000, "Member 'DCCharacterMovementComponent_RemoveMovementModifiers::MovementModifiers' has a wrong offset!");

// Function DungeonCrawler.DCCharacterMovementComponent.SetInputProcessing
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterMovementComponent_SetInputProcessing final
{
public:
	bool                                          bSet;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterMovementComponent_SetInputProcessing) == 0x000001, "Wrong alignment on DCCharacterMovementComponent_SetInputProcessing");
static_assert(sizeof(DCCharacterMovementComponent_SetInputProcessing) == 0x000001, "Wrong size on DCCharacterMovementComponent_SetInputProcessing");
static_assert(offsetof(DCCharacterMovementComponent_SetInputProcessing, bSet) == 0x000000, "Member 'DCCharacterMovementComponent_SetInputProcessing::bSet' has a wrong offset!");

// Function DungeonCrawler.DCCharacterMovementComponent.SetIsTrapped
// 0x0028 (0x0028 - 0x0000)
struct DCCharacterMovementComponent_SetIsTrapped final
{
public:
	bool                                          InbIsTrapped;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25B9[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InTrapPinnedLocation;                              // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTrapRange;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25BA[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCCharacterMovementComponent_SetIsTrapped) == 0x000008, "Wrong alignment on DCCharacterMovementComponent_SetIsTrapped");
static_assert(sizeof(DCCharacterMovementComponent_SetIsTrapped) == 0x000028, "Wrong size on DCCharacterMovementComponent_SetIsTrapped");
static_assert(offsetof(DCCharacterMovementComponent_SetIsTrapped, InbIsTrapped) == 0x000000, "Member 'DCCharacterMovementComponent_SetIsTrapped::InbIsTrapped' has a wrong offset!");
static_assert(offsetof(DCCharacterMovementComponent_SetIsTrapped, InTrapPinnedLocation) == 0x000008, "Member 'DCCharacterMovementComponent_SetIsTrapped::InTrapPinnedLocation' has a wrong offset!");
static_assert(offsetof(DCCharacterMovementComponent_SetIsTrapped, InTrapRange) == 0x000020, "Member 'DCCharacterMovementComponent_SetIsTrapped::InTrapRange' has a wrong offset!");

// Function DungeonCrawler.DCCharacterMovementComponent.SetWindForce
// 0x0018 (0x0018 - 0x0000)
struct DCCharacterMovementComponent_SetWindForce final
{
public:
	struct FVector                                WindVector;                                        // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterMovementComponent_SetWindForce) == 0x000008, "Wrong alignment on DCCharacterMovementComponent_SetWindForce");
static_assert(sizeof(DCCharacterMovementComponent_SetWindForce) == 0x000018, "Wrong size on DCCharacterMovementComponent_SetWindForce");
static_assert(offsetof(DCCharacterMovementComponent_SetWindForce, WindVector) == 0x000000, "Member 'DCCharacterMovementComponent_SetWindForce::WindVector' has a wrong offset!");

// Function DungeonCrawler.DCCharacterMovementComponent.IsAffectedByWindForce
// 0x0001 (0x0001 - 0x0000)
struct DCCharacterMovementComponent_IsAffectedByWindForce final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterMovementComponent_IsAffectedByWindForce) == 0x000001, "Wrong alignment on DCCharacterMovementComponent_IsAffectedByWindForce");
static_assert(sizeof(DCCharacterMovementComponent_IsAffectedByWindForce) == 0x000001, "Wrong size on DCCharacterMovementComponent_IsAffectedByWindForce");
static_assert(offsetof(DCCharacterMovementComponent_IsAffectedByWindForce, ReturnValue) == 0x000000, "Member 'DCCharacterMovementComponent_IsAffectedByWindForce::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterProduction.OnRep_ItemDataList
// 0x0010 (0x0010 - 0x0000)
struct DCCharacterProduction_OnRep_ItemDataList final
{
public:
	TArray<class FString>                         OldItemAssetIDList;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterProduction_OnRep_ItemDataList) == 0x000008, "Wrong alignment on DCCharacterProduction_OnRep_ItemDataList");
static_assert(sizeof(DCCharacterProduction_OnRep_ItemDataList) == 0x000010, "Wrong size on DCCharacterProduction_OnRep_ItemDataList");
static_assert(offsetof(DCCharacterProduction_OnRep_ItemDataList, OldItemAssetIDList) == 0x000000, "Member 'DCCharacterProduction_OnRep_ItemDataList::OldItemAssetIDList' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_PlayerSkillBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_PlayerSkillBase_AbilityActivated");
static_assert(sizeof(GA_PlayerSkillBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_PlayerSkillBase_AbilityActivated");
static_assert(offsetof(GA_PlayerSkillBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_PlayerSkillBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.ClientOnSkillActivate
// 0x0010 (0x0010 - 0x0000)
struct GA_PlayerSkillBase_ClientOnSkillActivate final
{
public:
	struct FGameplayTag                           SkillTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CooldownTag;                                       // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_ClientOnSkillActivate) == 0x000004, "Wrong alignment on GA_PlayerSkillBase_ClientOnSkillActivate");
static_assert(sizeof(GA_PlayerSkillBase_ClientOnSkillActivate) == 0x000010, "Wrong size on GA_PlayerSkillBase_ClientOnSkillActivate");
static_assert(offsetof(GA_PlayerSkillBase_ClientOnSkillActivate, SkillTag) == 0x000000, "Member 'GA_PlayerSkillBase_ClientOnSkillActivate::SkillTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_ClientOnSkillActivate, CooldownTag) == 0x000008, "Member 'GA_PlayerSkillBase_ClientOnSkillActivate::CooldownTag' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSkillBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_EventReceived) == 0x000008, "Wrong alignment on GA_PlayerSkillBase_EventReceived");
static_assert(sizeof(GA_PlayerSkillBase_EventReceived) == 0x0000B8, "Wrong size on GA_PlayerSkillBase_EventReceived");
static_assert(offsetof(GA_PlayerSkillBase_EventReceived, EventTag) == 0x000000, "Member 'GA_PlayerSkillBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_EventReceived, EventData) == 0x000008, "Member 'GA_PlayerSkillBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.OnBlendOut
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSkillBase_OnBlendOut final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_OnBlendOut) == 0x000008, "Wrong alignment on GA_PlayerSkillBase_OnBlendOut");
static_assert(sizeof(GA_PlayerSkillBase_OnBlendOut) == 0x0000B8, "Wrong size on GA_PlayerSkillBase_OnBlendOut");
static_assert(offsetof(GA_PlayerSkillBase_OnBlendOut, EventTag) == 0x000000, "Member 'GA_PlayerSkillBase_OnBlendOut::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_OnBlendOut, EventData) == 0x000008, "Member 'GA_PlayerSkillBase_OnBlendOut::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSkillBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_OnCancelled) == 0x000008, "Wrong alignment on GA_PlayerSkillBase_OnCancelled");
static_assert(sizeof(GA_PlayerSkillBase_OnCancelled) == 0x0000B8, "Wrong size on GA_PlayerSkillBase_OnCancelled");
static_assert(offsetof(GA_PlayerSkillBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_PlayerSkillBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_OnCancelled, EventData) == 0x000008, "Member 'GA_PlayerSkillBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSkillBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_OnCompleted) == 0x000008, "Wrong alignment on GA_PlayerSkillBase_OnCompleted");
static_assert(sizeof(GA_PlayerSkillBase_OnCompleted) == 0x0000B8, "Wrong size on GA_PlayerSkillBase_OnCompleted");
static_assert(offsetof(GA_PlayerSkillBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_PlayerSkillBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_OnCompleted, EventData) == 0x000008, "Member 'GA_PlayerSkillBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.OnCooldownStarted
// 0x0014 (0x0014 - 0x0000)
struct GA_PlayerSkillBase_OnCooldownStarted final
{
public:
	struct FGameplayTag                           SkillTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CooldownTag;                                       // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownDuration;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_OnCooldownStarted) == 0x000004, "Wrong alignment on GA_PlayerSkillBase_OnCooldownStarted");
static_assert(sizeof(GA_PlayerSkillBase_OnCooldownStarted) == 0x000014, "Wrong size on GA_PlayerSkillBase_OnCooldownStarted");
static_assert(offsetof(GA_PlayerSkillBase_OnCooldownStarted, SkillTag) == 0x000000, "Member 'GA_PlayerSkillBase_OnCooldownStarted::SkillTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_OnCooldownStarted, CooldownTag) == 0x000008, "Member 'GA_PlayerSkillBase_OnCooldownStarted::CooldownTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_OnCooldownStarted, CooldownDuration) == 0x000010, "Member 'GA_PlayerSkillBase_OnCooldownStarted::CooldownDuration' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.OnCooldownTagApplied
// 0x0018 (0x0018 - 0x0000)
struct GA_PlayerSkillBase_OnCooldownTagApplied final
{
public:
	struct FGameplayTag                           EffectGameplayTag;                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStackCount;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousStackCount;                                // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_OnCooldownTagApplied) == 0x000004, "Wrong alignment on GA_PlayerSkillBase_OnCooldownTagApplied");
static_assert(sizeof(GA_PlayerSkillBase_OnCooldownTagApplied) == 0x000018, "Wrong size on GA_PlayerSkillBase_OnCooldownTagApplied");
static_assert(offsetof(GA_PlayerSkillBase_OnCooldownTagApplied, EffectGameplayTag) == 0x000000, "Member 'GA_PlayerSkillBase_OnCooldownTagApplied::EffectGameplayTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_OnCooldownTagApplied, EffectHandle) == 0x000008, "Member 'GA_PlayerSkillBase_OnCooldownTagApplied::EffectHandle' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_OnCooldownTagApplied, NewStackCount) == 0x000010, "Member 'GA_PlayerSkillBase_OnCooldownTagApplied::NewStackCount' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_OnCooldownTagApplied, PreviousStackCount) == 0x000014, "Member 'GA_PlayerSkillBase_OnCooldownTagApplied::PreviousStackCount' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.OnInterrupted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSkillBase_OnInterrupted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_OnInterrupted) == 0x000008, "Wrong alignment on GA_PlayerSkillBase_OnInterrupted");
static_assert(sizeof(GA_PlayerSkillBase_OnInterrupted) == 0x0000B8, "Wrong size on GA_PlayerSkillBase_OnInterrupted");
static_assert(offsetof(GA_PlayerSkillBase_OnInterrupted, EventTag) == 0x000000, "Member 'GA_PlayerSkillBase_OnInterrupted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_OnInterrupted, EventData) == 0x000008, "Member 'GA_PlayerSkillBase_OnInterrupted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.OnSkillActivateNotify
// 0x00B0 (0x00B0 - 0x0000)
struct GA_PlayerSkillBase_OnSkillActivateNotify final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_OnSkillActivateNotify) == 0x000008, "Wrong alignment on GA_PlayerSkillBase_OnSkillActivateNotify");
static_assert(sizeof(GA_PlayerSkillBase_OnSkillActivateNotify) == 0x0000B0, "Wrong size on GA_PlayerSkillBase_OnSkillActivateNotify");
static_assert(offsetof(GA_PlayerSkillBase_OnSkillActivateNotify, EventData) == 0x000000, "Member 'GA_PlayerSkillBase_OnSkillActivateNotify::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSkillBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_PlayerSkillBase_ReceivedEvent");
static_assert(sizeof(GA_PlayerSkillBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_PlayerSkillBase_ReceivedEvent");
static_assert(offsetof(GA_PlayerSkillBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_PlayerSkillBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_PlayerSkillBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.ServerOnSkillActivate
// 0x0010 (0x0010 - 0x0000)
struct GA_PlayerSkillBase_ServerOnSkillActivate final
{
public:
	struct FGameplayTag                           SkillTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CooldownTag;                                       // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_ServerOnSkillActivate) == 0x000004, "Wrong alignment on GA_PlayerSkillBase_ServerOnSkillActivate");
static_assert(sizeof(GA_PlayerSkillBase_ServerOnSkillActivate) == 0x000010, "Wrong size on GA_PlayerSkillBase_ServerOnSkillActivate");
static_assert(offsetof(GA_PlayerSkillBase_ServerOnSkillActivate, SkillTag) == 0x000000, "Member 'GA_PlayerSkillBase_ServerOnSkillActivate::SkillTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillBase_ServerOnSkillActivate, CooldownTag) == 0x000008, "Member 'GA_PlayerSkillBase_ServerOnSkillActivate::CooldownTag' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.SetEquippedItemsHidden
// 0x0001 (0x0001 - 0x0000)
struct GA_PlayerSkillBase_SetEquippedItemsHidden final
{
public:
	bool                                          bShouldHide;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_SetEquippedItemsHidden) == 0x000001, "Wrong alignment on GA_PlayerSkillBase_SetEquippedItemsHidden");
static_assert(sizeof(GA_PlayerSkillBase_SetEquippedItemsHidden) == 0x000001, "Wrong size on GA_PlayerSkillBase_SetEquippedItemsHidden");
static_assert(offsetof(GA_PlayerSkillBase_SetEquippedItemsHidden, bShouldHide) == 0x000000, "Member 'GA_PlayerSkillBase_SetEquippedItemsHidden::bShouldHide' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.GetCurrentDesignDataSkill
// 0x00E0 (0x00E0 - 0x0000)
struct GA_PlayerSkillBase_GetCurrentDesignDataSkill final
{
public:
	struct FDesignDataSkill                       ReturnValue;                                       // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_GetCurrentDesignDataSkill) == 0x000008, "Wrong alignment on GA_PlayerSkillBase_GetCurrentDesignDataSkill");
static_assert(sizeof(GA_PlayerSkillBase_GetCurrentDesignDataSkill) == 0x0000E0, "Wrong size on GA_PlayerSkillBase_GetCurrentDesignDataSkill");
static_assert(offsetof(GA_PlayerSkillBase_GetCurrentDesignDataSkill, ReturnValue) == 0x000000, "Member 'GA_PlayerSkillBase_GetCurrentDesignDataSkill::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillBase.GetRange
// 0x0004 (0x0004 - 0x0000)
struct GA_PlayerSkillBase_GetRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillBase_GetRange) == 0x000004, "Wrong alignment on GA_PlayerSkillBase_GetRange");
static_assert(sizeof(GA_PlayerSkillBase_GetRange) == 0x000004, "Wrong size on GA_PlayerSkillBase_GetRange");
static_assert(offsetof(GA_PlayerSkillBase_GetRange, ReturnValue) == 0x000000, "Member 'GA_PlayerSkillBase_GetRange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameTooltipWithFlavorTextWidget.GetDescriptionVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCGameTooltipWithFlavorTextWidget_GetDescriptionVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameTooltipWithFlavorTextWidget_GetDescriptionVisibility) == 0x000001, "Wrong alignment on DCGameTooltipWithFlavorTextWidget_GetDescriptionVisibility");
static_assert(sizeof(DCGameTooltipWithFlavorTextWidget_GetDescriptionVisibility) == 0x000001, "Wrong size on DCGameTooltipWithFlavorTextWidget_GetDescriptionVisibility");
static_assert(offsetof(DCGameTooltipWithFlavorTextWidget_GetDescriptionVisibility, ReturnValue) == 0x000000, "Member 'DCGameTooltipWithFlavorTextWidget_GetDescriptionVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCharacterSkinComponent.OnRep_Data
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterSkinComponent_OnRep_Data final
{
public:
	const class UDCCharacterSkinDataAsset*        OldData;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterSkinComponent_OnRep_Data) == 0x000008, "Wrong alignment on DCCharacterSkinComponent_OnRep_Data");
static_assert(sizeof(DCCharacterSkinComponent_OnRep_Data) == 0x000008, "Wrong size on DCCharacterSkinComponent_OnRep_Data");
static_assert(offsetof(DCCharacterSkinComponent_OnRep_Data, OldData) == 0x000000, "Member 'DCCharacterSkinComponent_OnRep_Data::OldData' has a wrong offset!");

// Function DungeonCrawler.DCCharacterSkinComponent.SetDataForDebug_Server
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterSkinComponent_SetDataForDebug_Server final
{
public:
	const class UDCCharacterSkinDataAsset*        InData;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterSkinComponent_SetDataForDebug_Server) == 0x000008, "Wrong alignment on DCCharacterSkinComponent_SetDataForDebug_Server");
static_assert(sizeof(DCCharacterSkinComponent_SetDataForDebug_Server) == 0x000008, "Wrong size on DCCharacterSkinComponent_SetDataForDebug_Server");
static_assert(offsetof(DCCharacterSkinComponent_SetDataForDebug_Server, InData) == 0x000000, "Member 'DCCharacterSkinComponent_SetDataForDebug_Server::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillRouterBase.OnRoutedAbilityEnded
// 0x0010 (0x0010 - 0x0000)
struct GA_PlayerSkillRouterBase_OnRoutedAbilityEnded final
{
public:
	struct FAbilityEndedData                      AbilityEndedData;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillRouterBase_OnRoutedAbilityEnded) == 0x000008, "Wrong alignment on GA_PlayerSkillRouterBase_OnRoutedAbilityEnded");
static_assert(sizeof(GA_PlayerSkillRouterBase_OnRoutedAbilityEnded) == 0x000010, "Wrong size on GA_PlayerSkillRouterBase_OnRoutedAbilityEnded");
static_assert(offsetof(GA_PlayerSkillRouterBase_OnRoutedAbilityEnded, AbilityEndedData) == 0x000000, "Member 'GA_PlayerSkillRouterBase_OnRoutedAbilityEnded::AbilityEndedData' has a wrong offset!");

// Function DungeonCrawler.DCCharacterSkinWidget.GetTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCCharacterSkinWidget_GetTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCharacterSkinWidget_GetTooltipWidget) == 0x000008, "Wrong alignment on DCCharacterSkinWidget_GetTooltipWidget");
static_assert(sizeof(DCCharacterSkinWidget_GetTooltipWidget) == 0x000008, "Wrong size on DCCharacterSkinWidget_GetTooltipWidget");
static_assert(offsetof(DCCharacterSkinWidget_GetTooltipWidget, ReturnValue) == 0x000000, "Member 'DCCharacterSkinWidget_GetTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameSpawner.OnSetMonsterPeaceAction
// 0x0008 (0x0008 - 0x0000)
struct DCGameSpawner_OnSetMonsterPeaceAction final
{
public:
	class ADCMonsterBase*                         Monster;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSpawner_OnSetMonsterPeaceAction) == 0x000008, "Wrong alignment on DCGameSpawner_OnSetMonsterPeaceAction");
static_assert(sizeof(DCGameSpawner_OnSetMonsterPeaceAction) == 0x000008, "Wrong size on DCGameSpawner_OnSetMonsterPeaceAction");
static_assert(offsetof(DCGameSpawner_OnSetMonsterPeaceAction, Monster) == 0x000000, "Member 'DCGameSpawner_OnSetMonsterPeaceAction::Monster' has a wrong offset!");

// Function DungeonCrawler.DCGameSpawner.SpawnItemHolder
// 0x0030 (0x0030 - 0x0000)
struct DCGameSpawner_SpawnItemHolder final
{
public:
	struct FPrimaryAssetId                        InLootDropId;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        InLootDropRateId;                                  // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInPreview;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C8[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AItemHolderActorBase*                   ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSpawner_SpawnItemHolder) == 0x000008, "Wrong alignment on DCGameSpawner_SpawnItemHolder");
static_assert(sizeof(DCGameSpawner_SpawnItemHolder) == 0x000030, "Wrong size on DCGameSpawner_SpawnItemHolder");
static_assert(offsetof(DCGameSpawner_SpawnItemHolder, InLootDropId) == 0x000000, "Member 'DCGameSpawner_SpawnItemHolder::InLootDropId' has a wrong offset!");
static_assert(offsetof(DCGameSpawner_SpawnItemHolder, InLootDropRateId) == 0x000010, "Member 'DCGameSpawner_SpawnItemHolder::InLootDropRateId' has a wrong offset!");
static_assert(offsetof(DCGameSpawner_SpawnItemHolder, bInPreview) == 0x000020, "Member 'DCGameSpawner_SpawnItemHolder::bInPreview' has a wrong offset!");
static_assert(offsetof(DCGameSpawner_SpawnItemHolder, ReturnValue) == 0x000028, "Member 'DCGameSpawner_SpawnItemHolder::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameSpawner.SpawnMonster
// 0x0028 (0x0028 - 0x0000)
struct DCGameSpawner_SpawnMonster final
{
public:
	struct FPrimaryAssetId                        InMonsterId;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       Summoner;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInPreview;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C9[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCMonsterBase*                         ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSpawner_SpawnMonster) == 0x000008, "Wrong alignment on DCGameSpawner_SpawnMonster");
static_assert(sizeof(DCGameSpawner_SpawnMonster) == 0x000028, "Wrong size on DCGameSpawner_SpawnMonster");
static_assert(offsetof(DCGameSpawner_SpawnMonster, InMonsterId) == 0x000000, "Member 'DCGameSpawner_SpawnMonster::InMonsterId' has a wrong offset!");
static_assert(offsetof(DCGameSpawner_SpawnMonster, Summoner) == 0x000010, "Member 'DCGameSpawner_SpawnMonster::Summoner' has a wrong offset!");
static_assert(offsetof(DCGameSpawner_SpawnMonster, bInPreview) == 0x000018, "Member 'DCGameSpawner_SpawnMonster::bInPreview' has a wrong offset!");
static_assert(offsetof(DCGameSpawner_SpawnMonster, ReturnValue) == 0x000020, "Member 'DCGameSpawner_SpawnMonster::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameSpawner.SpawnProps
// 0x0020 (0x0020 - 0x0000)
struct DCGameSpawner_SpawnProps final
{
public:
	struct FPrimaryAssetId                        InPropsId;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInPreview;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25CA[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APropsActorBase*                        ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSpawner_SpawnProps) == 0x000008, "Wrong alignment on DCGameSpawner_SpawnProps");
static_assert(sizeof(DCGameSpawner_SpawnProps) == 0x000020, "Wrong size on DCGameSpawner_SpawnProps");
static_assert(offsetof(DCGameSpawner_SpawnProps, InPropsId) == 0x000000, "Member 'DCGameSpawner_SpawnProps::InPropsId' has a wrong offset!");
static_assert(offsetof(DCGameSpawner_SpawnProps, bInPreview) == 0x000010, "Member 'DCGameSpawner_SpawnProps::bInPreview' has a wrong offset!");
static_assert(offsetof(DCGameSpawner_SpawnProps, ReturnValue) == 0x000018, "Member 'DCGameSpawner_SpawnProps::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameSpawner.UpdateGameState
// 0x0008 (0x0008 - 0x0000)
struct DCGameSpawner_UpdateGameState final
{
public:
	struct FGameStateData                         InGameStateData;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSpawner_UpdateGameState) == 0x000004, "Wrong alignment on DCGameSpawner_UpdateGameState");
static_assert(sizeof(DCGameSpawner_UpdateGameState) == 0x000008, "Wrong size on DCGameSpawner_UpdateGameState");
static_assert(offsetof(DCGameSpawner_UpdateGameState, InGameStateData) == 0x000000, "Member 'DCGameSpawner_UpdateGameState::InGameStateData' has a wrong offset!");

// Function DungeonCrawler.GameSpellCurrentSlotWidget.OnSetSpellArtData
// 0x0008 (0x0008 - 0x0000)
struct GameSpellCurrentSlotWidget_OnSetSpellArtData final
{
public:
	const class UArtDataSpell*                    InArtSpellData;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSpellCurrentSlotWidget_OnSetSpellArtData) == 0x000008, "Wrong alignment on GameSpellCurrentSlotWidget_OnSetSpellArtData");
static_assert(sizeof(GameSpellCurrentSlotWidget_OnSetSpellArtData) == 0x000008, "Wrong size on GameSpellCurrentSlotWidget_OnSetSpellArtData");
static_assert(offsetof(GameSpellCurrentSlotWidget_OnSetSpellArtData, InArtSpellData) == 0x000000, "Member 'GameSpellCurrentSlotWidget_OnSetSpellArtData::InArtSpellData' has a wrong offset!");

// Function DungeonCrawler.GameSpellCurrentSlotWidget.OnSpellDataChanged
// 0x0118 (0x0118 - 0x0000)
struct GameSpellCurrentSlotWidget_OnSpellDataChanged final
{
public:
	struct FSpellData                             InSpellData;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDesignDataSpell                       InDesignDataSpell;                                 // 0x0040(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSpellCurrentSlotWidget_OnSpellDataChanged) == 0x000008, "Wrong alignment on GameSpellCurrentSlotWidget_OnSpellDataChanged");
static_assert(sizeof(GameSpellCurrentSlotWidget_OnSpellDataChanged) == 0x000118, "Wrong size on GameSpellCurrentSlotWidget_OnSpellDataChanged");
static_assert(offsetof(GameSpellCurrentSlotWidget_OnSpellDataChanged, InSpellData) == 0x000000, "Member 'GameSpellCurrentSlotWidget_OnSpellDataChanged::InSpellData' has a wrong offset!");
static_assert(offsetof(GameSpellCurrentSlotWidget_OnSpellDataChanged, InDesignDataSpell) == 0x000040, "Member 'GameSpellCurrentSlotWidget_OnSpellDataChanged::InDesignDataSpell' has a wrong offset!");

// Function DungeonCrawler.GameSpellCurrentSlotWidget.SetSpellData
// 0x0118 (0x0118 - 0x0000)
struct GameSpellCurrentSlotWidget_SetSpellData final
{
public:
	struct FSpellData                             InSpellData;                                       // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDesignDataSpell                       InDesignDataSpell;                                 // 0x0040(0x00D8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSpellCurrentSlotWidget_SetSpellData) == 0x000008, "Wrong alignment on GameSpellCurrentSlotWidget_SetSpellData");
static_assert(sizeof(GameSpellCurrentSlotWidget_SetSpellData) == 0x000118, "Wrong size on GameSpellCurrentSlotWidget_SetSpellData");
static_assert(offsetof(GameSpellCurrentSlotWidget_SetSpellData, InSpellData) == 0x000000, "Member 'GameSpellCurrentSlotWidget_SetSpellData::InSpellData' has a wrong offset!");
static_assert(offsetof(GameSpellCurrentSlotWidget_SetSpellData, InDesignDataSpell) == 0x000040, "Member 'GameSpellCurrentSlotWidget_SetSpellData::InDesignDataSpell' has a wrong offset!");

// Function DungeonCrawler.DCChildActorComponent.SpawnChildActor
// 0x0010 (0x0010 - 0x0000)
struct DCChildActorComponent_SpawnChildActor final
{
public:
	bool                                          bIsPreview;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D0[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APropsActorBase*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCChildActorComponent_SpawnChildActor) == 0x000008, "Wrong alignment on DCChildActorComponent_SpawnChildActor");
static_assert(sizeof(DCChildActorComponent_SpawnChildActor) == 0x000010, "Wrong size on DCChildActorComponent_SpawnChildActor");
static_assert(offsetof(DCChildActorComponent_SpawnChildActor, bIsPreview) == 0x000000, "Member 'DCChildActorComponent_SpawnChildActor::bIsPreview' has a wrong offset!");
static_assert(offsetof(DCChildActorComponent_SpawnChildActor, ReturnValue) == 0x000008, "Member 'DCChildActorComponent_SpawnChildActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct GameTestComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on GameTestComponent_BroadcastMsgBlueprint");
static_assert(sizeof(GameTestComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on GameTestComponent_BroadcastMsgBlueprint");
static_assert(offsetof(GameTestComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'GameTestComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassItemMoveRequest
// 0x0090 (0x0090 - 0x0000)
struct GameTestComponent_ClientMsgClassItemMoveRequest final
{
public:
	struct FMsgGameTestClassItemMoveRequest       InMsg;                                             // 0x0000(0x0090)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassItemMoveRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassItemMoveRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassItemMoveRequest) == 0x000090, "Wrong size on GameTestComponent_ClientMsgClassItemMoveRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassItemMoveRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassItemMoveRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassItemMoveResponse
// 0x0090 (0x0090 - 0x0000)
struct GameTestComponent_ClientMsgClassItemMoveResponse final
{
public:
	struct FMsgGameTestClassItemMoveResponse      InMsg;                                             // 0x0000(0x0090)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassItemMoveResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassItemMoveResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassItemMoveResponse) == 0x000090, "Wrong size on GameTestComponent_ClientMsgClassItemMoveResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassItemMoveResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassItemMoveResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassLevelInfoRequest
// 0x0020 (0x0020 - 0x0000)
struct GameTestComponent_ClientMsgClassLevelInfoRequest final
{
public:
	struct FMsgGameTestClassLevelInfoRequest      InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassLevelInfoRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassLevelInfoRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassLevelInfoRequest) == 0x000020, "Wrong size on GameTestComponent_ClientMsgClassLevelInfoRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassLevelInfoRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassLevelInfoRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassLevelInfoResponse
// 0x0038 (0x0038 - 0x0000)
struct GameTestComponent_ClientMsgClassLevelInfoResponse final
{
public:
	struct FMsgGameTestClassLevelInfoResponse     InMsg;                                             // 0x0000(0x0038)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassLevelInfoResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassLevelInfoResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassLevelInfoResponse) == 0x000038, "Wrong size on GameTestComponent_ClientMsgClassLevelInfoResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassLevelInfoResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassLevelInfoResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassMusicListRequest
// 0x0020 (0x0020 - 0x0000)
struct GameTestComponent_ClientMsgClassMusicListRequest final
{
public:
	struct FMsgGameTestClassMusicListRequest      InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassMusicListRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassMusicListRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassMusicListRequest) == 0x000020, "Wrong size on GameTestComponent_ClientMsgClassMusicListRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassMusicListRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassMusicListRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassMusicListResponse
// 0x0028 (0x0028 - 0x0000)
struct GameTestComponent_ClientMsgClassMusicListResponse final
{
public:
	struct FMsgGameTestClassMusicListResponse     InMsg;                                             // 0x0000(0x0028)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassMusicListResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassMusicListResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassMusicListResponse) == 0x000028, "Wrong size on GameTestComponent_ClientMsgClassMusicListResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassMusicListResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassMusicListResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassMusicSlotMoveRequest
// 0x0038 (0x0038 - 0x0000)
struct GameTestComponent_ClientMsgClassMusicSlotMoveRequest final
{
public:
	struct FMsgGameTestClassMusicSlotMoveRequest  InMsg;                                             // 0x0000(0x0038)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassMusicSlotMoveRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassMusicSlotMoveRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassMusicSlotMoveRequest) == 0x000038, "Wrong size on GameTestComponent_ClientMsgClassMusicSlotMoveRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassMusicSlotMoveRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassMusicSlotMoveRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassMusicSlotMoveResponse
// 0x0030 (0x0030 - 0x0000)
struct GameTestComponent_ClientMsgClassMusicSlotMoveResponse final
{
public:
	struct FMsgGameTestClassMusicSlotMoveResponse InMsg;                                             // 0x0000(0x0030)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassMusicSlotMoveResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassMusicSlotMoveResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassMusicSlotMoveResponse) == 0x000030, "Wrong size on GameTestComponent_ClientMsgClassMusicSlotMoveResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassMusicSlotMoveResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassMusicSlotMoveResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassPerkListRequest
// 0x0020 (0x0020 - 0x0000)
struct GameTestComponent_ClientMsgClassPerkListRequest final
{
public:
	struct FMsgGameTestClassPerkListRequest       InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassPerkListRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassPerkListRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassPerkListRequest) == 0x000020, "Wrong size on GameTestComponent_ClientMsgClassPerkListRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassPerkListRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassPerkListRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassPerkListResponse
// 0x0028 (0x0028 - 0x0000)
struct GameTestComponent_ClientMsgClassPerkListResponse final
{
public:
	struct FMsgGameTestClassPerkListResponse      InMsg;                                             // 0x0000(0x0028)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassPerkListResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassPerkListResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassPerkListResponse) == 0x000028, "Wrong size on GameTestComponent_ClientMsgClassPerkListResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassPerkListResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassPerkListResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassShapeShiftListRequest
// 0x0020 (0x0020 - 0x0000)
struct GameTestComponent_ClientMsgClassShapeShiftListRequest final
{
public:
	struct FMsgGameTestClassShapeShiftListRequest InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassShapeShiftListRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassShapeShiftListRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassShapeShiftListRequest) == 0x000020, "Wrong size on GameTestComponent_ClientMsgClassShapeShiftListRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassShapeShiftListRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassShapeShiftListRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassShapeShiftListResponse
// 0x0028 (0x0028 - 0x0000)
struct GameTestComponent_ClientMsgClassShapeShiftListResponse final
{
public:
	struct FMsgGameTestClassShapeShiftListResponse InMsg;                                             // 0x0000(0x0028)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassShapeShiftListResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassShapeShiftListResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassShapeShiftListResponse) == 0x000028, "Wrong size on GameTestComponent_ClientMsgClassShapeShiftListResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassShapeShiftListResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassShapeShiftListResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassShapeShiftSlotMoveRequest
// 0x0038 (0x0038 - 0x0000)
struct GameTestComponent_ClientMsgClassShapeShiftSlotMoveRequest final
{
public:
	struct FMsgGameTestClassShapeShiftSlotMoveRequest InMsg;                                             // 0x0000(0x0038)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassShapeShiftSlotMoveRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassShapeShiftSlotMoveRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassShapeShiftSlotMoveRequest) == 0x000038, "Wrong size on GameTestComponent_ClientMsgClassShapeShiftSlotMoveRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassShapeShiftSlotMoveRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassShapeShiftSlotMoveRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassShapeShiftSlotMoveResponse
// 0x0030 (0x0030 - 0x0000)
struct GameTestComponent_ClientMsgClassShapeShiftSlotMoveResponse final
{
public:
	struct FMsgGameTestClassShapeShiftSlotMoveResponse InMsg;                                             // 0x0000(0x0030)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassShapeShiftSlotMoveResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassShapeShiftSlotMoveResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassShapeShiftSlotMoveResponse) == 0x000030, "Wrong size on GameTestComponent_ClientMsgClassShapeShiftSlotMoveResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassShapeShiftSlotMoveResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassShapeShiftSlotMoveResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassSkillListRequest
// 0x0020 (0x0020 - 0x0000)
struct GameTestComponent_ClientMsgClassSkillListRequest final
{
public:
	struct FMsgGameTestClassSkillListRequest      InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassSkillListRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassSkillListRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassSkillListRequest) == 0x000020, "Wrong size on GameTestComponent_ClientMsgClassSkillListRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassSkillListRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassSkillListRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassSkillListResponse
// 0x0028 (0x0028 - 0x0000)
struct GameTestComponent_ClientMsgClassSkillListResponse final
{
public:
	struct FMsgGameTestClassSkillListResponse     InMsg;                                             // 0x0000(0x0028)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassSkillListResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassSkillListResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassSkillListResponse) == 0x000028, "Wrong size on GameTestComponent_ClientMsgClassSkillListResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassSkillListResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassSkillListResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellListRequest
// 0x0020 (0x0020 - 0x0000)
struct GameTestComponent_ClientMsgClassSpellListRequest final
{
public:
	struct FMsgGameTestClassSpellListRequest      InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassSpellListRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassSpellListRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassSpellListRequest) == 0x000020, "Wrong size on GameTestComponent_ClientMsgClassSpellListRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassSpellListRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassSpellListRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellListResponse
// 0x0028 (0x0028 - 0x0000)
struct GameTestComponent_ClientMsgClassSpellListResponse final
{
public:
	struct FMsgGameTestClassSpellListResponse     InMsg;                                             // 0x0000(0x0028)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassSpellListResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassSpellListResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassSpellListResponse) == 0x000028, "Wrong size on GameTestComponent_ClientMsgClassSpellListResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassSpellListResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassSpellListResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSequenceChangeRequest
// 0x0038 (0x0038 - 0x0000)
struct GameTestComponent_ClientMsgClassSpellSequenceChangeRequest final
{
public:
	struct FMsgGameTestClassSpellSequenceChangeRequest InMsg;                                             // 0x0000(0x0038)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassSpellSequenceChangeRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassSpellSequenceChangeRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassSpellSequenceChangeRequest) == 0x000038, "Wrong size on GameTestComponent_ClientMsgClassSpellSequenceChangeRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassSpellSequenceChangeRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassSpellSequenceChangeRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSequenceChangeResponse
// 0x0030 (0x0030 - 0x0000)
struct GameTestComponent_ClientMsgClassSpellSequenceChangeResponse final
{
public:
	struct FMsgGameTestClassSpellSequenceChangeResponse InMsg;                                             // 0x0000(0x0030)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassSpellSequenceChangeResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassSpellSequenceChangeResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassSpellSequenceChangeResponse) == 0x000030, "Wrong size on GameTestComponent_ClientMsgClassSpellSequenceChangeResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassSpellSequenceChangeResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassSpellSequenceChangeResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSlotMoveRequest
// 0x0038 (0x0038 - 0x0000)
struct GameTestComponent_ClientMsgClassSpellSlotMoveRequest final
{
public:
	struct FMsgGameTestClassSpellSlotMoveRequest  InMsg;                                             // 0x0000(0x0038)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassSpellSlotMoveRequest) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassSpellSlotMoveRequest");
static_assert(sizeof(GameTestComponent_ClientMsgClassSpellSlotMoveRequest) == 0x000038, "Wrong size on GameTestComponent_ClientMsgClassSpellSlotMoveRequest");
static_assert(offsetof(GameTestComponent_ClientMsgClassSpellSlotMoveRequest, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassSpellSlotMoveRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSlotMoveResponse
// 0x0030 (0x0030 - 0x0000)
struct GameTestComponent_ClientMsgClassSpellSlotMoveResponse final
{
public:
	struct FMsgGameTestClassSpellSlotMoveResponse InMsg;                                             // 0x0000(0x0030)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientMsgClassSpellSlotMoveResponse) == 0x000008, "Wrong alignment on GameTestComponent_ClientMsgClassSpellSlotMoveResponse");
static_assert(sizeof(GameTestComponent_ClientMsgClassSpellSlotMoveResponse) == 0x000030, "Wrong size on GameTestComponent_ClientMsgClassSpellSlotMoveResponse");
static_assert(offsetof(GameTestComponent_ClientMsgClassSpellSlotMoveResponse, InMsg) == 0x000000, "Member 'GameTestComponent_ClientMsgClassSpellSlotMoveResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientOnUpdateSkillList
// 0x0010 (0x0010 - 0x0000)
struct GameTestComponent_ClientOnUpdateSkillList final
{
public:
	TArray<struct FPrimaryAssetId>                InSkillIdArray;                                    // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientOnUpdateSkillList) == 0x000008, "Wrong alignment on GameTestComponent_ClientOnUpdateSkillList");
static_assert(sizeof(GameTestComponent_ClientOnUpdateSkillList) == 0x000010, "Wrong size on GameTestComponent_ClientOnUpdateSkillList");
static_assert(offsetof(GameTestComponent_ClientOnUpdateSkillList, InSkillIdArray) == 0x000000, "Member 'GameTestComponent_ClientOnUpdateSkillList::InSkillIdArray' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientResRedeemLearningToken
// 0x0020 (0x0020 - 0x0000)
struct GameTestComponent_ClientResRedeemLearningToken final
{
public:
	struct FPrimaryAssetId                        MasterClassId;                                     // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                InClassAbilityOptions;                             // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientResRedeemLearningToken) == 0x000008, "Wrong alignment on GameTestComponent_ClientResRedeemLearningToken");
static_assert(sizeof(GameTestComponent_ClientResRedeemLearningToken) == 0x000020, "Wrong size on GameTestComponent_ClientResRedeemLearningToken");
static_assert(offsetof(GameTestComponent_ClientResRedeemLearningToken, MasterClassId) == 0x000000, "Member 'GameTestComponent_ClientResRedeemLearningToken::MasterClassId' has a wrong offset!");
static_assert(offsetof(GameTestComponent_ClientResRedeemLearningToken, InClassAbilityOptions) == 0x000010, "Member 'GameTestComponent_ClientResRedeemLearningToken::InClassAbilityOptions' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientResRedeemRewardToken
// 0x0010 (0x0010 - 0x0000)
struct GameTestComponent_ClientResRedeemRewardToken final
{
public:
	TArray<struct FPrimaryAssetId>                InRewardOptions;                                   // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientResRedeemRewardToken) == 0x000008, "Wrong alignment on GameTestComponent_ClientResRedeemRewardToken");
static_assert(sizeof(GameTestComponent_ClientResRedeemRewardToken) == 0x000010, "Wrong size on GameTestComponent_ClientResRedeemRewardToken");
static_assert(offsetof(GameTestComponent_ClientResRedeemRewardToken, InRewardOptions) == 0x000000, "Member 'GameTestComponent_ClientResRedeemRewardToken::InRewardOptions' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ClientResTrainingInfo
// 0x0058 (0x0058 - 0x0000)
struct GameTestComponent_ClientResTrainingInfo final
{
public:
	struct FDCGameTestClassTrainingInfo           InTrainingInfo;                                    // 0x0000(0x0058)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ClientResTrainingInfo) == 0x000008, "Wrong alignment on GameTestComponent_ClientResTrainingInfo");
static_assert(sizeof(GameTestComponent_ClientResTrainingInfo) == 0x000058, "Wrong size on GameTestComponent_ClientResTrainingInfo");
static_assert(offsetof(GameTestComponent_ClientResTrainingInfo, InTrainingInfo) == 0x000000, "Member 'GameTestComponent_ClientResTrainingInfo::InTrainingInfo' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.MsgGameTestChangePlayerCharacterClassRequest
// 0x0020 (0x0020 - 0x0000)
struct GameTestComponent_MsgGameTestChangePlayerCharacterClassRequest final
{
public:
	struct FMsgGameTestChangePlayerCharacterClassRequest InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_MsgGameTestChangePlayerCharacterClassRequest) == 0x000008, "Wrong alignment on GameTestComponent_MsgGameTestChangePlayerCharacterClassRequest");
static_assert(sizeof(GameTestComponent_MsgGameTestChangePlayerCharacterClassRequest) == 0x000020, "Wrong size on GameTestComponent_MsgGameTestChangePlayerCharacterClassRequest");
static_assert(offsetof(GameTestComponent_MsgGameTestChangePlayerCharacterClassRequest, InMsg) == 0x000000, "Member 'GameTestComponent_MsgGameTestChangePlayerCharacterClassRequest::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.MsgGameTestChangePlayerCharacterClassResponse
// 0x0018 (0x0018 - 0x0000)
struct GameTestComponent_MsgGameTestChangePlayerCharacterClassResponse final
{
public:
	struct FMsgGameTestChangePlayerCharacterClassResponse InMsg;                                             // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_MsgGameTestChangePlayerCharacterClassResponse) == 0x000008, "Wrong alignment on GameTestComponent_MsgGameTestChangePlayerCharacterClassResponse");
static_assert(sizeof(GameTestComponent_MsgGameTestChangePlayerCharacterClassResponse) == 0x000018, "Wrong size on GameTestComponent_MsgGameTestChangePlayerCharacterClassResponse");
static_assert(offsetof(GameTestComponent_MsgGameTestChangePlayerCharacterClassResponse, InMsg) == 0x000000, "Member 'GameTestComponent_MsgGameTestChangePlayerCharacterClassResponse::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ServerReqReceiveTrainingClassAbility
// 0x0010 (0x0010 - 0x0000)
struct GameTestComponent_ServerReqReceiveTrainingClassAbility final
{
public:
	struct FPrimaryAssetId                        InClassAbilityId;                                  // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ServerReqReceiveTrainingClassAbility) == 0x000004, "Wrong alignment on GameTestComponent_ServerReqReceiveTrainingClassAbility");
static_assert(sizeof(GameTestComponent_ServerReqReceiveTrainingClassAbility) == 0x000010, "Wrong size on GameTestComponent_ServerReqReceiveTrainingClassAbility");
static_assert(offsetof(GameTestComponent_ServerReqReceiveTrainingClassAbility, InClassAbilityId) == 0x000000, "Member 'GameTestComponent_ServerReqReceiveTrainingClassAbility::InClassAbilityId' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.ServerReqRedeemLearningToken
// 0x0098 (0x0098 - 0x0000)
struct GameTestComponent_ServerReqRedeemLearningToken final
{
public:
	struct FDCTrainingCharacterInfo               InMasterCharacter;                                 // 0x0000(0x0098)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_ServerReqRedeemLearningToken) == 0x000008, "Wrong alignment on GameTestComponent_ServerReqRedeemLearningToken");
static_assert(sizeof(GameTestComponent_ServerReqRedeemLearningToken) == 0x000098, "Wrong size on GameTestComponent_ServerReqRedeemLearningToken");
static_assert(offsetof(GameTestComponent_ServerReqRedeemLearningToken, InMasterCharacter) == 0x000000, "Member 'GameTestComponent_ServerReqRedeemLearningToken::InMasterCharacter' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct GameTestComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_UnbindMsg) == 0x000008, "Wrong alignment on GameTestComponent_UnbindMsg");
static_assert(sizeof(GameTestComponent_UnbindMsg) == 0x000010, "Wrong size on GameTestComponent_UnbindMsg");
static_assert(offsetof(GameTestComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'GameTestComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(GameTestComponent_UnbindMsg, InObject) == 0x000008, "Member 'GameTestComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.GameTestComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct GameTestComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTestComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on GameTestComponent_UnbindMsgAll");
static_assert(sizeof(GameTestComponent_UnbindMsgAll) == 0x000008, "Wrong size on GameTestComponent_UnbindMsgAll");
static_assert(offsetof(GameTestComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'GameTestComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.GA_ActivateItemSpecialBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_ActivateItemSpecialBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ActivateItemSpecialBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_ActivateItemSpecialBase_AbilityActivated");
static_assert(sizeof(GA_ActivateItemSpecialBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_ActivateItemSpecialBase_AbilityActivated");
static_assert(offsetof(GA_ActivateItemSpecialBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_ActivateItemSpecialBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_ActivateItemSpecialBase.OnItemSpecialEnded
// 0x0010 (0x0010 - 0x0000)
struct GA_ActivateItemSpecialBase_OnItemSpecialEnded final
{
public:
	struct FAbilityEndedData                      AbilityEndedData;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ActivateItemSpecialBase_OnItemSpecialEnded) == 0x000008, "Wrong alignment on GA_ActivateItemSpecialBase_OnItemSpecialEnded");
static_assert(sizeof(GA_ActivateItemSpecialBase_OnItemSpecialEnded) == 0x000010, "Wrong size on GA_ActivateItemSpecialBase_OnItemSpecialEnded");
static_assert(offsetof(GA_ActivateItemSpecialBase_OnItemSpecialEnded, AbilityEndedData) == 0x000000, "Member 'GA_ActivateItemSpecialBase_OnItemSpecialEnded::AbilityEndedData' has a wrong offset!");

// Function DungeonCrawler.TopTitleWidgetBase.SetLeftButtonText
// 0x0018 (0x0018 - 0x0000)
struct TopTitleWidgetBase_SetLeftButtonText final
{
public:
	class FText                                   ButtonText;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TopTitleWidgetBase_SetLeftButtonText) == 0x000008, "Wrong alignment on TopTitleWidgetBase_SetLeftButtonText");
static_assert(sizeof(TopTitleWidgetBase_SetLeftButtonText) == 0x000018, "Wrong size on TopTitleWidgetBase_SetLeftButtonText");
static_assert(offsetof(TopTitleWidgetBase_SetLeftButtonText, ButtonText) == 0x000000, "Member 'TopTitleWidgetBase_SetLeftButtonText::ButtonText' has a wrong offset!");

// Function DungeonCrawler.TopTitleWidgetBase.SetRightButtonText
// 0x0018 (0x0018 - 0x0000)
struct TopTitleWidgetBase_SetRightButtonText final
{
public:
	class FText                                   ButtonText;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TopTitleWidgetBase_SetRightButtonText) == 0x000008, "Wrong alignment on TopTitleWidgetBase_SetRightButtonText");
static_assert(sizeof(TopTitleWidgetBase_SetRightButtonText) == 0x000018, "Wrong size on TopTitleWidgetBase_SetRightButtonText");
static_assert(offsetof(TopTitleWidgetBase_SetRightButtonText, ButtonText) == 0x000000, "Member 'TopTitleWidgetBase_SetRightButtonText::ButtonText' has a wrong offset!");

// Function DungeonCrawler.TopTitleWidgetBase.SetTitleText
// 0x0018 (0x0018 - 0x0000)
struct TopTitleWidgetBase_SetTitleText final
{
public:
	class FText                                   TitleText;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TopTitleWidgetBase_SetTitleText) == 0x000008, "Wrong alignment on TopTitleWidgetBase_SetTitleText");
static_assert(sizeof(TopTitleWidgetBase_SetTitleText) == 0x000018, "Wrong size on TopTitleWidgetBase_SetTitleText");
static_assert(offsetof(TopTitleWidgetBase_SetTitleText, TitleText) == 0x000000, "Member 'TopTitleWidgetBase_SetTitleText::TitleText' has a wrong offset!");

// Function DungeonCrawler.DCGhostTrailActor.HandleTimelineUpdate
// 0x0004 (0x0004 - 0x0000)
struct DCGhostTrailActor_HandleTimelineUpdate final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGhostTrailActor_HandleTimelineUpdate) == 0x000004, "Wrong alignment on DCGhostTrailActor_HandleTimelineUpdate");
static_assert(sizeof(DCGhostTrailActor_HandleTimelineUpdate) == 0x000004, "Wrong size on DCGhostTrailActor_HandleTimelineUpdate");
static_assert(offsetof(DCGhostTrailActor_HandleTimelineUpdate, Value) == 0x000000, "Member 'DCGhostTrailActor_HandleTimelineUpdate::Value' has a wrong offset!");

// Function DungeonCrawler.DCGhostTrailActor.SetGhostMaterial
// 0x0010 (0x0010 - 0x0000)
struct DCGhostTrailActor_SetGhostMaterial final
{
public:
	TArray<class UMeshComponent*>                 Components;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGhostTrailActor_SetGhostMaterial) == 0x000008, "Wrong alignment on DCGhostTrailActor_SetGhostMaterial");
static_assert(sizeof(DCGhostTrailActor_SetGhostMaterial) == 0x000010, "Wrong size on DCGhostTrailActor_SetGhostMaterial");
static_assert(offsetof(DCGhostTrailActor_SetGhostMaterial, Components) == 0x000000, "Member 'DCGhostTrailActor_SetGhostMaterial::Components' has a wrong offset!");

// Function DungeonCrawler.DCCommunityBlockEntryWidget.ExecuteContextMenu
// 0x0001 (0x0001 - 0x0000)
struct DCCommunityBlockEntryWidget_ExecuteContextMenu final
{
public:
	EContextOptionType                            Option;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommunityBlockEntryWidget_ExecuteContextMenu) == 0x000001, "Wrong alignment on DCCommunityBlockEntryWidget_ExecuteContextMenu");
static_assert(sizeof(DCCommunityBlockEntryWidget_ExecuteContextMenu) == 0x000001, "Wrong size on DCCommunityBlockEntryWidget_ExecuteContextMenu");
static_assert(offsetof(DCCommunityBlockEntryWidget_ExecuteContextMenu, Option) == 0x000000, "Member 'DCCommunityBlockEntryWidget_ExecuteContextMenu::Option' has a wrong offset!");

// Function DungeonCrawler.DCCommunityBlockWidget.FindId
// 0x0018 (0x0018 - 0x0000)
struct DCCommunityBlockWidget_FindId final
{
public:
	class FText                                   FindText;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommunityBlockWidget_FindId) == 0x000008, "Wrong alignment on DCCommunityBlockWidget_FindId");
static_assert(sizeof(DCCommunityBlockWidget_FindId) == 0x000018, "Wrong size on DCCommunityBlockWidget_FindId");
static_assert(offsetof(DCCommunityBlockWidget_FindId, FindText) == 0x000000, "Member 'DCCommunityBlockWidget_FindId::FindText' has a wrong offset!");

// Function DungeonCrawler.DCCommunityBlockWidget.GetMaxPage
// 0x0004 (0x0004 - 0x0000)
struct DCCommunityBlockWidget_GetMaxPage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommunityBlockWidget_GetMaxPage) == 0x000004, "Wrong alignment on DCCommunityBlockWidget_GetMaxPage");
static_assert(sizeof(DCCommunityBlockWidget_GetMaxPage) == 0x000004, "Wrong size on DCCommunityBlockWidget_GetMaxPage");
static_assert(offsetof(DCCommunityBlockWidget_GetMaxPage, ReturnValue) == 0x000000, "Member 'DCCommunityBlockWidget_GetMaxPage::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCommunityBlockWidget.NumItemsPerPage
// 0x0004 (0x0004 - 0x0000)
struct DCCommunityBlockWidget_NumItemsPerPage final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCommunityBlockWidget_NumItemsPerPage) == 0x000004, "Wrong alignment on DCCommunityBlockWidget_NumItemsPerPage");
static_assert(sizeof(DCCommunityBlockWidget_NumItemsPerPage) == 0x000004, "Wrong size on DCCommunityBlockWidget_NumItemsPerPage");
static_assert(offsetof(DCCommunityBlockWidget_NumItemsPerPage, ReturnValue) == 0x000000, "Member 'DCCommunityBlockWidget_NumItemsPerPage::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCommunityBlockWidget.OnEntryHovered
// 0x0010 (0x0010 - 0x0000)
struct DCCommunityBlockWidget_OnEntryHovered final
{
public:
	class UObject*                                WidgetData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHovered;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25DB[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCCommunityBlockWidget_OnEntryHovered) == 0x000008, "Wrong alignment on DCCommunityBlockWidget_OnEntryHovered");
static_assert(sizeof(DCCommunityBlockWidget_OnEntryHovered) == 0x000010, "Wrong size on DCCommunityBlockWidget_OnEntryHovered");
static_assert(offsetof(DCCommunityBlockWidget_OnEntryHovered, WidgetData) == 0x000000, "Member 'DCCommunityBlockWidget_OnEntryHovered::WidgetData' has a wrong offset!");
static_assert(offsetof(DCCommunityBlockWidget_OnEntryHovered, bIsHovered) == 0x000008, "Member 'DCCommunityBlockWidget_OnEntryHovered::bIsHovered' has a wrong offset!");

// Function DungeonCrawler.DCContextComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCContextComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCContextComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCContextComponent_BroadcastMsgBlueprint");
static_assert(sizeof(DCContextComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCContextComponent_BroadcastMsgBlueprint");
static_assert(offsetof(DCContextComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCContextComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCContextComponent.OnContextMenuHolderVisibilityChaned
// 0x0001 (0x0001 - 0x0000)
struct DCContextComponent_OnContextMenuHolderVisibilityChaned final
{
public:
	ESlateVisibility                              Visibility;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCContextComponent_OnContextMenuHolderVisibilityChaned) == 0x000001, "Wrong alignment on DCContextComponent_OnContextMenuHolderVisibilityChaned");
static_assert(sizeof(DCContextComponent_OnContextMenuHolderVisibilityChaned) == 0x000001, "Wrong size on DCContextComponent_OnContextMenuHolderVisibilityChaned");
static_assert(offsetof(DCContextComponent_OnContextMenuHolderVisibilityChaned, Visibility) == 0x000000, "Member 'DCContextComponent_OnContextMenuHolderVisibilityChaned::Visibility' has a wrong offset!");

// Function DungeonCrawler.DCContextComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCContextComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCContextComponent_UnbindMsg) == 0x000008, "Wrong alignment on DCContextComponent_UnbindMsg");
static_assert(sizeof(DCContextComponent_UnbindMsg) == 0x000010, "Wrong size on DCContextComponent_UnbindMsg");
static_assert(offsetof(DCContextComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'DCContextComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCContextComponent_UnbindMsg, InObject) == 0x000008, "Member 'DCContextComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCContextComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCContextComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCContextComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on DCContextComponent_UnbindMsgAll");
static_assert(sizeof(DCContextComponent_UnbindMsgAll) == 0x000008, "Wrong size on DCContextComponent_UnbindMsgAll");
static_assert(offsetof(DCContextComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'DCContextComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionComboBoxWidget.AddComboBox
// 0x0010 (0x0010 - 0x0000)
struct GameMenuOptionComboBoxWidget_AddComboBox final
{
public:
	class FString                                 InComboBoxData;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionComboBoxWidget_AddComboBox) == 0x000008, "Wrong alignment on GameMenuOptionComboBoxWidget_AddComboBox");
static_assert(sizeof(GameMenuOptionComboBoxWidget_AddComboBox) == 0x000010, "Wrong size on GameMenuOptionComboBoxWidget_AddComboBox");
static_assert(offsetof(GameMenuOptionComboBoxWidget_AddComboBox, InComboBoxData) == 0x000000, "Member 'GameMenuOptionComboBoxWidget_AddComboBox::InComboBoxData' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionComboBoxWidget.GetPrimaryGamepadFocusWidget
// 0x0008 (0x0008 - 0x0000)
struct GameMenuOptionComboBoxWidget_GetPrimaryGamepadFocusWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionComboBoxWidget_GetPrimaryGamepadFocusWidget) == 0x000008, "Wrong alignment on GameMenuOptionComboBoxWidget_GetPrimaryGamepadFocusWidget");
static_assert(sizeof(GameMenuOptionComboBoxWidget_GetPrimaryGamepadFocusWidget) == 0x000008, "Wrong size on GameMenuOptionComboBoxWidget_GetPrimaryGamepadFocusWidget");
static_assert(offsetof(GameMenuOptionComboBoxWidget_GetPrimaryGamepadFocusWidget, ReturnValue) == 0x000000, "Member 'GameMenuOptionComboBoxWidget_GetPrimaryGamepadFocusWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionComboBoxWidget.GetSelectedComboBoxIndex
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionComboBoxWidget_GetSelectedComboBoxIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionComboBoxWidget_GetSelectedComboBoxIndex) == 0x000004, "Wrong alignment on GameMenuOptionComboBoxWidget_GetSelectedComboBoxIndex");
static_assert(sizeof(GameMenuOptionComboBoxWidget_GetSelectedComboBoxIndex) == 0x000004, "Wrong size on GameMenuOptionComboBoxWidget_GetSelectedComboBoxIndex");
static_assert(offsetof(GameMenuOptionComboBoxWidget_GetSelectedComboBoxIndex, ReturnValue) == 0x000000, "Member 'GameMenuOptionComboBoxWidget_GetSelectedComboBoxIndex::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionComboBoxWidget.GetSelectedComboBoxText
// 0x0010 (0x0010 - 0x0000)
struct GameMenuOptionComboBoxWidget_GetSelectedComboBoxText final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionComboBoxWidget_GetSelectedComboBoxText) == 0x000008, "Wrong alignment on GameMenuOptionComboBoxWidget_GetSelectedComboBoxText");
static_assert(sizeof(GameMenuOptionComboBoxWidget_GetSelectedComboBoxText) == 0x000010, "Wrong size on GameMenuOptionComboBoxWidget_GetSelectedComboBoxText");
static_assert(offsetof(GameMenuOptionComboBoxWidget_GetSelectedComboBoxText, ReturnValue) == 0x000000, "Member 'GameMenuOptionComboBoxWidget_GetSelectedComboBoxText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetComboBoxIndex
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionComboBoxWidget_SetComboBoxIndex final
{
public:
	int32                                         InIndex;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionComboBoxWidget_SetComboBoxIndex) == 0x000004, "Wrong alignment on GameMenuOptionComboBoxWidget_SetComboBoxIndex");
static_assert(sizeof(GameMenuOptionComboBoxWidget_SetComboBoxIndex) == 0x000004, "Wrong size on GameMenuOptionComboBoxWidget_SetComboBoxIndex");
static_assert(offsetof(GameMenuOptionComboBoxWidget_SetComboBoxIndex, InIndex) == 0x000000, "Member 'GameMenuOptionComboBoxWidget_SetComboBoxIndex::InIndex' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetComboBoxList
// 0x0010 (0x0010 - 0x0000)
struct GameMenuOptionComboBoxWidget_SetComboBoxList final
{
public:
	TArray<class FString>                         InComboBoxDataList;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionComboBoxWidget_SetComboBoxList) == 0x000008, "Wrong alignment on GameMenuOptionComboBoxWidget_SetComboBoxList");
static_assert(sizeof(GameMenuOptionComboBoxWidget_SetComboBoxList) == 0x000010, "Wrong size on GameMenuOptionComboBoxWidget_SetComboBoxList");
static_assert(offsetof(GameMenuOptionComboBoxWidget_SetComboBoxList, InComboBoxDataList) == 0x000000, "Member 'GameMenuOptionComboBoxWidget_SetComboBoxList::InComboBoxDataList' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetSelectedOption
// 0x0010 (0x0010 - 0x0000)
struct GameMenuOptionComboBoxWidget_SetSelectedOption final
{
public:
	class FString                                 Option;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionComboBoxWidget_SetSelectedOption) == 0x000008, "Wrong alignment on GameMenuOptionComboBoxWidget_SetSelectedOption");
static_assert(sizeof(GameMenuOptionComboBoxWidget_SetSelectedOption) == 0x000010, "Wrong size on GameMenuOptionComboBoxWidget_SetSelectedOption");
static_assert(offsetof(GameMenuOptionComboBoxWidget_SetSelectedOption, Option) == 0x000000, "Member 'GameMenuOptionComboBoxWidget_SetSelectedOption::Option' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetTitle
// 0x0018 (0x0018 - 0x0000)
struct GameMenuOptionComboBoxWidget_SetTitle final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionComboBoxWidget_SetTitle) == 0x000008, "Wrong alignment on GameMenuOptionComboBoxWidget_SetTitle");
static_assert(sizeof(GameMenuOptionComboBoxWidget_SetTitle) == 0x000018, "Wrong size on GameMenuOptionComboBoxWidget_SetTitle");
static_assert(offsetof(GameMenuOptionComboBoxWidget_SetTitle, InText) == 0x000000, "Member 'GameMenuOptionComboBoxWidget_SetTitle::InText' has a wrong offset!");

// Function DungeonCrawler.DCCountButtonWidget.SetCount
// 0x0004 (0x0004 - 0x0000)
struct DCCountButtonWidget_SetCount final
{
public:
	int32                                         InCount;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCountButtonWidget_SetCount) == 0x000004, "Wrong alignment on DCCountButtonWidget_SetCount");
static_assert(sizeof(DCCountButtonWidget_SetCount) == 0x000004, "Wrong size on DCCountButtonWidget_SetCount");
static_assert(offsetof(DCCountButtonWidget_SetCount, InCount) == 0x000000, "Member 'DCCountButtonWidget_SetCount::InCount' has a wrong offset!");

// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnCheckBoxStateChanged
// 0x0001 (0x0001 - 0x0000)
struct DCCrossPlatformLinkPopup_OnCheckBoxStateChanged final
{
public:
	bool                                          bIsChecked;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCrossPlatformLinkPopup_OnCheckBoxStateChanged) == 0x000001, "Wrong alignment on DCCrossPlatformLinkPopup_OnCheckBoxStateChanged");
static_assert(sizeof(DCCrossPlatformLinkPopup_OnCheckBoxStateChanged) == 0x000001, "Wrong size on DCCrossPlatformLinkPopup_OnCheckBoxStateChanged");
static_assert(offsetof(DCCrossPlatformLinkPopup_OnCheckBoxStateChanged, bIsChecked) == 0x000000, "Member 'DCCrossPlatformLinkPopup_OnCheckBoxStateChanged::bIsChecked' has a wrong offset!");

// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnStateChanged
// 0x0001 (0x0001 - 0x0000)
struct DCCrossPlatformLinkPopup_OnStateChanged final
{
public:
	EDCCrossPlatfromLinkPopupState                InState;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCrossPlatformLinkPopup_OnStateChanged) == 0x000001, "Wrong alignment on DCCrossPlatformLinkPopup_OnStateChanged");
static_assert(sizeof(DCCrossPlatformLinkPopup_OnStateChanged) == 0x000001, "Wrong size on DCCrossPlatformLinkPopup_OnStateChanged");
static_assert(offsetof(DCCrossPlatformLinkPopup_OnStateChanged, InState) == 0x000000, "Member 'DCCrossPlatformLinkPopup_OnStateChanged::InState' has a wrong offset!");

// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnTextChangedLickCode
// 0x0018 (0x0018 - 0x0000)
struct DCCrossPlatformLinkPopup_OnTextChangedLickCode final
{
public:
	class FText                                   InLinkCode;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCrossPlatformLinkPopup_OnTextChangedLickCode) == 0x000008, "Wrong alignment on DCCrossPlatformLinkPopup_OnTextChangedLickCode");
static_assert(sizeof(DCCrossPlatformLinkPopup_OnTextChangedLickCode) == 0x000018, "Wrong size on DCCrossPlatformLinkPopup_OnTextChangedLickCode");
static_assert(offsetof(DCCrossPlatformLinkPopup_OnTextChangedLickCode, InLinkCode) == 0x000000, "Member 'DCCrossPlatformLinkPopup_OnTextChangedLickCode::InLinkCode' has a wrong offset!");

// Function DungeonCrawler.DCHitBoxComponent.GetClosestLocationOnMesh
// 0x0108 (0x0108 - 0x0000)
struct DCHitBoxComponent_GetClosestLocationOnMesh final
{
public:
	struct FHitResult                             InHitResult;                                       // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	const class AActor*                           Instigator;                                        // 0x00E8(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x00F0(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCHitBoxComponent_GetClosestLocationOnMesh) == 0x000008, "Wrong alignment on DCHitBoxComponent_GetClosestLocationOnMesh");
static_assert(sizeof(DCHitBoxComponent_GetClosestLocationOnMesh) == 0x000108, "Wrong size on DCHitBoxComponent_GetClosestLocationOnMesh");
static_assert(offsetof(DCHitBoxComponent_GetClosestLocationOnMesh, InHitResult) == 0x000000, "Member 'DCHitBoxComponent_GetClosestLocationOnMesh::InHitResult' has a wrong offset!");
static_assert(offsetof(DCHitBoxComponent_GetClosestLocationOnMesh, Instigator) == 0x0000E8, "Member 'DCHitBoxComponent_GetClosestLocationOnMesh::Instigator' has a wrong offset!");
static_assert(offsetof(DCHitBoxComponent_GetClosestLocationOnMesh, ReturnValue) == 0x0000F0, "Member 'DCHitBoxComponent_GetClosestLocationOnMesh::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCHitBoxComponent.GetHitDirection
// 0x0020 (0x0020 - 0x0000)
struct DCHitBoxComponent_GetHitDirection final
{
public:
	struct FVector                                AttackerLocation;                                  // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitDirection                                 ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25EA[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCHitBoxComponent_GetHitDirection) == 0x000008, "Wrong alignment on DCHitBoxComponent_GetHitDirection");
static_assert(sizeof(DCHitBoxComponent_GetHitDirection) == 0x000020, "Wrong size on DCHitBoxComponent_GetHitDirection");
static_assert(offsetof(DCHitBoxComponent_GetHitDirection, AttackerLocation) == 0x000000, "Member 'DCHitBoxComponent_GetHitDirection::AttackerLocation' has a wrong offset!");
static_assert(offsetof(DCHitBoxComponent_GetHitDirection, ReturnValue) == 0x000018, "Member 'DCHitBoxComponent_GetHitDirection::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCHitBoxComponent.GetHitResultFromClosestLocationTraceOnMesh
// 0x01D8 (0x01D8 - 0x0000)
struct DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh final
{
public:
	struct FHitResult                             InHitResult;                                       // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	const class AActor*                           Instigator;                                        // 0x00E8(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             ReturnValue;                                       // 0x00F0(0x00E8)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh) == 0x000008, "Wrong alignment on DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh");
static_assert(sizeof(DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh) == 0x0001D8, "Wrong size on DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh");
static_assert(offsetof(DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh, InHitResult) == 0x000000, "Member 'DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh::InHitResult' has a wrong offset!");
static_assert(offsetof(DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh, Instigator) == 0x0000E8, "Member 'DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh::Instigator' has a wrong offset!");
static_assert(offsetof(DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh, ReturnValue) == 0x0000F0, "Member 'DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeActionSkinListWidget.OnSetActionSkinInfoArray
// 0x0010 (0x0010 - 0x0000)
struct DCCustomizeActionSkinListWidget_OnSetActionSkinInfoArray final
{
public:
	TArray<struct FDCActionSkinInfo>              ActionSkinInfoArray;                               // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeActionSkinListWidget_OnSetActionSkinInfoArray) == 0x000008, "Wrong alignment on DCCustomizeActionSkinListWidget_OnSetActionSkinInfoArray");
static_assert(sizeof(DCCustomizeActionSkinListWidget_OnSetActionSkinInfoArray) == 0x000010, "Wrong size on DCCustomizeActionSkinListWidget_OnSetActionSkinInfoArray");
static_assert(offsetof(DCCustomizeActionSkinListWidget_OnSetActionSkinInfoArray, ActionSkinInfoArray) == 0x000000, "Member 'DCCustomizeActionSkinListWidget_OnSetActionSkinInfoArray::ActionSkinInfoArray' has a wrong offset!");

// Function DungeonCrawler.DCInGameQuestLogDealTableWidget.GetQuestState
// 0x0001 (0x0001 - 0x0000)
struct DCInGameQuestLogDealTableWidget_GetQuestState final
{
public:
	EDCQuestState                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInGameQuestLogDealTableWidget_GetQuestState) == 0x000001, "Wrong alignment on DCInGameQuestLogDealTableWidget_GetQuestState");
static_assert(sizeof(DCInGameQuestLogDealTableWidget_GetQuestState) == 0x000001, "Wrong size on DCInGameQuestLogDealTableWidget_GetQuestState");
static_assert(offsetof(DCInGameQuestLogDealTableWidget_GetQuestState, ReturnValue) == 0x000000, "Member 'DCInGameQuestLogDealTableWidget_GetQuestState::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeCharacterSkinListWidget.OnSetCharacterSkinInfoArray
// 0x0010 (0x0010 - 0x0000)
struct DCCustomizeCharacterSkinListWidget_OnSetCharacterSkinInfoArray final
{
public:
	TArray<struct FDCCharacterSkinInfo>           CharacterSkinInfoArray;                            // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeCharacterSkinListWidget_OnSetCharacterSkinInfoArray) == 0x000008, "Wrong alignment on DCCustomizeCharacterSkinListWidget_OnSetCharacterSkinInfoArray");
static_assert(sizeof(DCCustomizeCharacterSkinListWidget_OnSetCharacterSkinInfoArray) == 0x000010, "Wrong size on DCCustomizeCharacterSkinListWidget_OnSetCharacterSkinInfoArray");
static_assert(offsetof(DCCustomizeCharacterSkinListWidget_OnSetCharacterSkinInfoArray, CharacterSkinInfoArray) == 0x000000, "Member 'DCCustomizeCharacterSkinListWidget_OnSetCharacterSkinInfoArray::CharacterSkinInfoArray' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeEmoteListWidget.OnSetEmoteIdArray
// 0x0010 (0x0010 - 0x0000)
struct DCCustomizeEmoteListWidget_OnSetEmoteIdArray final
{
public:
	TArray<struct FDCEmoteInfo>                   EmoteIdArray;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeEmoteListWidget_OnSetEmoteIdArray) == 0x000008, "Wrong alignment on DCCustomizeEmoteListWidget_OnSetEmoteIdArray");
static_assert(sizeof(DCCustomizeEmoteListWidget_OnSetEmoteIdArray) == 0x000010, "Wrong size on DCCustomizeEmoteListWidget_OnSetEmoteIdArray");
static_assert(offsetof(DCCustomizeEmoteListWidget_OnSetEmoteIdArray, EmoteIdArray) == 0x000000, "Member 'DCCustomizeEmoteListWidget_OnSetEmoteIdArray::EmoteIdArray' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeItemSkinListWidget.OnChangedVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCCustomizeItemSkinListWidget_OnChangedVisibility final
{
public:
	ESlateVisibility                              InNewVisibility;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeItemSkinListWidget_OnChangedVisibility) == 0x000001, "Wrong alignment on DCCustomizeItemSkinListWidget_OnChangedVisibility");
static_assert(sizeof(DCCustomizeItemSkinListWidget_OnChangedVisibility) == 0x000001, "Wrong size on DCCustomizeItemSkinListWidget_OnChangedVisibility");
static_assert(offsetof(DCCustomizeItemSkinListWidget_OnChangedVisibility, InNewVisibility) == 0x000000, "Member 'DCCustomizeItemSkinListWidget_OnChangedVisibility::InNewVisibility' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeItemSkinListWidget.OnSetItemSkinInfoArray
// 0x0010 (0x0010 - 0x0000)
struct DCCustomizeItemSkinListWidget_OnSetItemSkinInfoArray final
{
public:
	TArray<struct FDCItemSkinInfo>                ItemSkinInfoArray;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeItemSkinListWidget_OnSetItemSkinInfoArray) == 0x000008, "Wrong alignment on DCCustomizeItemSkinListWidget_OnSetItemSkinInfoArray");
static_assert(sizeof(DCCustomizeItemSkinListWidget_OnSetItemSkinInfoArray) == 0x000010, "Wrong size on DCCustomizeItemSkinListWidget_OnSetItemSkinInfoArray");
static_assert(offsetof(DCCustomizeItemSkinListWidget_OnSetItemSkinInfoArray, ItemSkinInfoArray) == 0x000000, "Member 'DCCustomizeItemSkinListWidget_OnSetItemSkinInfoArray::ItemSkinInfoArray' has a wrong offset!");

// Function DungeonCrawler.DCIngameInventoryPageWidget.IsUnderDropArea
// 0x0018 (0x0018 - 0x0000)
struct DCIngameInventoryPageWidget_IsUnderDropArea final
{
public:
	struct FVector2D                              ScreenSpacePosition;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25F4[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCIngameInventoryPageWidget_IsUnderDropArea) == 0x000008, "Wrong alignment on DCIngameInventoryPageWidget_IsUnderDropArea");
static_assert(sizeof(DCIngameInventoryPageWidget_IsUnderDropArea) == 0x000018, "Wrong size on DCIngameInventoryPageWidget_IsUnderDropArea");
static_assert(offsetof(DCIngameInventoryPageWidget_IsUnderDropArea, ScreenSpacePosition) == 0x000000, "Member 'DCIngameInventoryPageWidget_IsUnderDropArea::ScreenSpacePosition' has a wrong offset!");
static_assert(offsetof(DCIngameInventoryPageWidget_IsUnderDropArea, ReturnValue) == 0x000010, "Member 'DCIngameInventoryPageWidget_IsUnderDropArea::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeLobbyEmoteListWidget.OnSetLobbyEmoteIdArray
// 0x0010 (0x0010 - 0x0000)
struct DCCustomizeLobbyEmoteListWidget_OnSetLobbyEmoteIdArray final
{
public:
	TArray<struct FDCLobbyEmoteInfo>              LobbyEmoteIdArray;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeLobbyEmoteListWidget_OnSetLobbyEmoteIdArray) == 0x000008, "Wrong alignment on DCCustomizeLobbyEmoteListWidget_OnSetLobbyEmoteIdArray");
static_assert(sizeof(DCCustomizeLobbyEmoteListWidget_OnSetLobbyEmoteIdArray) == 0x000010, "Wrong size on DCCustomizeLobbyEmoteListWidget_OnSetLobbyEmoteIdArray");
static_assert(offsetof(DCCustomizeLobbyEmoteListWidget_OnSetLobbyEmoteIdArray, LobbyEmoteIdArray) == 0x000000, "Member 'DCCustomizeLobbyEmoteListWidget_OnSetLobbyEmoteIdArray::LobbyEmoteIdArray' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeRadialSlotWidget.GetArrowVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCCustomizeRadialSlotWidget_GetArrowVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeRadialSlotWidget_GetArrowVisibility) == 0x000001, "Wrong alignment on DCCustomizeRadialSlotWidget_GetArrowVisibility");
static_assert(sizeof(DCCustomizeRadialSlotWidget_GetArrowVisibility) == 0x000001, "Wrong size on DCCustomizeRadialSlotWidget_GetArrowVisibility");
static_assert(offsetof(DCCustomizeRadialSlotWidget_GetArrowVisibility, ReturnValue) == 0x000000, "Member 'DCCustomizeRadialSlotWidget_GetArrowVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeRadialSlotWidget.GetHighlightVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCCustomizeRadialSlotWidget_GetHighlightVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeRadialSlotWidget_GetHighlightVisibility) == 0x000001, "Wrong alignment on DCCustomizeRadialSlotWidget_GetHighlightVisibility");
static_assert(sizeof(DCCustomizeRadialSlotWidget_GetHighlightVisibility) == 0x000001, "Wrong size on DCCustomizeRadialSlotWidget_GetHighlightVisibility");
static_assert(offsetof(DCCustomizeRadialSlotWidget_GetHighlightVisibility, ReturnValue) == 0x000000, "Member 'DCCustomizeRadialSlotWidget_GetHighlightVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeRadialSlotWidget.GetTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCCustomizeRadialSlotWidget_GetTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeRadialSlotWidget_GetTooltipWidget) == 0x000008, "Wrong alignment on DCCustomizeRadialSlotWidget_GetTooltipWidget");
static_assert(sizeof(DCCustomizeRadialSlotWidget_GetTooltipWidget) == 0x000008, "Wrong size on DCCustomizeRadialSlotWidget_GetTooltipWidget");
static_assert(offsetof(DCCustomizeRadialSlotWidget_GetTooltipWidget, ReturnValue) == 0x000000, "Member 'DCCustomizeRadialSlotWidget_GetTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeRadialSlotWidget.SetIconImageAngle
// 0x0004 (0x0004 - 0x0000)
struct DCCustomizeRadialSlotWidget_SetIconImageAngle final
{
public:
	float                                         NewAngle;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeRadialSlotWidget_SetIconImageAngle) == 0x000004, "Wrong alignment on DCCustomizeRadialSlotWidget_SetIconImageAngle");
static_assert(sizeof(DCCustomizeRadialSlotWidget_SetIconImageAngle) == 0x000004, "Wrong size on DCCustomizeRadialSlotWidget_SetIconImageAngle");
static_assert(offsetof(DCCustomizeRadialSlotWidget_SetIconImageAngle, NewAngle) == 0x000000, "Member 'DCCustomizeRadialSlotWidget_SetIconImageAngle::NewAngle' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeRadialSlotWidget.IsIconVisible
// 0x0001 (0x0001 - 0x0000)
struct DCCustomizeRadialSlotWidget_IsIconVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeRadialSlotWidget_IsIconVisible) == 0x000001, "Wrong alignment on DCCustomizeRadialSlotWidget_IsIconVisible");
static_assert(sizeof(DCCustomizeRadialSlotWidget_IsIconVisible) == 0x000001, "Wrong size on DCCustomizeRadialSlotWidget_IsIconVisible");
static_assert(offsetof(DCCustomizeRadialSlotWidget_IsIconVisible, ReturnValue) == 0x000000, "Member 'DCCustomizeRadialSlotWidget_IsIconVisible::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeRadialSlotWidget.IsPrewiewVisible
// 0x0001 (0x0001 - 0x0000)
struct DCCustomizeRadialSlotWidget_IsPrewiewVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeRadialSlotWidget_IsPrewiewVisible) == 0x000001, "Wrong alignment on DCCustomizeRadialSlotWidget_IsPrewiewVisible");
static_assert(sizeof(DCCustomizeRadialSlotWidget_IsPrewiewVisible) == 0x000001, "Wrong size on DCCustomizeRadialSlotWidget_IsPrewiewVisible");
static_assert(offsetof(DCCustomizeRadialSlotWidget_IsPrewiewVisible, ReturnValue) == 0x000000, "Member 'DCCustomizeRadialSlotWidget_IsPrewiewVisible::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeWidgetBase.AnyTabButtonSelected
// 0x0008 (0x0008 - 0x0000)
struct DCCustomizeWidgetBase_AnyTabButtonSelected final
{
public:
	class FName                                   InTabButtonId;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeWidgetBase_AnyTabButtonSelected) == 0x000004, "Wrong alignment on DCCustomizeWidgetBase_AnyTabButtonSelected");
static_assert(sizeof(DCCustomizeWidgetBase_AnyTabButtonSelected) == 0x000008, "Wrong size on DCCustomizeWidgetBase_AnyTabButtonSelected");
static_assert(offsetof(DCCustomizeWidgetBase_AnyTabButtonSelected, InTabButtonId) == 0x000000, "Member 'DCCustomizeWidgetBase_AnyTabButtonSelected::InTabButtonId' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeWidgetBase.IsCustomizeFirstPage
// 0x0001 (0x0001 - 0x0000)
struct DCCustomizeWidgetBase_IsCustomizeFirstPage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeWidgetBase_IsCustomizeFirstPage) == 0x000001, "Wrong alignment on DCCustomizeWidgetBase_IsCustomizeFirstPage");
static_assert(sizeof(DCCustomizeWidgetBase_IsCustomizeFirstPage) == 0x000001, "Wrong size on DCCustomizeWidgetBase_IsCustomizeFirstPage");
static_assert(offsetof(DCCustomizeWidgetBase_IsCustomizeFirstPage, ReturnValue) == 0x000000, "Member 'DCCustomizeWidgetBase_IsCustomizeFirstPage::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeWidgetBase.IsCustomizeLastPage
// 0x0001 (0x0001 - 0x0000)
struct DCCustomizeWidgetBase_IsCustomizeLastPage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeWidgetBase_IsCustomizeLastPage) == 0x000001, "Wrong alignment on DCCustomizeWidgetBase_IsCustomizeLastPage");
static_assert(sizeof(DCCustomizeWidgetBase_IsCustomizeLastPage) == 0x000001, "Wrong size on DCCustomizeWidgetBase_IsCustomizeLastPage");
static_assert(offsetof(DCCustomizeWidgetBase_IsCustomizeLastPage, ReturnValue) == 0x000000, "Member 'DCCustomizeWidgetBase_IsCustomizeLastPage::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCCustomizeWidgetBase.UpdateCustomizeMaxPageIndex
// 0x0008 (0x0008 - 0x0000)
struct DCCustomizeWidgetBase_UpdateCustomizeMaxPageIndex final
{
public:
	class FName                                   InTabButtonId;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCCustomizeWidgetBase_UpdateCustomizeMaxPageIndex) == 0x000004, "Wrong alignment on DCCustomizeWidgetBase_UpdateCustomizeMaxPageIndex");
static_assert(sizeof(DCCustomizeWidgetBase_UpdateCustomizeMaxPageIndex) == 0x000008, "Wrong size on DCCustomizeWidgetBase_UpdateCustomizeMaxPageIndex");
static_assert(offsetof(DCCustomizeWidgetBase_UpdateCustomizeMaxPageIndex, InTabButtonId) == 0x000000, "Member 'DCCustomizeWidgetBase_UpdateCustomizeMaxPageIndex::InTabButtonId' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.AccountIdToString
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_AccountIdToString final
{
public:
	struct FDCAccountId                           Value;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_AccountIdToString) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_AccountIdToString");
static_assert(sizeof(DCDataBlueprintLibrary_AccountIdToString) == 0x000020, "Wrong size on DCDataBlueprintLibrary_AccountIdToString");
static_assert(offsetof(DCDataBlueprintLibrary_AccountIdToString, Value) == 0x000000, "Member 'DCDataBlueprintLibrary_AccountIdToString::Value' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_AccountIdToString, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_AccountIdToString::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.CanAddStack
// 0x0170 (0x0170 - 0x0000)
struct DCDataBlueprintLibrary_CanAddStack final
{
public:
	struct FDCItemInfo                            ItemInfo;                                          // 0x0000(0x0168)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stack;                                             // 0x0168(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x016C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25FA[0x3];                                     // 0x016D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCDataBlueprintLibrary_CanAddStack) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_CanAddStack");
static_assert(sizeof(DCDataBlueprintLibrary_CanAddStack) == 0x000170, "Wrong size on DCDataBlueprintLibrary_CanAddStack");
static_assert(offsetof(DCDataBlueprintLibrary_CanAddStack, ItemInfo) == 0x000000, "Member 'DCDataBlueprintLibrary_CanAddStack::ItemInfo' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_CanAddStack, Stack) == 0x000168, "Member 'DCDataBlueprintLibrary_CanAddStack::Stack' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_CanAddStack, ReturnValue) == 0x00016C, "Member 'DCDataBlueprintLibrary_CanAddStack::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.FindActorFromActorClassList
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_FindActorFromActorClassList final
{
public:
	const class AActor*                           InActor;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             InActorClassList;                                  // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25FB[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCDataBlueprintLibrary_FindActorFromActorClassList) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_FindActorFromActorClassList");
static_assert(sizeof(DCDataBlueprintLibrary_FindActorFromActorClassList) == 0x000020, "Wrong size on DCDataBlueprintLibrary_FindActorFromActorClassList");
static_assert(offsetof(DCDataBlueprintLibrary_FindActorFromActorClassList, InActor) == 0x000000, "Member 'DCDataBlueprintLibrary_FindActorFromActorClassList::InActor' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_FindActorFromActorClassList, InActorClassList) == 0x000008, "Member 'DCDataBlueprintLibrary_FindActorFromActorClassList::InActorClassList' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_FindActorFromActorClassList, ReturnValue) == 0x000018, "Member 'DCDataBlueprintLibrary_FindActorFromActorClassList::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetActionSkinIdArray
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_GetActionSkinIdArray final
{
public:
	TArray<struct FPrimaryAssetId>                OutActionSkinIdArray;                              // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetActionSkinIdArray) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetActionSkinIdArray");
static_assert(sizeof(DCDataBlueprintLibrary_GetActionSkinIdArray) == 0x000010, "Wrong size on DCDataBlueprintLibrary_GetActionSkinIdArray");
static_assert(offsetof(DCDataBlueprintLibrary_GetActionSkinIdArray, OutActionSkinIdArray) == 0x000000, "Member 'DCDataBlueprintLibrary_GetActionSkinIdArray::OutActionSkinIdArray' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetArmorSkinIdArray
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_GetArmorSkinIdArray final
{
public:
	TArray<struct FPrimaryAssetId>                OutArmorSkinIdArray;                               // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetArmorSkinIdArray) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetArmorSkinIdArray");
static_assert(sizeof(DCDataBlueprintLibrary_GetArmorSkinIdArray) == 0x000010, "Wrong size on DCDataBlueprintLibrary_GetArmorSkinIdArray");
static_assert(offsetof(DCDataBlueprintLibrary_GetArmorSkinIdArray, OutArmorSkinIdArray) == 0x000000, "Member 'DCDataBlueprintLibrary_GetArmorSkinIdArray::OutArmorSkinIdArray' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetAttackTypeText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetAttackTypeText final
{
public:
	struct FGameplayTag                           InAttackTypeTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetAttackTypeText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetAttackTypeText");
static_assert(sizeof(DCDataBlueprintLibrary_GetAttackTypeText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetAttackTypeText");
static_assert(offsetof(DCDataBlueprintLibrary_GetAttackTypeText, InAttackTypeTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetAttackTypeText::InAttackTypeTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetAttackTypeText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetAttackTypeText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetAttackTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetAttackTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetAttackTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetAttackTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetAttackTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetAttackTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetAttackTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetAttackTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetAttributeText
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetAttributeText final
{
public:
	struct FGameplayAttribute                     Attribute;                                         // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0038(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetAttributeText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetAttributeText");
static_assert(sizeof(DCDataBlueprintLibrary_GetAttributeText) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetAttributeText");
static_assert(offsetof(DCDataBlueprintLibrary_GetAttributeText, Attribute) == 0x000000, "Member 'DCDataBlueprintLibrary_GetAttributeText::Attribute' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetAttributeText, ReturnValue) == 0x000038, "Member 'DCDataBlueprintLibrary_GetAttributeText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetAttributeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetAttributeTextMap final
{
public:
	TMap<struct FGameplayAttribute, class FText>  ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetAttributeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetAttributeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetAttributeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetAttributeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetAttributeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetAttributeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetCharacterClassText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetCharacterClassText final
{
public:
	EDCCharacterClass                             InClass;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25FC[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetCharacterClassText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetCharacterClassText");
static_assert(sizeof(DCDataBlueprintLibrary_GetCharacterClassText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetCharacterClassText");
static_assert(offsetof(DCDataBlueprintLibrary_GetCharacterClassText, InClass) == 0x000000, "Member 'DCDataBlueprintLibrary_GetCharacterClassText::InClass' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetCharacterClassText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetCharacterClassText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetCharacterSkinIdArray
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_GetCharacterSkinIdArray final
{
public:
	TArray<struct FPrimaryAssetId>                OutCharacterSkinIdArray;                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetCharacterSkinIdArray) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetCharacterSkinIdArray");
static_assert(sizeof(DCDataBlueprintLibrary_GetCharacterSkinIdArray) == 0x000010, "Wrong size on DCDataBlueprintLibrary_GetCharacterSkinIdArray");
static_assert(offsetof(DCDataBlueprintLibrary_GetCharacterSkinIdArray, OutCharacterSkinIdArray) == 0x000000, "Member 'DCDataBlueprintLibrary_GetCharacterSkinIdArray::OutCharacterSkinIdArray' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetConstantFloat
// 0x0014 (0x0014 - 0x0000)
struct DCDataBlueprintLibrary_GetConstantFloat final
{
public:
	struct FPrimaryAssetId                        InConstantId;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetConstantFloat) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetConstantFloat");
static_assert(sizeof(DCDataBlueprintLibrary_GetConstantFloat) == 0x000014, "Wrong size on DCDataBlueprintLibrary_GetConstantFloat");
static_assert(offsetof(DCDataBlueprintLibrary_GetConstantFloat, InConstantId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetConstantFloat::InConstantId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetConstantFloat, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetConstantFloat::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetConstantInt32
// 0x0014 (0x0014 - 0x0000)
struct DCDataBlueprintLibrary_GetConstantInt32 final
{
public:
	struct FPrimaryAssetId                        InConstantId;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetConstantInt32) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetConstantInt32");
static_assert(sizeof(DCDataBlueprintLibrary_GetConstantInt32) == 0x000014, "Wrong size on DCDataBlueprintLibrary_GetConstantInt32");
static_assert(offsetof(DCDataBlueprintLibrary_GetConstantInt32, InConstantId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetConstantInt32::InConstantId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetConstantInt32, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetConstantInt32::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDescData
// 0x0018 (0x0018 - 0x0000)
struct DCDataBlueprintLibrary_GetDescData final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDescData*                        ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDescData) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDescData");
static_assert(sizeof(DCDataBlueprintLibrary_GetDescData) == 0x000018, "Wrong size on DCDataBlueprintLibrary_GetDescData");
static_assert(offsetof(DCDataBlueprintLibrary_GetDescData, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDescData::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDescData, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDescData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataAssetItemRequirement
// 0x0018 (0x0018 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataAssetItemRequirement final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDesignDataAssetItemRequirement*        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataAssetItemRequirement) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataAssetItemRequirement");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataAssetItemRequirement) == 0x000018, "Wrong size on DCDataBlueprintLibrary_GetDesignDataAssetItemRequirement");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataAssetItemRequirement, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataAssetItemRequirement::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataAssetItemRequirement, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataAssetItemRequirement::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataBaseItem
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataBaseItem final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataBaseItem                    ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataBaseItem) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataBaseItem");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataBaseItem) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetDesignDataBaseItem");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataBaseItem, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataBaseItem::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataBaseItem, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataBaseItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataEmote
// 0x0078 (0x0078 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataEmote final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataEmote                       ReturnValue;                                       // 0x0010(0x0068)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataEmote) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataEmote");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataEmote) == 0x000078, "Wrong size on DCDataBlueprintLibrary_GetDesignDataEmote");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataEmote, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataEmote::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataEmote, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataEmote::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataGameplayAbility
// 0x0078 (0x0078 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataGameplayAbility final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataGameplayAbility             ReturnValue;                                       // 0x0010(0x0068)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataGameplayAbility) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataGameplayAbility");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataGameplayAbility) == 0x000078, "Wrong size on DCDataBlueprintLibrary_GetDesignDataGameplayAbility");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataGameplayAbility, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataGameplayAbility::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataGameplayAbility, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataGameplayAbility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataGameplayEffect
// 0x02B0 (0x02B0 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataGameplayEffect final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataGameplayEffect              ReturnValue;                                       // 0x0010(0x02A0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataGameplayEffect) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataGameplayEffect");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataGameplayEffect) == 0x0002B0, "Wrong size on DCDataBlueprintLibrary_GetDesignDataGameplayEffect");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataGameplayEffect, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataGameplayEffect::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataGameplayEffect, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataGameplayEffect::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataGEModifier
// 0x0038 (0x0038 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataGEModifier final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataGEModifier                  ReturnValue;                                       // 0x0010(0x0028)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataGEModifier) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataGEModifier");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataGEModifier) == 0x000038, "Wrong size on DCDataBlueprintLibrary_GetDesignDataGEModifier");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataGEModifier, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataGEModifier::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataGEModifier, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataGEModifier::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItem
// 0x01A8 (0x01A8 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataItem final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataItem                        ReturnValue;                                       // 0x0010(0x0198)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataItem) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataItem");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataItem) == 0x0001A8, "Wrong size on DCDataBlueprintLibrary_GetDesignDataItem");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItem, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataItem::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItem, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemConsume
// 0x0030 (0x0030 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataItemConsume final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataItemConsume                 ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataItemConsume) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataItemConsume");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataItemConsume) == 0x000030, "Wrong size on DCDataBlueprintLibrary_GetDesignDataItemConsume");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemConsume, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataItemConsume::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemConsume, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataItemConsume::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemContainer
// 0x0024 (0x0024 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataItemContainer final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataItemContainer               ReturnValue;                                       // 0x0010(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataItemContainer) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataItemContainer");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataItemContainer) == 0x000024, "Wrong size on DCDataBlueprintLibrary_GetDesignDataItemContainer");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemContainer, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataItemContainer::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemContainer, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataItemContainer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemIdsByGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag final
{
public:
	struct FGameplayTag                           ItemGameplayTag;                                   // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                ReturnValue;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag) == 0x000018, "Wrong size on DCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag, ItemGameplayTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag::ItemGameplayTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemProperty
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataItemProperty final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataItemProperty                ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataItemProperty) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataItemProperty");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataItemProperty) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetDesignDataItemProperty");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemProperty, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataItemProperty::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemProperty, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataItemProperty::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemPropertyType
// 0x0070 (0x0070 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataItemPropertyType final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataItemPropertyType            ReturnValue;                                       // 0x0010(0x0060)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataItemPropertyType) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataItemPropertyType");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataItemPropertyType) == 0x000070, "Wrong size on DCDataBlueprintLibrary_GetDesignDataItemPropertyType");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemPropertyType, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataItemPropertyType::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemPropertyType, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataItemPropertyType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemRequirement
// 0x0068 (0x0068 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataItemRequirement final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataItemRequirement             ReturnValue;                                       // 0x0010(0x0058)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataItemRequirement) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataItemRequirement");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataItemRequirement) == 0x000068, "Wrong size on DCDataBlueprintLibrary_GetDesignDataItemRequirement");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemRequirement, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataItemRequirement::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataItemRequirement, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataItemRequirement::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMeleeAttack
// 0x0064 (0x0064 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataMeleeAttack final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataMeleeAttack                 ReturnValue;                                       // 0x0010(0x0054)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataMeleeAttack) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataMeleeAttack");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataMeleeAttack) == 0x000064, "Wrong size on DCDataBlueprintLibrary_GetDesignDataMeleeAttack");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataMeleeAttack, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataMeleeAttack::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataMeleeAttack, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataMeleeAttack::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMonster
// 0x00D0 (0x00D0 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataMonster final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataMonster                     ReturnValue;                                       // 0x0010(0x00C0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataMonster) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataMonster");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataMonster) == 0x0000D0, "Wrong size on DCDataBlueprintLibrary_GetDesignDataMonster");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataMonster, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataMonster::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataMonster, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataMonster::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMovementModifier
// 0x0028 (0x0028 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataMovementModifier final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataMovementModifier            ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataMovementModifier) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataMovementModifier");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataMovementModifier) == 0x000028, "Wrong size on DCDataBlueprintLibrary_GetDesignDataMovementModifier");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataMovementModifier, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataMovementModifier::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataMovementModifier, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataMovementModifier::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMusic
// 0x00D8 (0x00D8 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataMusic final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataMusic                       ReturnValue;                                       // 0x0010(0x00C8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataMusic) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataMusic");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataMusic) == 0x0000D8, "Wrong size on DCDataBlueprintLibrary_GetDesignDataMusic");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataMusic, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataMusic::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataMusic, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataMusic::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMusicMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataMusicMap final
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataMusic> OutDesignDataMusicMap;                             // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataMusicMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataMusicMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataMusicMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetDesignDataMusicMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataMusicMap, OutDesignDataMusicMap) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataMusicMap::OutDesignDataMusicMap' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPerk
// 0x00A8 (0x00A8 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataPerk final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataPerk                        ReturnValue;                                       // 0x0010(0x0098)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataPerk) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataPerk");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataPerk) == 0x0000A8, "Wrong size on DCDataBlueprintLibrary_GetDesignDataPerk");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataPerk, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataPerk::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataPerk, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataPerk::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPerkMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataPerkMap final
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataPerk> OutDesignDataPerkMap;                              // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataPerkMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataPerkMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataPerkMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetDesignDataPerkMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataPerkMap, OutDesignDataPerkMap) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataPerkMap::OutDesignDataPerkMap' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPlayerCharacter
// 0x0138 (0x0138 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataPlayerCharacter final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataPlayerCharacter             ReturnValue;                                       // 0x0010(0x0128)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataPlayerCharacter) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataPlayerCharacter");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataPlayerCharacter) == 0x000138, "Wrong size on DCDataBlueprintLibrary_GetDesignDataPlayerCharacter");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataPlayerCharacter, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataPlayerCharacter::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataPlayerCharacter, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataPlayerCharacter::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPlayerCharacterMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataPlayerCharacterMap final
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataPlayerCharacter> OutDesignDataPlayerCharacterMap;                   // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataPlayerCharacterMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataPlayerCharacterMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataPlayerCharacterMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetDesignDataPlayerCharacterMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataPlayerCharacterMap, OutDesignDataPlayerCharacterMap) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataPlayerCharacterMap::OutDesignDataPlayerCharacterMap' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataProps
// 0x00C0 (0x00C0 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataProps final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataProps                       ReturnValue;                                       // 0x0010(0x00B0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataProps) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataProps");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataProps) == 0x0000C0, "Wrong size on DCDataBlueprintLibrary_GetDesignDataProps");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataProps, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataProps::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataProps, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataProps::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPropsInteract
// 0x00D0 (0x00D0 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataPropsInteract final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataPropsInteract               ReturnValue;                                       // 0x0010(0x00C0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataPropsInteract) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataPropsInteract");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataPropsInteract) == 0x0000D0, "Wrong size on DCDataBlueprintLibrary_GetDesignDataPropsInteract");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataPropsInteract, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataPropsInteract::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataPropsInteract, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataPropsInteract::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPropsSkillCheck
// 0x0040 (0x0040 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataPropsSkillCheck final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataPropsSkillCheck             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataPropsSkillCheck) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataPropsSkillCheck");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataPropsSkillCheck) == 0x000040, "Wrong size on DCDataBlueprintLibrary_GetDesignDataPropsSkillCheck");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataPropsSkillCheck, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataPropsSkillCheck::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataPropsSkillCheck, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataPropsSkillCheck::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataShapeShiftMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataShapeShiftMap final
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataShapeShift> OutDesignDataShapeShiftMap;                        // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataShapeShiftMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataShapeShiftMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataShapeShiftMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetDesignDataShapeShiftMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataShapeShiftMap, OutDesignDataShapeShiftMap) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataShapeShiftMap::OutDesignDataShapeShiftMap' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSkill
// 0x00F0 (0x00F0 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataSkill final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataSkill                       ReturnValue;                                       // 0x0010(0x00E0)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataSkill) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataSkill");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataSkill) == 0x0000F0, "Wrong size on DCDataBlueprintLibrary_GetDesignDataSkill");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataSkill, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataSkill::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataSkill, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataSkill::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSkillMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataSkillMap final
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataSkill> OutDesignDataSkillMap;                             // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataSkillMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataSkillMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataSkillMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetDesignDataSkillMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataSkillMap, OutDesignDataSkillMap) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataSkillMap::OutDesignDataSkillMap' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSpell
// 0x00E8 (0x00E8 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataSpell final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDesignDataSpell                       ReturnValue;                                       // 0x0010(0x00D8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataSpell) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataSpell");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataSpell) == 0x0000E8, "Wrong size on DCDataBlueprintLibrary_GetDesignDataSpell");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataSpell, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataSpell::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataSpell, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetDesignDataSpell::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSpellMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetDesignDataSpellMap final
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataSpell> OutDesignDataSpellMap;                             // 0x0000(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDesignDataSpellMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDesignDataSpellMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetDesignDataSpellMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetDesignDataSpellMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetDesignDataSpellMap, OutDesignDataSpellMap) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDesignDataSpellMap::OutDesignDataSpellMap' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDungeonTextByIdTag
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetDungeonTextByIdTag final
{
public:
	struct FGameplayTag                           InIdTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDungeonTextByIdTag) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDungeonTextByIdTag");
static_assert(sizeof(DCDataBlueprintLibrary_GetDungeonTextByIdTag) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetDungeonTextByIdTag");
static_assert(offsetof(DCDataBlueprintLibrary_GetDungeonTextByIdTag, InIdTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDungeonTextByIdTag::InIdTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDungeonTextByIdTag, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetDungeonTextByIdTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDungeonTypeChapterText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetDungeonTypeChapterText final
{
public:
	struct FGameplayTag                           InIdTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDungeonTypeChapterText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDungeonTypeChapterText");
static_assert(sizeof(DCDataBlueprintLibrary_GetDungeonTypeChapterText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetDungeonTypeChapterText");
static_assert(offsetof(DCDataBlueprintLibrary_GetDungeonTypeChapterText, InIdTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDungeonTypeChapterText::InIdTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDungeonTypeChapterText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetDungeonTypeChapterText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDungeonTypeDescText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetDungeonTypeDescText final
{
public:
	struct FGameplayTag                           InIdTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDungeonTypeDescText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDungeonTypeDescText");
static_assert(sizeof(DCDataBlueprintLibrary_GetDungeonTypeDescText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetDungeonTypeDescText");
static_assert(offsetof(DCDataBlueprintLibrary_GetDungeonTypeDescText, InIdTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDungeonTypeDescText::InIdTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDungeonTypeDescText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetDungeonTypeDescText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDungeonTypeGroupText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetDungeonTypeGroupText final
{
public:
	struct FGameplayTag                           InIdTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDungeonTypeGroupText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDungeonTypeGroupText");
static_assert(sizeof(DCDataBlueprintLibrary_GetDungeonTypeGroupText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetDungeonTypeGroupText");
static_assert(offsetof(DCDataBlueprintLibrary_GetDungeonTypeGroupText, InIdTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDungeonTypeGroupText::InIdTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDungeonTypeGroupText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetDungeonTypeGroupText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetDungeonTypeText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetDungeonTypeText final
{
public:
	struct FGameplayTag                           InIdTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetDungeonTypeText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetDungeonTypeText");
static_assert(sizeof(DCDataBlueprintLibrary_GetDungeonTypeText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetDungeonTypeText");
static_assert(offsetof(DCDataBlueprintLibrary_GetDungeonTypeText, InIdTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetDungeonTypeText::InIdTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetDungeonTypeText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetDungeonTypeText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetEmoteIdArray
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_GetEmoteIdArray final
{
public:
	TArray<struct FPrimaryAssetId>                OutEmoteIdArray;                                   // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetEmoteIdArray) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetEmoteIdArray");
static_assert(sizeof(DCDataBlueprintLibrary_GetEmoteIdArray) == 0x000010, "Wrong size on DCDataBlueprintLibrary_GetEmoteIdArray");
static_assert(offsetof(DCDataBlueprintLibrary_GetEmoteIdArray, OutEmoteIdArray) == 0x000000, "Member 'DCDataBlueprintLibrary_GetEmoteIdArray::OutEmoteIdArray' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetFriendErrorMsgText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetFriendErrorMsgText final
{
public:
	int32                                         InResult;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25FD[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetFriendErrorMsgText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetFriendErrorMsgText");
static_assert(sizeof(DCDataBlueprintLibrary_GetFriendErrorMsgText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetFriendErrorMsgText");
static_assert(offsetof(DCDataBlueprintLibrary_GetFriendErrorMsgText, InResult) == 0x000000, "Member 'DCDataBlueprintLibrary_GetFriendErrorMsgText::InResult' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetFriendErrorMsgText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetFriendErrorMsgText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetGameplayTagByItemRarity
// 0x000C (0x000C - 0x0000)
struct DCDataBlueprintLibrary_GetGameplayTagByItemRarity final
{
public:
	EDCItemRarity                                 ItemRarity;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25FE[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetGameplayTagByItemRarity) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetGameplayTagByItemRarity");
static_assert(sizeof(DCDataBlueprintLibrary_GetGameplayTagByItemRarity) == 0x00000C, "Wrong size on DCDataBlueprintLibrary_GetGameplayTagByItemRarity");
static_assert(offsetof(DCDataBlueprintLibrary_GetGameplayTagByItemRarity, ItemRarity) == 0x000000, "Member 'DCDataBlueprintLibrary_GetGameplayTagByItemRarity::ItemRarity' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetGameplayTagByItemRarity, ReturnValue) == 0x000004, "Member 'DCDataBlueprintLibrary_GetGameplayTagByItemRarity::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetGameTypeGroupText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetGameTypeGroupText final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25FF[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetGameTypeGroupText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetGameTypeGroupText");
static_assert(sizeof(DCDataBlueprintLibrary_GetGameTypeGroupText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetGameTypeGroupText");
static_assert(offsetof(DCDataBlueprintLibrary_GetGameTypeGroupText, InGameType) == 0x000000, "Member 'DCDataBlueprintLibrary_GetGameTypeGroupText::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetGameTypeGroupText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetGameTypeGroupText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetGameTypeText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetGameTypeText final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2600[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetGameTypeText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetGameTypeText");
static_assert(sizeof(DCDataBlueprintLibrary_GetGameTypeText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetGameTypeText");
static_assert(offsetof(DCDataBlueprintLibrary_GetGameTypeText, InGameType) == 0x000000, "Member 'DCDataBlueprintLibrary_GetGameTypeText::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetGameTypeText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetGameTypeText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetHighRollerGameType
// 0x0002 (0x0002 - 0x0000)
struct DCDataBlueprintLibrary_GetHighRollerGameType final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetHighRollerGameType) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_GetHighRollerGameType");
static_assert(sizeof(DCDataBlueprintLibrary_GetHighRollerGameType) == 0x000002, "Wrong size on DCDataBlueprintLibrary_GetHighRollerGameType");
static_assert(offsetof(DCDataBlueprintLibrary_GetHighRollerGameType, InGameType) == 0x000000, "Member 'DCDataBlueprintLibrary_GetHighRollerGameType::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetHighRollerGameType, ReturnValue) == 0x000001, "Member 'DCDataBlueprintLibrary_GetHighRollerGameType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetIdTagGroupContainer
// 0x0030 (0x0030 - 0x0000)
struct DCDataBlueprintLibrary_GetIdTagGroupContainer final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetIdTagGroupContainer) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetIdTagGroupContainer");
static_assert(sizeof(DCDataBlueprintLibrary_GetIdTagGroupContainer) == 0x000030, "Wrong size on DCDataBlueprintLibrary_GetIdTagGroupContainer");
static_assert(offsetof(DCDataBlueprintLibrary_GetIdTagGroupContainer, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetIdTagGroupContainer::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetIdTagGroupContainer, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetIdTagGroupContainer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetIdTagText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetIdTagText final
{
public:
	struct FGameplayTag                           InIdTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetIdTagText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetIdTagText");
static_assert(sizeof(DCDataBlueprintLibrary_GetIdTagText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetIdTagText");
static_assert(offsetof(DCDataBlueprintLibrary_GetIdTagText, InIdTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetIdTagText::InIdTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetIdTagText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetIdTagText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemAccessoryTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetItemAccessoryTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemAccessoryTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemAccessoryTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemAccessoryTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetItemAccessoryTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemAccessoryTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemAccessoryTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemActorClass
// 0x0110 (0x0110 - 0x0000)
struct DCDataBlueprintLibrary_GetItemActorClass final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              ItemData;                                          // 0x0008(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemActor>                 ReturnValue;                                       // 0x0108(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemActorClass) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemActorClass");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemActorClass) == 0x000110, "Wrong size on DCDataBlueprintLibrary_GetItemActorClass");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemActorClass, OwnerActor) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemActorClass::OwnerActor' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemActorClass, ItemData) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemActorClass::ItemData' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemActorClass, ReturnValue) == 0x000108, "Member 'DCDataBlueprintLibrary_GetItemActorClass::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemArmorTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetItemArmorTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemArmorTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemArmorTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemArmorTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetItemArmorTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemArmorTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemArmorTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemArtData
// 0x0108 (0x0108 - 0x0000)
struct DCDataBlueprintLibrary_GetItemArtData final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UArtDataItem*                           ReturnValue;                                       // 0x0100(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemArtData) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemArtData");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemArtData) == 0x000108, "Wrong size on DCDataBlueprintLibrary_GetItemArtData");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemArtData, ItemData) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemArtData::ItemData' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemArtData, ReturnValue) == 0x000100, "Member 'DCDataBlueprintLibrary_GetItemArtData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemAvailableCount
// 0x0170 (0x0170 - 0x0000)
struct DCDataBlueprintLibrary_GetItemAvailableCount final
{
public:
	struct FDCItemInfo                            ItemInfo;                                          // 0x0000(0x0168)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0168(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2601[0x4];                                     // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemAvailableCount) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemAvailableCount");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemAvailableCount) == 0x000170, "Wrong size on DCDataBlueprintLibrary_GetItemAvailableCount");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemAvailableCount, ItemInfo) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemAvailableCount::ItemInfo' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemAvailableCount, ReturnValue) == 0x000168, "Member 'DCDataBlueprintLibrary_GetItemAvailableCount::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemData
// 0x0268 (0x0268 - 0x0000)
struct DCDataBlueprintLibrary_GetItemData final
{
public:
	struct FDCItemInfo                            ItemInfo;                                          // 0x0000(0x0168)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              ReturnValue;                                       // 0x0168(0x0100)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemData) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemData");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemData) == 0x000268, "Wrong size on DCDataBlueprintLibrary_GetItemData");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemData, ItemInfo) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemData::ItemInfo' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemData, ReturnValue) == 0x000168, "Member 'DCDataBlueprintLibrary_GetItemData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemDataEx
// 0x0270 (0x0270 - 0x0000)
struct DCDataBlueprintLibrary_GetItemDataEx final
{
public:
	struct FDCItemInfo                            ItemInfo;                                          // 0x0000(0x0168)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCInventoryId                                Inventory;                                         // 0x0168(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2602[0x3];                                     // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Slot;                                              // 0x016C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              ReturnValue;                                       // 0x0170(0x0100)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemDataEx) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemDataEx");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemDataEx) == 0x000270, "Wrong size on DCDataBlueprintLibrary_GetItemDataEx");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemDataEx, ItemInfo) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemDataEx::ItemInfo' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemDataEx, Inventory) == 0x000168, "Member 'DCDataBlueprintLibrary_GetItemDataEx::Inventory' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemDataEx, Slot) == 0x00016C, "Member 'DCDataBlueprintLibrary_GetItemDataEx::Slot' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemDataEx, ReturnValue) == 0x000170, "Member 'DCDataBlueprintLibrary_GetItemDataEx::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemEffectDefaultFormatTagContainer
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetItemEffectDefaultFormatTagContainer final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemEffectDefaultFormatTagContainer) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemEffectDefaultFormatTagContainer");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemEffectDefaultFormatTagContainer) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetItemEffectDefaultFormatTagContainer");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemEffectDefaultFormatTagContainer, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemEffectDefaultFormatTagContainer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemEffectPercentFormatTagContainer
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetItemEffectPercentFormatTagContainer final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemEffectPercentFormatTagContainer) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemEffectPercentFormatTagContainer");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemEffectPercentFormatTagContainer) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetItemEffectPercentFormatTagContainer");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemEffectPercentFormatTagContainer, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemEffectPercentFormatTagContainer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemEffectTimeFormatTagContainer
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetItemEffectTimeFormatTagContainer final
{
public:
	struct FGameplayTagContainer                  ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemEffectTimeFormatTagContainer) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemEffectTimeFormatTagContainer");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemEffectTimeFormatTagContainer) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetItemEffectTimeFormatTagContainer");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemEffectTimeFormatTagContainer, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemEffectTimeFormatTagContainer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemEffectValueText
// 0x0028 (0x0028 - 0x0000)
struct DCDataBlueprintLibrary_GetItemEffectValueText final
{
public:
	struct FGameplayTag                           InItemEffectTypeTag;                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InValue;                                           // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2603[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemEffectValueText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemEffectValueText");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemEffectValueText) == 0x000028, "Wrong size on DCDataBlueprintLibrary_GetItemEffectValueText");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemEffectValueText, InItemEffectTypeTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemEffectValueText::InItemEffectTypeTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemEffectValueText, InValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemEffectValueText::InValue' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemEffectValueText, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetItemEffectValueText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemHandTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetItemHandTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemHandTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemHandTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemHandTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetItemHandTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemHandTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemHandTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemIdTagText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetItemIdTagText final
{
public:
	struct FGameplayTag                           InIdTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemIdTagText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemIdTagText");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemIdTagText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetItemIdTagText");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemIdTagText, InIdTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemIdTagText::InIdTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemIdTagText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemIdTagText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemLootStateText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetItemLootStateText final
{
public:
	EDCItemLootState                              InLootState;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2604[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemLootStateText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemLootStateText");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemLootStateText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetItemLootStateText");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemLootStateText, InLootState) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemLootStateText::InLootState' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemLootStateText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemLootStateText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemMiscTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetItemMiscTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemMiscTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemMiscTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemMiscTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetItemMiscTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemMiscTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemMiscTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyItemTooltipText
// 0x0038 (0x0038 - 0x0000)
struct DCDataBlueprintLibrary_GetItemPropertyItemTooltipText final
{
public:
	struct FGameplayTag                           InItemPropertyTypeTag;                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InValueString;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPriamary;                                       // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2605[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemPropertyItemTooltipText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemPropertyItemTooltipText");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemPropertyItemTooltipText) == 0x000038, "Wrong size on DCDataBlueprintLibrary_GetItemPropertyItemTooltipText");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemPropertyItemTooltipText, InItemPropertyTypeTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemPropertyItemTooltipText::InItemPropertyTypeTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemPropertyItemTooltipText, InValueString) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemPropertyItemTooltipText::InValueString' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemPropertyItemTooltipText, bIsPriamary) == 0x000018, "Member 'DCDataBlueprintLibrary_GetItemPropertyItemTooltipText::bIsPriamary' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemPropertyItemTooltipText, ReturnValue) == 0x000020, "Member 'DCDataBlueprintLibrary_GetItemPropertyItemTooltipText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyTypeId_Unidentified
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_GetItemPropertyTypeId_Unidentified final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemPropertyTypeId_Unidentified) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetItemPropertyTypeId_Unidentified");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemPropertyTypeId_Unidentified) == 0x000010, "Wrong size on DCDataBlueprintLibrary_GetItemPropertyTypeId_Unidentified");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemPropertyTypeId_Unidentified, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemPropertyTypeId_Unidentified::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyTypeText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetItemPropertyTypeText final
{
public:
	struct FGameplayTag                           InItemPropertyTypeTag;                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemPropertyTypeText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemPropertyTypeText");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemPropertyTypeText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetItemPropertyTypeText");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemPropertyTypeText, InItemPropertyTypeTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemPropertyTypeText::InItemPropertyTypeTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemPropertyTypeText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemPropertyTypeText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyTypeTextFromAsset
// 0x0028 (0x0028 - 0x0000)
struct DCDataBlueprintLibrary_GetItemPropertyTypeTextFromAsset final
{
public:
	struct FPrimaryAssetId                        InItemPropertyTypeId;                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemPropertyTypeTextFromAsset) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemPropertyTypeTextFromAsset");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemPropertyTypeTextFromAsset) == 0x000028, "Wrong size on DCDataBlueprintLibrary_GetItemPropertyTypeTextFromAsset");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemPropertyTypeTextFromAsset, InItemPropertyTypeId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemPropertyTypeTextFromAsset::InItemPropertyTypeId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemPropertyTypeTextFromAsset, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetItemPropertyTypeTextFromAsset::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetItemPropertyTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemPropertyTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemPropertyTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemPropertyTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetItemPropertyTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemPropertyTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemPropertyTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemRarityByGameplayTag
// 0x000C (0x000C - 0x0000)
struct DCDataBlueprintLibrary_GetItemRarityByGameplayTag final
{
public:
	struct FGameplayTag                           InItemRarityTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCItemRarity                                 ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2606[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemRarityByGameplayTag) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetItemRarityByGameplayTag");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemRarityByGameplayTag) == 0x00000C, "Wrong size on DCDataBlueprintLibrary_GetItemRarityByGameplayTag");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemRarityByGameplayTag, InItemRarityTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemRarityByGameplayTag::InItemRarityTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemRarityByGameplayTag, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemRarityByGameplayTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemRarityLimit
// 0x0018 (0x0018 - 0x0000)
struct DCDataBlueprintLibrary_GetItemRarityLimit final
{
public:
	const class UObject*                          InWorldContextObject;                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     InGameType;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2607[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2608[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemRarityLimit) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemRarityLimit");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemRarityLimit) == 0x000018, "Wrong size on DCDataBlueprintLibrary_GetItemRarityLimit");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemRarityLimit, InWorldContextObject) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemRarityLimit::InWorldContextObject' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemRarityLimit, InGameType) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemRarityLimit::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemRarityLimit, ReturnValue) == 0x00000C, "Member 'DCDataBlueprintLibrary_GetItemRarityLimit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemRarityText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetItemRarityText final
{
public:
	struct FGameplayTag                           InItemRarityTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemRarityText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemRarityText");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemRarityText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetItemRarityText");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemRarityText, InItemRarityTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemRarityText::InItemRarityTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemRarityText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemRarityText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemRarityTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetItemRarityTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemRarityTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemRarityTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemRarityTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetItemRarityTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemRarityTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemRarityTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemSkinIdArray
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_GetItemSkinIdArray final
{
public:
	TArray<struct FPrimaryAssetId>                OutItemSkinIdArray;                                // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemSkinIdArray) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemSkinIdArray");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemSkinIdArray) == 0x000010, "Wrong size on DCDataBlueprintLibrary_GetItemSkinIdArray");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemSkinIdArray, OutItemSkinIdArray) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemSkinIdArray::OutItemSkinIdArray' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemSlotText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetItemSlotText final
{
public:
	struct FGameplayTag                           InItemSlotTag;                                     // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemSlotText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemSlotText");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemSlotText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetItemSlotText");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemSlotText, InItemSlotTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemSlotText::InItemSlotTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemSlotText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemSlotText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemSlotTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetItemSlotTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemSlotTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemSlotTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemSlotTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetItemSlotTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemSlotTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemSlotTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemTypeCategoryText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetItemTypeCategoryText final
{
public:
	EItemType                                     ItemType;                                          // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2609[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemTypeCategoryText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemTypeCategoryText");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemTypeCategoryText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetItemTypeCategoryText");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeCategoryText, ItemType) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemTypeCategoryText::ItemType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeCategoryText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemTypeCategoryText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemTypeChatFilterTagContainerMaps
// 0x0198 (0x0198 - 0x0000)
struct DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps final
{
public:
	const class UDCChatRoomDataAsset*             InChatRoomData;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGameplayTagContainer> OutTypeIdTagChatFilterTagContainerMap;             // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGameplayTagContainer> OutTypeRarityChatFilterTagContainerMap;            // 0x0058(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGameplayTagContainer> OutTypeSlotChatFilterTagContainerMap;              // 0x00A8(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGameplayTagContainer> OutPropertyChatFilterTagContainerMap;              // 0x00F8(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FGameplayTagContainer> OutPlayerCharacterChatFilterTagContainerMap;       // 0x0148(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps) == 0x000198, "Wrong size on DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps, InChatRoomData) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps::InChatRoomData' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps, OutTypeIdTagChatFilterTagContainerMap) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps::OutTypeIdTagChatFilterTagContainerMap' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps, OutTypeRarityChatFilterTagContainerMap) == 0x000058, "Member 'DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps::OutTypeRarityChatFilterTagContainerMap' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps, OutTypeSlotChatFilterTagContainerMap) == 0x0000A8, "Member 'DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps::OutTypeSlotChatFilterTagContainerMap' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps, OutPropertyChatFilterTagContainerMap) == 0x0000F8, "Member 'DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps::OutPropertyChatFilterTagContainerMap' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps, OutPlayerCharacterChatFilterTagContainerMap) == 0x000148, "Member 'DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps::OutPlayerCharacterChatFilterTagContainerMap' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemTypeText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetItemTypeText final
{
public:
	struct FGameplayTag                           InTypeTag;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemTypeText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemTypeText");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemTypeText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetItemTypeText");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeText, InTypeTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemTypeText::InTypeTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemTypeText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemTypeTextByCategory
// 0x0030 (0x0030 - 0x0000)
struct DCDataBlueprintLibrary_GetItemTypeTextByCategory final
{
public:
	const class UDCItemDataAsset*                 ItemDataAsset;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FormatString;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemTypeTextByCategory) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemTypeTextByCategory");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemTypeTextByCategory) == 0x000030, "Wrong size on DCDataBlueprintLibrary_GetItemTypeTextByCategory");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeTextByCategory, ItemDataAsset) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemTypeTextByCategory::ItemDataAsset' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeTextByCategory, FormatString) == 0x000008, "Member 'DCDataBlueprintLibrary_GetItemTypeTextByCategory::FormatString' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemTypeTextByCategory, ReturnValue) == 0x000018, "Member 'DCDataBlueprintLibrary_GetItemTypeTextByCategory::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemUtilityTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetItemUtilityTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemUtilityTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemUtilityTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemUtilityTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetItemUtilityTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemUtilityTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemUtilityTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemWeaponTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetItemWeaponTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetItemWeaponTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetItemWeaponTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetItemWeaponTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetItemWeaponTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetItemWeaponTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetItemWeaponTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetLobbyEmoteIdArray
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_GetLobbyEmoteIdArray final
{
public:
	TArray<struct FPrimaryAssetId>                OutLobbyEmoteIdArray;                              // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetLobbyEmoteIdArray) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetLobbyEmoteIdArray");
static_assert(sizeof(DCDataBlueprintLibrary_GetLobbyEmoteIdArray) == 0x000010, "Wrong size on DCDataBlueprintLibrary_GetLobbyEmoteIdArray");
static_assert(offsetof(DCDataBlueprintLibrary_GetLobbyEmoteIdArray, OutLobbyEmoteIdArray) == 0x000000, "Member 'DCDataBlueprintLibrary_GetLobbyEmoteIdArray::OutLobbyEmoteIdArray' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetLogEventTypeText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetLogEventTypeText final
{
public:
	EDCLogEventType                               InLogEventType;                                    // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260A[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetLogEventTypeText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetLogEventTypeText");
static_assert(sizeof(DCDataBlueprintLibrary_GetLogEventTypeText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetLogEventTypeText");
static_assert(offsetof(DCDataBlueprintLibrary_GetLogEventTypeText, InLogEventType) == 0x000000, "Member 'DCDataBlueprintLibrary_GetLogEventTypeText::InLogEventType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetLogEventTypeText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetLogEventTypeText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetMatchModeText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetMatchModeText final
{
public:
	EMatchMode                                    InMatchMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260B[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetMatchModeText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetMatchModeText");
static_assert(sizeof(DCDataBlueprintLibrary_GetMatchModeText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetMatchModeText");
static_assert(offsetof(DCDataBlueprintLibrary_GetMatchModeText, InMatchMode) == 0x000000, "Member 'DCDataBlueprintLibrary_GetMatchModeText::InMatchMode' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetMatchModeText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetMatchModeText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetMonsterIdTagText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetMonsterIdTagText final
{
public:
	struct FGameplayTag                           InIdTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetMonsterIdTagText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetMonsterIdTagText");
static_assert(sizeof(DCDataBlueprintLibrary_GetMonsterIdTagText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetMonsterIdTagText");
static_assert(offsetof(DCDataBlueprintLibrary_GetMonsterIdTagText, InIdTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetMonsterIdTagText::InIdTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetMonsterIdTagText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetMonsterIdTagText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetNormalGameType
// 0x0002 (0x0002 - 0x0000)
struct DCDataBlueprintLibrary_GetNormalGameType final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetNormalGameType) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_GetNormalGameType");
static_assert(sizeof(DCDataBlueprintLibrary_GetNormalGameType) == 0x000002, "Wrong size on DCDataBlueprintLibrary_GetNormalGameType");
static_assert(offsetof(DCDataBlueprintLibrary_GetNormalGameType, InGameType) == 0x000000, "Member 'DCDataBlueprintLibrary_GetNormalGameType::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetNormalGameType, ReturnValue) == 0x000001, "Member 'DCDataBlueprintLibrary_GetNormalGameType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetPlatformName
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetPlatformName final
{
public:
	EDCPlatform                                   InPlatform;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260C[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetPlatformName) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetPlatformName");
static_assert(sizeof(DCDataBlueprintLibrary_GetPlatformName) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetPlatformName");
static_assert(offsetof(DCDataBlueprintLibrary_GetPlatformName, InPlatform) == 0x000000, "Member 'DCDataBlueprintLibrary_GetPlatformName::InPlatform' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetPlatformName, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetPlatformName::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetPrimaryAssetSync
// 0x0018 (0x0018 - 0x0000)
struct DCDataBlueprintLibrary_GetPrimaryAssetSync final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimaryDataAsset*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetPrimaryAssetSync) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetPrimaryAssetSync");
static_assert(sizeof(DCDataBlueprintLibrary_GetPrimaryAssetSync) == 0x000018, "Wrong size on DCDataBlueprintLibrary_GetPrimaryAssetSync");
static_assert(offsetof(DCDataBlueprintLibrary_GetPrimaryAssetSync, PrimaryAssetId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetPrimaryAssetSync::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetPrimaryAssetSync, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetPrimaryAssetSync::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetPropsIdTagText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetPropsIdTagText final
{
public:
	struct FGameplayTag                           InIdTag;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetPropsIdTagText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetPropsIdTagText");
static_assert(sizeof(DCDataBlueprintLibrary_GetPropsIdTagText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetPropsIdTagText");
static_assert(offsetof(DCDataBlueprintLibrary_GetPropsIdTagText, InIdTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetPropsIdTagText::InIdTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetPropsIdTagText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetPropsIdTagText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetRandomDesignDataItemId
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_GetRandomDesignDataItemId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetRandomDesignDataItemId) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_GetRandomDesignDataItemId");
static_assert(sizeof(DCDataBlueprintLibrary_GetRandomDesignDataItemId) == 0x000010, "Wrong size on DCDataBlueprintLibrary_GetRandomDesignDataItemId");
static_assert(offsetof(DCDataBlueprintLibrary_GetRandomDesignDataItemId, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetRandomDesignDataItemId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetSetByCallerTagText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetSetByCallerTagText final
{
public:
	struct FGameplayTag                           InSetByCallerTag;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetSetByCallerTagText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetSetByCallerTagText");
static_assert(sizeof(DCDataBlueprintLibrary_GetSetByCallerTagText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetSetByCallerTagText");
static_assert(offsetof(DCDataBlueprintLibrary_GetSetByCallerTagText, InSetByCallerTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetSetByCallerTagText::InSetByCallerTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetSetByCallerTagText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetSetByCallerTagText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetSetByCallerTagTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetSetByCallerTagTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetSetByCallerTagTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetSetByCallerTagTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetSetByCallerTagTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetSetByCallerTagTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetSetByCallerTagTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetSetByCallerTagTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetShapeShiftData
// 0x0018 (0x0018 - 0x0000)
struct DCDataBlueprintLibrary_GetShapeShiftData final
{
public:
	struct FPrimaryAssetId                        InId;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDCShapeShiftDataAsset*           ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetShapeShiftData) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetShapeShiftData");
static_assert(sizeof(DCDataBlueprintLibrary_GetShapeShiftData) == 0x000018, "Wrong size on DCDataBlueprintLibrary_GetShapeShiftData");
static_assert(offsetof(DCDataBlueprintLibrary_GetShapeShiftData, InId) == 0x000000, "Member 'DCDataBlueprintLibrary_GetShapeShiftData::InId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetShapeShiftData, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_GetShapeShiftData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetShapeShiftDataByTag
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_GetShapeShiftDataByTag final
{
public:
	struct FGameplayTag                           InTag;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCShapeShiftDataAsset*                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetShapeShiftDataByTag) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetShapeShiftDataByTag");
static_assert(sizeof(DCDataBlueprintLibrary_GetShapeShiftDataByTag) == 0x000010, "Wrong size on DCDataBlueprintLibrary_GetShapeShiftDataByTag");
static_assert(offsetof(DCDataBlueprintLibrary_GetShapeShiftDataByTag, InTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetShapeShiftDataByTag::InTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetShapeShiftDataByTag, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetShapeShiftDataByTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetShapeShiftDatas
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_GetShapeShiftDatas final
{
public:
	TArray<class UDCShapeShiftDataAsset*>         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetShapeShiftDatas) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetShapeShiftDatas");
static_assert(sizeof(DCDataBlueprintLibrary_GetShapeShiftDatas) == 0x000010, "Wrong size on DCDataBlueprintLibrary_GetShapeShiftDatas");
static_assert(offsetof(DCDataBlueprintLibrary_GetShapeShiftDatas, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetShapeShiftDatas::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetStatisticsTypeText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetStatisticsTypeText final
{
public:
	EStatisticsType                               InStatisticsType;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260D[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetStatisticsTypeText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetStatisticsTypeText");
static_assert(sizeof(DCDataBlueprintLibrary_GetStatisticsTypeText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetStatisticsTypeText");
static_assert(offsetof(DCDataBlueprintLibrary_GetStatisticsTypeText, InStatisticsType) == 0x000000, "Member 'DCDataBlueprintLibrary_GetStatisticsTypeText::InStatisticsType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetStatisticsTypeText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetStatisticsTypeText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetTypeTagText
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_GetTypeTagText final
{
public:
	struct FGameplayTag                           InTypeTag;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetTypeTagText) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetTypeTagText");
static_assert(sizeof(DCDataBlueprintLibrary_GetTypeTagText) == 0x000020, "Wrong size on DCDataBlueprintLibrary_GetTypeTagText");
static_assert(offsetof(DCDataBlueprintLibrary_GetTypeTagText, InTypeTag) == 0x000000, "Member 'DCDataBlueprintLibrary_GetTypeTagText::InTypeTag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetTypeTagText, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_GetTypeTagText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetTypeTextMap
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetTypeTextMap final
{
public:
	TMap<struct FGameplayTag, class FText>        ReturnValue;                                       // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetTypeTextMap) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetTypeTextMap");
static_assert(sizeof(DCDataBlueprintLibrary_GetTypeTextMap) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetTypeTextMap");
static_assert(offsetof(DCDataBlueprintLibrary_GetTypeTextMap, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_GetTypeTextMap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetViewNickname
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetViewNickname final
{
public:
	struct FNickname                              Nickname;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetViewNickname) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetViewNickname");
static_assert(sizeof(DCDataBlueprintLibrary_GetViewNickname) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetViewNickname");
static_assert(offsetof(DCDataBlueprintLibrary_GetViewNickname, Nickname) == 0x000000, "Member 'DCDataBlueprintLibrary_GetViewNickname::Nickname' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetViewNickname, ReturnValue) == 0x000040, "Member 'DCDataBlueprintLibrary_GetViewNickname::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.GetViewNicknameColor
// 0x0050 (0x0050 - 0x0000)
struct DCDataBlueprintLibrary_GetViewNicknameColor final
{
public:
	struct FNickname                              Nickname;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_GetViewNicknameColor) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_GetViewNicknameColor");
static_assert(sizeof(DCDataBlueprintLibrary_GetViewNicknameColor) == 0x000050, "Wrong size on DCDataBlueprintLibrary_GetViewNicknameColor");
static_assert(offsetof(DCDataBlueprintLibrary_GetViewNicknameColor, Nickname) == 0x000000, "Member 'DCDataBlueprintLibrary_GetViewNicknameColor::Nickname' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_GetViewNicknameColor, ReturnValue) == 0x000040, "Member 'DCDataBlueprintLibrary_GetViewNicknameColor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsArenaGameType
// 0x0002 (0x0002 - 0x0000)
struct DCDataBlueprintLibrary_IsArenaGameType final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_IsArenaGameType) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_IsArenaGameType");
static_assert(sizeof(DCDataBlueprintLibrary_IsArenaGameType) == 0x000002, "Wrong size on DCDataBlueprintLibrary_IsArenaGameType");
static_assert(offsetof(DCDataBlueprintLibrary_IsArenaGameType, InGameType) == 0x000000, "Member 'DCDataBlueprintLibrary_IsArenaGameType::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsArenaGameType, ReturnValue) == 0x000001, "Member 'DCDataBlueprintLibrary_IsArenaGameType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsArenaSelected
// 0x0001 (0x0001 - 0x0000)
struct DCDataBlueprintLibrary_IsArenaSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_IsArenaSelected) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_IsArenaSelected");
static_assert(sizeof(DCDataBlueprintLibrary_IsArenaSelected) == 0x000001, "Wrong size on DCDataBlueprintLibrary_IsArenaSelected");
static_assert(offsetof(DCDataBlueprintLibrary_IsArenaSelected, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_IsArenaSelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsAvailableInteraction
// 0x0100 (0x0100 - 0x0000)
struct DCDataBlueprintLibrary_IsAvailableInteraction final
{
public:
	class ADCPlayerCharacterBase*                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DstActor;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             InHitResult;                                       // 0x0010(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         OutDistance;                                       // 0x00F8(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00FC(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260E[0x3];                                     // 0x00FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCDataBlueprintLibrary_IsAvailableInteraction) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_IsAvailableInteraction");
static_assert(sizeof(DCDataBlueprintLibrary_IsAvailableInteraction) == 0x000100, "Wrong size on DCDataBlueprintLibrary_IsAvailableInteraction");
static_assert(offsetof(DCDataBlueprintLibrary_IsAvailableInteraction, Interacter) == 0x000000, "Member 'DCDataBlueprintLibrary_IsAvailableInteraction::Interacter' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsAvailableInteraction, DstActor) == 0x000008, "Member 'DCDataBlueprintLibrary_IsAvailableInteraction::DstActor' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsAvailableInteraction, InHitResult) == 0x000010, "Member 'DCDataBlueprintLibrary_IsAvailableInteraction::InHitResult' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsAvailableInteraction, OutDistance) == 0x0000F8, "Member 'DCDataBlueprintLibrary_IsAvailableInteraction::OutDistance' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsAvailableInteraction, ReturnValue) == 0x0000FC, "Member 'DCDataBlueprintLibrary_IsAvailableInteraction::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsAvailableInteractionWithPhysicalTarget
// 0x0018 (0x0018 - 0x0000)
struct DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget final
{
public:
	class ADCPlayerCharacterBase*                 Interacter;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DstActor;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutXYDistance;                                     // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260F[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget");
static_assert(sizeof(DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget) == 0x000018, "Wrong size on DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget");
static_assert(offsetof(DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget, Interacter) == 0x000000, "Member 'DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget::Interacter' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget, DstActor) == 0x000008, "Member 'DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget::DstActor' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget, OutXYDistance) == 0x000010, "Member 'DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget::OutXYDistance' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget, ReturnValue) == 0x000014, "Member 'DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsDungeonGameType
// 0x0002 (0x0002 - 0x0000)
struct DCDataBlueprintLibrary_IsDungeonGameType final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_IsDungeonGameType) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_IsDungeonGameType");
static_assert(sizeof(DCDataBlueprintLibrary_IsDungeonGameType) == 0x000002, "Wrong size on DCDataBlueprintLibrary_IsDungeonGameType");
static_assert(offsetof(DCDataBlueprintLibrary_IsDungeonGameType, InGameType) == 0x000000, "Member 'DCDataBlueprintLibrary_IsDungeonGameType::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsDungeonGameType, ReturnValue) == 0x000001, "Member 'DCDataBlueprintLibrary_IsDungeonGameType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsDuoGameType
// 0x0002 (0x0002 - 0x0000)
struct DCDataBlueprintLibrary_IsDuoGameType final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_IsDuoGameType) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_IsDuoGameType");
static_assert(sizeof(DCDataBlueprintLibrary_IsDuoGameType) == 0x000002, "Wrong size on DCDataBlueprintLibrary_IsDuoGameType");
static_assert(offsetof(DCDataBlueprintLibrary_IsDuoGameType, InGameType) == 0x000000, "Member 'DCDataBlueprintLibrary_IsDuoGameType::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsDuoGameType, ReturnValue) == 0x000001, "Member 'DCDataBlueprintLibrary_IsDuoGameType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsHighRoller
// 0x0002 (0x0002 - 0x0000)
struct DCDataBlueprintLibrary_IsHighRoller final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_IsHighRoller) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_IsHighRoller");
static_assert(sizeof(DCDataBlueprintLibrary_IsHighRoller) == 0x000002, "Wrong size on DCDataBlueprintLibrary_IsHighRoller");
static_assert(offsetof(DCDataBlueprintLibrary_IsHighRoller, InGameType) == 0x000000, "Member 'DCDataBlueprintLibrary_IsHighRoller::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsHighRoller, ReturnValue) == 0x000001, "Member 'DCDataBlueprintLibrary_IsHighRoller::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsItemWearableByClass
// 0x0018 (0x0018 - 0x0000)
struct DCDataBlueprintLibrary_IsItemWearableByClass final
{
public:
	class AActor*                                 InOwnerActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AItemActor*                       InItemActor;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2610[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCDataBlueprintLibrary_IsItemWearableByClass) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_IsItemWearableByClass");
static_assert(sizeof(DCDataBlueprintLibrary_IsItemWearableByClass) == 0x000018, "Wrong size on DCDataBlueprintLibrary_IsItemWearableByClass");
static_assert(offsetof(DCDataBlueprintLibrary_IsItemWearableByClass, InOwnerActor) == 0x000000, "Member 'DCDataBlueprintLibrary_IsItemWearableByClass::InOwnerActor' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsItemWearableByClass, InItemActor) == 0x000008, "Member 'DCDataBlueprintLibrary_IsItemWearableByClass::InItemActor' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsItemWearableByClass, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_IsItemWearableByClass::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsLowViolenceMode
// 0x0001 (0x0001 - 0x0000)
struct DCDataBlueprintLibrary_IsLowViolenceMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_IsLowViolenceMode) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_IsLowViolenceMode");
static_assert(sizeof(DCDataBlueprintLibrary_IsLowViolenceMode) == 0x000001, "Wrong size on DCDataBlueprintLibrary_IsLowViolenceMode");
static_assert(offsetof(DCDataBlueprintLibrary_IsLowViolenceMode, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_IsLowViolenceMode::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsSoloGameType
// 0x0002 (0x0002 - 0x0000)
struct DCDataBlueprintLibrary_IsSoloGameType final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_IsSoloGameType) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_IsSoloGameType");
static_assert(sizeof(DCDataBlueprintLibrary_IsSoloGameType) == 0x000002, "Wrong size on DCDataBlueprintLibrary_IsSoloGameType");
static_assert(offsetof(DCDataBlueprintLibrary_IsSoloGameType, InGameType) == 0x000000, "Member 'DCDataBlueprintLibrary_IsSoloGameType::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsSoloGameType, ReturnValue) == 0x000001, "Member 'DCDataBlueprintLibrary_IsSoloGameType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsStreamingMode
// 0x0001 (0x0001 - 0x0000)
struct DCDataBlueprintLibrary_IsStreamingMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_IsStreamingMode) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_IsStreamingMode");
static_assert(sizeof(DCDataBlueprintLibrary_IsStreamingMode) == 0x000001, "Wrong size on DCDataBlueprintLibrary_IsStreamingMode");
static_assert(offsetof(DCDataBlueprintLibrary_IsStreamingMode, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_IsStreamingMode::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsTrioGameType
// 0x0002 (0x0002 - 0x0000)
struct DCDataBlueprintLibrary_IsTrioGameType final
{
public:
	EGameType                                     InGameType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_IsTrioGameType) == 0x000001, "Wrong alignment on DCDataBlueprintLibrary_IsTrioGameType");
static_assert(sizeof(DCDataBlueprintLibrary_IsTrioGameType) == 0x000002, "Wrong size on DCDataBlueprintLibrary_IsTrioGameType");
static_assert(offsetof(DCDataBlueprintLibrary_IsTrioGameType, InGameType) == 0x000000, "Member 'DCDataBlueprintLibrary_IsTrioGameType::InGameType' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsTrioGameType, ReturnValue) == 0x000001, "Member 'DCDataBlueprintLibrary_IsTrioGameType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.IsUtilityItem
// 0x0178 (0x0178 - 0x0000)
struct DCDataBlueprintLibrary_IsUtilityItem final
{
public:
	struct FDCItemInfo                            ItemInfo;                                          // 0x0000(0x0168)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0168(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0170(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2611[0x7];                                     // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCDataBlueprintLibrary_IsUtilityItem) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_IsUtilityItem");
static_assert(sizeof(DCDataBlueprintLibrary_IsUtilityItem) == 0x000178, "Wrong size on DCDataBlueprintLibrary_IsUtilityItem");
static_assert(offsetof(DCDataBlueprintLibrary_IsUtilityItem, ItemInfo) == 0x000000, "Member 'DCDataBlueprintLibrary_IsUtilityItem::ItemInfo' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsUtilityItem, Tag) == 0x000168, "Member 'DCDataBlueprintLibrary_IsUtilityItem::Tag' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_IsUtilityItem, ReturnValue) == 0x000170, "Member 'DCDataBlueprintLibrary_IsUtilityItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.ItemIdToInteger
// 0x0010 (0x0010 - 0x0000)
struct DCDataBlueprintLibrary_ItemIdToInteger final
{
public:
	struct FDCItemId                              Value;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_ItemIdToInteger) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_ItemIdToInteger");
static_assert(sizeof(DCDataBlueprintLibrary_ItemIdToInteger) == 0x000010, "Wrong size on DCDataBlueprintLibrary_ItemIdToInteger");
static_assert(offsetof(DCDataBlueprintLibrary_ItemIdToInteger, Value) == 0x000000, "Member 'DCDataBlueprintLibrary_ItemIdToInteger::Value' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_ItemIdToInteger, ReturnValue) == 0x000008, "Member 'DCDataBlueprintLibrary_ItemIdToInteger::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.LoadObjectLibrary
// 0x0028 (0x0028 - 0x0000)
struct DCDataBlueprintLibrary_LoadObjectLibrary final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    ObjectClass;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_LoadObjectLibrary) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_LoadObjectLibrary");
static_assert(sizeof(DCDataBlueprintLibrary_LoadObjectLibrary) == 0x000028, "Wrong size on DCDataBlueprintLibrary_LoadObjectLibrary");
static_assert(offsetof(DCDataBlueprintLibrary_LoadObjectLibrary, Path) == 0x000000, "Member 'DCDataBlueprintLibrary_LoadObjectLibrary::Path' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_LoadObjectLibrary, ObjectClass) == 0x000010, "Member 'DCDataBlueprintLibrary_LoadObjectLibrary::ObjectClass' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_LoadObjectLibrary, ReturnValue) == 0x000018, "Member 'DCDataBlueprintLibrary_LoadObjectLibrary::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.LoadPrimaryAsset
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_LoadPrimaryAsset final
{
public:
	struct FPrimaryAssetId                        InPrimaryAssetId;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UObject* InObjectLoaded)> InOnComplete;                                      // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_LoadPrimaryAsset) == 0x000004, "Wrong alignment on DCDataBlueprintLibrary_LoadPrimaryAsset");
static_assert(sizeof(DCDataBlueprintLibrary_LoadPrimaryAsset) == 0x000020, "Wrong size on DCDataBlueprintLibrary_LoadPrimaryAsset");
static_assert(offsetof(DCDataBlueprintLibrary_LoadPrimaryAsset, InPrimaryAssetId) == 0x000000, "Member 'DCDataBlueprintLibrary_LoadPrimaryAsset::InPrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_LoadPrimaryAsset, InOnComplete) == 0x000010, "Member 'DCDataBlueprintLibrary_LoadPrimaryAsset::InOnComplete' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.MakePrimaryAssetId
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_MakePrimaryAssetId final
{
public:
	class FString                                 PrimaryAssetIdStr;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_MakePrimaryAssetId) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_MakePrimaryAssetId");
static_assert(sizeof(DCDataBlueprintLibrary_MakePrimaryAssetId) == 0x000020, "Wrong size on DCDataBlueprintLibrary_MakePrimaryAssetId");
static_assert(offsetof(DCDataBlueprintLibrary_MakePrimaryAssetId, PrimaryAssetIdStr) == 0x000000, "Member 'DCDataBlueprintLibrary_MakePrimaryAssetId::PrimaryAssetIdStr' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_MakePrimaryAssetId, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_MakePrimaryAssetId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.MakePrimaryAssetIdStr
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_MakePrimaryAssetIdStr final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_MakePrimaryAssetIdStr) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_MakePrimaryAssetIdStr");
static_assert(sizeof(DCDataBlueprintLibrary_MakePrimaryAssetIdStr) == 0x000020, "Wrong size on DCDataBlueprintLibrary_MakePrimaryAssetIdStr");
static_assert(offsetof(DCDataBlueprintLibrary_MakePrimaryAssetIdStr, PrimaryAssetId) == 0x000000, "Member 'DCDataBlueprintLibrary_MakePrimaryAssetIdStr::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_MakePrimaryAssetIdStr, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_MakePrimaryAssetIdStr::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.MakeUniqueId
// 0x0008 (0x0008 - 0x0000)
struct DCDataBlueprintLibrary_MakeUniqueId final
{
public:
	int64                                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_MakeUniqueId) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_MakeUniqueId");
static_assert(sizeof(DCDataBlueprintLibrary_MakeUniqueId) == 0x000008, "Wrong size on DCDataBlueprintLibrary_MakeUniqueId");
static_assert(offsetof(DCDataBlueprintLibrary_MakeUniqueId, ReturnValue) == 0x000000, "Member 'DCDataBlueprintLibrary_MakeUniqueId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.PartyIdToString
// 0x0020 (0x0020 - 0x0000)
struct DCDataBlueprintLibrary_PartyIdToString final
{
public:
	struct FDCPartyId                             Value;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_PartyIdToString) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_PartyIdToString");
static_assert(sizeof(DCDataBlueprintLibrary_PartyIdToString) == 0x000020, "Wrong size on DCDataBlueprintLibrary_PartyIdToString");
static_assert(offsetof(DCDataBlueprintLibrary_PartyIdToString, Value) == 0x000000, "Member 'DCDataBlueprintLibrary_PartyIdToString::Value' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_PartyIdToString, ReturnValue) == 0x000010, "Member 'DCDataBlueprintLibrary_PartyIdToString::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.SpawnItemActor
// 0x0180 (0x0180 - 0x0000)
struct DCDataBlueprintLibrary_SpawnItemActor final
{
public:
	class AActor*                                 OwnerActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              ItemData;                                          // 0x0008(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_2612[0x8];                                     // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0110(0x0060)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AItemActor*                             ReturnValue;                                       // 0x0170(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2613[0x8];                                     // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCDataBlueprintLibrary_SpawnItemActor) == 0x000010, "Wrong alignment on DCDataBlueprintLibrary_SpawnItemActor");
static_assert(sizeof(DCDataBlueprintLibrary_SpawnItemActor) == 0x000180, "Wrong size on DCDataBlueprintLibrary_SpawnItemActor");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemActor, OwnerActor) == 0x000000, "Member 'DCDataBlueprintLibrary_SpawnItemActor::OwnerActor' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemActor, ItemData) == 0x000008, "Member 'DCDataBlueprintLibrary_SpawnItemActor::ItemData' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemActor, Transform) == 0x000110, "Member 'DCDataBlueprintLibrary_SpawnItemActor::Transform' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemActor, ReturnValue) == 0x000170, "Member 'DCDataBlueprintLibrary_SpawnItemActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.SpawnItemHolderActor
// 0x0110 (0x0110 - 0x0000)
struct DCDataBlueprintLibrary_SpawnItemHolderActor final
{
public:
	class AActor*                                 Spawner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              ItemData;                                          // 0x0008(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AItemHolderActorBase*                   ReturnValue;                                       // 0x0108(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_SpawnItemHolderActor) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_SpawnItemHolderActor");
static_assert(sizeof(DCDataBlueprintLibrary_SpawnItemHolderActor) == 0x000110, "Wrong size on DCDataBlueprintLibrary_SpawnItemHolderActor");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemHolderActor, Spawner) == 0x000000, "Member 'DCDataBlueprintLibrary_SpawnItemHolderActor::Spawner' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemHolderActor, ItemData) == 0x000008, "Member 'DCDataBlueprintLibrary_SpawnItemHolderActor::ItemData' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemHolderActor, ReturnValue) == 0x000108, "Member 'DCDataBlueprintLibrary_SpawnItemHolderActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDataBlueprintLibrary.SpawnItemHolderActorWithItemHolderActorClass
// 0x0118 (0x0118 - 0x0000)
struct DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass final
{
public:
	class AActor*                                 Spawner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              ItemData;                                          // 0x0008(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemHolderActorBase>       ItemHolderActorClass;                              // 0x0108(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AItemHolderActorBase*                   ReturnValue;                                       // 0x0110(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass) == 0x000008, "Wrong alignment on DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass");
static_assert(sizeof(DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass) == 0x000118, "Wrong size on DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass, Spawner) == 0x000000, "Member 'DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass::Spawner' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass, ItemData) == 0x000008, "Member 'DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass::ItemData' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass, ItemHolderActorClass) == 0x000108, "Member 'DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass::ItemHolderActorClass' has a wrong offset!");
static_assert(offsetof(DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass, ReturnValue) == 0x000110, "Member 'DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDeathCamWidget.GetProgress
// 0x0004 (0x0004 - 0x0000)
struct DCDeathCamWidget_GetProgress final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDeathCamWidget_GetProgress) == 0x000004, "Wrong alignment on DCDeathCamWidget_GetProgress");
static_assert(sizeof(DCDeathCamWidget_GetProgress) == 0x000004, "Wrong size on DCDeathCamWidget_GetProgress");
static_assert(offsetof(DCDeathCamWidget_GetProgress, ReturnValue) == 0x000000, "Member 'DCDeathCamWidget_GetProgress::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDeathCamWidget.IsEnded
// 0x0001 (0x0001 - 0x0000)
struct DCDeathCamWidget_IsEnded final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDeathCamWidget_IsEnded) == 0x000001, "Wrong alignment on DCDeathCamWidget_IsEnded");
static_assert(sizeof(DCDeathCamWidget_IsEnded) == 0x000001, "Wrong size on DCDeathCamWidget_IsEnded");
static_assert(offsetof(DCDeathCamWidget_IsEnded, ReturnValue) == 0x000000, "Member 'DCDeathCamWidget_IsEnded::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDeathCamWidget.IsPlaying
// 0x0001 (0x0001 - 0x0000)
struct DCDeathCamWidget_IsPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDeathCamWidget_IsPlaying) == 0x000001, "Wrong alignment on DCDeathCamWidget_IsPlaying");
static_assert(sizeof(DCDeathCamWidget_IsPlaying) == 0x000001, "Wrong size on DCDeathCamWidget_IsPlaying");
static_assert(offsetof(DCDeathCamWidget_IsPlaying, ReturnValue) == 0x000000, "Member 'DCDeathCamWidget_IsPlaying::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCDrawbridgeWheel.OnRep_WheelInteractData
// 0x0010 (0x0010 - 0x0000)
struct DCDrawbridgeWheel_OnRep_WheelInteractData final
{
public:
	struct FDCWheelInteractData                   InOldWheelInteractData;                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDrawbridgeWheel_OnRep_WheelInteractData) == 0x000008, "Wrong alignment on DCDrawbridgeWheel_OnRep_WheelInteractData");
static_assert(sizeof(DCDrawbridgeWheel_OnRep_WheelInteractData) == 0x000010, "Wrong size on DCDrawbridgeWheel_OnRep_WheelInteractData");
static_assert(offsetof(DCDrawbridgeWheel_OnRep_WheelInteractData, InOldWheelInteractData) == 0x000000, "Member 'DCDrawbridgeWheel_OnRep_WheelInteractData::InOldWheelInteractData' has a wrong offset!");

// Function DungeonCrawler.DCItemDataAsset.GetEquipType
// 0x0001 (0x0001 - 0x0000)
struct DCItemDataAsset_GetEquipType final
{
public:
	EDCItemEquipType                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemDataAsset_GetEquipType) == 0x000001, "Wrong alignment on DCItemDataAsset_GetEquipType");
static_assert(sizeof(DCItemDataAsset_GetEquipType) == 0x000001, "Wrong size on DCItemDataAsset_GetEquipType");
static_assert(offsetof(DCItemDataAsset_GetEquipType, ReturnValue) == 0x000000, "Member 'DCItemDataAsset_GetEquipType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemDataAsset.IsSoulHeart
// 0x0001 (0x0001 - 0x0000)
struct DCItemDataAsset_IsSoulHeart final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemDataAsset_IsSoulHeart) == 0x000001, "Wrong alignment on DCItemDataAsset_IsSoulHeart");
static_assert(sizeof(DCItemDataAsset_IsSoulHeart) == 0x000001, "Wrong size on DCItemDataAsset_IsSoulHeart");
static_assert(offsetof(DCItemDataAsset_IsSoulHeart, ReturnValue) == 0x000000, "Member 'DCItemDataAsset_IsSoulHeart::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_MusicGrantingAbilityBase.OnTargetActorOverlap
// 0x0010 (0x0010 - 0x0000)
struct GA_MusicGrantingAbilityBase_OnTargetActorOverlap final
{
public:
	TArray<class AActor*>                         TargetActors;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MusicGrantingAbilityBase_OnTargetActorOverlap) == 0x000008, "Wrong alignment on GA_MusicGrantingAbilityBase_OnTargetActorOverlap");
static_assert(sizeof(GA_MusicGrantingAbilityBase_OnTargetActorOverlap) == 0x000010, "Wrong size on GA_MusicGrantingAbilityBase_OnTargetActorOverlap");
static_assert(offsetof(GA_MusicGrantingAbilityBase_OnTargetActorOverlap, TargetActors) == 0x000000, "Member 'GA_MusicGrantingAbilityBase_OnTargetActorOverlap::TargetActors' has a wrong offset!");

// Function DungeonCrawler.DCDungeonGameState.OnRep_bPauseServerUpdate
// 0x0001 (0x0001 - 0x0000)
struct DCDungeonGameState_OnRep_bPauseServerUpdate final
{
public:
	bool                                          bOldPauseServerUpdate;                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonGameState_OnRep_bPauseServerUpdate) == 0x000001, "Wrong alignment on DCDungeonGameState_OnRep_bPauseServerUpdate");
static_assert(sizeof(DCDungeonGameState_OnRep_bPauseServerUpdate) == 0x000001, "Wrong size on DCDungeonGameState_OnRep_bPauseServerUpdate");
static_assert(offsetof(DCDungeonGameState_OnRep_bPauseServerUpdate, bOldPauseServerUpdate) == 0x000000, "Member 'DCDungeonGameState_OnRep_bPauseServerUpdate::bOldPauseServerUpdate' has a wrong offset!");

// Function DungeonCrawler.DCDungeonGameState.OnRep_NumPlayers
// 0x0004 (0x0004 - 0x0000)
struct DCDungeonGameState_OnRep_NumPlayers final
{
public:
	int32                                         OldNumPlayers;                                     // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCDungeonGameState_OnRep_NumPlayers) == 0x000004, "Wrong alignment on DCDungeonGameState_OnRep_NumPlayers");
static_assert(sizeof(DCDungeonGameState_OnRep_NumPlayers) == 0x000004, "Wrong size on DCDungeonGameState_OnRep_NumPlayers");
static_assert(offsetof(DCDungeonGameState_OnRep_NumPlayers, OldNumPlayers) == 0x000000, "Member 'DCDungeonGameState_OnRep_NumPlayers::OldNumPlayers' has a wrong offset!");

// Function DungeonCrawler.DCStateButtonWidgetBase.SetActive
// 0x0001 (0x0001 - 0x0000)
struct DCStateButtonWidgetBase_SetActive final
{
public:
	bool                                          bState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCStateButtonWidgetBase_SetActive) == 0x000001, "Wrong alignment on DCStateButtonWidgetBase_SetActive");
static_assert(sizeof(DCStateButtonWidgetBase_SetActive) == 0x000001, "Wrong size on DCStateButtonWidgetBase_SetActive");
static_assert(offsetof(DCStateButtonWidgetBase_SetActive, bState) == 0x000000, "Member 'DCStateButtonWidgetBase_SetActive::bState' has a wrong offset!");

// Function DungeonCrawler.DCItemSkinWidget.GetTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCItemSkinWidget_GetTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemSkinWidget_GetTooltipWidget) == 0x000008, "Wrong alignment on DCItemSkinWidget_GetTooltipWidget");
static_assert(sizeof(DCItemSkinWidget_GetTooltipWidget) == 0x000008, "Wrong size on DCItemSkinWidget_GetTooltipWidget");
static_assert(offsetof(DCItemSkinWidget_GetTooltipWidget, ReturnValue) == 0x000000, "Member 'DCItemSkinWidget_GetTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ItemTooltipWidget.OnItemData
// 0x0200 (0x0200 - 0x0000)
struct ItemTooltipWidget_OnItemData final
{
public:
	struct FItemData                              NewItemData;                                       // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FItemData                              OldItemData;                                       // 0x0100(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipWidget_OnItemData) == 0x000008, "Wrong alignment on ItemTooltipWidget_OnItemData");
static_assert(sizeof(ItemTooltipWidget_OnItemData) == 0x000200, "Wrong size on ItemTooltipWidget_OnItemData");
static_assert(offsetof(ItemTooltipWidget_OnItemData, NewItemData) == 0x000000, "Member 'ItemTooltipWidget_OnItemData::NewItemData' has a wrong offset!");
static_assert(offsetof(ItemTooltipWidget_OnItemData, OldItemData) == 0x000100, "Member 'ItemTooltipWidget_OnItemData::OldItemData' has a wrong offset!");

// Function DungeonCrawler.ItemTooltipWidget.SetItemData
// 0x0100 (0x0100 - 0x0000)
struct ItemTooltipWidget_SetItemData final
{
public:
	struct FItemData                              NewItemData;                                       // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipWidget_SetItemData) == 0x000008, "Wrong alignment on ItemTooltipWidget_SetItemData");
static_assert(sizeof(ItemTooltipWidget_SetItemData) == 0x000100, "Wrong size on ItemTooltipWidget_SetItemData");
static_assert(offsetof(ItemTooltipWidget_SetItemData, NewItemData) == 0x000000, "Member 'ItemTooltipWidget_SetItemData::NewItemData' has a wrong offset!");

// Function DungeonCrawler.DCEmoteWidget.GetTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCEmoteWidget_GetTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEmoteWidget_GetTooltipWidget) == 0x000008, "Wrong alignment on DCEmoteWidget_GetTooltipWidget");
static_assert(sizeof(DCEmoteWidget_GetTooltipWidget) == 0x000008, "Wrong size on DCEmoteWidget_GetTooltipWidget");
static_assert(offsetof(DCEmoteWidget_GetTooltipWidget, ReturnValue) == 0x000000, "Member 'DCEmoteWidget_GetTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEmoteListEntryWidget.GetSelectedVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCEmoteListEntryWidget_GetSelectedVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEmoteListEntryWidget_GetSelectedVisibility) == 0x000001, "Wrong alignment on DCEmoteListEntryWidget_GetSelectedVisibility");
static_assert(sizeof(DCEmoteListEntryWidget_GetSelectedVisibility) == 0x000001, "Wrong size on DCEmoteListEntryWidget_GetSelectedVisibility");
static_assert(offsetof(DCEmoteListEntryWidget_GetSelectedVisibility, ReturnValue) == 0x000000, "Member 'DCEmoteListEntryWidget_GetSelectedVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.AddPlayerMappableConfigByTagContainer
// 0x0028 (0x0028 - 0x0000)
struct DCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InputConfigTags;                                   // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer");
static_assert(sizeof(DCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer) == 0x000028, "Wrong size on DCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer");
static_assert(offsetof(DCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer, InputConfigTags) == 0x000008, "Member 'DCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer::InputConfigTags' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.GetActionBoolByTags
// 0x0020 (0x0020 - 0x0000)
struct DCEnhancedInputLibrary_GetActionBoolByTags final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputConfigTag;                                    // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_262D[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCEnhancedInputLibrary_GetActionBoolByTags) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_GetActionBoolByTags");
static_assert(sizeof(DCEnhancedInputLibrary_GetActionBoolByTags) == 0x000020, "Wrong size on DCEnhancedInputLibrary_GetActionBoolByTags");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionBoolByTags, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_GetActionBoolByTags::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionBoolByTags, InputConfigTag) == 0x000008, "Member 'DCEnhancedInputLibrary_GetActionBoolByTags::InputConfigTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionBoolByTags, InputTag) == 0x000010, "Member 'DCEnhancedInputLibrary_GetActionBoolByTags::InputTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionBoolByTags, ReturnValue) == 0x000018, "Member 'DCEnhancedInputLibrary_GetActionBoolByTags::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.GetActionBoolWithController
// 0x0018 (0x0018 - 0x0000)
struct DCEnhancedInputLibrary_GetActionBoolWithController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInputAction*                     Action;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_262E[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCEnhancedInputLibrary_GetActionBoolWithController) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_GetActionBoolWithController");
static_assert(sizeof(DCEnhancedInputLibrary_GetActionBoolWithController) == 0x000018, "Wrong size on DCEnhancedInputLibrary_GetActionBoolWithController");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionBoolWithController, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_GetActionBoolWithController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionBoolWithController, Action) == 0x000008, "Member 'DCEnhancedInputLibrary_GetActionBoolWithController::Action' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionBoolWithController, ReturnValue) == 0x000010, "Member 'DCEnhancedInputLibrary_GetActionBoolWithController::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.GetActionValueByTags
// 0x0038 (0x0038 - 0x0000)
struct DCEnhancedInputLibrary_GetActionValueByTags final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputConfigTag;                                    // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputActionValue                      ReturnValue;                                       // 0x0018(0x0020)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_GetActionValueByTags) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_GetActionValueByTags");
static_assert(sizeof(DCEnhancedInputLibrary_GetActionValueByTags) == 0x000038, "Wrong size on DCEnhancedInputLibrary_GetActionValueByTags");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionValueByTags, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_GetActionValueByTags::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionValueByTags, InputConfigTag) == 0x000008, "Member 'DCEnhancedInputLibrary_GetActionValueByTags::InputConfigTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionValueByTags, InputTag) == 0x000010, "Member 'DCEnhancedInputLibrary_GetActionValueByTags::InputTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionValueByTags, ReturnValue) == 0x000018, "Member 'DCEnhancedInputLibrary_GetActionValueByTags::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.GetActionValueWithController
// 0x0030 (0x0030 - 0x0000)
struct DCEnhancedInputLibrary_GetActionValueWithController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInputAction*                     Action;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputActionValue                      ReturnValue;                                       // 0x0010(0x0020)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_GetActionValueWithController) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_GetActionValueWithController");
static_assert(sizeof(DCEnhancedInputLibrary_GetActionValueWithController) == 0x000030, "Wrong size on DCEnhancedInputLibrary_GetActionValueWithController");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionValueWithController, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_GetActionValueWithController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionValueWithController, Action) == 0x000008, "Member 'DCEnhancedInputLibrary_GetActionValueWithController::Action' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetActionValueWithController, ReturnValue) == 0x000010, "Member 'DCEnhancedInputLibrary_GetActionValueWithController::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.GetDCEnhancedInputLocalPlayerSubSystem
// 0x0010 (0x0010 - 0x0000)
struct DCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCEnhancedInputLocalPlayerSubsystem*   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem");
static_assert(sizeof(DCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem) == 0x000010, "Wrong size on DCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem");
static_assert(offsetof(DCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem, ReturnValue) == 0x000008, "Member 'DCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.GetEnhancedPlayerInput
// 0x0010 (0x0010 - 0x0000)
struct DCEnhancedInputLibrary_GetEnhancedPlayerInput final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnhancedPlayerInput*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_GetEnhancedPlayerInput) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_GetEnhancedPlayerInput");
static_assert(sizeof(DCEnhancedInputLibrary_GetEnhancedPlayerInput) == 0x000010, "Wrong size on DCEnhancedInputLibrary_GetEnhancedPlayerInput");
static_assert(offsetof(DCEnhancedInputLibrary_GetEnhancedPlayerInput, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_GetEnhancedPlayerInput::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetEnhancedPlayerInput, ReturnValue) == 0x000008, "Member 'DCEnhancedInputLibrary_GetEnhancedPlayerInput::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.GetFirstMappedKeyFromRegisteredInputToAction
// 0x0028 (0x0028 - 0x0000)
struct DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInputAction*                     Action;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction");
static_assert(sizeof(DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction) == 0x000028, "Wrong size on DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction");
static_assert(offsetof(DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction, Action) == 0x000008, "Member 'DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction::Action' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction, ReturnValue) == 0x000010, "Member 'DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.GetInputAction
// 0x0020 (0x0020 - 0x0000)
struct DCEnhancedInputLibrary_GetInputAction final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputConfigTag;                                    // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInputAction*                     ReturnValue;                                       // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_GetInputAction) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_GetInputAction");
static_assert(sizeof(DCEnhancedInputLibrary_GetInputAction) == 0x000020, "Wrong size on DCEnhancedInputLibrary_GetInputAction");
static_assert(offsetof(DCEnhancedInputLibrary_GetInputAction, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_GetInputAction::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetInputAction, InputConfigTag) == 0x000008, "Member 'DCEnhancedInputLibrary_GetInputAction::InputConfigTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetInputAction, InputTag) == 0x000010, "Member 'DCEnhancedInputLibrary_GetInputAction::InputTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetInputAction, ReturnValue) == 0x000018, "Member 'DCEnhancedInputLibrary_GetInputAction::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.GetInputConfigByTag
// 0x0018 (0x0018 - 0x0000)
struct DCEnhancedInputLibrary_GetInputConfigByTag final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputConfigTag;                                    // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDCInputConfig*                   ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_GetInputConfigByTag) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_GetInputConfigByTag");
static_assert(sizeof(DCEnhancedInputLibrary_GetInputConfigByTag) == 0x000018, "Wrong size on DCEnhancedInputLibrary_GetInputConfigByTag");
static_assert(offsetof(DCEnhancedInputLibrary_GetInputConfigByTag, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_GetInputConfigByTag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetInputConfigByTag, InputConfigTag) == 0x000008, "Member 'DCEnhancedInputLibrary_GetInputConfigByTag::InputConfigTag' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetInputConfigByTag, ReturnValue) == 0x000010, "Member 'DCEnhancedInputLibrary_GetInputConfigByTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.GetKeysMappedToAction
// 0x0020 (0x0020 - 0x0000)
struct DCEnhancedInputLibrary_GetKeysMappedToAction final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInputAction*                     Action;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_GetKeysMappedToAction) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_GetKeysMappedToAction");
static_assert(sizeof(DCEnhancedInputLibrary_GetKeysMappedToAction) == 0x000020, "Wrong size on DCEnhancedInputLibrary_GetKeysMappedToAction");
static_assert(offsetof(DCEnhancedInputLibrary_GetKeysMappedToAction, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_GetKeysMappedToAction::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetKeysMappedToAction, Action) == 0x000008, "Member 'DCEnhancedInputLibrary_GetKeysMappedToAction::Action' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_GetKeysMappedToAction, ReturnValue) == 0x000010, "Member 'DCEnhancedInputLibrary_GetKeysMappedToAction::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.InjectInputForAction
// 0x0050 (0x0050 - 0x0000)
struct DCEnhancedInputLibrary_InjectInputForAction final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInputAction*                     Action;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputActionValue                      RawValue;                                          // 0x0010(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UInputModifier*>                 Modifiers;                                         // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UInputTrigger*>                  Triggers;                                          // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_InjectInputForAction) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_InjectInputForAction");
static_assert(sizeof(DCEnhancedInputLibrary_InjectInputForAction) == 0x000050, "Wrong size on DCEnhancedInputLibrary_InjectInputForAction");
static_assert(offsetof(DCEnhancedInputLibrary_InjectInputForAction, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_InjectInputForAction::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_InjectInputForAction, Action) == 0x000008, "Member 'DCEnhancedInputLibrary_InjectInputForAction::Action' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_InjectInputForAction, RawValue) == 0x000010, "Member 'DCEnhancedInputLibrary_InjectInputForAction::RawValue' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_InjectInputForAction, Modifiers) == 0x000030, "Member 'DCEnhancedInputLibrary_InjectInputForAction::Modifiers' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_InjectInputForAction, Triggers) == 0x000040, "Member 'DCEnhancedInputLibrary_InjectInputForAction::Triggers' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.InjectInputVectorForAction
// 0x0048 (0x0048 - 0x0000)
struct DCEnhancedInputLibrary_InjectInputVectorForAction final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UInputAction*                     Action;                                            // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0010(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInputModifier*>                 Modifiers;                                         // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UInputTrigger*>                  Triggers;                                          // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_InjectInputVectorForAction) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_InjectInputVectorForAction");
static_assert(sizeof(DCEnhancedInputLibrary_InjectInputVectorForAction) == 0x000048, "Wrong size on DCEnhancedInputLibrary_InjectInputVectorForAction");
static_assert(offsetof(DCEnhancedInputLibrary_InjectInputVectorForAction, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_InjectInputVectorForAction::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_InjectInputVectorForAction, Action) == 0x000008, "Member 'DCEnhancedInputLibrary_InjectInputVectorForAction::Action' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_InjectInputVectorForAction, Value) == 0x000010, "Member 'DCEnhancedInputLibrary_InjectInputVectorForAction::Value' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_InjectInputVectorForAction, Modifiers) == 0x000028, "Member 'DCEnhancedInputLibrary_InjectInputVectorForAction::Modifiers' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_InjectInputVectorForAction, Triggers) == 0x000038, "Member 'DCEnhancedInputLibrary_InjectInputVectorForAction::Triggers' has a wrong offset!");

// Function DungeonCrawler.DCEnhancedInputLibrary.RemovePlayerMappableConfigByTagContainer
// 0x0028 (0x0028 - 0x0000)
struct DCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InputConfigTags;                                   // 0x0008(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer) == 0x000008, "Wrong alignment on DCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer");
static_assert(sizeof(DCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer) == 0x000028, "Wrong size on DCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer");
static_assert(offsetof(DCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer, WorldContextObject) == 0x000000, "Member 'DCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer, InputConfigTags) == 0x000008, "Member 'DCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer::InputConfigTags' has a wrong offset!");

// Function DungeonCrawler.DCQuestProgressSlotWidget.GetQuestIndexText
// 0x0018 (0x0018 - 0x0000)
struct DCQuestProgressSlotWidget_GetQuestIndexText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestProgressSlotWidget_GetQuestIndexText) == 0x000008, "Wrong alignment on DCQuestProgressSlotWidget_GetQuestIndexText");
static_assert(sizeof(DCQuestProgressSlotWidget_GetQuestIndexText) == 0x000018, "Wrong size on DCQuestProgressSlotWidget_GetQuestIndexText");
static_assert(offsetof(DCQuestProgressSlotWidget_GetQuestIndexText, ReturnValue) == 0x000000, "Member 'DCQuestProgressSlotWidget_GetQuestIndexText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEquipAbility.OnInterrupt
// 0x00B8 (0x00B8 - 0x0000)
struct DCEquipAbility_OnInterrupt final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipAbility_OnInterrupt) == 0x000008, "Wrong alignment on DCEquipAbility_OnInterrupt");
static_assert(sizeof(DCEquipAbility_OnInterrupt) == 0x0000B8, "Wrong size on DCEquipAbility_OnInterrupt");
static_assert(offsetof(DCEquipAbility_OnInterrupt, EventTag) == 0x000000, "Member 'DCEquipAbility_OnInterrupt::EventTag' has a wrong offset!");
static_assert(offsetof(DCEquipAbility_OnInterrupt, EventData) == 0x000008, "Member 'DCEquipAbility_OnInterrupt::EventData' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.OnRep_EquipAnimData
// 0x02D0 (0x02D0 - 0x0000)
struct DCEquipmentComponent_OnRep_EquipAnimData final
{
public:
	struct FDCEquipAnimData                       OldEquipAnimData;                                  // 0x0000(0x02D0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentComponent_OnRep_EquipAnimData) == 0x000008, "Wrong alignment on DCEquipmentComponent_OnRep_EquipAnimData");
static_assert(sizeof(DCEquipmentComponent_OnRep_EquipAnimData) == 0x0002D0, "Wrong size on DCEquipmentComponent_OnRep_EquipAnimData");
static_assert(offsetof(DCEquipmentComponent_OnRep_EquipAnimData, OldEquipAnimData) == 0x000000, "Member 'DCEquipmentComponent_OnRep_EquipAnimData::OldEquipAnimData' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.OnRep_EquipArmorInfo
// 0x0020 (0x0020 - 0x0000)
struct DCEquipmentComponent_OnRep_EquipArmorInfo final
{
public:
	struct FDCEquipArmorInfo                      OldEquipArmorInfo;                                 // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentComponent_OnRep_EquipArmorInfo) == 0x000008, "Wrong alignment on DCEquipmentComponent_OnRep_EquipArmorInfo");
static_assert(sizeof(DCEquipmentComponent_OnRep_EquipArmorInfo) == 0x000020, "Wrong size on DCEquipmentComponent_OnRep_EquipArmorInfo");
static_assert(offsetof(DCEquipmentComponent_OnRep_EquipArmorInfo, OldEquipArmorInfo) == 0x000000, "Member 'DCEquipmentComponent_OnRep_EquipArmorInfo::OldEquipArmorInfo' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.OnRep_EquipHoldableInfos
// 0x0010 (0x0010 - 0x0000)
struct DCEquipmentComponent_OnRep_EquipHoldableInfos final
{
public:
	TArray<struct FDCEquipHoldableInfo>           OldEquipHoldableInfo;                              // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentComponent_OnRep_EquipHoldableInfos) == 0x000008, "Wrong alignment on DCEquipmentComponent_OnRep_EquipHoldableInfos");
static_assert(sizeof(DCEquipmentComponent_OnRep_EquipHoldableInfos) == 0x000010, "Wrong size on DCEquipmentComponent_OnRep_EquipHoldableInfos");
static_assert(offsetof(DCEquipmentComponent_OnRep_EquipHoldableInfos, OldEquipHoldableInfo) == 0x000000, "Member 'DCEquipmentComponent_OnRep_EquipHoldableInfos::OldEquipHoldableInfo' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.OnRep_EquipHoldInfo
// 0x0028 (0x0028 - 0x0000)
struct DCEquipmentComponent_OnRep_EquipHoldInfo final
{
public:
	struct FDCEquipHoldInfo                       OldEquipHoldInfo;                                  // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentComponent_OnRep_EquipHoldInfo) == 0x000008, "Wrong alignment on DCEquipmentComponent_OnRep_EquipHoldInfo");
static_assert(sizeof(DCEquipmentComponent_OnRep_EquipHoldInfo) == 0x000028, "Wrong size on DCEquipmentComponent_OnRep_EquipHoldInfo");
static_assert(offsetof(DCEquipmentComponent_OnRep_EquipHoldInfo, OldEquipHoldInfo) == 0x000000, "Member 'DCEquipmentComponent_OnRep_EquipHoldInfo::OldEquipHoldInfo' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.GetEquipHoldInfo
// 0x0028 (0x0028 - 0x0000)
struct DCEquipmentComponent_GetEquipHoldInfo final
{
public:
	struct FDCEquipHoldInfo                       ReturnValue;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentComponent_GetEquipHoldInfo) == 0x000008, "Wrong alignment on DCEquipmentComponent_GetEquipHoldInfo");
static_assert(sizeof(DCEquipmentComponent_GetEquipHoldInfo) == 0x000028, "Wrong size on DCEquipmentComponent_GetEquipHoldInfo");
static_assert(offsetof(DCEquipmentComponent_GetEquipHoldInfo, ReturnValue) == 0x000000, "Member 'DCEquipmentComponent_GetEquipHoldInfo::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.GetEquippedItemActors
// 0x0010 (0x0010 - 0x0000)
struct DCEquipmentComponent_GetEquippedItemActors final
{
public:
	TArray<class AItemActor*>                     OutItemActors;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentComponent_GetEquippedItemActors) == 0x000008, "Wrong alignment on DCEquipmentComponent_GetEquippedItemActors");
static_assert(sizeof(DCEquipmentComponent_GetEquippedItemActors) == 0x000010, "Wrong size on DCEquipmentComponent_GetEquippedItemActors");
static_assert(offsetof(DCEquipmentComponent_GetEquippedItemActors, OutItemActors) == 0x000000, "Member 'DCEquipmentComponent_GetEquippedItemActors::OutItemActors' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.GetEquippedItemInfos
// 0x0010 (0x0010 - 0x0000)
struct DCEquipmentComponent_GetEquippedItemInfos final
{
public:
	TArray<struct FDCItemInfo>                    ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentComponent_GetEquippedItemInfos) == 0x000008, "Wrong alignment on DCEquipmentComponent_GetEquippedItemInfos");
static_assert(sizeof(DCEquipmentComponent_GetEquippedItemInfos) == 0x000010, "Wrong size on DCEquipmentComponent_GetEquippedItemInfos");
static_assert(offsetof(DCEquipmentComponent_GetEquippedItemInfos, ReturnValue) == 0x000000, "Member 'DCEquipmentComponent_GetEquippedItemInfos::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.GetHoldingItemActors
// 0x0010 (0x0010 - 0x0000)
struct DCEquipmentComponent_GetHoldingItemActors final
{
public:
	TArray<class AItemActor*>                     OutItemActors;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentComponent_GetHoldingItemActors) == 0x000008, "Wrong alignment on DCEquipmentComponent_GetHoldingItemActors");
static_assert(sizeof(DCEquipmentComponent_GetHoldingItemActors) == 0x000010, "Wrong size on DCEquipmentComponent_GetHoldingItemActors");
static_assert(offsetof(DCEquipmentComponent_GetHoldingItemActors, OutItemActors) == 0x000000, "Member 'DCEquipmentComponent_GetHoldingItemActors::OutItemActors' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.GetItemActorById
// 0x0010 (0x0010 - 0x0000)
struct DCEquipmentComponent_GetItemActorById final
{
public:
	struct FDCItemId                              ItemId;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AItemActor*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentComponent_GetItemActorById) == 0x000008, "Wrong alignment on DCEquipmentComponent_GetItemActorById");
static_assert(sizeof(DCEquipmentComponent_GetItemActorById) == 0x000010, "Wrong size on DCEquipmentComponent_GetItemActorById");
static_assert(offsetof(DCEquipmentComponent_GetItemActorById, ItemId) == 0x000000, "Member 'DCEquipmentComponent_GetItemActorById::ItemId' has a wrong offset!");
static_assert(offsetof(DCEquipmentComponent_GetItemActorById, ReturnValue) == 0x000008, "Member 'DCEquipmentComponent_GetItemActorById::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.GetItemActorBySlot
// 0x0010 (0x0010 - 0x0000)
struct DCEquipmentComponent_GetItemActorBySlot final
{
public:
	EDCEquipmentSlotIndex                         Slot;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2635[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AItemActor*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentComponent_GetItemActorBySlot) == 0x000008, "Wrong alignment on DCEquipmentComponent_GetItemActorBySlot");
static_assert(sizeof(DCEquipmentComponent_GetItemActorBySlot) == 0x000010, "Wrong size on DCEquipmentComponent_GetItemActorBySlot");
static_assert(offsetof(DCEquipmentComponent_GetItemActorBySlot, Slot) == 0x000000, "Member 'DCEquipmentComponent_GetItemActorBySlot::Slot' has a wrong offset!");
static_assert(offsetof(DCEquipmentComponent_GetItemActorBySlot, ReturnValue) == 0x000008, "Member 'DCEquipmentComponent_GetItemActorBySlot::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentComponent.GetItemInfoBySlot
// 0x0178 (0x0178 - 0x0000)
struct DCEquipmentComponent_GetItemInfoBySlot final
{
public:
	EDCEquipmentSlotIndex                         Slot;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2636[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCItemInfo                            OutItemInfo;                                       // 0x0008(0x0168)(Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0170(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2637[0x7];                                     // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCEquipmentComponent_GetItemInfoBySlot) == 0x000008, "Wrong alignment on DCEquipmentComponent_GetItemInfoBySlot");
static_assert(sizeof(DCEquipmentComponent_GetItemInfoBySlot) == 0x000178, "Wrong size on DCEquipmentComponent_GetItemInfoBySlot");
static_assert(offsetof(DCEquipmentComponent_GetItemInfoBySlot, Slot) == 0x000000, "Member 'DCEquipmentComponent_GetItemInfoBySlot::Slot' has a wrong offset!");
static_assert(offsetof(DCEquipmentComponent_GetItemInfoBySlot, OutItemInfo) == 0x000008, "Member 'DCEquipmentComponent_GetItemInfoBySlot::OutItemInfo' has a wrong offset!");
static_assert(offsetof(DCEquipmentComponent_GetItemInfoBySlot, ReturnValue) == 0x000170, "Member 'DCEquipmentComponent_GetItemInfoBySlot::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemSkinComponent.AddDataForDebug_Server
// 0x0008 (0x0008 - 0x0000)
struct DCItemSkinComponent_AddDataForDebug_Server final
{
public:
	const class UDCItemSkinDataAsset*             InData;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemSkinComponent_AddDataForDebug_Server) == 0x000008, "Wrong alignment on DCItemSkinComponent_AddDataForDebug_Server");
static_assert(sizeof(DCItemSkinComponent_AddDataForDebug_Server) == 0x000008, "Wrong size on DCItemSkinComponent_AddDataForDebug_Server");
static_assert(offsetof(DCItemSkinComponent_AddDataForDebug_Server, InData) == 0x000000, "Member 'DCItemSkinComponent_AddDataForDebug_Server::InData' has a wrong offset!");

// Function DungeonCrawler.DCItemSkinComponent.OnRep_Datas
// 0x0010 (0x0010 - 0x0000)
struct DCItemSkinComponent_OnRep_Datas final
{
public:
	TArray<class UDCItemSkinDataAsset*>           OldDatas;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemSkinComponent_OnRep_Datas) == 0x000008, "Wrong alignment on DCItemSkinComponent_OnRep_Datas");
static_assert(sizeof(DCItemSkinComponent_OnRep_Datas) == 0x000010, "Wrong size on DCItemSkinComponent_OnRep_Datas");
static_assert(offsetof(DCItemSkinComponent_OnRep_Datas, OldDatas) == 0x000000, "Member 'DCItemSkinComponent_OnRep_Datas::OldDatas' has a wrong offset!");

// Function DungeonCrawler.DCItemSkinComponent.RemoveDataForDebug_Server
// 0x0010 (0x0010 - 0x0000)
struct DCItemSkinComponent_RemoveDataForDebug_Server final
{
public:
	struct FPrimaryAssetId                        ID;                                                // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemSkinComponent_RemoveDataForDebug_Server) == 0x000004, "Wrong alignment on DCItemSkinComponent_RemoveDataForDebug_Server");
static_assert(sizeof(DCItemSkinComponent_RemoveDataForDebug_Server) == 0x000010, "Wrong size on DCItemSkinComponent_RemoveDataForDebug_Server");
static_assert(offsetof(DCItemSkinComponent_RemoveDataForDebug_Server, ID) == 0x000000, "Member 'DCItemSkinComponent_RemoveDataForDebug_Server::ID' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentSlotWidget.GetEquipElapsedSeconds
// 0x0004 (0x0004 - 0x0000)
struct DCEquipmentSlotWidget_GetEquipElapsedSeconds final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentSlotWidget_GetEquipElapsedSeconds) == 0x000004, "Wrong alignment on DCEquipmentSlotWidget_GetEquipElapsedSeconds");
static_assert(sizeof(DCEquipmentSlotWidget_GetEquipElapsedSeconds) == 0x000004, "Wrong size on DCEquipmentSlotWidget_GetEquipElapsedSeconds");
static_assert(offsetof(DCEquipmentSlotWidget_GetEquipElapsedSeconds, ReturnValue) == 0x000000, "Member 'DCEquipmentSlotWidget_GetEquipElapsedSeconds::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentSlotWidget.GetEquipRemainSeconds
// 0x0004 (0x0004 - 0x0000)
struct DCEquipmentSlotWidget_GetEquipRemainSeconds final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentSlotWidget_GetEquipRemainSeconds) == 0x000004, "Wrong alignment on DCEquipmentSlotWidget_GetEquipRemainSeconds");
static_assert(sizeof(DCEquipmentSlotWidget_GetEquipRemainSeconds) == 0x000004, "Wrong size on DCEquipmentSlotWidget_GetEquipRemainSeconds");
static_assert(offsetof(DCEquipmentSlotWidget_GetEquipRemainSeconds, ReturnValue) == 0x000000, "Member 'DCEquipmentSlotWidget_GetEquipRemainSeconds::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentSlotWidget.IsPairSlot
// 0x0001 (0x0001 - 0x0000)
struct DCEquipmentSlotWidget_IsPairSlot final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentSlotWidget_IsPairSlot) == 0x000001, "Wrong alignment on DCEquipmentSlotWidget_IsPairSlot");
static_assert(sizeof(DCEquipmentSlotWidget_IsPairSlot) == 0x000001, "Wrong size on DCEquipmentSlotWidget_IsPairSlot");
static_assert(offsetof(DCEquipmentSlotWidget_IsPairSlot, ReturnValue) == 0x000000, "Member 'DCEquipmentSlotWidget_IsPairSlot::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentSlotWidget.IsTwoHandedWeapon
// 0x0001 (0x0001 - 0x0000)
struct DCEquipmentSlotWidget_IsTwoHandedWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentSlotWidget_IsTwoHandedWeapon) == 0x000001, "Wrong alignment on DCEquipmentSlotWidget_IsTwoHandedWeapon");
static_assert(sizeof(DCEquipmentSlotWidget_IsTwoHandedWeapon) == 0x000001, "Wrong size on DCEquipmentSlotWidget_IsTwoHandedWeapon");
static_assert(offsetof(DCEquipmentSlotWidget_IsTwoHandedWeapon, ReturnValue) == 0x000000, "Member 'DCEquipmentSlotWidget_IsTwoHandedWeapon::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentSlotWidget.IsWeapon
// 0x0001 (0x0001 - 0x0000)
struct DCEquipmentSlotWidget_IsWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentSlotWidget_IsWeapon) == 0x000001, "Wrong alignment on DCEquipmentSlotWidget_IsWeapon");
static_assert(sizeof(DCEquipmentSlotWidget_IsWeapon) == 0x000001, "Wrong size on DCEquipmentSlotWidget_IsWeapon");
static_assert(offsetof(DCEquipmentSlotWidget_IsWeapon, ReturnValue) == 0x000000, "Member 'DCEquipmentSlotWidget_IsWeapon::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCEquipmentWidget.GetSlotWidget
// 0x0010 (0x0010 - 0x0000)
struct DCEquipmentWidget_GetSlotWidget final
{
public:
	EDCEquipmentSlotIndex                         Param_Index;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2640[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCEquipmentSlotWidget*                 ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCEquipmentWidget_GetSlotWidget) == 0x000008, "Wrong alignment on DCEquipmentWidget_GetSlotWidget");
static_assert(sizeof(DCEquipmentWidget_GetSlotWidget) == 0x000010, "Wrong size on DCEquipmentWidget_GetSlotWidget");
static_assert(offsetof(DCEquipmentWidget_GetSlotWidget, Param_Index) == 0x000000, "Member 'DCEquipmentWidget_GetSlotWidget::Param_Index' has a wrong offset!");
static_assert(offsetof(DCEquipmentWidget_GetSlotWidget, ReturnValue) == 0x000008, "Member 'DCEquipmentWidget_GetSlotWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_ShapeShiftBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_ShapeShiftBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ShapeShiftBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_ShapeShiftBase_AbilityActivated");
static_assert(sizeof(GA_ShapeShiftBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_ShapeShiftBase_AbilityActivated");
static_assert(offsetof(GA_ShapeShiftBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_ShapeShiftBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_ShapeShiftBase.OnShapeShiftBuffTagRemoved
// 0x0004 (0x0004 - 0x0000)
struct GA_ShapeShiftBase_OnShapeShiftBuffTagRemoved final
{
public:
	int32                                         NewCount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ShapeShiftBase_OnShapeShiftBuffTagRemoved) == 0x000004, "Wrong alignment on GA_ShapeShiftBase_OnShapeShiftBuffTagRemoved");
static_assert(sizeof(GA_ShapeShiftBase_OnShapeShiftBuffTagRemoved) == 0x000004, "Wrong size on GA_ShapeShiftBase_OnShapeShiftBuffTagRemoved");
static_assert(offsetof(GA_ShapeShiftBase_OnShapeShiftBuffTagRemoved, NewCount) == 0x000000, "Member 'GA_ShapeShiftBase_OnShapeShiftBuffTagRemoved::NewCount' has a wrong offset!");

// Function DungeonCrawler.DCFeatureUnlockRemainTimeWidget.OnAccountStatusUpdated
// 0x0001 (0x0001 - 0x0000)
struct DCFeatureUnlockRemainTimeWidget_OnAccountStatusUpdated final
{
public:
	EDCAccountStatus                              InAccountStatus;                                   // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCFeatureUnlockRemainTimeWidget_OnAccountStatusUpdated) == 0x000001, "Wrong alignment on DCFeatureUnlockRemainTimeWidget_OnAccountStatusUpdated");
static_assert(sizeof(DCFeatureUnlockRemainTimeWidget_OnAccountStatusUpdated) == 0x000001, "Wrong size on DCFeatureUnlockRemainTimeWidget_OnAccountStatusUpdated");
static_assert(offsetof(DCFeatureUnlockRemainTimeWidget_OnAccountStatusUpdated, InAccountStatus) == 0x000000, "Member 'DCFeatureUnlockRemainTimeWidget_OnAccountStatusUpdated::InAccountStatus' has a wrong offset!");

// Function DungeonCrawler.DCFeatureUnlockRemainTimeWidget.SetRemainTime
// 0x0008 (0x0008 - 0x0000)
struct DCFeatureUnlockRemainTimeWidget_SetRemainTime final
{
public:
	struct FTimespan                              InRemainTime;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCFeatureUnlockRemainTimeWidget_SetRemainTime) == 0x000008, "Wrong alignment on DCFeatureUnlockRemainTimeWidget_SetRemainTime");
static_assert(sizeof(DCFeatureUnlockRemainTimeWidget_SetRemainTime) == 0x000008, "Wrong size on DCFeatureUnlockRemainTimeWidget_SetRemainTime");
static_assert(offsetof(DCFeatureUnlockRemainTimeWidget_SetRemainTime, InRemainTime) == 0x000000, "Member 'DCFeatureUnlockRemainTimeWidget_SetRemainTime::InRemainTime' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.AbilityActivated_BP
// 0x00B8 (0x00B8 - 0x0000)
struct GA_SpellBase_AbilityActivated_BP final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          bIsSocketSightBlocked;                             // 0x00B0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2649[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_SpellBase_AbilityActivated_BP) == 0x000008, "Wrong alignment on GA_SpellBase_AbilityActivated_BP");
static_assert(sizeof(GA_SpellBase_AbilityActivated_BP) == 0x0000B8, "Wrong size on GA_SpellBase_AbilityActivated_BP");
static_assert(offsetof(GA_SpellBase_AbilityActivated_BP, TriggerEventData) == 0x000000, "Member 'GA_SpellBase_AbilityActivated_BP::TriggerEventData' has a wrong offset!");
static_assert(offsetof(GA_SpellBase_AbilityActivated_BP, bIsSocketSightBlocked) == 0x0000B0, "Member 'GA_SpellBase_AbilityActivated_BP::bIsSocketSightBlocked' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.CastToSelf
// 0x0008 (0x0008 - 0x0000)
struct GA_SpellBase_CastToSelf final
{
public:
	struct FGameplayTag                           OptionalEffectContainerTag;                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellBase_CastToSelf) == 0x000004, "Wrong alignment on GA_SpellBase_CastToSelf");
static_assert(sizeof(GA_SpellBase_CastToSelf) == 0x000008, "Wrong size on GA_SpellBase_CastToSelf");
static_assert(offsetof(GA_SpellBase_CastToSelf, OptionalEffectContainerTag) == 0x000000, "Member 'GA_SpellBase_CastToSelf::OptionalEffectContainerTag' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.CastToTarget
// 0x00F8 (0x00F8 - 0x0000)
struct GA_SpellBase_CastToTarget final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OptionalEffectContainerTag;                        // 0x00E8(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264A[0x7];                                     // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_SpellBase_CastToTarget) == 0x000008, "Wrong alignment on GA_SpellBase_CastToTarget");
static_assert(sizeof(GA_SpellBase_CastToTarget) == 0x0000F8, "Wrong size on GA_SpellBase_CastToTarget");
static_assert(offsetof(GA_SpellBase_CastToTarget, HitResult) == 0x000000, "Member 'GA_SpellBase_CastToTarget::HitResult' has a wrong offset!");
static_assert(offsetof(GA_SpellBase_CastToTarget, OptionalEffectContainerTag) == 0x0000E8, "Member 'GA_SpellBase_CastToTarget::OptionalEffectContainerTag' has a wrong offset!");
static_assert(offsetof(GA_SpellBase_CastToTarget, ReturnValue) == 0x0000F0, "Member 'GA_SpellBase_CastToTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.FireProjectile
// 0x00F8 (0x00F8 - 0x0000)
struct GA_SpellBase_FireProjectile final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class AProjectileActor>           ProjectileActorClass;                              // 0x00E8(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AProjectileActor*                       ReturnValue;                                       // 0x00F0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellBase_FireProjectile) == 0x000008, "Wrong alignment on GA_SpellBase_FireProjectile");
static_assert(sizeof(GA_SpellBase_FireProjectile) == 0x0000F8, "Wrong size on GA_SpellBase_FireProjectile");
static_assert(offsetof(GA_SpellBase_FireProjectile, HitResult) == 0x000000, "Member 'GA_SpellBase_FireProjectile::HitResult' has a wrong offset!");
static_assert(offsetof(GA_SpellBase_FireProjectile, ProjectileActorClass) == 0x0000E8, "Member 'GA_SpellBase_FireProjectile::ProjectileActorClass' has a wrong offset!");
static_assert(offsetof(GA_SpellBase_FireProjectile, ReturnValue) == 0x0000F0, "Member 'GA_SpellBase_FireProjectile::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.OnCasted
// 0x0008 (0x0008 - 0x0000)
struct GA_SpellBase_OnCasted final
{
public:
	class AActor*                                 InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellBase_OnCasted) == 0x000008, "Wrong alignment on GA_SpellBase_OnCasted");
static_assert(sizeof(GA_SpellBase_OnCasted) == 0x000008, "Wrong size on GA_SpellBase_OnCasted");
static_assert(offsetof(GA_SpellBase_OnCasted, InTarget) == 0x000000, "Member 'GA_SpellBase_OnCasted::InTarget' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.GetAimRadius
// 0x0004 (0x0004 - 0x0000)
struct GA_SpellBase_GetAimRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellBase_GetAimRadius) == 0x000004, "Wrong alignment on GA_SpellBase_GetAimRadius");
static_assert(sizeof(GA_SpellBase_GetAimRadius) == 0x000004, "Wrong size on GA_SpellBase_GetAimRadius");
static_assert(offsetof(GA_SpellBase_GetAimRadius, ReturnValue) == 0x000000, "Member 'GA_SpellBase_GetAimRadius::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.GetAreaRadius
// 0x0004 (0x0004 - 0x0000)
struct GA_SpellBase_GetAreaRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellBase_GetAreaRadius) == 0x000004, "Wrong alignment on GA_SpellBase_GetAreaRadius");
static_assert(sizeof(GA_SpellBase_GetAreaRadius) == 0x000004, "Wrong size on GA_SpellBase_GetAreaRadius");
static_assert(offsetof(GA_SpellBase_GetAreaRadius, ReturnValue) == 0x000000, "Member 'GA_SpellBase_GetAreaRadius::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.GetDesignDataSpell
// 0x00D8 (0x00D8 - 0x0000)
struct GA_SpellBase_GetDesignDataSpell final
{
public:
	struct FDesignDataSpell                       ReturnValue;                                       // 0x0000(0x00D8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellBase_GetDesignDataSpell) == 0x000008, "Wrong alignment on GA_SpellBase_GetDesignDataSpell");
static_assert(sizeof(GA_SpellBase_GetDesignDataSpell) == 0x0000D8, "Wrong size on GA_SpellBase_GetDesignDataSpell");
static_assert(offsetof(GA_SpellBase_GetDesignDataSpell, ReturnValue) == 0x000000, "Member 'GA_SpellBase_GetDesignDataSpell::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.GetRange
// 0x0004 (0x0004 - 0x0000)
struct GA_SpellBase_GetRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellBase_GetRange) == 0x000004, "Wrong alignment on GA_SpellBase_GetRange");
static_assert(sizeof(GA_SpellBase_GetRange) == 0x000004, "Wrong size on GA_SpellBase_GetRange");
static_assert(offsetof(GA_SpellBase_GetRange, ReturnValue) == 0x000000, "Member 'GA_SpellBase_GetRange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.IsAreaInstall
// 0x0001 (0x0001 - 0x0000)
struct GA_SpellBase_IsAreaInstall final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellBase_IsAreaInstall) == 0x000001, "Wrong alignment on GA_SpellBase_IsAreaInstall");
static_assert(sizeof(GA_SpellBase_IsAreaInstall) == 0x000001, "Wrong size on GA_SpellBase_IsAreaInstall");
static_assert(offsetof(GA_SpellBase_IsAreaInstall, ReturnValue) == 0x000000, "Member 'GA_SpellBase_IsAreaInstall::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.IsSightBlocked
// 0x00F0 (0x00F0 - 0x0000)
struct GA_SpellBase_IsSightBlocked final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00E8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264B[0x7];                                     // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_SpellBase_IsSightBlocked) == 0x000008, "Wrong alignment on GA_SpellBase_IsSightBlocked");
static_assert(sizeof(GA_SpellBase_IsSightBlocked) == 0x0000F0, "Wrong size on GA_SpellBase_IsSightBlocked");
static_assert(offsetof(GA_SpellBase_IsSightBlocked, HitResult) == 0x000000, "Member 'GA_SpellBase_IsSightBlocked::HitResult' has a wrong offset!");
static_assert(offsetof(GA_SpellBase_IsSightBlocked, ReturnValue) == 0x0000E8, "Member 'GA_SpellBase_IsSightBlocked::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_SpellBase.IsSocketSightBlocked
// 0x0001 (0x0001 - 0x0000)
struct GA_SpellBase_IsSocketSightBlocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellBase_IsSocketSightBlocked) == 0x000001, "Wrong alignment on GA_SpellBase_IsSocketSightBlocked");
static_assert(sizeof(GA_SpellBase_IsSocketSightBlocked) == 0x000001, "Wrong size on GA_SpellBase_IsSocketSightBlocked");
static_assert(offsetof(GA_SpellBase_IsSocketSightBlocked, ReturnValue) == 0x000000, "Member 'GA_SpellBase_IsSocketSightBlocked::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemTooltipRequirementWidget.IsEmpty
// 0x0001 (0x0001 - 0x0000)
struct DCItemTooltipRequirementWidget_IsEmpty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemTooltipRequirementWidget_IsEmpty) == 0x000001, "Wrong alignment on DCItemTooltipRequirementWidget_IsEmpty");
static_assert(sizeof(DCItemTooltipRequirementWidget_IsEmpty) == 0x000001, "Wrong size on DCItemTooltipRequirementWidget_IsEmpty");
static_assert(offsetof(DCItemTooltipRequirementWidget_IsEmpty, ReturnValue) == 0x000000, "Member 'DCItemTooltipRequirementWidget_IsEmpty::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_ChangeIdle.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_ChangeIdle_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ChangeIdle_AbilityActivated) == 0x000008, "Wrong alignment on GA_ChangeIdle_AbilityActivated");
static_assert(sizeof(GA_ChangeIdle_AbilityActivated) == 0x0000B0, "Wrong size on GA_ChangeIdle_AbilityActivated");
static_assert(offsetof(GA_ChangeIdle_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_ChangeIdle_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_ChangeIdle.OnBlendOut
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ChangeIdle_OnBlendOut final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ChangeIdle_OnBlendOut) == 0x000008, "Wrong alignment on GA_ChangeIdle_OnBlendOut");
static_assert(sizeof(GA_ChangeIdle_OnBlendOut) == 0x0000B8, "Wrong size on GA_ChangeIdle_OnBlendOut");
static_assert(offsetof(GA_ChangeIdle_OnBlendOut, EventTag) == 0x000000, "Member 'GA_ChangeIdle_OnBlendOut::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ChangeIdle_OnBlendOut, EventData) == 0x000008, "Member 'GA_ChangeIdle_OnBlendOut::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ChangeIdle.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ChangeIdle_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ChangeIdle_OnCompleted) == 0x000008, "Wrong alignment on GA_ChangeIdle_OnCompleted");
static_assert(sizeof(GA_ChangeIdle_OnCompleted) == 0x0000B8, "Wrong size on GA_ChangeIdle_OnCompleted");
static_assert(offsetof(GA_ChangeIdle_OnCompleted, EventTag) == 0x000000, "Member 'GA_ChangeIdle_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ChangeIdle_OnCompleted, EventData) == 0x000008, "Member 'GA_ChangeIdle_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.TimerWidgetBase.OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint
// 0x00B0 (0x00B0 - 0x0000)
struct TimerWidgetBase_OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint final
{
public:
	struct FMsgAccountLinkAccountDataReplicationNotify InMsg;                                             // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimerWidgetBase_OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint) == 0x000008, "Wrong alignment on TimerWidgetBase_OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint");
static_assert(sizeof(TimerWidgetBase_OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint) == 0x0000B0, "Wrong size on TimerWidgetBase_OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint");
static_assert(offsetof(TimerWidgetBase_OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint, InMsg) == 0x000000, "Member 'TimerWidgetBase_OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.TimerWidgetBase.OnLeftHour
// 0x0008 (0x0008 - 0x0000)
struct TimerWidgetBase_OnLeftHour final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimerWidgetBase_OnLeftHour) == 0x000004, "Wrong alignment on TimerWidgetBase_OnLeftHour");
static_assert(sizeof(TimerWidgetBase_OnLeftHour) == 0x000008, "Wrong size on TimerWidgetBase_OnLeftHour");
static_assert(offsetof(TimerWidgetBase_OnLeftHour, NewValue) == 0x000000, "Member 'TimerWidgetBase_OnLeftHour::NewValue' has a wrong offset!");
static_assert(offsetof(TimerWidgetBase_OnLeftHour, OldValue) == 0x000004, "Member 'TimerWidgetBase_OnLeftHour::OldValue' has a wrong offset!");

// Function DungeonCrawler.TimerWidgetBase.OnLeftMinute
// 0x0008 (0x0008 - 0x0000)
struct TimerWidgetBase_OnLeftMinute final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimerWidgetBase_OnLeftMinute) == 0x000004, "Wrong alignment on TimerWidgetBase_OnLeftMinute");
static_assert(sizeof(TimerWidgetBase_OnLeftMinute) == 0x000008, "Wrong size on TimerWidgetBase_OnLeftMinute");
static_assert(offsetof(TimerWidgetBase_OnLeftMinute, NewValue) == 0x000000, "Member 'TimerWidgetBase_OnLeftMinute::NewValue' has a wrong offset!");
static_assert(offsetof(TimerWidgetBase_OnLeftMinute, OldValue) == 0x000004, "Member 'TimerWidgetBase_OnLeftMinute::OldValue' has a wrong offset!");

// Function DungeonCrawler.TimerWidgetBase.OnLeftSecond
// 0x0008 (0x0008 - 0x0000)
struct TimerWidgetBase_OnLeftSecond final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimerWidgetBase_OnLeftSecond) == 0x000004, "Wrong alignment on TimerWidgetBase_OnLeftSecond");
static_assert(sizeof(TimerWidgetBase_OnLeftSecond) == 0x000008, "Wrong size on TimerWidgetBase_OnLeftSecond");
static_assert(offsetof(TimerWidgetBase_OnLeftSecond, NewValue) == 0x000000, "Member 'TimerWidgetBase_OnLeftSecond::NewValue' has a wrong offset!");
static_assert(offsetof(TimerWidgetBase_OnLeftSecond, OldValue) == 0x000004, "Member 'TimerWidgetBase_OnLeftSecond::OldValue' has a wrong offset!");

// Function DungeonCrawler.TimerWidgetBase.OnProgress
// 0x0008 (0x0008 - 0x0000)
struct TimerWidgetBase_OnProgress final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimerWidgetBase_OnProgress) == 0x000004, "Wrong alignment on TimerWidgetBase_OnProgress");
static_assert(sizeof(TimerWidgetBase_OnProgress) == 0x000008, "Wrong size on TimerWidgetBase_OnProgress");
static_assert(offsetof(TimerWidgetBase_OnProgress, NewValue) == 0x000000, "Member 'TimerWidgetBase_OnProgress::NewValue' has a wrong offset!");
static_assert(offsetof(TimerWidgetBase_OnProgress, OldValue) == 0x000004, "Member 'TimerWidgetBase_OnProgress::OldValue' has a wrong offset!");

// Function DungeonCrawler.TimerWidgetBase.StartTimer
// 0x0004 (0x0004 - 0x0000)
struct TimerWidgetBase_StartTimer final
{
public:
	float                                         InEndServerWorldTime;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimerWidgetBase_StartTimer) == 0x000004, "Wrong alignment on TimerWidgetBase_StartTimer");
static_assert(sizeof(TimerWidgetBase_StartTimer) == 0x000004, "Wrong size on TimerWidgetBase_StartTimer");
static_assert(offsetof(TimerWidgetBase_StartTimer, InEndServerWorldTime) == 0x000000, "Member 'TimerWidgetBase_StartTimer::InEndServerWorldTime' has a wrong offset!");

// Function DungeonCrawler.DCGameInstance.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCGameInstance_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameInstance_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCGameInstance_BroadcastMsgBlueprint");
static_assert(sizeof(DCGameInstance_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCGameInstance_BroadcastMsgBlueprint");
static_assert(offsetof(DCGameInstance_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCGameInstance_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCGameInstance.OnPostLoadMapWithWorld
// 0x0008 (0x0008 - 0x0000)
struct DCGameInstance_OnPostLoadMapWithWorld final
{
public:
	class UWorld*                                 LoadedWorld;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameInstance_OnPostLoadMapWithWorld) == 0x000008, "Wrong alignment on DCGameInstance_OnPostLoadMapWithWorld");
static_assert(sizeof(DCGameInstance_OnPostLoadMapWithWorld) == 0x000008, "Wrong size on DCGameInstance_OnPostLoadMapWithWorld");
static_assert(offsetof(DCGameInstance_OnPostLoadMapWithWorld, LoadedWorld) == 0x000000, "Member 'DCGameInstance_OnPostLoadMapWithWorld::LoadedWorld' has a wrong offset!");

// Function DungeonCrawler.DCGameInstance.OnPreLoadMap
// 0x0010 (0x0010 - 0x0000)
struct DCGameInstance_OnPreLoadMap final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameInstance_OnPreLoadMap) == 0x000008, "Wrong alignment on DCGameInstance_OnPreLoadMap");
static_assert(sizeof(DCGameInstance_OnPreLoadMap) == 0x000010, "Wrong size on DCGameInstance_OnPreLoadMap");
static_assert(offsetof(DCGameInstance_OnPreLoadMap, MapName) == 0x000000, "Member 'DCGameInstance_OnPreLoadMap::MapName' has a wrong offset!");

// Function DungeonCrawler.DCGameInstance.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCGameInstance_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameInstance_UnbindMsg) == 0x000008, "Wrong alignment on DCGameInstance_UnbindMsg");
static_assert(sizeof(DCGameInstance_UnbindMsg) == 0x000010, "Wrong size on DCGameInstance_UnbindMsg");
static_assert(offsetof(DCGameInstance_UnbindMsg, InMsgType) == 0x000000, "Member 'DCGameInstance_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCGameInstance_UnbindMsg, InObject) == 0x000008, "Member 'DCGameInstance_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCGameInstance.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCGameInstance_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameInstance_UnbindMsgAll) == 0x000008, "Wrong alignment on DCGameInstance_UnbindMsgAll");
static_assert(sizeof(DCGameInstance_UnbindMsgAll) == 0x000008, "Wrong size on DCGameInstance_UnbindMsgAll");
static_assert(offsetof(DCGameInstance_UnbindMsgAll, InObject) == 0x000000, "Member 'DCGameInstance_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.GA_DrawbridgeWheel.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_DrawbridgeWheel_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_DrawbridgeWheel_AbilityActivated) == 0x000008, "Wrong alignment on GA_DrawbridgeWheel_AbilityActivated");
static_assert(sizeof(GA_DrawbridgeWheel_AbilityActivated) == 0x0000B0, "Wrong size on GA_DrawbridgeWheel_AbilityActivated");
static_assert(offsetof(GA_DrawbridgeWheel_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_DrawbridgeWheel_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_DrawbridgeWheel.OnBlendOut
// 0x00B8 (0x00B8 - 0x0000)
struct GA_DrawbridgeWheel_OnBlendOut final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_DrawbridgeWheel_OnBlendOut) == 0x000008, "Wrong alignment on GA_DrawbridgeWheel_OnBlendOut");
static_assert(sizeof(GA_DrawbridgeWheel_OnBlendOut) == 0x0000B8, "Wrong size on GA_DrawbridgeWheel_OnBlendOut");
static_assert(offsetof(GA_DrawbridgeWheel_OnBlendOut, EventTag) == 0x000000, "Member 'GA_DrawbridgeWheel_OnBlendOut::EventTag' has a wrong offset!");
static_assert(offsetof(GA_DrawbridgeWheel_OnBlendOut, EventData) == 0x000008, "Member 'GA_DrawbridgeWheel_OnBlendOut::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_DrawbridgeWheel.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_DrawbridgeWheel_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_DrawbridgeWheel_OnCompleted) == 0x000008, "Wrong alignment on GA_DrawbridgeWheel_OnCompleted");
static_assert(sizeof(GA_DrawbridgeWheel_OnCompleted) == 0x0000B8, "Wrong size on GA_DrawbridgeWheel_OnCompleted");
static_assert(offsetof(GA_DrawbridgeWheel_OnCompleted, EventTag) == 0x000000, "Member 'GA_DrawbridgeWheel_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_DrawbridgeWheel_OnCompleted, EventData) == 0x000008, "Member 'GA_DrawbridgeWheel_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.DCGameObjectLinkComponent.BroadcastGlobalEvent
// 0x0010 (0x0010 - 0x0000)
struct DCGameObjectLinkComponent_BroadcastGlobalEvent final
{
public:
	struct FObjectLinkGlobalEvent                 InGlobalEvent;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameObjectLinkComponent_BroadcastGlobalEvent) == 0x000004, "Wrong alignment on DCGameObjectLinkComponent_BroadcastGlobalEvent");
static_assert(sizeof(DCGameObjectLinkComponent_BroadcastGlobalEvent) == 0x000010, "Wrong size on DCGameObjectLinkComponent_BroadcastGlobalEvent");
static_assert(offsetof(DCGameObjectLinkComponent_BroadcastGlobalEvent, InGlobalEvent) == 0x000000, "Member 'DCGameObjectLinkComponent_BroadcastGlobalEvent::InGlobalEvent' has a wrong offset!");

// Function DungeonCrawler.DCGameObjectLinkComponent.IsLinkerSet
// 0x0001 (0x0001 - 0x0000)
struct DCGameObjectLinkComponent_IsLinkerSet final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameObjectLinkComponent_IsLinkerSet) == 0x000001, "Wrong alignment on DCGameObjectLinkComponent_IsLinkerSet");
static_assert(sizeof(DCGameObjectLinkComponent_IsLinkerSet) == 0x000001, "Wrong size on DCGameObjectLinkComponent_IsLinkerSet");
static_assert(offsetof(DCGameObjectLinkComponent_IsLinkerSet, ReturnValue) == 0x000000, "Member 'DCGameObjectLinkComponent_IsLinkerSet::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameObjectLinkComponent.RequestToLinkers
// 0x00E0 (0x00E0 - 0x0000)
struct DCGameObjectLinkComponent_RequestToLinkers final
{
public:
	struct FObjectLinkRequestEvent                ObjectLinkRequestEvent;                            // 0x0000(0x00D0)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FObjectLinkResponeEvent>        ReturnValue;                                       // 0x00D0(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameObjectLinkComponent_RequestToLinkers) == 0x000008, "Wrong alignment on DCGameObjectLinkComponent_RequestToLinkers");
static_assert(sizeof(DCGameObjectLinkComponent_RequestToLinkers) == 0x0000E0, "Wrong size on DCGameObjectLinkComponent_RequestToLinkers");
static_assert(offsetof(DCGameObjectLinkComponent_RequestToLinkers, ObjectLinkRequestEvent) == 0x000000, "Member 'DCGameObjectLinkComponent_RequestToLinkers::ObjectLinkRequestEvent' has a wrong offset!");
static_assert(offsetof(DCGameObjectLinkComponent_RequestToLinkers, ReturnValue) == 0x0000D0, "Member 'DCGameObjectLinkComponent_RequestToLinkers::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCUIFadeEffectWidget.FindParentActivatableWidget
// 0x0008 (0x0008 - 0x0000)
struct DCUIFadeEffectWidget_FindParentActivatableWidget final
{
public:
	class UDCCommonActivatableWidgetBase*         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCUIFadeEffectWidget_FindParentActivatableWidget) == 0x000008, "Wrong alignment on DCUIFadeEffectWidget_FindParentActivatableWidget");
static_assert(sizeof(DCUIFadeEffectWidget_FindParentActivatableWidget) == 0x000008, "Wrong size on DCUIFadeEffectWidget_FindParentActivatableWidget");
static_assert(offsetof(DCUIFadeEffectWidget_FindParentActivatableWidget, ReturnValue) == 0x000000, "Member 'DCUIFadeEffectWidget_FindParentActivatableWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCUIFadeEffectWidget.OnActiveEffectPanelVisibilityChanged
// 0x0001 (0x0001 - 0x0000)
struct DCUIFadeEffectWidget_OnActiveEffectPanelVisibilityChanged final
{
public:
	ESlateVisibility                              NewVisibility;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCUIFadeEffectWidget_OnActiveEffectPanelVisibilityChanged) == 0x000001, "Wrong alignment on DCUIFadeEffectWidget_OnActiveEffectPanelVisibilityChanged");
static_assert(sizeof(DCUIFadeEffectWidget_OnActiveEffectPanelVisibilityChanged) == 0x000001, "Wrong size on DCUIFadeEffectWidget_OnActiveEffectPanelVisibilityChanged");
static_assert(offsetof(DCUIFadeEffectWidget_OnActiveEffectPanelVisibilityChanged, NewVisibility) == 0x000000, "Member 'DCUIFadeEffectWidget_OnActiveEffectPanelVisibilityChanged::NewVisibility' has a wrong offset!");

// Function DungeonCrawler.DCGameplayTagCollider.OnOverlapBegin
// 0x0108 (0x0108 - 0x0000)
struct DCGameplayTagCollider_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2660[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayTagCollider_OnOverlapBegin) == 0x000008, "Wrong alignment on DCGameplayTagCollider_OnOverlapBegin");
static_assert(sizeof(DCGameplayTagCollider_OnOverlapBegin) == 0x000108, "Wrong size on DCGameplayTagCollider_OnOverlapBegin");
static_assert(offsetof(DCGameplayTagCollider_OnOverlapBegin, OverlappedComponent) == 0x000000, "Member 'DCGameplayTagCollider_OnOverlapBegin::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(DCGameplayTagCollider_OnOverlapBegin, OtherActor) == 0x000008, "Member 'DCGameplayTagCollider_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(DCGameplayTagCollider_OnOverlapBegin, OtherComp) == 0x000010, "Member 'DCGameplayTagCollider_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(DCGameplayTagCollider_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'DCGameplayTagCollider_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(DCGameplayTagCollider_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'DCGameplayTagCollider_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(DCGameplayTagCollider_OnOverlapBegin, SweepResult) == 0x000020, "Member 'DCGameplayTagCollider_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function DungeonCrawler.DCGameplayTagCollider.OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct DCGameplayTagCollider_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2661[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCGameplayTagCollider_OnOverlapEnd) == 0x000008, "Wrong alignment on DCGameplayTagCollider_OnOverlapEnd");
static_assert(sizeof(DCGameplayTagCollider_OnOverlapEnd) == 0x000020, "Wrong size on DCGameplayTagCollider_OnOverlapEnd");
static_assert(offsetof(DCGameplayTagCollider_OnOverlapEnd, OverlappedComponent) == 0x000000, "Member 'DCGameplayTagCollider_OnOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(DCGameplayTagCollider_OnOverlapEnd, OtherActor) == 0x000008, "Member 'DCGameplayTagCollider_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(DCGameplayTagCollider_OnOverlapEnd, OtherComp) == 0x000010, "Member 'DCGameplayTagCollider_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(DCGameplayTagCollider_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'DCGameplayTagCollider_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DungeonCrawler.DCGameplayTagCollider.OnRep_TargetAccountId
// 0x0010 (0x0010 - 0x0000)
struct DCGameplayTagCollider_OnRep_TargetAccountId final
{
public:
	class FString                                 InOldTargetAccountId;                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameplayTagCollider_OnRep_TargetAccountId) == 0x000008, "Wrong alignment on DCGameplayTagCollider_OnRep_TargetAccountId");
static_assert(sizeof(DCGameplayTagCollider_OnRep_TargetAccountId) == 0x000010, "Wrong size on DCGameplayTagCollider_OnRep_TargetAccountId");
static_assert(offsetof(DCGameplayTagCollider_OnRep_TargetAccountId, InOldTargetAccountId) == 0x000000, "Member 'DCGameplayTagCollider_OnRep_TargetAccountId::InOldTargetAccountId' has a wrong offset!");

// Function DungeonCrawler.DescData.GetDescription
// 0x0018 (0x0018 - 0x0000)
struct DescData_GetDescription final
{
public:
	const class UDescDataParam*                   InDescDataParam;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           OutDescTextArray;                                  // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DescData_GetDescription) == 0x000008, "Wrong alignment on DescData_GetDescription");
static_assert(sizeof(DescData_GetDescription) == 0x000018, "Wrong size on DescData_GetDescription");
static_assert(offsetof(DescData_GetDescription, InDescDataParam) == 0x000000, "Member 'DescData_GetDescription::InDescDataParam' has a wrong offset!");
static_assert(offsetof(DescData_GetDescription, OutDescTextArray) == 0x000008, "Member 'DescData_GetDescription::OutDescTextArray' has a wrong offset!");

// Function DungeonCrawler.DescData.GetExecImpactPower
// 0x0010 (0x0010 - 0x0000)
struct DescData_GetExecImpactPower final
{
public:
	const class UDescDataParam*                   InDescDataParam;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2663[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DescData_GetExecImpactPower) == 0x000008, "Wrong alignment on DescData_GetExecImpactPower");
static_assert(sizeof(DescData_GetExecImpactPower) == 0x000010, "Wrong size on DescData_GetExecImpactPower");
static_assert(offsetof(DescData_GetExecImpactPower, InDescDataParam) == 0x000000, "Member 'DescData_GetExecImpactPower::InDescDataParam' has a wrong offset!");
static_assert(offsetof(DescData_GetExecImpactPower, ReturnValue) == 0x000008, "Member 'DescData_GetExecImpactPower::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCGameSpawnableComponent.OnRep_bCastShadows
// 0x0001 (0x0001 - 0x0000)
struct DCGameSpawnableComponent_OnRep_bCastShadows final
{
public:
	bool                                          bOldCastShadows;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSpawnableComponent_OnRep_bCastShadows) == 0x000001, "Wrong alignment on DCGameSpawnableComponent_OnRep_bCastShadows");
static_assert(sizeof(DCGameSpawnableComponent_OnRep_bCastShadows) == 0x000001, "Wrong size on DCGameSpawnableComponent_OnRep_bCastShadows");
static_assert(offsetof(DCGameSpawnableComponent_OnRep_bCastShadows, bOldCastShadows) == 0x000000, "Member 'DCGameSpawnableComponent_OnRep_bCastShadows::bOldCastShadows' has a wrong offset!");

// Function DungeonCrawler.DCGameSpawnerGroup.OnRep_ClientDestroyActorNameArray
// 0x0010 (0x0010 - 0x0000)
struct DCGameSpawnerGroup_OnRep_ClientDestroyActorNameArray final
{
public:
	TArray<class FString>                         OldClientDestroyActorNameArray;                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameSpawnerGroup_OnRep_ClientDestroyActorNameArray) == 0x000008, "Wrong alignment on DCGameSpawnerGroup_OnRep_ClientDestroyActorNameArray");
static_assert(sizeof(DCGameSpawnerGroup_OnRep_ClientDestroyActorNameArray) == 0x000010, "Wrong size on DCGameSpawnerGroup_OnRep_ClientDestroyActorNameArray");
static_assert(offsetof(DCGameSpawnerGroup_OnRep_ClientDestroyActorNameArray, OldClientDestroyActorNameArray) == 0x000000, "Member 'DCGameSpawnerGroup_OnRep_ClientDestroyActorNameArray::OldClientDestroyActorNameArray' has a wrong offset!");

// Function DungeonCrawler.DCGameUserSettings.GetInputConfigByName
// 0x0010 (0x0010 - 0x0000)
struct DCGameUserSettings_GetInputConfigByName final
{
public:
	class FName                                   ConfigName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UPlayerMappableInputConfig*       ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCGameUserSettings_GetInputConfigByName) == 0x000008, "Wrong alignment on DCGameUserSettings_GetInputConfigByName");
static_assert(sizeof(DCGameUserSettings_GetInputConfigByName) == 0x000010, "Wrong size on DCGameUserSettings_GetInputConfigByName");
static_assert(offsetof(DCGameUserSettings_GetInputConfigByName, ConfigName) == 0x000000, "Member 'DCGameUserSettings_GetInputConfigByName::ConfigName' has a wrong offset!");
static_assert(offsetof(DCGameUserSettings_GetInputConfigByName, ReturnValue) == 0x000008, "Member 'DCGameUserSettings_GetInputConfigByName::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCSkeletalMeshComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCSkeletalMeshComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSkeletalMeshComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCSkeletalMeshComponent_BroadcastMsgBlueprint");
static_assert(sizeof(DCSkeletalMeshComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCSkeletalMeshComponent_BroadcastMsgBlueprint");
static_assert(offsetof(DCSkeletalMeshComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCSkeletalMeshComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCSkeletalMeshComponent.SetAffectNavigation
// 0x0001 (0x0001 - 0x0000)
struct DCSkeletalMeshComponent_SetAffectNavigation final
{
public:
	bool                                          bRelevant;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSkeletalMeshComponent_SetAffectNavigation) == 0x000001, "Wrong alignment on DCSkeletalMeshComponent_SetAffectNavigation");
static_assert(sizeof(DCSkeletalMeshComponent_SetAffectNavigation) == 0x000001, "Wrong size on DCSkeletalMeshComponent_SetAffectNavigation");
static_assert(offsetof(DCSkeletalMeshComponent_SetAffectNavigation, bRelevant) == 0x000000, "Member 'DCSkeletalMeshComponent_SetAffectNavigation::bRelevant' has a wrong offset!");

// Function DungeonCrawler.DCSkeletalMeshComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCSkeletalMeshComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSkeletalMeshComponent_UnbindMsg) == 0x000008, "Wrong alignment on DCSkeletalMeshComponent_UnbindMsg");
static_assert(sizeof(DCSkeletalMeshComponent_UnbindMsg) == 0x000010, "Wrong size on DCSkeletalMeshComponent_UnbindMsg");
static_assert(offsetof(DCSkeletalMeshComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'DCSkeletalMeshComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCSkeletalMeshComponent_UnbindMsg, InObject) == 0x000008, "Member 'DCSkeletalMeshComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCSkeletalMeshComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCSkeletalMeshComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSkeletalMeshComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on DCSkeletalMeshComponent_UnbindMsgAll");
static_assert(sizeof(DCSkeletalMeshComponent_UnbindMsgAll) == 0x000008, "Wrong size on DCSkeletalMeshComponent_UnbindMsgAll");
static_assert(offsetof(DCSkeletalMeshComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'DCSkeletalMeshComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCReligionConvetCompletePopup.SetReligionImageEvent
// 0x00D0 (0x00D0 - 0x0000)
struct DCReligionConvetCompletePopup_SetReligionImageEvent final
{
public:
	struct FSlateBrush                            Bursh;                                             // 0x0000(0x00D0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionConvetCompletePopup_SetReligionImageEvent) == 0x000010, "Wrong alignment on DCReligionConvetCompletePopup_SetReligionImageEvent");
static_assert(sizeof(DCReligionConvetCompletePopup_SetReligionImageEvent) == 0x0000D0, "Wrong size on DCReligionConvetCompletePopup_SetReligionImageEvent");
static_assert(offsetof(DCReligionConvetCompletePopup_SetReligionImageEvent, Bursh) == 0x000000, "Member 'DCReligionConvetCompletePopup_SetReligionImageEvent::Bursh' has a wrong offset!");

// Function DungeonCrawler.DCInGameQuestLog.OnQuestLogVisibilityChange
// 0x0001 (0x0001 - 0x0000)
struct DCInGameQuestLog_OnQuestLogVisibilityChange final
{
public:
	bool                                          bIsEmpty;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInGameQuestLog_OnQuestLogVisibilityChange) == 0x000001, "Wrong alignment on DCInGameQuestLog_OnQuestLogVisibilityChange");
static_assert(sizeof(DCInGameQuestLog_OnQuestLogVisibilityChange) == 0x000001, "Wrong size on DCInGameQuestLog_OnQuestLogVisibilityChange");
static_assert(offsetof(DCInGameQuestLog_OnQuestLogVisibilityChange, bIsEmpty) == 0x000000, "Member 'DCInGameQuestLog_OnQuestLogVisibilityChange::bIsEmpty' has a wrong offset!");

// Function DungeonCrawler.DCTradePhaseConfirmWidget.OnLocalTraderCheckBoxStateChanged
// 0x0001 (0x0001 - 0x0000)
struct DCTradePhaseConfirmWidget_OnLocalTraderCheckBoxStateChanged final
{
public:
	bool                                          bIsChecked;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTradePhaseConfirmWidget_OnLocalTraderCheckBoxStateChanged) == 0x000001, "Wrong alignment on DCTradePhaseConfirmWidget_OnLocalTraderCheckBoxStateChanged");
static_assert(sizeof(DCTradePhaseConfirmWidget_OnLocalTraderCheckBoxStateChanged) == 0x000001, "Wrong size on DCTradePhaseConfirmWidget_OnLocalTraderCheckBoxStateChanged");
static_assert(offsetof(DCTradePhaseConfirmWidget_OnLocalTraderCheckBoxStateChanged, bIsChecked) == 0x000000, "Member 'DCTradePhaseConfirmWidget_OnLocalTraderCheckBoxStateChanged::bIsChecked' has a wrong offset!");

// Function DungeonCrawler.DCTradePhaseConfirmWidget.OnResponseLocalTraderConfirmRequestResult
// 0x0001 (0x0001 - 0x0000)
struct DCTradePhaseConfirmWidget_OnResponseLocalTraderConfirmRequestResult final
{
public:
	bool                                          bRequestSucceed;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTradePhaseConfirmWidget_OnResponseLocalTraderConfirmRequestResult) == 0x000001, "Wrong alignment on DCTradePhaseConfirmWidget_OnResponseLocalTraderConfirmRequestResult");
static_assert(sizeof(DCTradePhaseConfirmWidget_OnResponseLocalTraderConfirmRequestResult) == 0x000001, "Wrong size on DCTradePhaseConfirmWidget_OnResponseLocalTraderConfirmRequestResult");
static_assert(offsetof(DCTradePhaseConfirmWidget_OnResponseLocalTraderConfirmRequestResult, bRequestSucceed) == 0x000000, "Member 'DCTradePhaseConfirmWidget_OnResponseLocalTraderConfirmRequestResult::bRequestSucceed' has a wrong offset!");

// Function DungeonCrawler.DCInputNumberWidget.IsValidText
// 0x0020 (0x0020 - 0x0000)
struct DCInputNumberWidget_IsValidText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2673[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCInputNumberWidget_IsValidText) == 0x000008, "Wrong alignment on DCInputNumberWidget_IsValidText");
static_assert(sizeof(DCInputNumberWidget_IsValidText) == 0x000020, "Wrong size on DCInputNumberWidget_IsValidText");
static_assert(offsetof(DCInputNumberWidget_IsValidText, Text) == 0x000000, "Member 'DCInputNumberWidget_IsValidText::Text' has a wrong offset!");
static_assert(offsetof(DCInputNumberWidget_IsValidText, ReturnValue) == 0x000018, "Member 'DCInputNumberWidget_IsValidText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCTrainingOptionSlotWidgetBase.OnActive
// 0x0004 (0x0004 - 0x0000)
struct DCTrainingOptionSlotWidgetBase_OnActive final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTrainingOptionSlotWidgetBase_OnActive) == 0x000004, "Wrong alignment on DCTrainingOptionSlotWidgetBase_OnActive");
static_assert(sizeof(DCTrainingOptionSlotWidgetBase_OnActive) == 0x000004, "Wrong size on DCTrainingOptionSlotWidgetBase_OnActive");
static_assert(offsetof(DCTrainingOptionSlotWidgetBase_OnActive, Delay) == 0x000000, "Member 'DCTrainingOptionSlotWidgetBase_OnActive::Delay' has a wrong offset!");

// Function DungeonCrawler.DCInventoryComponent.AddItemData
// 0x0108 (0x0108 - 0x0000)
struct DCInventoryComponent_AddItemData final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2678[0x7];                                     // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCInventoryComponent_AddItemData) == 0x000008, "Wrong alignment on DCInventoryComponent_AddItemData");
static_assert(sizeof(DCInventoryComponent_AddItemData) == 0x000108, "Wrong size on DCInventoryComponent_AddItemData");
static_assert(offsetof(DCInventoryComponent_AddItemData, ItemData) == 0x000000, "Member 'DCInventoryComponent_AddItemData::ItemData' has a wrong offset!");
static_assert(offsetof(DCInventoryComponent_AddItemData, ReturnValue) == 0x000100, "Member 'DCInventoryComponent_AddItemData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCInventoryComponent.AddItemDatas
// 0x0020 (0x0020 - 0x0000)
struct DCInventoryComponent_AddItemDatas final
{
public:
	EDCInventoryId                                InventoryId;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2679[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      ItemDatas;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_267A[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCInventoryComponent_AddItemDatas) == 0x000008, "Wrong alignment on DCInventoryComponent_AddItemDatas");
static_assert(sizeof(DCInventoryComponent_AddItemDatas) == 0x000020, "Wrong size on DCInventoryComponent_AddItemDatas");
static_assert(offsetof(DCInventoryComponent_AddItemDatas, InventoryId) == 0x000000, "Member 'DCInventoryComponent_AddItemDatas::InventoryId' has a wrong offset!");
static_assert(offsetof(DCInventoryComponent_AddItemDatas, ItemDatas) == 0x000008, "Member 'DCInventoryComponent_AddItemDatas::ItemDatas' has a wrong offset!");
static_assert(offsetof(DCInventoryComponent_AddItemDatas, ReturnValue) == 0x000018, "Member 'DCInventoryComponent_AddItemDatas::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCInventoryComponent.AddItemDataToInventory
// 0x0110 (0x0110 - 0x0000)
struct DCInventoryComponent_AddItemDataToInventory final
{
public:
	EDCInventoryId                                InventoryId;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_267B[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemData                              ItemData;                                          // 0x0008(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0108(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_267C[0x7];                                     // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCInventoryComponent_AddItemDataToInventory) == 0x000008, "Wrong alignment on DCInventoryComponent_AddItemDataToInventory");
static_assert(sizeof(DCInventoryComponent_AddItemDataToInventory) == 0x000110, "Wrong size on DCInventoryComponent_AddItemDataToInventory");
static_assert(offsetof(DCInventoryComponent_AddItemDataToInventory, InventoryId) == 0x000000, "Member 'DCInventoryComponent_AddItemDataToInventory::InventoryId' has a wrong offset!");
static_assert(offsetof(DCInventoryComponent_AddItemDataToInventory, ItemData) == 0x000008, "Member 'DCInventoryComponent_AddItemDataToInventory::ItemData' has a wrong offset!");
static_assert(offsetof(DCInventoryComponent_AddItemDataToInventory, ReturnValue) == 0x000108, "Member 'DCInventoryComponent_AddItemDataToInventory::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCInventoryComponent.InitExpandableBox
// 0x0020 (0x0020 - 0x0000)
struct DCInventoryComponent_InitExpandableBox final
{
public:
	EDCInventoryId                                InventoryId;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_267D[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      ItemDatas;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_267E[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCInventoryComponent_InitExpandableBox) == 0x000008, "Wrong alignment on DCInventoryComponent_InitExpandableBox");
static_assert(sizeof(DCInventoryComponent_InitExpandableBox) == 0x000020, "Wrong size on DCInventoryComponent_InitExpandableBox");
static_assert(offsetof(DCInventoryComponent_InitExpandableBox, InventoryId) == 0x000000, "Member 'DCInventoryComponent_InitExpandableBox::InventoryId' has a wrong offset!");
static_assert(offsetof(DCInventoryComponent_InitExpandableBox, ItemDatas) == 0x000008, "Member 'DCInventoryComponent_InitExpandableBox::ItemDatas' has a wrong offset!");
static_assert(offsetof(DCInventoryComponent_InitExpandableBox, ReturnValue) == 0x000018, "Member 'DCInventoryComponent_InitExpandableBox::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCInventoryComponent.PlayItemSoundClient
// 0x0170 (0x0170 - 0x0000)
struct DCInventoryComponent_PlayItemSoundClient final
{
public:
	struct FDCItemInfo                            Item;                                              // 0x0000(0x0168)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0168(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInventoryComponent_PlayItemSoundClient) == 0x000008, "Wrong alignment on DCInventoryComponent_PlayItemSoundClient");
static_assert(sizeof(DCInventoryComponent_PlayItemSoundClient) == 0x000170, "Wrong size on DCInventoryComponent_PlayItemSoundClient");
static_assert(offsetof(DCInventoryComponent_PlayItemSoundClient, Item) == 0x000000, "Member 'DCInventoryComponent_PlayItemSoundClient::Item' has a wrong offset!");
static_assert(offsetof(DCInventoryComponent_PlayItemSoundClient, Tag) == 0x000168, "Member 'DCInventoryComponent_PlayItemSoundClient::Tag' has a wrong offset!");

// Function DungeonCrawler.DCInventoryComponent.PlayItemSoundNetMulticast
// 0x0170 (0x0170 - 0x0000)
struct DCInventoryComponent_PlayItemSoundNetMulticast final
{
public:
	struct FDCItemInfo                            Item;                                              // 0x0000(0x0168)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0168(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInventoryComponent_PlayItemSoundNetMulticast) == 0x000008, "Wrong alignment on DCInventoryComponent_PlayItemSoundNetMulticast");
static_assert(sizeof(DCInventoryComponent_PlayItemSoundNetMulticast) == 0x000170, "Wrong size on DCInventoryComponent_PlayItemSoundNetMulticast");
static_assert(offsetof(DCInventoryComponent_PlayItemSoundNetMulticast, Item) == 0x000000, "Member 'DCInventoryComponent_PlayItemSoundNetMulticast::Item' has a wrong offset!");
static_assert(offsetof(DCInventoryComponent_PlayItemSoundNetMulticast, Tag) == 0x000168, "Member 'DCInventoryComponent_PlayItemSoundNetMulticast::Tag' has a wrong offset!");

// Function DungeonCrawler.DCInventoryComponent.PlayItemSoundServer
// 0x0170 (0x0170 - 0x0000)
struct DCInventoryComponent_PlayItemSoundServer final
{
public:
	struct FDCItemInfo                            Item;                                              // 0x0000(0x0168)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0168(0x0008)(ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCInventoryComponent_PlayItemSoundServer) == 0x000008, "Wrong alignment on DCInventoryComponent_PlayItemSoundServer");
static_assert(sizeof(DCInventoryComponent_PlayItemSoundServer) == 0x000170, "Wrong size on DCInventoryComponent_PlayItemSoundServer");
static_assert(offsetof(DCInventoryComponent_PlayItemSoundServer, Item) == 0x000000, "Member 'DCInventoryComponent_PlayItemSoundServer::Item' has a wrong offset!");
static_assert(offsetof(DCInventoryComponent_PlayItemSoundServer, Tag) == 0x000168, "Member 'DCInventoryComponent_PlayItemSoundServer::Tag' has a wrong offset!");

// Function DungeonCrawler.DCShowingKeyWidgetBase.HandleInputMethodChanged
// 0x0001 (0x0001 - 0x0000)
struct DCShowingKeyWidgetBase_HandleInputMethodChanged final
{
public:
	ECommonInputType                              InInputType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShowingKeyWidgetBase_HandleInputMethodChanged) == 0x000001, "Wrong alignment on DCShowingKeyWidgetBase_HandleInputMethodChanged");
static_assert(sizeof(DCShowingKeyWidgetBase_HandleInputMethodChanged) == 0x000001, "Wrong size on DCShowingKeyWidgetBase_HandleInputMethodChanged");
static_assert(offsetof(DCShowingKeyWidgetBase_HandleInputMethodChanged, InInputType) == 0x000000, "Member 'DCShowingKeyWidgetBase_HandleInputMethodChanged::InInputType' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.OnRep_ArtData
// 0x0008 (0x0008 - 0x0000)
struct DCItemActorBase_OnRep_ArtData final
{
public:
	class UArtDataItem*                           OldArtData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_OnRep_ArtData) == 0x000008, "Wrong alignment on DCItemActorBase_OnRep_ArtData");
static_assert(sizeof(DCItemActorBase_OnRep_ArtData) == 0x000008, "Wrong size on DCItemActorBase_OnRep_ArtData");
static_assert(offsetof(DCItemActorBase_OnRep_ArtData, OldArtData) == 0x000000, "Member 'DCItemActorBase_OnRep_ArtData::OldArtData' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.OnRep_ItemInfo
// 0x0168 (0x0168 - 0x0000)
struct DCItemActorBase_OnRep_ItemInfo final
{
public:
	struct FDCItemInfo                            OldItemInfo;                                       // 0x0000(0x0168)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_OnRep_ItemInfo) == 0x000008, "Wrong alignment on DCItemActorBase_OnRep_ItemInfo");
static_assert(sizeof(DCItemActorBase_OnRep_ItemInfo) == 0x000168, "Wrong size on DCItemActorBase_OnRep_ItemInfo");
static_assert(offsetof(DCItemActorBase_OnRep_ItemInfo, OldItemInfo) == 0x000000, "Member 'DCItemActorBase_OnRep_ItemInfo::OldItemInfo' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.GetIdTag
// 0x0008 (0x0008 - 0x0000)
struct DCItemActorBase_GetIdTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_GetIdTag) == 0x000004, "Wrong alignment on DCItemActorBase_GetIdTag");
static_assert(sizeof(DCItemActorBase_GetIdTag) == 0x000008, "Wrong size on DCItemActorBase_GetIdTag");
static_assert(offsetof(DCItemActorBase_GetIdTag, ReturnValue) == 0x000000, "Member 'DCItemActorBase_GetIdTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.GetItemArtData
// 0x0010 (0x0010 - 0x0000)
struct DCItemActorBase_GetItemArtData final
{
public:
	float                                         WaitAsyncLoadingSeconds;                           // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2684[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UArtDataItem*                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_GetItemArtData) == 0x000008, "Wrong alignment on DCItemActorBase_GetItemArtData");
static_assert(sizeof(DCItemActorBase_GetItemArtData) == 0x000010, "Wrong size on DCItemActorBase_GetItemArtData");
static_assert(offsetof(DCItemActorBase_GetItemArtData, WaitAsyncLoadingSeconds) == 0x000000, "Member 'DCItemActorBase_GetItemArtData::WaitAsyncLoadingSeconds' has a wrong offset!");
static_assert(offsetof(DCItemActorBase_GetItemArtData, ReturnValue) == 0x000008, "Member 'DCItemActorBase_GetItemArtData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.GetItemInfo
// 0x0168 (0x0168 - 0x0000)
struct DCItemActorBase_GetItemInfo final
{
public:
	struct FDCItemInfo                            ReturnValue;                                       // 0x0000(0x0168)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_GetItemInfo) == 0x000008, "Wrong alignment on DCItemActorBase_GetItemInfo");
static_assert(sizeof(DCItemActorBase_GetItemInfo) == 0x000168, "Wrong size on DCItemActorBase_GetItemInfo");
static_assert(offsetof(DCItemActorBase_GetItemInfo, ReturnValue) == 0x000000, "Member 'DCItemActorBase_GetItemInfo::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.GetItemUniqueId
// 0x0008 (0x0008 - 0x0000)
struct DCItemActorBase_GetItemUniqueId final
{
public:
	int64                                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_GetItemUniqueId) == 0x000008, "Wrong alignment on DCItemActorBase_GetItemUniqueId");
static_assert(sizeof(DCItemActorBase_GetItemUniqueId) == 0x000008, "Wrong size on DCItemActorBase_GetItemUniqueId");
static_assert(offsetof(DCItemActorBase_GetItemUniqueId, ReturnValue) == 0x000000, "Member 'DCItemActorBase_GetItemUniqueId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.GetRarity
// 0x0008 (0x0008 - 0x0000)
struct DCItemActorBase_GetRarity final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_GetRarity) == 0x000004, "Wrong alignment on DCItemActorBase_GetRarity");
static_assert(sizeof(DCItemActorBase_GetRarity) == 0x000008, "Wrong size on DCItemActorBase_GetRarity");
static_assert(offsetof(DCItemActorBase_GetRarity, ReturnValue) == 0x000000, "Member 'DCItemActorBase_GetRarity::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.GetSlotType
// 0x0008 (0x0008 - 0x0000)
struct DCItemActorBase_GetSlotType final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_GetSlotType) == 0x000004, "Wrong alignment on DCItemActorBase_GetSlotType");
static_assert(sizeof(DCItemActorBase_GetSlotType) == 0x000008, "Wrong size on DCItemActorBase_GetSlotType");
static_assert(offsetof(DCItemActorBase_GetSlotType, ReturnValue) == 0x000000, "Member 'DCItemActorBase_GetSlotType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.GetUtilityType
// 0x0008 (0x0008 - 0x0000)
struct DCItemActorBase_GetUtilityType final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_GetUtilityType) == 0x000004, "Wrong alignment on DCItemActorBase_GetUtilityType");
static_assert(sizeof(DCItemActorBase_GetUtilityType) == 0x000008, "Wrong size on DCItemActorBase_GetUtilityType");
static_assert(offsetof(DCItemActorBase_GetUtilityType, ReturnValue) == 0x000000, "Member 'DCItemActorBase_GetUtilityType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.GetWeaponTypes
// 0x0010 (0x0010 - 0x0000)
struct DCItemActorBase_GetWeaponTypes final
{
public:
	TArray<struct FGameplayTag>                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_GetWeaponTypes) == 0x000008, "Wrong alignment on DCItemActorBase_GetWeaponTypes");
static_assert(sizeof(DCItemActorBase_GetWeaponTypes) == 0x000010, "Wrong size on DCItemActorBase_GetWeaponTypes");
static_assert(offsetof(DCItemActorBase_GetWeaponTypes, ReturnValue) == 0x000000, "Member 'DCItemActorBase_GetWeaponTypes::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.IsShield
// 0x0001 (0x0001 - 0x0000)
struct DCItemActorBase_IsShield final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_IsShield) == 0x000001, "Wrong alignment on DCItemActorBase_IsShield");
static_assert(sizeof(DCItemActorBase_IsShield) == 0x000001, "Wrong size on DCItemActorBase_IsShield");
static_assert(offsetof(DCItemActorBase_IsShield, ReturnValue) == 0x000000, "Member 'DCItemActorBase_IsShield::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.IsSoulHeart
// 0x0001 (0x0001 - 0x0000)
struct DCItemActorBase_IsSoulHeart final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_IsSoulHeart) == 0x000001, "Wrong alignment on DCItemActorBase_IsSoulHeart");
static_assert(sizeof(DCItemActorBase_IsSoulHeart) == 0x000001, "Wrong size on DCItemActorBase_IsSoulHeart");
static_assert(offsetof(DCItemActorBase_IsSoulHeart, ReturnValue) == 0x000000, "Member 'DCItemActorBase_IsSoulHeart::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.IsUtility
// 0x0001 (0x0001 - 0x0000)
struct DCItemActorBase_IsUtility final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_IsUtility) == 0x000001, "Wrong alignment on DCItemActorBase_IsUtility");
static_assert(sizeof(DCItemActorBase_IsUtility) == 0x000001, "Wrong size on DCItemActorBase_IsUtility");
static_assert(offsetof(DCItemActorBase_IsUtility, ReturnValue) == 0x000000, "Member 'DCItemActorBase_IsUtility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.IsWeapon
// 0x0001 (0x0001 - 0x0000)
struct DCItemActorBase_IsWeapon final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_IsWeapon) == 0x000001, "Wrong alignment on DCItemActorBase_IsWeapon");
static_assert(sizeof(DCItemActorBase_IsWeapon) == 0x000001, "Wrong size on DCItemActorBase_IsWeapon");
static_assert(offsetof(DCItemActorBase_IsWeapon, ReturnValue) == 0x000000, "Member 'DCItemActorBase_IsWeapon::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemActorBase.IsWeaponSlotEquippable
// 0x0001 (0x0001 - 0x0000)
struct DCItemActorBase_IsWeaponSlotEquippable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemActorBase_IsWeaponSlotEquippable) == 0x000001, "Wrong alignment on DCItemActorBase_IsWeaponSlotEquippable");
static_assert(sizeof(DCItemActorBase_IsWeaponSlotEquippable) == 0x000001, "Wrong size on DCItemActorBase_IsWeaponSlotEquippable");
static_assert(offsetof(DCItemActorBase_IsWeaponSlotEquippable, ReturnValue) == 0x000000, "Member 'DCItemActorBase_IsWeaponSlotEquippable::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameEmoteSlotWidget.OnSelectionChanged
// 0x0001 (0x0001 - 0x0000)
struct GameEmoteSlotWidget_OnSelectionChanged final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameEmoteSlotWidget_OnSelectionChanged) == 0x000001, "Wrong alignment on GameEmoteSlotWidget_OnSelectionChanged");
static_assert(sizeof(GameEmoteSlotWidget_OnSelectionChanged) == 0x000001, "Wrong size on GameEmoteSlotWidget_OnSelectionChanged");
static_assert(offsetof(GameEmoteSlotWidget_OnSelectionChanged, bIsSelected) == 0x000000, "Member 'GameEmoteSlotWidget_OnSelectionChanged::bIsSelected' has a wrong offset!");

// Function DungeonCrawler.GameEmoteSlotWidget.OnSetEmoteArtData
// 0x0008 (0x0008 - 0x0000)
struct GameEmoteSlotWidget_OnSetEmoteArtData final
{
public:
	const class UArtDataEmote*                    InArtEmoteData;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameEmoteSlotWidget_OnSetEmoteArtData) == 0x000008, "Wrong alignment on GameEmoteSlotWidget_OnSetEmoteArtData");
static_assert(sizeof(GameEmoteSlotWidget_OnSetEmoteArtData) == 0x000008, "Wrong size on GameEmoteSlotWidget_OnSetEmoteArtData");
static_assert(offsetof(GameEmoteSlotWidget_OnSetEmoteArtData, InArtEmoteData) == 0x000000, "Member 'GameEmoteSlotWidget_OnSetEmoteArtData::InArtEmoteData' has a wrong offset!");

// Function DungeonCrawler.GameEmoteSlotWidget.SelectionChange
// 0x0001 (0x0001 - 0x0000)
struct GameEmoteSlotWidget_SelectionChange final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameEmoteSlotWidget_SelectionChange) == 0x000001, "Wrong alignment on GameEmoteSlotWidget_SelectionChange");
static_assert(sizeof(GameEmoteSlotWidget_SelectionChange) == 0x000001, "Wrong size on GameEmoteSlotWidget_SelectionChange");
static_assert(offsetof(GameEmoteSlotWidget_SelectionChange, bIsSelected) == 0x000000, "Member 'GameEmoteSlotWidget_SelectionChange::bIsSelected' has a wrong offset!");

// Function DungeonCrawler.GameEmoteSlotWidget.SetEmoteData
// 0x0008 (0x0008 - 0x0000)
struct GameEmoteSlotWidget_SetEmoteData final
{
public:
	const class UDCEmoteDataAsset*                InDesignDataEmote;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameEmoteSlotWidget_SetEmoteData) == 0x000008, "Wrong alignment on GameEmoteSlotWidget_SetEmoteData");
static_assert(sizeof(GameEmoteSlotWidget_SetEmoteData) == 0x000008, "Wrong size on GameEmoteSlotWidget_SetEmoteData");
static_assert(offsetof(GameEmoteSlotWidget_SetEmoteData, InDesignDataEmote) == 0x000000, "Member 'GameEmoteSlotWidget_SetEmoteData::InDesignDataEmote' has a wrong offset!");

// Function DungeonCrawler.GameInventoryGroupWidget.OnItemDrop
// 0x0108 (0x0108 - 0x0000)
struct GameInventoryGroupWidget_OnItemDrop final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 OldOwnerActor;                                     // 0x0100(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInventoryGroupWidget_OnItemDrop) == 0x000008, "Wrong alignment on GameInventoryGroupWidget_OnItemDrop");
static_assert(sizeof(GameInventoryGroupWidget_OnItemDrop) == 0x000108, "Wrong size on GameInventoryGroupWidget_OnItemDrop");
static_assert(offsetof(GameInventoryGroupWidget_OnItemDrop, ItemData) == 0x000000, "Member 'GameInventoryGroupWidget_OnItemDrop::ItemData' has a wrong offset!");
static_assert(offsetof(GameInventoryGroupWidget_OnItemDrop, OldOwnerActor) == 0x000100, "Member 'GameInventoryGroupWidget_OnItemDrop::OldOwnerActor' has a wrong offset!");

// Function DungeonCrawler.GameInventoryGroupWidget.OnItemDropOne
// 0x0108 (0x0108 - 0x0000)
struct GameInventoryGroupWidget_OnItemDropOne final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 OldOwnerActor;                                     // 0x0100(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInventoryGroupWidget_OnItemDropOne) == 0x000008, "Wrong alignment on GameInventoryGroupWidget_OnItemDropOne");
static_assert(sizeof(GameInventoryGroupWidget_OnItemDropOne) == 0x000108, "Wrong size on GameInventoryGroupWidget_OnItemDropOne");
static_assert(offsetof(GameInventoryGroupWidget_OnItemDropOne, ItemData) == 0x000000, "Member 'GameInventoryGroupWidget_OnItemDropOne::ItemData' has a wrong offset!");
static_assert(offsetof(GameInventoryGroupWidget_OnItemDropOne, OldOwnerActor) == 0x000100, "Member 'GameInventoryGroupWidget_OnItemDropOne::OldOwnerActor' has a wrong offset!");

// Function DungeonCrawler.GameInventoryGroupWidget.OnPopItemSelectWidget
// 0x0108 (0x0108 - 0x0000)
struct GameInventoryGroupWidget_OnPopItemSelectWidget final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(Parm, NativeAccessSpecifierPublic)
	class AActor*                                 OldOwnerActor;                                     // 0x0100(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInventoryGroupWidget_OnPopItemSelectWidget) == 0x000008, "Wrong alignment on GameInventoryGroupWidget_OnPopItemSelectWidget");
static_assert(sizeof(GameInventoryGroupWidget_OnPopItemSelectWidget) == 0x000108, "Wrong size on GameInventoryGroupWidget_OnPopItemSelectWidget");
static_assert(offsetof(GameInventoryGroupWidget_OnPopItemSelectWidget, ItemData) == 0x000000, "Member 'GameInventoryGroupWidget_OnPopItemSelectWidget::ItemData' has a wrong offset!");
static_assert(offsetof(GameInventoryGroupWidget_OnPopItemSelectWidget, OldOwnerActor) == 0x000100, "Member 'GameInventoryGroupWidget_OnPopItemSelectWidget::OldOwnerActor' has a wrong offset!");

// Function DungeonCrawler.DCItemSwitchAbilityBase.OnCharacterMontageEventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct DCItemSwitchAbilityBase_OnCharacterMontageEventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemSwitchAbilityBase_OnCharacterMontageEventReceived) == 0x000008, "Wrong alignment on DCItemSwitchAbilityBase_OnCharacterMontageEventReceived");
static_assert(sizeof(DCItemSwitchAbilityBase_OnCharacterMontageEventReceived) == 0x0000B8, "Wrong size on DCItemSwitchAbilityBase_OnCharacterMontageEventReceived");
static_assert(offsetof(DCItemSwitchAbilityBase_OnCharacterMontageEventReceived, EventTag) == 0x000000, "Member 'DCItemSwitchAbilityBase_OnCharacterMontageEventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(DCItemSwitchAbilityBase_OnCharacterMontageEventReceived, EventData) == 0x000008, "Member 'DCItemSwitchAbilityBase_OnCharacterMontageEventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.DCItemSwitchAbilityBase.OnCharacterMontageFinished
// 0x00B8 (0x00B8 - 0x0000)
struct DCItemSwitchAbilityBase_OnCharacterMontageFinished final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemSwitchAbilityBase_OnCharacterMontageFinished) == 0x000008, "Wrong alignment on DCItemSwitchAbilityBase_OnCharacterMontageFinished");
static_assert(sizeof(DCItemSwitchAbilityBase_OnCharacterMontageFinished) == 0x0000B8, "Wrong size on DCItemSwitchAbilityBase_OnCharacterMontageFinished");
static_assert(offsetof(DCItemSwitchAbilityBase_OnCharacterMontageFinished, EventTag) == 0x000000, "Member 'DCItemSwitchAbilityBase_OnCharacterMontageFinished::EventTag' has a wrong offset!");
static_assert(offsetof(DCItemSwitchAbilityBase_OnCharacterMontageFinished, EventData) == 0x000008, "Member 'DCItemSwitchAbilityBase_OnCharacterMontageFinished::EventData' has a wrong offset!");

// Function DungeonCrawler.DCItemSwitchAbilityBase.OnCharacterMontageInterrupted
// 0x00B8 (0x00B8 - 0x0000)
struct DCItemSwitchAbilityBase_OnCharacterMontageInterrupted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemSwitchAbilityBase_OnCharacterMontageInterrupted) == 0x000008, "Wrong alignment on DCItemSwitchAbilityBase_OnCharacterMontageInterrupted");
static_assert(sizeof(DCItemSwitchAbilityBase_OnCharacterMontageInterrupted) == 0x0000B8, "Wrong size on DCItemSwitchAbilityBase_OnCharacterMontageInterrupted");
static_assert(offsetof(DCItemSwitchAbilityBase_OnCharacterMontageInterrupted, EventTag) == 0x000000, "Member 'DCItemSwitchAbilityBase_OnCharacterMontageInterrupted::EventTag' has a wrong offset!");
static_assert(offsetof(DCItemSwitchAbilityBase_OnCharacterMontageInterrupted, EventData) == 0x000008, "Member 'DCItemSwitchAbilityBase_OnCharacterMontageInterrupted::EventData' has a wrong offset!");

// Function DungeonCrawler.DCItemTooltipStatWidget.IsEmpty
// 0x0001 (0x0001 - 0x0000)
struct DCItemTooltipStatWidget_IsEmpty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemTooltipStatWidget_IsEmpty) == 0x000001, "Wrong alignment on DCItemTooltipStatWidget_IsEmpty");
static_assert(sizeof(DCItemTooltipStatWidget_IsEmpty) == 0x000001, "Wrong size on DCItemTooltipStatWidget_IsEmpty");
static_assert(offsetof(DCItemTooltipStatWidget_IsEmpty, ReturnValue) == 0x000000, "Member 'DCItemTooltipStatWidget_IsEmpty::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemTooltipAbilityWidget.IsEmpty
// 0x0001 (0x0001 - 0x0000)
struct DCItemTooltipAbilityWidget_IsEmpty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemTooltipAbilityWidget_IsEmpty) == 0x000001, "Wrong alignment on DCItemTooltipAbilityWidget_IsEmpty");
static_assert(sizeof(DCItemTooltipAbilityWidget_IsEmpty) == 0x000001, "Wrong size on DCItemTooltipAbilityWidget_IsEmpty");
static_assert(offsetof(DCItemTooltipAbilityWidget_IsEmpty, ReturnValue) == 0x000000, "Member 'DCItemTooltipAbilityWidget_IsEmpty::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemTooltipRequiredAttributeEntryWidget.CanEquipByRequiredAttribute
// 0x0001 (0x0001 - 0x0000)
struct DCItemTooltipRequiredAttributeEntryWidget_CanEquipByRequiredAttribute final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemTooltipRequiredAttributeEntryWidget_CanEquipByRequiredAttribute) == 0x000001, "Wrong alignment on DCItemTooltipRequiredAttributeEntryWidget_CanEquipByRequiredAttribute");
static_assert(sizeof(DCItemTooltipRequiredAttributeEntryWidget_CanEquipByRequiredAttribute) == 0x000001, "Wrong size on DCItemTooltipRequiredAttributeEntryWidget_CanEquipByRequiredAttribute");
static_assert(offsetof(DCItemTooltipRequiredAttributeEntryWidget_CanEquipByRequiredAttribute, ReturnValue) == 0x000000, "Member 'DCItemTooltipRequiredAttributeEntryWidget_CanEquipByRequiredAttribute::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemTooltipRequiredAttributeEntryWidget.GetRequiredAttributeType
// 0x0001 (0x0001 - 0x0000)
struct DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeType final
{
public:
	EItemRequirementType                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeType) == 0x000001, "Wrong alignment on DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeType");
static_assert(sizeof(DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeType) == 0x000001, "Wrong size on DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeType");
static_assert(offsetof(DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeType, ReturnValue) == 0x000000, "Member 'DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCItemTooltipRequiredAttributeEntryWidget.GetRequiredAttributeValue
// 0x0004 (0x0004 - 0x0000)
struct DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeValue final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeValue) == 0x000004, "Wrong alignment on DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeValue");
static_assert(sizeof(DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeValue) == 0x000004, "Wrong size on DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeValue");
static_assert(offsetof(DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeValue, ReturnValue) == 0x000000, "Member 'DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeValue::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCSpawnPoolComponent.Rent
// 0x0008 (0x0008 - 0x0000)
struct DCSpawnPoolComponent_Rent final
{
public:
	class APropsActorBase*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSpawnPoolComponent_Rent) == 0x000008, "Wrong alignment on DCSpawnPoolComponent_Rent");
static_assert(sizeof(DCSpawnPoolComponent_Rent) == 0x000008, "Wrong size on DCSpawnPoolComponent_Rent");
static_assert(offsetof(DCSpawnPoolComponent_Rent, ReturnValue) == 0x000000, "Member 'DCSpawnPoolComponent_Rent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCSpawnPoolComponent.Return
// 0x0008 (0x0008 - 0x0000)
struct DCSpawnPoolComponent_Return final
{
public:
	class APropsActorBase*                        RentedPropActor;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSpawnPoolComponent_Return) == 0x000008, "Wrong alignment on DCSpawnPoolComponent_Return");
static_assert(sizeof(DCSpawnPoolComponent_Return) == 0x000008, "Wrong size on DCSpawnPoolComponent_Return");
static_assert(offsetof(DCSpawnPoolComponent_Return, RentedPropActor) == 0x000000, "Member 'DCSpawnPoolComponent_Return::RentedPropActor' has a wrong offset!");

// Function DungeonCrawler.DCSpellWidgetBase.GetSpellTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCSpellWidgetBase_GetSpellTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSpellWidgetBase_GetSpellTooltipWidget) == 0x000008, "Wrong alignment on DCSpellWidgetBase_GetSpellTooltipWidget");
static_assert(sizeof(DCSpellWidgetBase_GetSpellTooltipWidget) == 0x000008, "Wrong size on DCSpellWidgetBase_GetSpellTooltipWidget");
static_assert(offsetof(DCSpellWidgetBase_GetSpellTooltipWidget, ReturnValue) == 0x000000, "Member 'DCSpellWidgetBase_GetSpellTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCSpellWidgetBase.OnArtDataSet
// 0x0008 (0x0008 - 0x0000)
struct DCSpellWidgetBase_OnArtDataSet final
{
public:
	const class UArtDataSpell*                    ArtData;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSpellWidgetBase_OnArtDataSet) == 0x000008, "Wrong alignment on DCSpellWidgetBase_OnArtDataSet");
static_assert(sizeof(DCSpellWidgetBase_OnArtDataSet) == 0x000008, "Wrong size on DCSpellWidgetBase_OnArtDataSet");
static_assert(offsetof(DCSpellWidgetBase_OnArtDataSet, ArtData) == 0x000000, "Member 'DCSpellWidgetBase_OnArtDataSet::ArtData' has a wrong offset!");

// Function DungeonCrawler.DCTabListWidgetBase.ActivateFirstSelectableTab
// 0x0001 (0x0001 - 0x0000)
struct DCTabListWidgetBase_ActivateFirstSelectableTab final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTabListWidgetBase_ActivateFirstSelectableTab) == 0x000001, "Wrong alignment on DCTabListWidgetBase_ActivateFirstSelectableTab");
static_assert(sizeof(DCTabListWidgetBase_ActivateFirstSelectableTab) == 0x000001, "Wrong size on DCTabListWidgetBase_ActivateFirstSelectableTab");
static_assert(offsetof(DCTabListWidgetBase_ActivateFirstSelectableTab, ReturnValue) == 0x000000, "Member 'DCTabListWidgetBase_ActivateFirstSelectableTab::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCTabListWidgetBase.OnTabButtonSelected
// 0x0008 (0x0008 - 0x0000)
struct DCTabListWidgetBase_OnTabButtonSelected final
{
public:
	class FName                                   TabId;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTabListWidgetBase_OnTabButtonSelected) == 0x000004, "Wrong alignment on DCTabListWidgetBase_OnTabButtonSelected");
static_assert(sizeof(DCTabListWidgetBase_OnTabButtonSelected) == 0x000008, "Wrong size on DCTabListWidgetBase_OnTabButtonSelected");
static_assert(offsetof(DCTabListWidgetBase_OnTabButtonSelected, TabId) == 0x000000, "Member 'DCTabListWidgetBase_OnTabButtonSelected::TabId' has a wrong offset!");

// Function DungeonCrawler.DCTargetType.GetTargets
// 0x00E0 (0x00E0 - 0x0000)
struct DCTargetType_GetTargets final
{
public:
	class AActor*                                 TargetingOwnerActor;                               // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetingAvatarActor;                              // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0010(0x00B0)(Parm, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     OutHitResults;                                     // 0x00C0(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x00D0(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTargetType_GetTargets) == 0x000008, "Wrong alignment on DCTargetType_GetTargets");
static_assert(sizeof(DCTargetType_GetTargets) == 0x0000E0, "Wrong size on DCTargetType_GetTargets");
static_assert(offsetof(DCTargetType_GetTargets, TargetingOwnerActor) == 0x000000, "Member 'DCTargetType_GetTargets::TargetingOwnerActor' has a wrong offset!");
static_assert(offsetof(DCTargetType_GetTargets, TargetingAvatarActor) == 0x000008, "Member 'DCTargetType_GetTargets::TargetingAvatarActor' has a wrong offset!");
static_assert(offsetof(DCTargetType_GetTargets, EventData) == 0x000010, "Member 'DCTargetType_GetTargets::EventData' has a wrong offset!");
static_assert(offsetof(DCTargetType_GetTargets, OutHitResults) == 0x0000C0, "Member 'DCTargetType_GetTargets::OutHitResults' has a wrong offset!");
static_assert(offsetof(DCTargetType_GetTargets, OutActors) == 0x0000D0, "Member 'DCTargetType_GetTargets::OutActors' has a wrong offset!");

// Function DungeonCrawler.DCKillLogItemWidgetBase.OnSetKillLog
// 0x0001 (0x0001 - 0x0000)
struct DCKillLogItemWidgetBase_OnSetKillLog final
{
public:
	bool                                          bIsHitHead;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCKillLogItemWidgetBase_OnSetKillLog) == 0x000001, "Wrong alignment on DCKillLogItemWidgetBase_OnSetKillLog");
static_assert(sizeof(DCKillLogItemWidgetBase_OnSetKillLog) == 0x000001, "Wrong size on DCKillLogItemWidgetBase_OnSetKillLog");
static_assert(offsetof(DCKillLogItemWidgetBase_OnSetKillLog, bIsHitHead) == 0x000000, "Member 'DCKillLogItemWidgetBase_OnSetKillLog::bIsHitHead' has a wrong offset!");

// Function DungeonCrawler.EmoteComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct EmoteComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EmoteComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on EmoteComponent_BroadcastMsgBlueprint");
static_assert(sizeof(EmoteComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on EmoteComponent_BroadcastMsgBlueprint");
static_assert(offsetof(EmoteComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'EmoteComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.EmoteComponent.OnRep_EmoteSlotInfoArray
// 0x0010 (0x0010 - 0x0000)
struct EmoteComponent_OnRep_EmoteSlotInfoArray final
{
public:
	TArray<struct FDCEmoteSlotInfo>               OldEmoteSlotInfoArray;                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EmoteComponent_OnRep_EmoteSlotInfoArray) == 0x000008, "Wrong alignment on EmoteComponent_OnRep_EmoteSlotInfoArray");
static_assert(sizeof(EmoteComponent_OnRep_EmoteSlotInfoArray) == 0x000010, "Wrong size on EmoteComponent_OnRep_EmoteSlotInfoArray");
static_assert(offsetof(EmoteComponent_OnRep_EmoteSlotInfoArray, OldEmoteSlotInfoArray) == 0x000000, "Member 'EmoteComponent_OnRep_EmoteSlotInfoArray::OldEmoteSlotInfoArray' has a wrong offset!");

// Function DungeonCrawler.EmoteComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct EmoteComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EmoteComponent_UnbindMsg) == 0x000008, "Wrong alignment on EmoteComponent_UnbindMsg");
static_assert(sizeof(EmoteComponent_UnbindMsg) == 0x000010, "Wrong size on EmoteComponent_UnbindMsg");
static_assert(offsetof(EmoteComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'EmoteComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(EmoteComponent_UnbindMsg, InObject) == 0x000008, "Member 'EmoteComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.EmoteComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct EmoteComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EmoteComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on EmoteComponent_UnbindMsgAll");
static_assert(sizeof(EmoteComponent_UnbindMsgAll) == 0x000008, "Wrong size on EmoteComponent_UnbindMsgAll");
static_assert(offsetof(EmoteComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'EmoteComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCKnightLinkWidgetBase.OnGameUserSettingControlsChanged
// 0x0088 (0x0088 - 0x0000)
struct DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged final
{
public:
	struct FGameUserSettingControls               InGameUserSettingControls;                         // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameUserSettingControls               InOldGameUserSettingControls;                      // 0x0040(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInForce;                                          // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269B[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged) == 0x000008, "Wrong alignment on DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged");
static_assert(sizeof(DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged) == 0x000088, "Wrong size on DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged");
static_assert(offsetof(DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged, InGameUserSettingControls) == 0x000000, "Member 'DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged::InGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged, InOldGameUserSettingControls) == 0x000040, "Member 'DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged::InOldGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged, bInForce) == 0x000080, "Member 'DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged::bInForce' has a wrong offset!");

// Function DungeonCrawler.InventoryComponent.AddContainingItem
// 0x0108 (0x0108 - 0x0000)
struct InventoryComponent_AddContainingItem final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(Parm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A3[0x7];                                     // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InventoryComponent_AddContainingItem) == 0x000008, "Wrong alignment on InventoryComponent_AddContainingItem");
static_assert(sizeof(InventoryComponent_AddContainingItem) == 0x000108, "Wrong size on InventoryComponent_AddContainingItem");
static_assert(offsetof(InventoryComponent_AddContainingItem, ItemData) == 0x000000, "Member 'InventoryComponent_AddContainingItem::ItemData' has a wrong offset!");
static_assert(offsetof(InventoryComponent_AddContainingItem, ReturnValue) == 0x000100, "Member 'InventoryComponent_AddContainingItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InventoryComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct InventoryComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on InventoryComponent_BroadcastMsgBlueprint");
static_assert(sizeof(InventoryComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on InventoryComponent_BroadcastMsgBlueprint");
static_assert(offsetof(InventoryComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'InventoryComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.InventoryComponent.ClientShowMessage
// 0x0018 (0x0018 - 0x0000)
struct InventoryComponent_ClientShowMessage final
{
public:
	class FText                                   OutputMessage;                                     // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_ClientShowMessage) == 0x000008, "Wrong alignment on InventoryComponent_ClientShowMessage");
static_assert(sizeof(InventoryComponent_ClientShowMessage) == 0x000018, "Wrong size on InventoryComponent_ClientShowMessage");
static_assert(offsetof(InventoryComponent_ClientShowMessage, OutputMessage) == 0x000000, "Member 'InventoryComponent_ClientShowMessage::OutputMessage' has a wrong offset!");

// Function DungeonCrawler.InventoryComponent.OnRep_ContainingItems
// 0x0010 (0x0010 - 0x0000)
struct InventoryComponent_OnRep_ContainingItems final
{
public:
	TArray<struct FItemData>                      OldContainingItems;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_OnRep_ContainingItems) == 0x000008, "Wrong alignment on InventoryComponent_OnRep_ContainingItems");
static_assert(sizeof(InventoryComponent_OnRep_ContainingItems) == 0x000010, "Wrong size on InventoryComponent_OnRep_ContainingItems");
static_assert(offsetof(InventoryComponent_OnRep_ContainingItems, OldContainingItems) == 0x000000, "Member 'InventoryComponent_OnRep_ContainingItems::OldContainingItems' has a wrong offset!");

// Function DungeonCrawler.InventoryComponent.OnRep_TotalGoldCount
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_OnRep_TotalGoldCount final
{
public:
	int64                                         OldTotalGoldCount;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_OnRep_TotalGoldCount) == 0x000008, "Wrong alignment on InventoryComponent_OnRep_TotalGoldCount");
static_assert(sizeof(InventoryComponent_OnRep_TotalGoldCount) == 0x000008, "Wrong size on InventoryComponent_OnRep_TotalGoldCount");
static_assert(offsetof(InventoryComponent_OnRep_TotalGoldCount, OldTotalGoldCount) == 0x000000, "Member 'InventoryComponent_OnRep_TotalGoldCount::OldTotalGoldCount' has a wrong offset!");

// Function DungeonCrawler.InventoryComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct InventoryComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_UnbindMsg) == 0x000008, "Wrong alignment on InventoryComponent_UnbindMsg");
static_assert(sizeof(InventoryComponent_UnbindMsg) == 0x000010, "Wrong size on InventoryComponent_UnbindMsg");
static_assert(offsetof(InventoryComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'InventoryComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(InventoryComponent_UnbindMsg, InObject) == 0x000008, "Member 'InventoryComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.InventoryComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct InventoryComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on InventoryComponent_UnbindMsgAll");
static_assert(sizeof(InventoryComponent_UnbindMsgAll) == 0x000008, "Wrong size on InventoryComponent_UnbindMsgAll");
static_assert(offsetof(InventoryComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'InventoryComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.InventoryComponent.GetInventoryType
// 0x0001 (0x0001 - 0x0000)
struct InventoryComponent_GetInventoryType final
{
public:
	EInventoryType                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetInventoryType) == 0x000001, "Wrong alignment on InventoryComponent_GetInventoryType");
static_assert(sizeof(InventoryComponent_GetInventoryType) == 0x000001, "Wrong size on InventoryComponent_GetInventoryType");
static_assert(offsetof(InventoryComponent_GetInventoryType, ReturnValue) == 0x000000, "Member 'InventoryComponent_GetInventoryType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InventoryComponent.GetItemByItemUniqueId
// 0x0010 (0x0010 - 0x0000)
struct InventoryComponent_GetItemByItemUniqueId final
{
public:
	int64                                         InItemUniqueId;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItem*                                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryComponent_GetItemByItemUniqueId) == 0x000008, "Wrong alignment on InventoryComponent_GetItemByItemUniqueId");
static_assert(sizeof(InventoryComponent_GetItemByItemUniqueId) == 0x000010, "Wrong size on InventoryComponent_GetItemByItemUniqueId");
static_assert(offsetof(InventoryComponent_GetItemByItemUniqueId, InItemUniqueId) == 0x000000, "Member 'InventoryComponent_GetItemByItemUniqueId::InItemUniqueId' has a wrong offset!");
static_assert(offsetof(InventoryComponent_GetItemByItemUniqueId, ReturnValue) == 0x000008, "Member 'InventoryComponent_GetItemByItemUniqueId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLeaderboardDataAsset.GetNextLeaderboardRankData
// 0x0010 (0x0010 - 0x0000)
struct DCLeaderboardDataAsset_GetNextLeaderboardRankData final
{
public:
	const class UDCLeaderboardRankDataAsset*      InLeaderboardRankData;                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDCLeaderboardRankDataAsset*      ReturnValue;                                       // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLeaderboardDataAsset_GetNextLeaderboardRankData) == 0x000008, "Wrong alignment on DCLeaderboardDataAsset_GetNextLeaderboardRankData");
static_assert(sizeof(DCLeaderboardDataAsset_GetNextLeaderboardRankData) == 0x000010, "Wrong size on DCLeaderboardDataAsset_GetNextLeaderboardRankData");
static_assert(offsetof(DCLeaderboardDataAsset_GetNextLeaderboardRankData, InLeaderboardRankData) == 0x000000, "Member 'DCLeaderboardDataAsset_GetNextLeaderboardRankData::InLeaderboardRankData' has a wrong offset!");
static_assert(offsetof(DCLeaderboardDataAsset_GetNextLeaderboardRankData, ReturnValue) == 0x000008, "Member 'DCLeaderboardDataAsset_GetNextLeaderboardRankData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.FloorRuleInterface.BindFloorRuleDataDelegate
// 0x0010 (0x0010 - 0x0000)
struct FloorRuleInterface_BindFloorRuleDataDelegate final
{
public:
	TDelegate<void(struct FGameFloorRuleData& InFloorRuleData)> InBindDelegate;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FloorRuleInterface_BindFloorRuleDataDelegate) == 0x000004, "Wrong alignment on FloorRuleInterface_BindFloorRuleDataDelegate");
static_assert(sizeof(FloorRuleInterface_BindFloorRuleDataDelegate) == 0x000010, "Wrong size on FloorRuleInterface_BindFloorRuleDataDelegate");
static_assert(offsetof(FloorRuleInterface_BindFloorRuleDataDelegate, InBindDelegate) == 0x000000, "Member 'FloorRuleInterface_BindFloorRuleDataDelegate::InBindDelegate' has a wrong offset!");

// Function DungeonCrawler.FloorRuleInterface.BindFloorRuleFinishedDelegate
// 0x0010 (0x0010 - 0x0000)
struct FloorRuleInterface_BindFloorRuleFinishedDelegate final
{
public:
	TDelegate<void()>                             InBindDelegate;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FloorRuleInterface_BindFloorRuleFinishedDelegate) == 0x000004, "Wrong alignment on FloorRuleInterface_BindFloorRuleFinishedDelegate");
static_assert(sizeof(FloorRuleInterface_BindFloorRuleFinishedDelegate) == 0x000010, "Wrong size on FloorRuleInterface_BindFloorRuleFinishedDelegate");
static_assert(offsetof(FloorRuleInterface_BindFloorRuleFinishedDelegate, InBindDelegate) == 0x000000, "Member 'FloorRuleInterface_BindFloorRuleFinishedDelegate::InBindDelegate' has a wrong offset!");

// Function DungeonCrawler.FloorRuleInterface.UnbindFloorRuleDataDelegate
// 0x0008 (0x0008 - 0x0000)
struct FloorRuleInterface_UnbindFloorRuleDataDelegate final
{
public:
	class UObject*                                InBoundObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FloorRuleInterface_UnbindFloorRuleDataDelegate) == 0x000008, "Wrong alignment on FloorRuleInterface_UnbindFloorRuleDataDelegate");
static_assert(sizeof(FloorRuleInterface_UnbindFloorRuleDataDelegate) == 0x000008, "Wrong size on FloorRuleInterface_UnbindFloorRuleDataDelegate");
static_assert(offsetof(FloorRuleInterface_UnbindFloorRuleDataDelegate, InBoundObject) == 0x000000, "Member 'FloorRuleInterface_UnbindFloorRuleDataDelegate::InBoundObject' has a wrong offset!");

// Function DungeonCrawler.FloorRuleInterface.GetFloorRuleData
// 0x0040 (0x0040 - 0x0000)
struct FloorRuleInterface_GetFloorRuleData final
{
public:
	struct FGameFloorRuleData                     ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FloorRuleInterface_GetFloorRuleData) == 0x000008, "Wrong alignment on FloorRuleInterface_GetFloorRuleData");
static_assert(sizeof(FloorRuleInterface_GetFloorRuleData) == 0x000040, "Wrong size on FloorRuleInterface_GetFloorRuleData");
static_assert(offsetof(FloorRuleInterface_GetFloorRuleData, ReturnValue) == 0x000000, "Member 'FloorRuleInterface_GetFloorRuleData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.FloorRuleInterface.LogHandleFloorRuleData
// 0x0048 (0x0048 - 0x0000)
struct FloorRuleInterface_LogHandleFloorRuleData final
{
public:
	const class UObject*                          InHandler;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameFloorRuleData                     InFloorRuleData;                                   // 0x0008(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FloorRuleInterface_LogHandleFloorRuleData) == 0x000008, "Wrong alignment on FloorRuleInterface_LogHandleFloorRuleData");
static_assert(sizeof(FloorRuleInterface_LogHandleFloorRuleData) == 0x000048, "Wrong size on FloorRuleInterface_LogHandleFloorRuleData");
static_assert(offsetof(FloorRuleInterface_LogHandleFloorRuleData, InHandler) == 0x000000, "Member 'FloorRuleInterface_LogHandleFloorRuleData::InHandler' has a wrong offset!");
static_assert(offsetof(FloorRuleInterface_LogHandleFloorRuleData, InFloorRuleData) == 0x000008, "Member 'FloorRuleInterface_LogHandleFloorRuleData::InFloorRuleData' has a wrong offset!");

// Function DungeonCrawler.DCLearningTokensWidgetBase.OnCharacterTileViewSelectionChanged
// 0x0008 (0x0008 - 0x0000)
struct DCLearningTokensWidgetBase_OnCharacterTileViewSelectionChanged final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLearningTokensWidgetBase_OnCharacterTileViewSelectionChanged) == 0x000008, "Wrong alignment on DCLearningTokensWidgetBase_OnCharacterTileViewSelectionChanged");
static_assert(sizeof(DCLearningTokensWidgetBase_OnCharacterTileViewSelectionChanged) == 0x000008, "Wrong size on DCLearningTokensWidgetBase_OnCharacterTileViewSelectionChanged");
static_assert(offsetof(DCLearningTokensWidgetBase_OnCharacterTileViewSelectionChanged, Item) == 0x000000, "Member 'DCLearningTokensWidgetBase_OnCharacterTileViewSelectionChanged::Item' has a wrong offset!");

// Function DungeonCrawler.DCLearningTokensWidgetBase.GetSelectedCharacterNickname
// 0x0040 (0x0040 - 0x0000)
struct DCLearningTokensWidgetBase_GetSelectedCharacterNickname final
{
public:
	struct FNickname                              ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLearningTokensWidgetBase_GetSelectedCharacterNickname) == 0x000008, "Wrong alignment on DCLearningTokensWidgetBase_GetSelectedCharacterNickname");
static_assert(sizeof(DCLearningTokensWidgetBase_GetSelectedCharacterNickname) == 0x000040, "Wrong size on DCLearningTokensWidgetBase_GetSelectedCharacterNickname");
static_assert(offsetof(DCLearningTokensWidgetBase_GetSelectedCharacterNickname, ReturnValue) == 0x000000, "Member 'DCLearningTokensWidgetBase_GetSelectedCharacterNickname::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLearningTokensWidgetBase.GetSelectedClassText
// 0x0018 (0x0018 - 0x0000)
struct DCLearningTokensWidgetBase_GetSelectedClassText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLearningTokensWidgetBase_GetSelectedClassText) == 0x000008, "Wrong alignment on DCLearningTokensWidgetBase_GetSelectedClassText");
static_assert(sizeof(DCLearningTokensWidgetBase_GetSelectedClassText) == 0x000018, "Wrong size on DCLearningTokensWidgetBase_GetSelectedClassText");
static_assert(offsetof(DCLearningTokensWidgetBase_GetSelectedClassText, ReturnValue) == 0x000000, "Member 'DCLearningTokensWidgetBase_GetSelectedClassText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLearningTokensWidgetBase.IsMasterSelected
// 0x0001 (0x0001 - 0x0000)
struct DCLearningTokensWidgetBase_IsMasterSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLearningTokensWidgetBase_IsMasterSelected) == 0x000001, "Wrong alignment on DCLearningTokensWidgetBase_IsMasterSelected");
static_assert(sizeof(DCLearningTokensWidgetBase_IsMasterSelected) == 0x000001, "Wrong size on DCLearningTokensWidgetBase_IsMasterSelected");
static_assert(offsetof(DCLearningTokensWidgetBase_IsMasterSelected, ReturnValue) == 0x000000, "Member 'DCLearningTokensWidgetBase_IsMasterSelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLegendaryStatusPopup.OnSetAccountStatus
// 0x0001 (0x0001 - 0x0000)
struct DCLegendaryStatusPopup_OnSetAccountStatus final
{
public:
	EDCAccountStatus                              InAccountStatus;                                   // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLegendaryStatusPopup_OnSetAccountStatus) == 0x000001, "Wrong alignment on DCLegendaryStatusPopup_OnSetAccountStatus");
static_assert(sizeof(DCLegendaryStatusPopup_OnSetAccountStatus) == 0x000001, "Wrong size on DCLegendaryStatusPopup_OnSetAccountStatus");
static_assert(offsetof(DCLegendaryStatusPopup_OnSetAccountStatus, InAccountStatus) == 0x000000, "Member 'DCLegendaryStatusPopup_OnSetAccountStatus::InAccountStatus' has a wrong offset!");

// Function DungeonCrawler.DCLegendaryStatusPopup.OnSetAccountStatusUpgradeShopInfo
// 0x0018 (0x0018 - 0x0000)
struct DCLegendaryStatusPopup_OnSetAccountStatusUpgradeShopInfo final
{
public:
	struct FDCAccountStatusUpgradeShopInfo        InShopInfo;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLegendaryStatusPopup_OnSetAccountStatusUpgradeShopInfo) == 0x000008, "Wrong alignment on DCLegendaryStatusPopup_OnSetAccountStatusUpgradeShopInfo");
static_assert(sizeof(DCLegendaryStatusPopup_OnSetAccountStatusUpgradeShopInfo) == 0x000018, "Wrong size on DCLegendaryStatusPopup_OnSetAccountStatusUpgradeShopInfo");
static_assert(offsetof(DCLegendaryStatusPopup_OnSetAccountStatusUpgradeShopInfo, InShopInfo) == 0x000000, "Member 'DCLegendaryStatusPopup_OnSetAccountStatusUpgradeShopInfo::InShopInfo' has a wrong offset!");

// Function DungeonCrawler.DCLegendaryStatusPopup.OnSetContentsBlockHours
// 0x0008 (0x0008 - 0x0000)
struct DCLegendaryStatusPopup_OnSetContentsBlockHours final
{
public:
	EServicePolicyType                            InPolicyType;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26AA[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InBlockHours;                                      // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLegendaryStatusPopup_OnSetContentsBlockHours) == 0x000004, "Wrong alignment on DCLegendaryStatusPopup_OnSetContentsBlockHours");
static_assert(sizeof(DCLegendaryStatusPopup_OnSetContentsBlockHours) == 0x000008, "Wrong size on DCLegendaryStatusPopup_OnSetContentsBlockHours");
static_assert(offsetof(DCLegendaryStatusPopup_OnSetContentsBlockHours, InPolicyType) == 0x000000, "Member 'DCLegendaryStatusPopup_OnSetContentsBlockHours::InPolicyType' has a wrong offset!");
static_assert(offsetof(DCLegendaryStatusPopup_OnSetContentsBlockHours, InBlockHours) == 0x000004, "Member 'DCLegendaryStatusPopup_OnSetContentsBlockHours::InBlockHours' has a wrong offset!");

// Function DungeonCrawler.DCLevelSequenceActor.ProcessSequence
// 0x0008 (0x0008 - 0x0000)
struct DCLevelSequenceActor_ProcessSequence final
{
public:
	struct FGameplayTag                           InEventTag;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLevelSequenceActor_ProcessSequence) == 0x000004, "Wrong alignment on DCLevelSequenceActor_ProcessSequence");
static_assert(sizeof(DCLevelSequenceActor_ProcessSequence) == 0x000008, "Wrong size on DCLevelSequenceActor_ProcessSequence");
static_assert(offsetof(DCLevelSequenceActor_ProcessSequence, InEventTag) == 0x000000, "Member 'DCLevelSequenceActor_ProcessSequence::InEventTag' has a wrong offset!");

// Function DungeonCrawler.GameActorStatusSlotWidget.OnActorStatusData
// 0x0040 (0x0040 - 0x0000)
struct GameActorStatusSlotWidget_OnActorStatusData final
{
public:
	struct FActorStatusData                       NewValue;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActorStatusData                       OldValue;                                          // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameActorStatusSlotWidget_OnActorStatusData) == 0x000008, "Wrong alignment on GameActorStatusSlotWidget_OnActorStatusData");
static_assert(sizeof(GameActorStatusSlotWidget_OnActorStatusData) == 0x000040, "Wrong size on GameActorStatusSlotWidget_OnActorStatusData");
static_assert(offsetof(GameActorStatusSlotWidget_OnActorStatusData, NewValue) == 0x000000, "Member 'GameActorStatusSlotWidget_OnActorStatusData::NewValue' has a wrong offset!");
static_assert(offsetof(GameActorStatusSlotWidget_OnActorStatusData, OldValue) == 0x000020, "Member 'GameActorStatusSlotWidget_OnActorStatusData::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCLoadingScreenWidget.OnUpdated
// 0x0020 (0x0020 - 0x0000)
struct DCLoadingScreenWidget_OnUpdated final
{
public:
	class UTexture2D*                             InLoadingImage;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InDescText;                                        // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLoadingScreenWidget_OnUpdated) == 0x000008, "Wrong alignment on DCLoadingScreenWidget_OnUpdated");
static_assert(sizeof(DCLoadingScreenWidget_OnUpdated) == 0x000020, "Wrong size on DCLoadingScreenWidget_OnUpdated");
static_assert(offsetof(DCLoadingScreenWidget_OnUpdated, InLoadingImage) == 0x000000, "Member 'DCLoadingScreenWidget_OnUpdated::InLoadingImage' has a wrong offset!");
static_assert(offsetof(DCLoadingScreenWidget_OnUpdated, InDescText) == 0x000008, "Member 'DCLoadingScreenWidget_OnUpdated::InDescText' has a wrong offset!");

// Function DungeonCrawler.DCLoadoutPageWidget.GetFame
// 0x0004 (0x0004 - 0x0000)
struct DCLoadoutPageWidget_GetFame final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLoadoutPageWidget_GetFame) == 0x000004, "Wrong alignment on DCLoadoutPageWidget_GetFame");
static_assert(sizeof(DCLoadoutPageWidget_GetFame) == 0x000004, "Wrong size on DCLoadoutPageWidget_GetFame");
static_assert(offsetof(DCLoadoutPageWidget_GetFame, ReturnValue) == 0x000000, "Member 'DCLoadoutPageWidget_GetFame::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLoadoutPageWidget.GetLevel
// 0x0004 (0x0004 - 0x0000)
struct DCLoadoutPageWidget_GetLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLoadoutPageWidget_GetLevel) == 0x000004, "Wrong alignment on DCLoadoutPageWidget_GetLevel");
static_assert(sizeof(DCLoadoutPageWidget_GetLevel) == 0x000004, "Wrong size on DCLoadoutPageWidget_GetLevel");
static_assert(offsetof(DCLoadoutPageWidget_GetLevel, ReturnValue) == 0x000000, "Member 'DCLoadoutPageWidget_GetLevel::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPurchaseConfirmPopupData.GetMessage
// 0x0018 (0x0018 - 0x0000)
struct DCPurchaseConfirmPopupData_GetMessage final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPurchaseConfirmPopupData_GetMessage) == 0x000008, "Wrong alignment on DCPurchaseConfirmPopupData_GetMessage");
static_assert(sizeof(DCPurchaseConfirmPopupData_GetMessage) == 0x000018, "Wrong size on DCPurchaseConfirmPopupData_GetMessage");
static_assert(offsetof(DCPurchaseConfirmPopupData_GetMessage, ReturnValue) == 0x000000, "Member 'DCPurchaseConfirmPopupData_GetMessage::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPurchaseConfirmPopupData.GetPrice
// 0x0008 (0x0008 - 0x0000)
struct DCPurchaseConfirmPopupData_GetPrice final
{
public:
	struct FDCPrice                               ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPurchaseConfirmPopupData_GetPrice) == 0x000004, "Wrong alignment on DCPurchaseConfirmPopupData_GetPrice");
static_assert(sizeof(DCPurchaseConfirmPopupData_GetPrice) == 0x000008, "Wrong size on DCPurchaseConfirmPopupData_GetPrice");
static_assert(offsetof(DCPurchaseConfirmPopupData_GetPrice, ReturnValue) == 0x000000, "Member 'DCPurchaseConfirmPopupData_GetPrice::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLobbyCaptureViewerActor.SetActorRotation
// 0x0004 (0x0004 - 0x0000)
struct DCLobbyCaptureViewerActor_SetActorRotation final
{
public:
	float                                         InYaw;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyCaptureViewerActor_SetActorRotation) == 0x000004, "Wrong alignment on DCLobbyCaptureViewerActor_SetActorRotation");
static_assert(sizeof(DCLobbyCaptureViewerActor_SetActorRotation) == 0x000004, "Wrong size on DCLobbyCaptureViewerActor_SetActorRotation");
static_assert(offsetof(DCLobbyCaptureViewerActor_SetActorRotation, InYaw) == 0x000000, "Member 'DCLobbyCaptureViewerActor_SetActorRotation::InYaw' has a wrong offset!");

// Function DungeonCrawler.DCLobbyCaptureViewerActor.SetMeshRotationSpeedMultiplier
// 0x0004 (0x0004 - 0x0000)
struct DCLobbyCaptureViewerActor_SetMeshRotationSpeedMultiplier final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyCaptureViewerActor_SetMeshRotationSpeedMultiplier) == 0x000004, "Wrong alignment on DCLobbyCaptureViewerActor_SetMeshRotationSpeedMultiplier");
static_assert(sizeof(DCLobbyCaptureViewerActor_SetMeshRotationSpeedMultiplier) == 0x000004, "Wrong size on DCLobbyCaptureViewerActor_SetMeshRotationSpeedMultiplier");
static_assert(offsetof(DCLobbyCaptureViewerActor_SetMeshRotationSpeedMultiplier, Value) == 0x000000, "Member 'DCLobbyCaptureViewerActor_SetMeshRotationSpeedMultiplier::Value' has a wrong offset!");

// Function DungeonCrawler.DCLobbyCaptureViewerActor.SetStartRotateLocation
// 0x0004 (0x0004 - 0x0000)
struct DCLobbyCaptureViewerActor_SetStartRotateLocation final
{
public:
	float                                         InStartPosition;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyCaptureViewerActor_SetStartRotateLocation) == 0x000004, "Wrong alignment on DCLobbyCaptureViewerActor_SetStartRotateLocation");
static_assert(sizeof(DCLobbyCaptureViewerActor_SetStartRotateLocation) == 0x000004, "Wrong size on DCLobbyCaptureViewerActor_SetStartRotateLocation");
static_assert(offsetof(DCLobbyCaptureViewerActor_SetStartRotateLocation, InStartPosition) == 0x000000, "Member 'DCLobbyCaptureViewerActor_SetStartRotateLocation::InStartPosition' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnAddCharacterTypeChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnAddCharacterTypeChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnAddCharacterTypeChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnAddCharacterTypeChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnAddCharacterTypeChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnAddCharacterTypeChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnAddCharacterTypeChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnAddCharacterTypeChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnAddIdTagChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnAddIdTagChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnAddIdTagChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnAddIdTagChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnAddIdTagChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnAddIdTagChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnAddIdTagChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnAddIdTagChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnAddPropertyChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnAddPropertyChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnAddPropertyChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnAddPropertyChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnAddPropertyChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnAddPropertyChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnAddPropertyChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnAddPropertyChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnAddRarityChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnAddRarityChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnAddRarityChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnAddRarityChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnAddRarityChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnAddRarityChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnAddRarityChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnAddRarityChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnAddSlotChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnAddSlotChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnAddSlotChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnAddSlotChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnAddSlotChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnAddSlotChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnAddSlotChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnAddSlotChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnAddTypeChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnAddTypeChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnAddTypeChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnAddTypeChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnAddTypeChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnAddTypeChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnAddTypeChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnAddTypeChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnRemoveCharacterTypeChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnRemoveCharacterTypeChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnRemoveCharacterTypeChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnRemoveCharacterTypeChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnRemoveCharacterTypeChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnRemoveCharacterTypeChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnRemoveCharacterTypeChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnRemoveCharacterTypeChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnRemoveIdTagChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnRemoveIdTagChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnRemoveIdTagChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnRemoveIdTagChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnRemoveIdTagChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnRemoveIdTagChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnRemoveIdTagChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnRemoveIdTagChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnRemovePropertyChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnRemovePropertyChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnRemovePropertyChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnRemovePropertyChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnRemovePropertyChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnRemovePropertyChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnRemovePropertyChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnRemovePropertyChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnRemoveRarityChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnRemoveRarityChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnRemoveRarityChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnRemoveRarityChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnRemoveRarityChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnRemoveRarityChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnRemoveRarityChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnRemoveRarityChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnRemoveSlotChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnRemoveSlotChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnRemoveSlotChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnRemoveSlotChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnRemoveSlotChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnRemoveSlotChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnRemoveSlotChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnRemoveSlotChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.TradeChannelChatWidget.OnRemoveTypeChatFilterTag
// 0x0008 (0x0008 - 0x0000)
struct TradeChannelChatWidget_OnRemoveTypeChatFilterTag final
{
public:
	struct FGameplayTag                           InChatFilterTag;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelChatWidget_OnRemoveTypeChatFilterTag) == 0x000004, "Wrong alignment on TradeChannelChatWidget_OnRemoveTypeChatFilterTag");
static_assert(sizeof(TradeChannelChatWidget_OnRemoveTypeChatFilterTag) == 0x000008, "Wrong size on TradeChannelChatWidget_OnRemoveTypeChatFilterTag");
static_assert(offsetof(TradeChannelChatWidget_OnRemoveTypeChatFilterTag, InChatFilterTag) == 0x000000, "Member 'TradeChannelChatWidget_OnRemoveTypeChatFilterTag::InChatFilterTag' has a wrong offset!");

// Function DungeonCrawler.DCLobbyEmoteGroupWidgetBase.GetVisibilityBySelectedEmote
// 0x0001 (0x0001 - 0x0000)
struct DCLobbyEmoteGroupWidgetBase_GetVisibilityBySelectedEmote final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyEmoteGroupWidgetBase_GetVisibilityBySelectedEmote) == 0x000001, "Wrong alignment on DCLobbyEmoteGroupWidgetBase_GetVisibilityBySelectedEmote");
static_assert(sizeof(DCLobbyEmoteGroupWidgetBase_GetVisibilityBySelectedEmote) == 0x000001, "Wrong size on DCLobbyEmoteGroupWidgetBase_GetVisibilityBySelectedEmote");
static_assert(offsetof(DCLobbyEmoteGroupWidgetBase_GetVisibilityBySelectedEmote, ReturnValue) == 0x000000, "Member 'DCLobbyEmoteGroupWidgetBase_GetVisibilityBySelectedEmote::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLobbyEmoteWidget.GetTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCLobbyEmoteWidget_GetTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyEmoteWidget_GetTooltipWidget) == 0x000008, "Wrong alignment on DCLobbyEmoteWidget_GetTooltipWidget");
static_assert(sizeof(DCLobbyEmoteWidget_GetTooltipWidget) == 0x000008, "Wrong size on DCLobbyEmoteWidget_GetTooltipWidget");
static_assert(offsetof(DCLobbyEmoteWidget_GetTooltipWidget, ReturnValue) == 0x000000, "Member 'DCLobbyEmoteWidget_GetTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLobbyEmoteListEntryWidget.GetSelectedVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCLobbyEmoteListEntryWidget_GetSelectedVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyEmoteListEntryWidget_GetSelectedVisibility) == 0x000001, "Wrong alignment on DCLobbyEmoteListEntryWidget_GetSelectedVisibility");
static_assert(sizeof(DCLobbyEmoteListEntryWidget_GetSelectedVisibility) == 0x000001, "Wrong size on DCLobbyEmoteListEntryWidget_GetSelectedVisibility");
static_assert(offsetof(DCLobbyEmoteListEntryWidget_GetSelectedVisibility, ReturnValue) == 0x000000, "Member 'DCLobbyEmoteListEntryWidget_GetSelectedVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLobbyEmoteSlotWidget.GetLobbyEmoteIconVisibility
// 0x0001 (0x0001 - 0x0000)
struct DCLobbyEmoteSlotWidget_GetLobbyEmoteIconVisibility final
{
public:
	ESlateVisibility                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyEmoteSlotWidget_GetLobbyEmoteIconVisibility) == 0x000001, "Wrong alignment on DCLobbyEmoteSlotWidget_GetLobbyEmoteIconVisibility");
static_assert(sizeof(DCLobbyEmoteSlotWidget_GetLobbyEmoteIconVisibility) == 0x000001, "Wrong size on DCLobbyEmoteSlotWidget_GetLobbyEmoteIconVisibility");
static_assert(offsetof(DCLobbyEmoteSlotWidget_GetLobbyEmoteIconVisibility, ReturnValue) == 0x000000, "Member 'DCLobbyEmoteSlotWidget_GetLobbyEmoteIconVisibility::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLobbyEmoteSlotWidget.OnSelectionChanged
// 0x0001 (0x0001 - 0x0000)
struct DCLobbyEmoteSlotWidget_OnSelectionChanged final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyEmoteSlotWidget_OnSelectionChanged) == 0x000001, "Wrong alignment on DCLobbyEmoteSlotWidget_OnSelectionChanged");
static_assert(sizeof(DCLobbyEmoteSlotWidget_OnSelectionChanged) == 0x000001, "Wrong size on DCLobbyEmoteSlotWidget_OnSelectionChanged");
static_assert(offsetof(DCLobbyEmoteSlotWidget_OnSelectionChanged, bIsSelected) == 0x000000, "Member 'DCLobbyEmoteSlotWidget_OnSelectionChanged::bIsSelected' has a wrong offset!");

// Function DungeonCrawler.DCLobbyEmoteSlotWidget.SelectionChange
// 0x0001 (0x0001 - 0x0000)
struct DCLobbyEmoteSlotWidget_SelectionChange final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyEmoteSlotWidget_SelectionChange) == 0x000001, "Wrong alignment on DCLobbyEmoteSlotWidget_SelectionChange");
static_assert(sizeof(DCLobbyEmoteSlotWidget_SelectionChange) == 0x000001, "Wrong size on DCLobbyEmoteSlotWidget_SelectionChange");
static_assert(offsetof(DCLobbyEmoteSlotWidget_SelectionChange, bIsSelected) == 0x000000, "Member 'DCLobbyEmoteSlotWidget_SelectionChange::bIsSelected' has a wrong offset!");

// Function DungeonCrawler.DCLobbyEmoteSlotWidget.SetLobbyEmoteData
// 0x0008 (0x0008 - 0x0000)
struct DCLobbyEmoteSlotWidget_SetLobbyEmoteData final
{
public:
	const class UDCLobbyEmoteDataAsset*           InDesignDataLobbyEmote;                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyEmoteSlotWidget_SetLobbyEmoteData) == 0x000008, "Wrong alignment on DCLobbyEmoteSlotWidget_SetLobbyEmoteData");
static_assert(sizeof(DCLobbyEmoteSlotWidget_SetLobbyEmoteData) == 0x000008, "Wrong size on DCLobbyEmoteSlotWidget_SetLobbyEmoteData");
static_assert(offsetof(DCLobbyEmoteSlotWidget_SetLobbyEmoteData, InDesignDataLobbyEmote) == 0x000000, "Member 'DCLobbyEmoteSlotWidget_SetLobbyEmoteData::InDesignDataLobbyEmote' has a wrong offset!");

// Function DungeonCrawler.DCLobbyTabButton.SetTabType
// 0x0001 (0x0001 - 0x0000)
struct DCLobbyTabButton_SetTabType final
{
public:
	EDCWidgetLobbyTabType                         InType;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLobbyTabButton_SetTabType) == 0x000001, "Wrong alignment on DCLobbyTabButton_SetTabType");
static_assert(sizeof(DCLobbyTabButton_SetTabType) == 0x000001, "Wrong size on DCLobbyTabButton_SetTabType");
static_assert(offsetof(DCLobbyTabButton_SetTabType, InType) == 0x000000, "Member 'DCLobbyTabButton_SetTabType::InType' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerHighRollerWidget.CanReport
// 0x0001 (0x0001 - 0x0000)
struct DCReportPlayerHighRollerWidget_CanReport final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerHighRollerWidget_CanReport) == 0x000001, "Wrong alignment on DCReportPlayerHighRollerWidget_CanReport");
static_assert(sizeof(DCReportPlayerHighRollerWidget_CanReport) == 0x000001, "Wrong size on DCReportPlayerHighRollerWidget_CanReport");
static_assert(offsetof(DCReportPlayerHighRollerWidget_CanReport, ReturnValue) == 0x000000, "Member 'DCReportPlayerHighRollerWidget_CanReport::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerHighRollerWidget.HandleCheckStatedChanged
// 0x0002 (0x0002 - 0x0000)
struct DCReportPlayerHighRollerWidget_HandleCheckStatedChanged final
{
public:
	EDCReportPlayerCategory                       InCategory;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InbNewChecked;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerHighRollerWidget_HandleCheckStatedChanged) == 0x000001, "Wrong alignment on DCReportPlayerHighRollerWidget_HandleCheckStatedChanged");
static_assert(sizeof(DCReportPlayerHighRollerWidget_HandleCheckStatedChanged) == 0x000002, "Wrong size on DCReportPlayerHighRollerWidget_HandleCheckStatedChanged");
static_assert(offsetof(DCReportPlayerHighRollerWidget_HandleCheckStatedChanged, InCategory) == 0x000000, "Member 'DCReportPlayerHighRollerWidget_HandleCheckStatedChanged::InCategory' has a wrong offset!");
static_assert(offsetof(DCReportPlayerHighRollerWidget_HandleCheckStatedChanged, InbNewChecked) == 0x000001, "Member 'DCReportPlayerHighRollerWidget_HandleCheckStatedChanged::InbNewChecked' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerHighRollerWidget.OnPlayerListComboBoxItemSelected
// 0x0008 (0x0008 - 0x0000)
struct DCReportPlayerHighRollerWidget_OnPlayerListComboBoxItemSelected final
{
public:
	class UObject*                                Item;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerHighRollerWidget_OnPlayerListComboBoxItemSelected) == 0x000008, "Wrong alignment on DCReportPlayerHighRollerWidget_OnPlayerListComboBoxItemSelected");
static_assert(sizeof(DCReportPlayerHighRollerWidget_OnPlayerListComboBoxItemSelected) == 0x000008, "Wrong size on DCReportPlayerHighRollerWidget_OnPlayerListComboBoxItemSelected");
static_assert(offsetof(DCReportPlayerHighRollerWidget_OnPlayerListComboBoxItemSelected, Item) == 0x000000, "Member 'DCReportPlayerHighRollerWidget_OnPlayerListComboBoxItemSelected::Item' has a wrong offset!");

// Function DungeonCrawler.DCLocalLoginWidget.OnLoginButtonClicked
// 0x0020 (0x0020 - 0x0000)
struct DCLocalLoginWidget_OnLoginButtonClicked final
{
public:
	class FString                                 IpAddress;                                         // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Nickname;                                          // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLocalLoginWidget_OnLoginButtonClicked) == 0x000008, "Wrong alignment on DCLocalLoginWidget_OnLoginButtonClicked");
static_assert(sizeof(DCLocalLoginWidget_OnLoginButtonClicked) == 0x000020, "Wrong size on DCLocalLoginWidget_OnLoginButtonClicked");
static_assert(offsetof(DCLocalLoginWidget_OnLoginButtonClicked, IpAddress) == 0x000000, "Member 'DCLocalLoginWidget_OnLoginButtonClicked::IpAddress' has a wrong offset!");
static_assert(offsetof(DCLocalLoginWidget_OnLoginButtonClicked, Nickname) == 0x000010, "Member 'DCLocalLoginWidget_OnLoginButtonClicked::Nickname' has a wrong offset!");

// Function DungeonCrawler.VoipPartySettingWidget.OnbVoipGlobal
// 0x0002 (0x0002 - 0x0000)
struct VoipPartySettingWidget_OnbVoipGlobal final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipPartySettingWidget_OnbVoipGlobal) == 0x000001, "Wrong alignment on VoipPartySettingWidget_OnbVoipGlobal");
static_assert(sizeof(VoipPartySettingWidget_OnbVoipGlobal) == 0x000002, "Wrong size on VoipPartySettingWidget_OnbVoipGlobal");
static_assert(offsetof(VoipPartySettingWidget_OnbVoipGlobal, NewValue) == 0x000000, "Member 'VoipPartySettingWidget_OnbVoipGlobal::NewValue' has a wrong offset!");
static_assert(offsetof(VoipPartySettingWidget_OnbVoipGlobal, OldValue) == 0x000001, "Member 'VoipPartySettingWidget_OnbVoipGlobal::OldValue' has a wrong offset!");

// Function DungeonCrawler.VoipPartySettingWidget.OnVoipGlobalSet
// 0x0001 (0x0001 - 0x0000)
struct VoipPartySettingWidget_OnVoipGlobalSet final
{
public:
	bool                                          InbVoipGlobal;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VoipPartySettingWidget_OnVoipGlobalSet) == 0x000001, "Wrong alignment on VoipPartySettingWidget_OnVoipGlobalSet");
static_assert(sizeof(VoipPartySettingWidget_OnVoipGlobalSet) == 0x000001, "Wrong size on VoipPartySettingWidget_OnVoipGlobalSet");
static_assert(offsetof(VoipPartySettingWidget_OnVoipGlobalSet, InbVoipGlobal) == 0x000000, "Member 'VoipPartySettingWidget_OnVoipGlobalSet::InbVoipGlobal' has a wrong offset!");

// Function DungeonCrawler.DCLootComponent.ClearLootTarget
// 0x0001 (0x0001 - 0x0000)
struct DCLootComponent_ClearLootTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLootComponent_ClearLootTarget) == 0x000001, "Wrong alignment on DCLootComponent_ClearLootTarget");
static_assert(sizeof(DCLootComponent_ClearLootTarget) == 0x000001, "Wrong size on DCLootComponent_ClearLootTarget");
static_assert(offsetof(DCLootComponent_ClearLootTarget, ReturnValue) == 0x000000, "Member 'DCLootComponent_ClearLootTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCLootComponent.OnRep_TargetActor
// 0x0008 (0x0008 - 0x0000)
struct DCLootComponent_OnRep_TargetActor final
{
public:
	class AActor*                                 OldTargetActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCLootComponent_OnRep_TargetActor) == 0x000008, "Wrong alignment on DCLootComponent_OnRep_TargetActor");
static_assert(sizeof(DCLootComponent_OnRep_TargetActor) == 0x000008, "Wrong size on DCLootComponent_OnRep_TargetActor");
static_assert(offsetof(DCLootComponent_OnRep_TargetActor, OldTargetActor) == 0x000000, "Member 'DCLootComponent_OnRep_TargetActor::OldTargetActor' has a wrong offset!");

// Function DungeonCrawler.DCLootComponent.SetLootTarget
// 0x0010 (0x0010 - 0x0000)
struct DCLootComponent_SetLootTarget final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26CD[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCLootComponent_SetLootTarget) == 0x000008, "Wrong alignment on DCLootComponent_SetLootTarget");
static_assert(sizeof(DCLootComponent_SetLootTarget) == 0x000010, "Wrong size on DCLootComponent_SetLootTarget");
static_assert(offsetof(DCLootComponent_SetLootTarget, Actor) == 0x000000, "Member 'DCLootComponent_SetLootTarget::Actor' has a wrong offset!");
static_assert(offsetof(DCLootComponent_SetLootTarget, ReturnValue) == 0x000008, "Member 'DCLootComponent_SetLootTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCRopeBase.OnRep_RopeMoveData
// 0x0020 (0x0020 - 0x0000)
struct DCRopeBase_OnRep_RopeMoveData final
{
public:
	struct FDCRopeMoveData                        InOldRopeMoveData;                                 // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCRopeBase_OnRep_RopeMoveData) == 0x000008, "Wrong alignment on DCRopeBase_OnRep_RopeMoveData");
static_assert(sizeof(DCRopeBase_OnRep_RopeMoveData) == 0x000020, "Wrong size on DCRopeBase_OnRep_RopeMoveData");
static_assert(offsetof(DCRopeBase_OnRep_RopeMoveData, InOldRopeMoveData) == 0x000000, "Member 'DCRopeBase_OnRep_RopeMoveData::InOldRopeMoveData' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceGroupWidgetBase.OnHasAnySoldItem
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceGroupWidgetBase_OnHasAnySoldItem final
{
public:
	bool                                          bHasAny;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceGroupWidgetBase_OnHasAnySoldItem) == 0x000001, "Wrong alignment on DCMarketplaceGroupWidgetBase_OnHasAnySoldItem");
static_assert(sizeof(DCMarketplaceGroupWidgetBase_OnHasAnySoldItem) == 0x000001, "Wrong size on DCMarketplaceGroupWidgetBase_OnHasAnySoldItem");
static_assert(offsetof(DCMarketplaceGroupWidgetBase_OnHasAnySoldItem, bHasAny) == 0x000000, "Member 'DCMarketplaceGroupWidgetBase_OnHasAnySoldItem::bHasAny' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceGroupWidgetBase.OnTabSelected
// 0x0008 (0x0008 - 0x0000)
struct DCMarketplaceGroupWidgetBase_OnTabSelected final
{
public:
	class FName                                   InTabButtonId;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceGroupWidgetBase_OnTabSelected) == 0x000004, "Wrong alignment on DCMarketplaceGroupWidgetBase_OnTabSelected");
static_assert(sizeof(DCMarketplaceGroupWidgetBase_OnTabSelected) == 0x000008, "Wrong size on DCMarketplaceGroupWidgetBase_OnTabSelected");
static_assert(offsetof(DCMarketplaceGroupWidgetBase_OnTabSelected, InTabButtonId) == 0x000000, "Member 'DCMarketplaceGroupWidgetBase_OnTabSelected::InTabButtonId' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemInfoWidgetBase.GetItemTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCMarketplaceItemInfoWidgetBase_GetItemTooltipWidget final
{
public:
	class UDCItemTooltipWidget*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemInfoWidgetBase_GetItemTooltipWidget) == 0x000008, "Wrong alignment on DCMarketplaceItemInfoWidgetBase_GetItemTooltipWidget");
static_assert(sizeof(DCMarketplaceItemInfoWidgetBase_GetItemTooltipWidget) == 0x000008, "Wrong size on DCMarketplaceItemInfoWidgetBase_GetItemTooltipWidget");
static_assert(offsetof(DCMarketplaceItemInfoWidgetBase_GetItemTooltipWidget, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemInfoWidgetBase_GetItemTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemInfoWidgetBase.GetCount
// 0x0004 (0x0004 - 0x0000)
struct DCMarketplaceItemInfoWidgetBase_GetCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemInfoWidgetBase_GetCount) == 0x000004, "Wrong alignment on DCMarketplaceItemInfoWidgetBase_GetCount");
static_assert(sizeof(DCMarketplaceItemInfoWidgetBase_GetCount) == 0x000004, "Wrong size on DCMarketplaceItemInfoWidgetBase_GetCount");
static_assert(offsetof(DCMarketplaceItemInfoWidgetBase_GetCount, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemInfoWidgetBase_GetCount::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemInfoWidgetBase.IsExpiredItem
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceItemInfoWidgetBase_IsExpiredItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemInfoWidgetBase_IsExpiredItem) == 0x000001, "Wrong alignment on DCMarketplaceItemInfoWidgetBase_IsExpiredItem");
static_assert(sizeof(DCMarketplaceItemInfoWidgetBase_IsExpiredItem) == 0x000001, "Wrong size on DCMarketplaceItemInfoWidgetBase_IsExpiredItem");
static_assert(offsetof(DCMarketplaceItemInfoWidgetBase_IsExpiredItem, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemInfoWidgetBase_IsExpiredItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.OnPriceTextChanged
// 0x0018 (0x0018 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_OnPriceTextChanged final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_OnPriceTextChanged) == 0x000008, "Wrong alignment on DCMarketplaceItemManageWidgetBase_OnPriceTextChanged");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_OnPriceTextChanged) == 0x000018, "Wrong size on DCMarketplaceItemManageWidgetBase_OnPriceTextChanged");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_OnPriceTextChanged, InText) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_OnPriceTextChanged::InText' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.OnTargetItemClickEvent
// 0x0088 (0x0088 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent final
{
public:
	struct FDCItemId                              ItemId;                                            // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPointerEvent                          MouseEvent;                                        // 0x0008(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bIsLocked;                                         // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsItemReadOnly;                                   // 0x0081(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26DF[0x6];                                     // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent) == 0x000008, "Wrong alignment on DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent) == 0x000088, "Wrong size on DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent, ItemId) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent::ItemId' has a wrong offset!");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent, MouseEvent) == 0x000008, "Member 'DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent::MouseEvent' has a wrong offset!");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent, bIsLocked) == 0x000080, "Member 'DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent::bIsLocked' has a wrong offset!");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent, bIsItemReadOnly) == 0x000081, "Member 'DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent::bIsItemReadOnly' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.CannotListingItem
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_CannotListingItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_CannotListingItem) == 0x000001, "Wrong alignment on DCMarketplaceItemManageWidgetBase_CannotListingItem");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_CannotListingItem) == 0x000001, "Wrong size on DCMarketplaceItemManageWidgetBase_CannotListingItem");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_CannotListingItem, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_CannotListingItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetFixedListingFee
// 0x0004 (0x0004 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_GetFixedListingFee final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_GetFixedListingFee) == 0x000004, "Wrong alignment on DCMarketplaceItemManageWidgetBase_GetFixedListingFee");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_GetFixedListingFee) == 0x000004, "Wrong size on DCMarketplaceItemManageWidgetBase_GetFixedListingFee");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_GetFixedListingFee, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_GetFixedListingFee::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetListingExpiredDays
// 0x0004 (0x0004 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_GetListingExpiredDays final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_GetListingExpiredDays) == 0x000004, "Wrong alignment on DCMarketplaceItemManageWidgetBase_GetListingExpiredDays");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_GetListingExpiredDays) == 0x000004, "Wrong size on DCMarketplaceItemManageWidgetBase_GetListingExpiredDays");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_GetListingExpiredDays, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_GetListingExpiredDays::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetListingFee
// 0x0004 (0x0004 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_GetListingFee final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_GetListingFee) == 0x000004, "Wrong alignment on DCMarketplaceItemManageWidgetBase_GetListingFee");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_GetListingFee) == 0x000004, "Wrong size on DCMarketplaceItemManageWidgetBase_GetListingFee");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_GetListingFee, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_GetListingFee::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetListItemState
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_GetListItemState final
{
public:
	EDCMarketplaceMyListState                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_GetListItemState) == 0x000001, "Wrong alignment on DCMarketplaceItemManageWidgetBase_GetListItemState");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_GetListItemState) == 0x000001, "Wrong size on DCMarketplaceItemManageWidgetBase_GetListItemState");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_GetListItemState, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_GetListItemState::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetPriceLimit
// 0x0004 (0x0004 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_GetPriceLimit final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_GetPriceLimit) == 0x000004, "Wrong alignment on DCMarketplaceItemManageWidgetBase_GetPriceLimit");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_GetPriceLimit) == 0x000004, "Wrong size on DCMarketplaceItemManageWidgetBase_GetPriceLimit");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_GetPriceLimit, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_GetPriceLimit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetVariableListingFee
// 0x0004 (0x0004 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_GetVariableListingFee final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_GetVariableListingFee) == 0x000004, "Wrong alignment on DCMarketplaceItemManageWidgetBase_GetVariableListingFee");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_GetVariableListingFee) == 0x000004, "Wrong size on DCMarketplaceItemManageWidgetBase_GetVariableListingFee");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_GetVariableListingFee, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_GetVariableListingFee::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetVariableListingFeeRate
// 0x0004 (0x0004 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_GetVariableListingFeeRate final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_GetVariableListingFeeRate) == 0x000004, "Wrong alignment on DCMarketplaceItemManageWidgetBase_GetVariableListingFeeRate");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_GetVariableListingFeeRate) == 0x000004, "Wrong size on DCMarketplaceItemManageWidgetBase_GetVariableListingFeeRate");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_GetVariableListingFeeRate, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_GetVariableListingFeeRate::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.IsListingPriceSet
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_IsListingPriceSet final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_IsListingPriceSet) == 0x000001, "Wrong alignment on DCMarketplaceItemManageWidgetBase_IsListingPriceSet");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_IsListingPriceSet) == 0x000001, "Wrong size on DCMarketplaceItemManageWidgetBase_IsListingPriceSet");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_IsListingPriceSet, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_IsListingPriceSet::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.OnItemStateChanged
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceItemManageWidgetBase_OnItemStateChanged final
{
public:
	EDCMarketplaceMyListState                     State;                                             // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemManageWidgetBase_OnItemStateChanged) == 0x000001, "Wrong alignment on DCMarketplaceItemManageWidgetBase_OnItemStateChanged");
static_assert(sizeof(DCMarketplaceItemManageWidgetBase_OnItemStateChanged) == 0x000001, "Wrong size on DCMarketplaceItemManageWidgetBase_OnItemStateChanged");
static_assert(offsetof(DCMarketplaceItemManageWidgetBase_OnItemStateChanged, State) == 0x000000, "Member 'DCMarketplaceItemManageWidgetBase_OnItemStateChanged::State' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemWidget.GetItemTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCMarketplaceItemWidget_GetItemTooltipWidget final
{
public:
	class UDCItemTooltipWidget*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemWidget_GetItemTooltipWidget) == 0x000008, "Wrong alignment on DCMarketplaceItemWidget_GetItemTooltipWidget");
static_assert(sizeof(DCMarketplaceItemWidget_GetItemTooltipWidget) == 0x000008, "Wrong size on DCMarketplaceItemWidget_GetItemTooltipWidget");
static_assert(offsetof(DCMarketplaceItemWidget_GetItemTooltipWidget, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemWidget_GetItemTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceItemWidget.IsItemSet
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceItemWidget_IsItemSet final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceItemWidget_IsItemSet) == 0x000001, "Wrong alignment on DCMarketplaceItemWidget_IsItemSet");
static_assert(sizeof(DCMarketplaceItemWidget_IsItemSet) == 0x000001, "Wrong size on DCMarketplaceItemWidget_IsItemSet");
static_assert(offsetof(DCMarketplaceItemWidget_IsItemSet, ReturnValue) == 0x000000, "Member 'DCMarketplaceItemWidget_IsItemSet::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceListEntryWidgetBase.GetRandomAttributeValue
// 0x0018 (0x0018 - 0x0000)
struct DCMarketplaceListEntryWidgetBase_GetRandomAttributeValue final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceListEntryWidgetBase_GetRandomAttributeValue) == 0x000008, "Wrong alignment on DCMarketplaceListEntryWidgetBase_GetRandomAttributeValue");
static_assert(sizeof(DCMarketplaceListEntryWidgetBase_GetRandomAttributeValue) == 0x000018, "Wrong size on DCMarketplaceListEntryWidgetBase_GetRandomAttributeValue");
static_assert(offsetof(DCMarketplaceListEntryWidgetBase_GetRandomAttributeValue, ReturnValue) == 0x000000, "Member 'DCMarketplaceListEntryWidgetBase_GetRandomAttributeValue::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceListEntryWidgetBase.GetStaticAttributeValue
// 0x0018 (0x0018 - 0x0000)
struct DCMarketplaceListEntryWidgetBase_GetStaticAttributeValue final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceListEntryWidgetBase_GetStaticAttributeValue) == 0x000008, "Wrong alignment on DCMarketplaceListEntryWidgetBase_GetStaticAttributeValue");
static_assert(sizeof(DCMarketplaceListEntryWidgetBase_GetStaticAttributeValue) == 0x000018, "Wrong size on DCMarketplaceListEntryWidgetBase_GetStaticAttributeValue");
static_assert(offsetof(DCMarketplaceListEntryWidgetBase_GetStaticAttributeValue, ReturnValue) == 0x000000, "Member 'DCMarketplaceListEntryWidgetBase_GetStaticAttributeValue::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnComboBoxItemSelectionAddition
// 0x0008 (0x0008 - 0x0000)
struct DCMarketplaceListWidgetBase_OnComboBoxItemSelectionAddition final
{
public:
	class UObject*                                SelectedItem;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceListWidgetBase_OnComboBoxItemSelectionAddition) == 0x000008, "Wrong alignment on DCMarketplaceListWidgetBase_OnComboBoxItemSelectionAddition");
static_assert(sizeof(DCMarketplaceListWidgetBase_OnComboBoxItemSelectionAddition) == 0x000008, "Wrong size on DCMarketplaceListWidgetBase_OnComboBoxItemSelectionAddition");
static_assert(offsetof(DCMarketplaceListWidgetBase_OnComboBoxItemSelectionAddition, SelectedItem) == 0x000000, "Member 'DCMarketplaceListWidgetBase_OnComboBoxItemSelectionAddition::SelectedItem' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnComboBoxItemSelectionChanged
// 0x0008 (0x0008 - 0x0000)
struct DCMarketplaceListWidgetBase_OnComboBoxItemSelectionChanged final
{
public:
	class UObject*                                SelectedItem;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceListWidgetBase_OnComboBoxItemSelectionChanged) == 0x000008, "Wrong alignment on DCMarketplaceListWidgetBase_OnComboBoxItemSelectionChanged");
static_assert(sizeof(DCMarketplaceListWidgetBase_OnComboBoxItemSelectionChanged) == 0x000008, "Wrong size on DCMarketplaceListWidgetBase_OnComboBoxItemSelectionChanged");
static_assert(offsetof(DCMarketplaceListWidgetBase_OnComboBoxItemSelectionChanged, SelectedItem) == 0x000000, "Member 'DCMarketplaceListWidgetBase_OnComboBoxItemSelectionChanged::SelectedItem' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnComboBoxItemSelectionCleared
// 0x0008 (0x0008 - 0x0000)
struct DCMarketplaceListWidgetBase_OnComboBoxItemSelectionCleared final
{
public:
	class UObject*                                SelectedItem;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceListWidgetBase_OnComboBoxItemSelectionCleared) == 0x000008, "Wrong alignment on DCMarketplaceListWidgetBase_OnComboBoxItemSelectionCleared");
static_assert(sizeof(DCMarketplaceListWidgetBase_OnComboBoxItemSelectionCleared) == 0x000008, "Wrong size on DCMarketplaceListWidgetBase_OnComboBoxItemSelectionCleared");
static_assert(offsetof(DCMarketplaceListWidgetBase_OnComboBoxItemSelectionCleared, SelectedItem) == 0x000000, "Member 'DCMarketplaceListWidgetBase_OnComboBoxItemSelectionCleared::SelectedItem' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnSortButtonClicked
// 0x000C (0x000C - 0x0000)
struct DCMarketplaceListWidgetBase_OnSortButtonClicked final
{
public:
	class FName                                   Target;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCSortButtonState                            State;                                             // 0x0008(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26E7[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMarketplaceListWidgetBase_OnSortButtonClicked) == 0x000004, "Wrong alignment on DCMarketplaceListWidgetBase_OnSortButtonClicked");
static_assert(sizeof(DCMarketplaceListWidgetBase_OnSortButtonClicked) == 0x00000C, "Wrong size on DCMarketplaceListWidgetBase_OnSortButtonClicked");
static_assert(offsetof(DCMarketplaceListWidgetBase_OnSortButtonClicked, Target) == 0x000000, "Member 'DCMarketplaceListWidgetBase_OnSortButtonClicked::Target' has a wrong offset!");
static_assert(offsetof(DCMarketplaceListWidgetBase_OnSortButtonClicked, State) == 0x000008, "Member 'DCMarketplaceListWidgetBase_OnSortButtonClicked::State' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceListWidgetBase.UpdatePageButton
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceListWidgetBase_UpdatePageButton final
{
public:
	bool                                          bInRecent;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceListWidgetBase_UpdatePageButton) == 0x000001, "Wrong alignment on DCMarketplaceListWidgetBase_UpdatePageButton");
static_assert(sizeof(DCMarketplaceListWidgetBase_UpdatePageButton) == 0x000001, "Wrong size on DCMarketplaceListWidgetBase_UpdatePageButton");
static_assert(offsetof(DCMarketplaceListWidgetBase_UpdatePageButton, bInRecent) == 0x000000, "Member 'DCMarketplaceListWidgetBase_UpdatePageButton::bInRecent' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceListWidgetBase.IsAnyFilterSelected
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceListWidgetBase_IsAnyFilterSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceListWidgetBase_IsAnyFilterSelected) == 0x000001, "Wrong alignment on DCMarketplaceListWidgetBase_IsAnyFilterSelected");
static_assert(sizeof(DCMarketplaceListWidgetBase_IsAnyFilterSelected) == 0x000001, "Wrong size on DCMarketplaceListWidgetBase_IsAnyFilterSelected");
static_assert(offsetof(DCMarketplaceListWidgetBase_IsAnyFilterSelected, ReturnValue) == 0x000000, "Member 'DCMarketplaceListWidgetBase_IsAnyFilterSelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceMyListEntryWidgetBase.GetListState
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceMyListEntryWidgetBase_GetListState final
{
public:
	EDCMarketplaceMyListState                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceMyListEntryWidgetBase_GetListState) == 0x000001, "Wrong alignment on DCMarketplaceMyListEntryWidgetBase_GetListState");
static_assert(sizeof(DCMarketplaceMyListEntryWidgetBase_GetListState) == 0x000001, "Wrong size on DCMarketplaceMyListEntryWidgetBase_GetListState");
static_assert(offsetof(DCMarketplaceMyListEntryWidgetBase_GetListState, ReturnValue) == 0x000000, "Member 'DCMarketplaceMyListEntryWidgetBase_GetListState::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceMyListEntryWidgetBase.IsListing
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplaceMyListEntryWidgetBase_IsListing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceMyListEntryWidgetBase_IsListing) == 0x000001, "Wrong alignment on DCMarketplaceMyListEntryWidgetBase_IsListing");
static_assert(sizeof(DCMarketplaceMyListEntryWidgetBase_IsListing) == 0x000001, "Wrong size on DCMarketplaceMyListEntryWidgetBase_IsListing");
static_assert(offsetof(DCMarketplaceMyListEntryWidgetBase_IsListing, ReturnValue) == 0x000000, "Member 'DCMarketplaceMyListEntryWidgetBase_IsListing::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplaceMyListWidgetBase.OnTargetItemWidgetClicked
// 0x0008 (0x0008 - 0x0000)
struct DCMarketplaceMyListWidgetBase_OnTargetItemWidgetClicked final
{
public:
	struct FDCItemId                              ItemId;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplaceMyListWidgetBase_OnTargetItemWidgetClicked) == 0x000008, "Wrong alignment on DCMarketplaceMyListWidgetBase_OnTargetItemWidgetClicked");
static_assert(sizeof(DCMarketplaceMyListWidgetBase_OnTargetItemWidgetClicked) == 0x000008, "Wrong size on DCMarketplaceMyListWidgetBase_OnTargetItemWidgetClicked");
static_assert(offsetof(DCMarketplaceMyListWidgetBase_OnTargetItemWidgetClicked, ItemId) == 0x000000, "Member 'DCMarketplaceMyListWidgetBase_OnTargetItemWidgetClicked::ItemId' has a wrong offset!");

// Function DungeonCrawler.DCMarketplacePaymentTransferWidgetBase.GetPirce
// 0x0004 (0x0004 - 0x0000)
struct DCMarketplacePaymentTransferWidgetBase_GetPirce final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplacePaymentTransferWidgetBase_GetPirce) == 0x000004, "Wrong alignment on DCMarketplacePaymentTransferWidgetBase_GetPirce");
static_assert(sizeof(DCMarketplacePaymentTransferWidgetBase_GetPirce) == 0x000004, "Wrong size on DCMarketplacePaymentTransferWidgetBase_GetPirce");
static_assert(offsetof(DCMarketplacePaymentTransferWidgetBase_GetPirce, ReturnValue) == 0x000000, "Member 'DCMarketplacePaymentTransferWidgetBase_GetPirce::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplacePaymentTransferWidgetBase.IsDestoryed
// 0x0001 (0x0001 - 0x0000)
struct DCMarketplacePaymentTransferWidgetBase_IsDestoryed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplacePaymentTransferWidgetBase_IsDestoryed) == 0x000001, "Wrong alignment on DCMarketplacePaymentTransferWidgetBase_IsDestoryed");
static_assert(sizeof(DCMarketplacePaymentTransferWidgetBase_IsDestoryed) == 0x000001, "Wrong size on DCMarketplacePaymentTransferWidgetBase_IsDestoryed");
static_assert(offsetof(DCMarketplacePaymentTransferWidgetBase_IsDestoryed, ReturnValue) == 0x000000, "Member 'DCMarketplacePaymentTransferWidgetBase_IsDestoryed::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMarketplacePurchaseGroupWidgetBase.GetCounterTotalPayment
// 0x0004 (0x0004 - 0x0000)
struct DCMarketplacePurchaseGroupWidgetBase_GetCounterTotalPayment final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMarketplacePurchaseGroupWidgetBase_GetCounterTotalPayment) == 0x000004, "Wrong alignment on DCMarketplacePurchaseGroupWidgetBase_GetCounterTotalPayment");
static_assert(sizeof(DCMarketplacePurchaseGroupWidgetBase_GetCounterTotalPayment) == 0x000004, "Wrong size on DCMarketplacePurchaseGroupWidgetBase_GetCounterTotalPayment");
static_assert(offsetof(DCMarketplacePurchaseGroupWidgetBase_GetCounterTotalPayment, ReturnValue) == 0x000000, "Member 'DCMarketplacePurchaseGroupWidgetBase_GetCounterTotalPayment::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectButtonWidget.OnbMatching
// 0x0002 (0x0002 - 0x0000)
struct DungeonSelectButtonWidget_OnbMatching final
{
public:
	bool                                          NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectButtonWidget_OnbMatching) == 0x000001, "Wrong alignment on DungeonSelectButtonWidget_OnbMatching");
static_assert(sizeof(DungeonSelectButtonWidget_OnbMatching) == 0x000002, "Wrong size on DungeonSelectButtonWidget_OnbMatching");
static_assert(offsetof(DungeonSelectButtonWidget_OnbMatching, NewValue) == 0x000000, "Member 'DungeonSelectButtonWidget_OnbMatching::NewValue' has a wrong offset!");
static_assert(offsetof(DungeonSelectButtonWidget_OnbMatching, OldValue) == 0x000001, "Member 'DungeonSelectButtonWidget_OnbMatching::OldValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectButtonWidget.OnDungeonRotationItemInfo
// 0x0018 (0x0018 - 0x0000)
struct DungeonSelectButtonWidget_OnDungeonRotationItemInfo final
{
public:
	struct FDungeonRotationItemInfo               NewValue;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDungeonRotationItemInfo               OldValue;                                          // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectButtonWidget_OnDungeonRotationItemInfo) == 0x000004, "Wrong alignment on DungeonSelectButtonWidget_OnDungeonRotationItemInfo");
static_assert(sizeof(DungeonSelectButtonWidget_OnDungeonRotationItemInfo) == 0x000018, "Wrong size on DungeonSelectButtonWidget_OnDungeonRotationItemInfo");
static_assert(offsetof(DungeonSelectButtonWidget_OnDungeonRotationItemInfo, NewValue) == 0x000000, "Member 'DungeonSelectButtonWidget_OnDungeonRotationItemInfo::NewValue' has a wrong offset!");
static_assert(offsetof(DungeonSelectButtonWidget_OnDungeonRotationItemInfo, OldValue) == 0x00000C, "Member 'DungeonSelectButtonWidget_OnDungeonRotationItemInfo::OldValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectButtonWidget.OnDungeonRotationTimerData
// 0x0018 (0x0018 - 0x0000)
struct DungeonSelectButtonWidget_OnDungeonRotationTimerData final
{
public:
	struct FDungeonRotationTimerData              NewValue;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDungeonRotationTimerData              OldValue;                                          // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectButtonWidget_OnDungeonRotationTimerData) == 0x000004, "Wrong alignment on DungeonSelectButtonWidget_OnDungeonRotationTimerData");
static_assert(sizeof(DungeonSelectButtonWidget_OnDungeonRotationTimerData) == 0x000018, "Wrong size on DungeonSelectButtonWidget_OnDungeonRotationTimerData");
static_assert(offsetof(DungeonSelectButtonWidget_OnDungeonRotationTimerData, NewValue) == 0x000000, "Member 'DungeonSelectButtonWidget_OnDungeonRotationTimerData::NewValue' has a wrong offset!");
static_assert(offsetof(DungeonSelectButtonWidget_OnDungeonRotationTimerData, OldValue) == 0x00000C, "Member 'DungeonSelectButtonWidget_OnDungeonRotationTimerData::OldValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectButtonWidget.OnGameType
// 0x0002 (0x0002 - 0x0000)
struct DungeonSelectButtonWidget_OnGameType final
{
public:
	EGameType                                     NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectButtonWidget_OnGameType) == 0x000001, "Wrong alignment on DungeonSelectButtonWidget_OnGameType");
static_assert(sizeof(DungeonSelectButtonWidget_OnGameType) == 0x000002, "Wrong size on DungeonSelectButtonWidget_OnGameType");
static_assert(offsetof(DungeonSelectButtonWidget_OnGameType, NewValue) == 0x000000, "Member 'DungeonSelectButtonWidget_OnGameType::NewValue' has a wrong offset!");
static_assert(offsetof(DungeonSelectButtonWidget_OnGameType, OldValue) == 0x000001, "Member 'DungeonSelectButtonWidget_OnGameType::OldValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectButtonWidget.OnGameUserSettingControlsChanged
// 0x0088 (0x0088 - 0x0000)
struct DungeonSelectButtonWidget_OnGameUserSettingControlsChanged final
{
public:
	struct FGameUserSettingControls               InGameUserSettingControls;                         // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameUserSettingControls               InOldGameUserSettingControls;                      // 0x0040(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInForce;                                          // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F1[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DungeonSelectButtonWidget_OnGameUserSettingControlsChanged) == 0x000008, "Wrong alignment on DungeonSelectButtonWidget_OnGameUserSettingControlsChanged");
static_assert(sizeof(DungeonSelectButtonWidget_OnGameUserSettingControlsChanged) == 0x000088, "Wrong size on DungeonSelectButtonWidget_OnGameUserSettingControlsChanged");
static_assert(offsetof(DungeonSelectButtonWidget_OnGameUserSettingControlsChanged, InGameUserSettingControls) == 0x000000, "Member 'DungeonSelectButtonWidget_OnGameUserSettingControlsChanged::InGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(DungeonSelectButtonWidget_OnGameUserSettingControlsChanged, InOldGameUserSettingControls) == 0x000040, "Member 'DungeonSelectButtonWidget_OnGameUserSettingControlsChanged::InOldGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(DungeonSelectButtonWidget_OnGameUserSettingControlsChanged, bInForce) == 0x000080, "Member 'DungeonSelectButtonWidget_OnGameUserSettingControlsChanged::bInForce' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectButtonWidget.OnMatchMode
// 0x0002 (0x0002 - 0x0000)
struct DungeonSelectButtonWidget_OnMatchMode final
{
public:
	EMatchMode                                    NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMatchMode                                    OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectButtonWidget_OnMatchMode) == 0x000001, "Wrong alignment on DungeonSelectButtonWidget_OnMatchMode");
static_assert(sizeof(DungeonSelectButtonWidget_OnMatchMode) == 0x000002, "Wrong size on DungeonSelectButtonWidget_OnMatchMode");
static_assert(offsetof(DungeonSelectButtonWidget_OnMatchMode, NewValue) == 0x000000, "Member 'DungeonSelectButtonWidget_OnMatchMode::NewValue' has a wrong offset!");
static_assert(offsetof(DungeonSelectButtonWidget_OnMatchMode, OldValue) == 0x000001, "Member 'DungeonSelectButtonWidget_OnMatchMode::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCMaterialInterface.RemoveOverrideMaterial
// 0x0001 (0x0001 - 0x0000)
struct DCMaterialInterface_RemoveOverrideMaterial final
{
public:
	EDCMaterialType                               InMaterialType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMaterialInterface_RemoveOverrideMaterial) == 0x000001, "Wrong alignment on DCMaterialInterface_RemoveOverrideMaterial");
static_assert(sizeof(DCMaterialInterface_RemoveOverrideMaterial) == 0x000001, "Wrong size on DCMaterialInterface_RemoveOverrideMaterial");
static_assert(offsetof(DCMaterialInterface_RemoveOverrideMaterial, InMaterialType) == 0x000000, "Member 'DCMaterialInterface_RemoveOverrideMaterial::InMaterialType' has a wrong offset!");

// Function DungeonCrawler.DCMaterialInterface.ResetBaseMaterial
// 0x0008 (0x0008 - 0x0000)
struct DCMaterialInterface_ResetBaseMaterial final
{
public:
	class UMeshComponent*                         InMeshComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMaterialInterface_ResetBaseMaterial) == 0x000008, "Wrong alignment on DCMaterialInterface_ResetBaseMaterial");
static_assert(sizeof(DCMaterialInterface_ResetBaseMaterial) == 0x000008, "Wrong size on DCMaterialInterface_ResetBaseMaterial");
static_assert(offsetof(DCMaterialInterface_ResetBaseMaterial, InMeshComponent) == 0x000000, "Member 'DCMaterialInterface_ResetBaseMaterial::InMeshComponent' has a wrong offset!");

// Function DungeonCrawler.DCMaterialInterface.SetBaseMaterial
// 0x0018 (0x0018 - 0x0000)
struct DCMaterialInterface_SetBaseMaterial final
{
public:
	class UMeshComponent*                         InMeshComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InElementIndex;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F4[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     InMaterialInterface;                               // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMaterialInterface_SetBaseMaterial) == 0x000008, "Wrong alignment on DCMaterialInterface_SetBaseMaterial");
static_assert(sizeof(DCMaterialInterface_SetBaseMaterial) == 0x000018, "Wrong size on DCMaterialInterface_SetBaseMaterial");
static_assert(offsetof(DCMaterialInterface_SetBaseMaterial, InMeshComponent) == 0x000000, "Member 'DCMaterialInterface_SetBaseMaterial::InMeshComponent' has a wrong offset!");
static_assert(offsetof(DCMaterialInterface_SetBaseMaterial, InElementIndex) == 0x000008, "Member 'DCMaterialInterface_SetBaseMaterial::InElementIndex' has a wrong offset!");
static_assert(offsetof(DCMaterialInterface_SetBaseMaterial, InMaterialInterface) == 0x000010, "Member 'DCMaterialInterface_SetBaseMaterial::InMaterialInterface' has a wrong offset!");

// Function DungeonCrawler.DCMaterialInterface.SetBaseMaterialBySlotName
// 0x0018 (0x0018 - 0x0000)
struct DCMaterialInterface_SetBaseMaterialBySlotName final
{
public:
	class UMeshComponent*                         InMeshComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialSlotName;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     InMaterialInterface;                               // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMaterialInterface_SetBaseMaterialBySlotName) == 0x000008, "Wrong alignment on DCMaterialInterface_SetBaseMaterialBySlotName");
static_assert(sizeof(DCMaterialInterface_SetBaseMaterialBySlotName) == 0x000018, "Wrong size on DCMaterialInterface_SetBaseMaterialBySlotName");
static_assert(offsetof(DCMaterialInterface_SetBaseMaterialBySlotName, InMeshComponent) == 0x000000, "Member 'DCMaterialInterface_SetBaseMaterialBySlotName::InMeshComponent' has a wrong offset!");
static_assert(offsetof(DCMaterialInterface_SetBaseMaterialBySlotName, MaterialSlotName) == 0x000008, "Member 'DCMaterialInterface_SetBaseMaterialBySlotName::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(DCMaterialInterface_SetBaseMaterialBySlotName, InMaterialInterface) == 0x000010, "Member 'DCMaterialInterface_SetBaseMaterialBySlotName::InMaterialInterface' has a wrong offset!");

// Function DungeonCrawler.DCMaterialInterface.SetOverrideMaterial
// 0x0018 (0x0018 - 0x0000)
struct DCMaterialInterface_SetOverrideMaterial final
{
public:
	EDCMaterialType                               InMaterialType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F5[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     InMaterialInterface;                               // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSetRenderingPriority;                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F6[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMaterialInterface_SetOverrideMaterial) == 0x000008, "Wrong alignment on DCMaterialInterface_SetOverrideMaterial");
static_assert(sizeof(DCMaterialInterface_SetOverrideMaterial) == 0x000018, "Wrong size on DCMaterialInterface_SetOverrideMaterial");
static_assert(offsetof(DCMaterialInterface_SetOverrideMaterial, InMaterialType) == 0x000000, "Member 'DCMaterialInterface_SetOverrideMaterial::InMaterialType' has a wrong offset!");
static_assert(offsetof(DCMaterialInterface_SetOverrideMaterial, InMaterialInterface) == 0x000008, "Member 'DCMaterialInterface_SetOverrideMaterial::InMaterialInterface' has a wrong offset!");
static_assert(offsetof(DCMaterialInterface_SetOverrideMaterial, bInSetRenderingPriority) == 0x000010, "Member 'DCMaterialInterface_SetOverrideMaterial::bInSetRenderingPriority' has a wrong offset!");

// Function DungeonCrawler.DCMaterialInterface.SetOverrideMaterialValue
// 0x0010 (0x0010 - 0x0000)
struct DCMaterialInterface_SetOverrideMaterialValue final
{
public:
	EDCMaterialType                               InMaterialType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26F7[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InKey;                                             // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMaterialInterface_SetOverrideMaterialValue) == 0x000004, "Wrong alignment on DCMaterialInterface_SetOverrideMaterialValue");
static_assert(sizeof(DCMaterialInterface_SetOverrideMaterialValue) == 0x000010, "Wrong size on DCMaterialInterface_SetOverrideMaterialValue");
static_assert(offsetof(DCMaterialInterface_SetOverrideMaterialValue, InMaterialType) == 0x000000, "Member 'DCMaterialInterface_SetOverrideMaterialValue::InMaterialType' has a wrong offset!");
static_assert(offsetof(DCMaterialInterface_SetOverrideMaterialValue, InKey) == 0x000004, "Member 'DCMaterialInterface_SetOverrideMaterialValue::InKey' has a wrong offset!");
static_assert(offsetof(DCMaterialInterface_SetOverrideMaterialValue, InValue) == 0x00000C, "Member 'DCMaterialInterface_SetOverrideMaterialValue::InValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayUserInfoWidget.OnLocationUpdate
// 0x0008 (0x0008 - 0x0000)
struct DCPlayUserInfoWidget_OnLocationUpdate final
{
public:
	bool                                          bIsReady;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26FE[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MetaLocationIndex;                                 // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayUserInfoWidget_OnLocationUpdate) == 0x000004, "Wrong alignment on DCPlayUserInfoWidget_OnLocationUpdate");
static_assert(sizeof(DCPlayUserInfoWidget_OnLocationUpdate) == 0x000008, "Wrong size on DCPlayUserInfoWidget_OnLocationUpdate");
static_assert(offsetof(DCPlayUserInfoWidget_OnLocationUpdate, bIsReady) == 0x000000, "Member 'DCPlayUserInfoWidget_OnLocationUpdate::bIsReady' has a wrong offset!");
static_assert(offsetof(DCPlayUserInfoWidget_OnLocationUpdate, MetaLocationIndex) == 0x000004, "Member 'DCPlayUserInfoWidget_OnLocationUpdate::MetaLocationIndex' has a wrong offset!");

// Function DungeonCrawler.DCPlayUserInfoWidget.OnPlayPartyUserState
// 0x0001 (0x0001 - 0x0000)
struct DCPlayUserInfoWidget_OnPlayPartyUserState final
{
public:
	EWidgetPlayUserPartyState                     InPartyMemberState;                                // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayUserInfoWidget_OnPlayPartyUserState) == 0x000001, "Wrong alignment on DCPlayUserInfoWidget_OnPlayPartyUserState");
static_assert(sizeof(DCPlayUserInfoWidget_OnPlayPartyUserState) == 0x000001, "Wrong size on DCPlayUserInfoWidget_OnPlayPartyUserState");
static_assert(offsetof(DCPlayUserInfoWidget_OnPlayPartyUserState, InPartyMemberState) == 0x000000, "Member 'DCPlayUserInfoWidget_OnPlayPartyUserState::InPartyMemberState' has a wrong offset!");

// Function DungeonCrawler.DCPlayUserInfoWidget.OnPlayUserInfo
// 0x00C0 (0x00C0 - 0x0000)
struct DCPlayUserInfoWidget_OnPlayUserInfo final
{
public:
	struct FPlayPartyUserInfo                     InPlaypartyUserInfo;                               // 0x0000(0x00C0)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayUserInfoWidget_OnPlayUserInfo) == 0x000008, "Wrong alignment on DCPlayUserInfoWidget_OnPlayUserInfo");
static_assert(sizeof(DCPlayUserInfoWidget_OnPlayUserInfo) == 0x0000C0, "Wrong size on DCPlayUserInfoWidget_OnPlayUserInfo");
static_assert(offsetof(DCPlayUserInfoWidget_OnPlayUserInfo, InPlaypartyUserInfo) == 0x000000, "Member 'DCPlayUserInfoWidget_OnPlayUserInfo::InPlaypartyUserInfo' has a wrong offset!");

// Function DungeonCrawler.DCPlayUserInfoWidget.OnUpdateLobbyCharacterInfo
// 0x00C8 (0x00C8 - 0x0000)
struct DCPlayUserInfoWidget_OnUpdateLobbyCharacterInfo final
{
public:
	struct FLobbyCharacterInfo                    InLobbyCharacterInfo;                              // 0x0000(0x00C8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayUserInfoWidget_OnUpdateLobbyCharacterInfo) == 0x000008, "Wrong alignment on DCPlayUserInfoWidget_OnUpdateLobbyCharacterInfo");
static_assert(sizeof(DCPlayUserInfoWidget_OnUpdateLobbyCharacterInfo) == 0x0000C8, "Wrong size on DCPlayUserInfoWidget_OnUpdateLobbyCharacterInfo");
static_assert(offsetof(DCPlayUserInfoWidget_OnUpdateLobbyCharacterInfo, InLobbyCharacterInfo) == 0x000000, "Member 'DCPlayUserInfoWidget_OnUpdateLobbyCharacterInfo::InLobbyCharacterInfo' has a wrong offset!");

// Function DungeonCrawler.DCMerchantDealTablePurchaseWidget.IsRequiredItemsFilled
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantDealTablePurchaseWidget_IsRequiredItemsFilled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantDealTablePurchaseWidget_IsRequiredItemsFilled) == 0x000001, "Wrong alignment on DCMerchantDealTablePurchaseWidget_IsRequiredItemsFilled");
static_assert(sizeof(DCMerchantDealTablePurchaseWidget_IsRequiredItemsFilled) == 0x000001, "Wrong size on DCMerchantDealTablePurchaseWidget_IsRequiredItemsFilled");
static_assert(offsetof(DCMerchantDealTablePurchaseWidget_IsRequiredItemsFilled, ReturnValue) == 0x000000, "Member 'DCMerchantDealTablePurchaseWidget_IsRequiredItemsFilled::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantDealTablePurchaseWidget.IsTargetItemSet
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantDealTablePurchaseWidget_IsTargetItemSet final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantDealTablePurchaseWidget_IsTargetItemSet) == 0x000001, "Wrong alignment on DCMerchantDealTablePurchaseWidget_IsTargetItemSet");
static_assert(sizeof(DCMerchantDealTablePurchaseWidget_IsTargetItemSet) == 0x000001, "Wrong size on DCMerchantDealTablePurchaseWidget_IsTargetItemSet");
static_assert(offsetof(DCMerchantDealTablePurchaseWidget_IsTargetItemSet, ReturnValue) == 0x000000, "Member 'DCMerchantDealTablePurchaseWidget_IsTargetItemSet::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantDealTableQuestWidget.GetQuestState
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantDealTableQuestWidget_GetQuestState final
{
public:
	EDCQuestState                                 ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantDealTableQuestWidget_GetQuestState) == 0x000001, "Wrong alignment on DCMerchantDealTableQuestWidget_GetQuestState");
static_assert(sizeof(DCMerchantDealTableQuestWidget_GetQuestState) == 0x000001, "Wrong size on DCMerchantDealTableQuestWidget_GetQuestState");
static_assert(offsetof(DCMerchantDealTableQuestWidget_GetQuestState, ReturnValue) == 0x000000, "Member 'DCMerchantDealTableQuestWidget_GetQuestState::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantDealTableSellWidget.GetPrice
// 0x0004 (0x0004 - 0x0000)
struct DCMerchantDealTableSellWidget_GetPrice final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantDealTableSellWidget_GetPrice) == 0x000004, "Wrong alignment on DCMerchantDealTableSellWidget_GetPrice");
static_assert(sizeof(DCMerchantDealTableSellWidget_GetPrice) == 0x000004, "Wrong size on DCMerchantDealTableSellWidget_GetPrice");
static_assert(offsetof(DCMerchantDealTableSellWidget_GetPrice, ReturnValue) == 0x000000, "Member 'DCMerchantDealTableSellWidget_GetPrice::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantDealTableSellWidget.IsSellEnabled
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantDealTableSellWidget_IsSellEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantDealTableSellWidget_IsSellEnabled) == 0x000001, "Wrong alignment on DCMerchantDealTableSellWidget_IsSellEnabled");
static_assert(sizeof(DCMerchantDealTableSellWidget_IsSellEnabled) == 0x000001, "Wrong size on DCMerchantDealTableSellWidget_IsSellEnabled");
static_assert(offsetof(DCMerchantDealTableSellWidget_IsSellEnabled, ReturnValue) == 0x000000, "Member 'DCMerchantDealTableSellWidget_IsSellEnabled::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantItemWidget.GetMerchantItemTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCMerchantItemWidget_GetMerchantItemTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantItemWidget_GetMerchantItemTooltipWidget) == 0x000008, "Wrong alignment on DCMerchantItemWidget_GetMerchantItemTooltipWidget");
static_assert(sizeof(DCMerchantItemWidget_GetMerchantItemTooltipWidget) == 0x000008, "Wrong size on DCMerchantItemWidget_GetMerchantItemTooltipWidget");
static_assert(offsetof(DCMerchantItemWidget_GetMerchantItemTooltipWidget, ReturnValue) == 0x000000, "Member 'DCMerchantItemWidget_GetMerchantItemTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantListEntryWidget.IsOnNewAlram
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantListEntryWidget_IsOnNewAlram final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantListEntryWidget_IsOnNewAlram) == 0x000001, "Wrong alignment on DCMerchantListEntryWidget_IsOnNewAlram");
static_assert(sizeof(DCMerchantListEntryWidget_IsOnNewAlram) == 0x000001, "Wrong size on DCMerchantListEntryWidget_IsOnNewAlram");
static_assert(offsetof(DCMerchantListEntryWidget_IsOnNewAlram, ReturnValue) == 0x000000, "Member 'DCMerchantListEntryWidget_IsOnNewAlram::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantListEntryWidget.IsOnSuccesAlram
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantListEntryWidget_IsOnSuccesAlram final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantListEntryWidget_IsOnSuccesAlram) == 0x000001, "Wrong alignment on DCMerchantListEntryWidget_IsOnSuccesAlram");
static_assert(sizeof(DCMerchantListEntryWidget_IsOnSuccesAlram) == 0x000001, "Wrong size on DCMerchantListEntryWidget_IsOnSuccesAlram");
static_assert(offsetof(DCMerchantListEntryWidget_IsOnSuccesAlram, ReturnValue) == 0x000000, "Member 'DCMerchantListEntryWidget_IsOnSuccesAlram::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantMindwipeWidget.GetCanMindwipe
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantMindwipeWidget_GetCanMindwipe final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantMindwipeWidget_GetCanMindwipe) == 0x000001, "Wrong alignment on DCMerchantMindwipeWidget_GetCanMindwipe");
static_assert(sizeof(DCMerchantMindwipeWidget_GetCanMindwipe) == 0x000001, "Wrong size on DCMerchantMindwipeWidget_GetCanMindwipe");
static_assert(offsetof(DCMerchantMindwipeWidget_GetCanMindwipe, ReturnValue) == 0x000000, "Member 'DCMerchantMindwipeWidget_GetCanMindwipe::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantPageWidget.OnCategoryTabSelected
// 0x0008 (0x0008 - 0x0000)
struct DCMerchantPageWidget_OnCategoryTabSelected final
{
public:
	class FName                                   TabId;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantPageWidget_OnCategoryTabSelected) == 0x000004, "Wrong alignment on DCMerchantPageWidget_OnCategoryTabSelected");
static_assert(sizeof(DCMerchantPageWidget_OnCategoryTabSelected) == 0x000008, "Wrong size on DCMerchantPageWidget_OnCategoryTabSelected");
static_assert(offsetof(DCMerchantPageWidget_OnCategoryTabSelected, TabId) == 0x000000, "Member 'DCMerchantPageWidget_OnCategoryTabSelected::TabId' has a wrong offset!");

// Function DungeonCrawler.DCMerchantPageWidget.OnComboBoxItemSelectionChanged
// 0x0008 (0x0008 - 0x0000)
struct DCMerchantPageWidget_OnComboBoxItemSelectionChanged final
{
public:
	class UObject*                                SelectedItem;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantPageWidget_OnComboBoxItemSelectionChanged) == 0x000008, "Wrong alignment on DCMerchantPageWidget_OnComboBoxItemSelectionChanged");
static_assert(sizeof(DCMerchantPageWidget_OnComboBoxItemSelectionChanged) == 0x000008, "Wrong size on DCMerchantPageWidget_OnComboBoxItemSelectionChanged");
static_assert(offsetof(DCMerchantPageWidget_OnComboBoxItemSelectionChanged, SelectedItem) == 0x000000, "Member 'DCMerchantPageWidget_OnComboBoxItemSelectionChanged::SelectedItem' has a wrong offset!");

// Function DungeonCrawler.DCMerchantPageWidget.OnComboBoxItemSelectionCleared
// 0x0008 (0x0008 - 0x0000)
struct DCMerchantPageWidget_OnComboBoxItemSelectionCleared final
{
public:
	class UObject*                                SelectedItem;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantPageWidget_OnComboBoxItemSelectionCleared) == 0x000008, "Wrong alignment on DCMerchantPageWidget_OnComboBoxItemSelectionCleared");
static_assert(sizeof(DCMerchantPageWidget_OnComboBoxItemSelectionCleared) == 0x000008, "Wrong size on DCMerchantPageWidget_OnComboBoxItemSelectionCleared");
static_assert(offsetof(DCMerchantPageWidget_OnComboBoxItemSelectionCleared, SelectedItem) == 0x000000, "Member 'DCMerchantPageWidget_OnComboBoxItemSelectionCleared::SelectedItem' has a wrong offset!");

// Function DungeonCrawler.DCMerchantPageWidget.OnServiceTabSelected
// 0x0008 (0x0008 - 0x0000)
struct DCMerchantPageWidget_OnServiceTabSelected final
{
public:
	class FName                                   TabId;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantPageWidget_OnServiceTabSelected) == 0x000004, "Wrong alignment on DCMerchantPageWidget_OnServiceTabSelected");
static_assert(sizeof(DCMerchantPageWidget_OnServiceTabSelected) == 0x000008, "Wrong size on DCMerchantPageWidget_OnServiceTabSelected");
static_assert(offsetof(DCMerchantPageWidget_OnServiceTabSelected, TabId) == 0x000000, "Member 'DCMerchantPageWidget_OnServiceTabSelected::TabId' has a wrong offset!");

// Function DungeonCrawler.DCMerchantPageWidget.OnServiceTypeChanged
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantPageWidget_OnServiceTypeChanged final
{
public:
	EDCMerchantServiceType                        ServiceType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantPageWidget_OnServiceTypeChanged) == 0x000001, "Wrong alignment on DCMerchantPageWidget_OnServiceTypeChanged");
static_assert(sizeof(DCMerchantPageWidget_OnServiceTypeChanged) == 0x000001, "Wrong size on DCMerchantPageWidget_OnServiceTypeChanged");
static_assert(offsetof(DCMerchantPageWidget_OnServiceTypeChanged, ServiceType) == 0x000000, "Member 'DCMerchantPageWidget_OnServiceTypeChanged::ServiceType' has a wrong offset!");

// Function DungeonCrawler.DCMerchantQuickPrepareWidget.HasAnyTargetItem
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantQuickPrepareWidget_HasAnyTargetItem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantQuickPrepareWidget_HasAnyTargetItem) == 0x000001, "Wrong alignment on DCMerchantQuickPrepareWidget_HasAnyTargetItem");
static_assert(sizeof(DCMerchantQuickPrepareWidget_HasAnyTargetItem) == 0x000001, "Wrong size on DCMerchantQuickPrepareWidget_HasAnyTargetItem");
static_assert(offsetof(DCMerchantQuickPrepareWidget_HasAnyTargetItem, ReturnValue) == 0x000000, "Member 'DCMerchantQuickPrepareWidget_HasAnyTargetItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantRequiredEntryWidget.GetCurrentStack
// 0x0004 (0x0004 - 0x0000)
struct DCMerchantRequiredEntryWidget_GetCurrentStack final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantRequiredEntryWidget_GetCurrentStack) == 0x000004, "Wrong alignment on DCMerchantRequiredEntryWidget_GetCurrentStack");
static_assert(sizeof(DCMerchantRequiredEntryWidget_GetCurrentStack) == 0x000004, "Wrong size on DCMerchantRequiredEntryWidget_GetCurrentStack");
static_assert(offsetof(DCMerchantRequiredEntryWidget_GetCurrentStack, ReturnValue) == 0x000000, "Member 'DCMerchantRequiredEntryWidget_GetCurrentStack::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantRequiredEntryWidget.GetMaxStack
// 0x0004 (0x0004 - 0x0000)
struct DCMerchantRequiredEntryWidget_GetMaxStack final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantRequiredEntryWidget_GetMaxStack) == 0x000004, "Wrong alignment on DCMerchantRequiredEntryWidget_GetMaxStack");
static_assert(sizeof(DCMerchantRequiredEntryWidget_GetMaxStack) == 0x000004, "Wrong size on DCMerchantRequiredEntryWidget_GetMaxStack");
static_assert(offsetof(DCMerchantRequiredEntryWidget_GetMaxStack, ReturnValue) == 0x000000, "Member 'DCMerchantRequiredEntryWidget_GetMaxStack::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantRequiredEntryWidget.GetRequireData
// 0x0008 (0x0008 - 0x0000)
struct DCMerchantRequiredEntryWidget_GetRequireData final
{
public:
	class UObject*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantRequiredEntryWidget_GetRequireData) == 0x000008, "Wrong alignment on DCMerchantRequiredEntryWidget_GetRequireData");
static_assert(sizeof(DCMerchantRequiredEntryWidget_GetRequireData) == 0x000008, "Wrong size on DCMerchantRequiredEntryWidget_GetRequireData");
static_assert(offsetof(DCMerchantRequiredEntryWidget_GetRequireData, ReturnValue) == 0x000000, "Member 'DCMerchantRequiredEntryWidget_GetRequireData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantRequiredEntryWidget.IsEmpty
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantRequiredEntryWidget_IsEmpty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantRequiredEntryWidget_IsEmpty) == 0x000001, "Wrong alignment on DCMerchantRequiredEntryWidget_IsEmpty");
static_assert(sizeof(DCMerchantRequiredEntryWidget_IsEmpty) == 0x000001, "Wrong size on DCMerchantRequiredEntryWidget_IsEmpty");
static_assert(offsetof(DCMerchantRequiredEntryWidget_IsEmpty, ReturnValue) == 0x000000, "Member 'DCMerchantRequiredEntryWidget_IsEmpty::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMerchantRequiredEntryWidget.IsFilled
// 0x0001 (0x0001 - 0x0000)
struct DCMerchantRequiredEntryWidget_IsFilled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantRequiredEntryWidget_IsFilled) == 0x000001, "Wrong alignment on DCMerchantRequiredEntryWidget_IsFilled");
static_assert(sizeof(DCMerchantRequiredEntryWidget_IsFilled) == 0x000001, "Wrong size on DCMerchantRequiredEntryWidget_IsFilled");
static_assert(offsetof(DCMerchantRequiredEntryWidget_IsFilled, ReturnValue) == 0x000000, "Member 'DCMerchantRequiredEntryWidget_IsFilled::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCReligionOfferingWidget.ChangeActivateOfferState
// 0x0001 (0x0001 - 0x0000)
struct DCReligionOfferingWidget_ChangeActivateOfferState final
{
public:
	bool                                          bIsActiavte;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionOfferingWidget_ChangeActivateOfferState) == 0x000001, "Wrong alignment on DCReligionOfferingWidget_ChangeActivateOfferState");
static_assert(sizeof(DCReligionOfferingWidget_ChangeActivateOfferState) == 0x000001, "Wrong size on DCReligionOfferingWidget_ChangeActivateOfferState");
static_assert(offsetof(DCReligionOfferingWidget_ChangeActivateOfferState, bIsActiavte) == 0x000000, "Member 'DCReligionOfferingWidget_ChangeActivateOfferState::bIsActiavte' has a wrong offset!");

// Function DungeonCrawler.DCMerchantShortcutPopupBase.OnSetMerchantShortcutPopupData
// 0x0008 (0x0008 - 0x0000)
struct DCMerchantShortcutPopupBase_OnSetMerchantShortcutPopupData final
{
public:
	class UDCMerchantShortcutPopupData*           PopupData;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMerchantShortcutPopupBase_OnSetMerchantShortcutPopupData) == 0x000008, "Wrong alignment on DCMerchantShortcutPopupBase_OnSetMerchantShortcutPopupData");
static_assert(sizeof(DCMerchantShortcutPopupBase_OnSetMerchantShortcutPopupData) == 0x000008, "Wrong size on DCMerchantShortcutPopupBase_OnSetMerchantShortcutPopupData");
static_assert(offsetof(DCMerchantShortcutPopupBase_OnSetMerchantShortcutPopupData, PopupData) == 0x000000, "Member 'DCMerchantShortcutPopupBase_OnSetMerchantShortcutPopupData::PopupData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.AckPlayerCharacterLocation_Client
// 0x0040 (0x0040 - 0x0000)
struct DCPlayerController_AckPlayerCharacterLocation_Client final
{
public:
	struct FDCAccountId                           InAccountId;                                       // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPlayerPawnLocation;                              // 0x0010(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InPlayerPawnRotation;                              // 0x0028(0x0018)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_AckPlayerCharacterLocation_Client) == 0x000008, "Wrong alignment on DCPlayerController_AckPlayerCharacterLocation_Client");
static_assert(sizeof(DCPlayerController_AckPlayerCharacterLocation_Client) == 0x000040, "Wrong size on DCPlayerController_AckPlayerCharacterLocation_Client");
static_assert(offsetof(DCPlayerController_AckPlayerCharacterLocation_Client, InAccountId) == 0x000000, "Member 'DCPlayerController_AckPlayerCharacterLocation_Client::InAccountId' has a wrong offset!");
static_assert(offsetof(DCPlayerController_AckPlayerCharacterLocation_Client, InPlayerPawnLocation) == 0x000010, "Member 'DCPlayerController_AckPlayerCharacterLocation_Client::InPlayerPawnLocation' has a wrong offset!");
static_assert(offsetof(DCPlayerController_AckPlayerCharacterLocation_Client, InPlayerPawnRotation) == 0x000028, "Member 'DCPlayerController_AckPlayerCharacterLocation_Client::InPlayerPawnRotation' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.Announce_Client
// 0x0090 (0x0090 - 0x0000)
struct DCPlayerController_Announce_Client final
{
public:
	struct FGameAnnounceData                      AnnounceData;                                      // 0x0000(0x0090)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_Announce_Client) == 0x000008, "Wrong alignment on DCPlayerController_Announce_Client");
static_assert(sizeof(DCPlayerController_Announce_Client) == 0x000090, "Wrong size on DCPlayerController_Announce_Client");
static_assert(offsetof(DCPlayerController_Announce_Client, AnnounceData) == 0x000000, "Member 'DCPlayerController_Announce_Client::AnnounceData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCPlayerController_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCPlayerController_BroadcastMsgBlueprint");
static_assert(sizeof(DCPlayerController_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCPlayerController_BroadcastMsgBlueprint");
static_assert(offsetof(DCPlayerController_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCPlayerController_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.ChangeParty_Server
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_ChangeParty_Server final
{
public:
	struct FDCPartyId                             InPartyId;                                         // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_ChangeParty_Server) == 0x000008, "Wrong alignment on DCPlayerController_ChangeParty_Server");
static_assert(sizeof(DCPlayerController_ChangeParty_Server) == 0x000010, "Wrong size on DCPlayerController_ChangeParty_Server");
static_assert(offsetof(DCPlayerController_ChangeParty_Server, InPartyId) == 0x000000, "Member 'DCPlayerController_ChangeParty_Server::InPartyId' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.ExitUser
// 0x0001 (0x0001 - 0x0000)
struct DCPlayerController_ExitUser final
{
public:
	EDCExitType                                   ExitType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_ExitUser) == 0x000001, "Wrong alignment on DCPlayerController_ExitUser");
static_assert(sizeof(DCPlayerController_ExitUser) == 0x000001, "Wrong size on DCPlayerController_ExitUser");
static_assert(offsetof(DCPlayerController_ExitUser, ExitType) == 0x000000, "Member 'DCPlayerController_ExitUser::ExitType' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.ExitUser_Server
// 0x0001 (0x0001 - 0x0000)
struct DCPlayerController_ExitUser_Server final
{
public:
	EDCExitType                                   ExitType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_ExitUser_Server) == 0x000001, "Wrong alignment on DCPlayerController_ExitUser_Server");
static_assert(sizeof(DCPlayerController_ExitUser_Server) == 0x000001, "Wrong size on DCPlayerController_ExitUser_Server");
static_assert(offsetof(DCPlayerController_ExitUser_Server, ExitType) == 0x000000, "Member 'DCPlayerController_ExitUser_Server::ExitType' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.GetDebugFaceTargetActor
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerController_GetDebugFaceTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_GetDebugFaceTargetActor) == 0x000008, "Wrong alignment on DCPlayerController_GetDebugFaceTargetActor");
static_assert(sizeof(DCPlayerController_GetDebugFaceTargetActor) == 0x000008, "Wrong size on DCPlayerController_GetDebugFaceTargetActor");
static_assert(offsetof(DCPlayerController_GetDebugFaceTargetActor, ReturnValue) == 0x000000, "Member 'DCPlayerController_GetDebugFaceTargetActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.Gm
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_Gm final
{
public:
	class FString                                 InCmd;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_Gm) == 0x000008, "Wrong alignment on DCPlayerController_Gm");
static_assert(sizeof(DCPlayerController_Gm) == 0x000010, "Wrong size on DCPlayerController_Gm");
static_assert(offsetof(DCPlayerController_Gm, InCmd) == 0x000000, "Member 'DCPlayerController_Gm::InCmd' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.GmServer
// 0x0020 (0x0020 - 0x0000)
struct DCPlayerController_GmServer final
{
public:
	class FString                                 InKey;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InCmd;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_GmServer) == 0x000008, "Wrong alignment on DCPlayerController_GmServer");
static_assert(sizeof(DCPlayerController_GmServer) == 0x000020, "Wrong size on DCPlayerController_GmServer");
static_assert(offsetof(DCPlayerController_GmServer, InKey) == 0x000000, "Member 'DCPlayerController_GmServer::InKey' has a wrong offset!");
static_assert(offsetof(DCPlayerController_GmServer, InCmd) == 0x000010, "Member 'DCPlayerController_GmServer::InCmd' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.IsTargetAccountSelf
// 0x0001 (0x0001 - 0x0000)
struct DCPlayerController_IsTargetAccountSelf final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_IsTargetAccountSelf) == 0x000001, "Wrong alignment on DCPlayerController_IsTargetAccountSelf");
static_assert(sizeof(DCPlayerController_IsTargetAccountSelf) == 0x000001, "Wrong size on DCPlayerController_IsTargetAccountSelf");
static_assert(offsetof(DCPlayerController_IsTargetAccountSelf, ReturnValue) == 0x000000, "Member 'DCPlayerController_IsTargetAccountSelf::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.NotifySystemMessage_Client
// 0x0020 (0x0020 - 0x0000)
struct DCPlayerController_NotifySystemMessage_Client final
{
public:
	class FText                                   SystemMessage;                                     // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2721[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPlayerController_NotifySystemMessage_Client) == 0x000008, "Wrong alignment on DCPlayerController_NotifySystemMessage_Client");
static_assert(sizeof(DCPlayerController_NotifySystemMessage_Client) == 0x000020, "Wrong size on DCPlayerController_NotifySystemMessage_Client");
static_assert(offsetof(DCPlayerController_NotifySystemMessage_Client, SystemMessage) == 0x000000, "Member 'DCPlayerController_NotifySystemMessage_Client::SystemMessage' has a wrong offset!");
static_assert(offsetof(DCPlayerController_NotifySystemMessage_Client, Duration) == 0x000018, "Member 'DCPlayerController_NotifySystemMessage_Client::Duration' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnAnyPlayerDied
// 0x00E0 (0x00E0 - 0x0000)
struct DCPlayerController_OnAnyPlayerDied final
{
public:
	struct FDCPlayerInfo                          InPlayerInfo;                                      // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnAnyPlayerDied) == 0x000008, "Wrong alignment on DCPlayerController_OnAnyPlayerDied");
static_assert(sizeof(DCPlayerController_OnAnyPlayerDied) == 0x0000E0, "Wrong size on DCPlayerController_OnAnyPlayerDied");
static_assert(offsetof(DCPlayerController_OnAnyPlayerDied, InPlayerInfo) == 0x000000, "Member 'DCPlayerController_OnAnyPlayerDied::InPlayerInfo' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnBackToLobbyConfirmed
// 0x0001 (0x0001 - 0x0000)
struct DCPlayerController_OnBackToLobbyConfirmed final
{
public:
	EPopupResult                                  PopupResult;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnBackToLobbyConfirmed) == 0x000001, "Wrong alignment on DCPlayerController_OnBackToLobbyConfirmed");
static_assert(sizeof(DCPlayerController_OnBackToLobbyConfirmed) == 0x000001, "Wrong size on DCPlayerController_OnBackToLobbyConfirmed");
static_assert(offsetof(DCPlayerController_OnBackToLobbyConfirmed, PopupResult) == 0x000000, "Member 'DCPlayerController_OnBackToLobbyConfirmed::PopupResult' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnClientCall
// 0x0018 (0x0018 - 0x0000)
struct DCPlayerController_OnClientCall final
{
public:
	struct FCallData                              CallData;                                          // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnClientCall) == 0x000008, "Wrong alignment on DCPlayerController_OnClientCall");
static_assert(sizeof(DCPlayerController_OnClientCall) == 0x000018, "Wrong size on DCPlayerController_OnClientCall");
static_assert(offsetof(DCPlayerController_OnClientCall, CallData) == 0x000000, "Member 'DCPlayerController_OnClientCall::CallData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnDungeonDownOverlapped
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_OnDungeonDownOverlapped final
{
public:
	class ADCPlayerCharacterBase*                 InCharacter;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2722[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPlayerController_OnDungeonDownOverlapped) == 0x000008, "Wrong alignment on DCPlayerController_OnDungeonDownOverlapped");
static_assert(sizeof(DCPlayerController_OnDungeonDownOverlapped) == 0x000010, "Wrong size on DCPlayerController_OnDungeonDownOverlapped");
static_assert(offsetof(DCPlayerController_OnDungeonDownOverlapped, InCharacter) == 0x000000, "Member 'DCPlayerController_OnDungeonDownOverlapped::InCharacter' has a wrong offset!");
static_assert(offsetof(DCPlayerController_OnDungeonDownOverlapped, ReturnValue) == 0x000008, "Member 'DCPlayerController_OnDungeonDownOverlapped::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnDungeonEscapeOverlapped
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_OnDungeonEscapeOverlapped final
{
public:
	class ADCPlayerCharacterBase*                 InCharacter;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2723[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPlayerController_OnDungeonEscapeOverlapped) == 0x000008, "Wrong alignment on DCPlayerController_OnDungeonEscapeOverlapped");
static_assert(sizeof(DCPlayerController_OnDungeonEscapeOverlapped) == 0x000010, "Wrong size on DCPlayerController_OnDungeonEscapeOverlapped");
static_assert(offsetof(DCPlayerController_OnDungeonEscapeOverlapped, InCharacter) == 0x000000, "Member 'DCPlayerController_OnDungeonEscapeOverlapped::InCharacter' has a wrong offset!");
static_assert(offsetof(DCPlayerController_OnDungeonEscapeOverlapped, ReturnValue) == 0x000008, "Member 'DCPlayerController_OnDungeonEscapeOverlapped::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnExitConfirmed
// 0x0001 (0x0001 - 0x0000)
struct DCPlayerController_OnExitConfirmed final
{
public:
	EPopupResult                                  PopupResult;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnExitConfirmed) == 0x000001, "Wrong alignment on DCPlayerController_OnExitConfirmed");
static_assert(sizeof(DCPlayerController_OnExitConfirmed) == 0x000001, "Wrong size on DCPlayerController_OnExitConfirmed");
static_assert(offsetof(DCPlayerController_OnExitConfirmed, PopupResult) == 0x000000, "Member 'DCPlayerController_OnExitConfirmed::PopupResult' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnFMsgGameAnnounceNotifyClient
// 0x0090 (0x0090 - 0x0000)
struct DCPlayerController_OnFMsgGameAnnounceNotifyClient final
{
public:
	struct FGameAnnounceData                      InGameAnnounceData;                                // 0x0000(0x0090)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnFMsgGameAnnounceNotifyClient) == 0x000008, "Wrong alignment on DCPlayerController_OnFMsgGameAnnounceNotifyClient");
static_assert(sizeof(DCPlayerController_OnFMsgGameAnnounceNotifyClient) == 0x000090, "Wrong size on DCPlayerController_OnFMsgGameAnnounceNotifyClient");
static_assert(offsetof(DCPlayerController_OnFMsgGameAnnounceNotifyClient, InGameAnnounceData) == 0x000000, "Member 'DCPlayerController_OnFMsgGameAnnounceNotifyClient::InGameAnnounceData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnFMsgGameFloorLogNotify_Client
// 0x00B0 (0x00B0 - 0x0000)
struct DCPlayerController_OnFMsgGameFloorLogNotify_Client final
{
public:
	struct FMsgGameFloorLogNotify                 Msg;                                               // 0x0000(0x00B0)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnFMsgGameFloorLogNotify_Client) == 0x000008, "Wrong alignment on DCPlayerController_OnFMsgGameFloorLogNotify_Client");
static_assert(sizeof(DCPlayerController_OnFMsgGameFloorLogNotify_Client) == 0x0000B0, "Wrong size on DCPlayerController_OnFMsgGameFloorLogNotify_Client");
static_assert(offsetof(DCPlayerController_OnFMsgGameFloorLogNotify_Client, Msg) == 0x000000, "Member 'DCPlayerController_OnFMsgGameFloorLogNotify_Client::Msg' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnFMsgGameKillLogNotify_Client
// 0x0130 (0x0130 - 0x0000)
struct DCPlayerController_OnFMsgGameKillLogNotify_Client final
{
public:
	struct FMsgGameKillLogNotify                  Msg;                                               // 0x0000(0x0130)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnFMsgGameKillLogNotify_Client) == 0x000008, "Wrong alignment on DCPlayerController_OnFMsgGameKillLogNotify_Client");
static_assert(sizeof(DCPlayerController_OnFMsgGameKillLogNotify_Client) == 0x000130, "Wrong size on DCPlayerController_OnFMsgGameKillLogNotify_Client");
static_assert(offsetof(DCPlayerController_OnFMsgGameKillLogNotify_Client, Msg) == 0x000000, "Member 'DCPlayerController_OnFMsgGameKillLogNotify_Client::Msg' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnGameStateNotify
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerController_OnGameStateNotify final
{
public:
	struct FGameStateData                         InGameStateData;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnGameStateNotify) == 0x000004, "Wrong alignment on DCPlayerController_OnGameStateNotify");
static_assert(sizeof(DCPlayerController_OnGameStateNotify) == 0x000008, "Wrong size on DCPlayerController_OnGameStateNotify");
static_assert(offsetof(DCPlayerController_OnGameStateNotify, InGameStateData) == 0x000000, "Member 'DCPlayerController_OnGameStateNotify::InGameStateData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnKilledByUser_Client
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_OnKilledByUser_Client final
{
public:
	struct FDCAccountId                           Killer;                                            // 0x0000(0x0010)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnKilledByUser_Client) == 0x000008, "Wrong alignment on DCPlayerController_OnKilledByUser_Client");
static_assert(sizeof(DCPlayerController_OnKilledByUser_Client) == 0x000010, "Wrong size on DCPlayerController_OnKilledByUser_Client");
static_assert(offsetof(DCPlayerController_OnKilledByUser_Client, Killer) == 0x000000, "Member 'DCPlayerController_OnKilledByUser_Client::Killer' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnPartyChat
// 0x0080 (0x0080 - 0x0000)
struct DCPlayerController_OnPartyChat final
{
public:
	struct FChatData                              InChatData;                                        // 0x0000(0x0080)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnPartyChat) == 0x000008, "Wrong alignment on DCPlayerController_OnPartyChat");
static_assert(sizeof(DCPlayerController_OnPartyChat) == 0x000080, "Wrong size on DCPlayerController_OnPartyChat");
static_assert(offsetof(DCPlayerController_OnPartyChat, InChatData) == 0x000000, "Member 'DCPlayerController_OnPartyChat::InChatData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnPawnChanged
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_OnPawnChanged final
{
public:
	class APawn*                                  InOldPawn;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  InNewPawn;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnPawnChanged) == 0x000008, "Wrong alignment on DCPlayerController_OnPawnChanged");
static_assert(sizeof(DCPlayerController_OnPawnChanged) == 0x000010, "Wrong size on DCPlayerController_OnPawnChanged");
static_assert(offsetof(DCPlayerController_OnPawnChanged, InOldPawn) == 0x000000, "Member 'DCPlayerController_OnPawnChanged::InOldPawn' has a wrong offset!");
static_assert(offsetof(DCPlayerController_OnPawnChanged, InNewPawn) == 0x000008, "Member 'DCPlayerController_OnPawnChanged::InNewPawn' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnPortalScrollOverlapped
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_OnPortalScrollOverlapped final
{
public:
	class AFloorPortalScrollBase*                 Portal;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCPlayerCharacterBase*                 InCharacter;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnPortalScrollOverlapped) == 0x000008, "Wrong alignment on DCPlayerController_OnPortalScrollOverlapped");
static_assert(sizeof(DCPlayerController_OnPortalScrollOverlapped) == 0x000010, "Wrong size on DCPlayerController_OnPortalScrollOverlapped");
static_assert(offsetof(DCPlayerController_OnPortalScrollOverlapped, Portal) == 0x000000, "Member 'DCPlayerController_OnPortalScrollOverlapped::Portal' has a wrong offset!");
static_assert(offsetof(DCPlayerController_OnPortalScrollOverlapped, InCharacter) == 0x000008, "Member 'DCPlayerController_OnPortalScrollOverlapped::InCharacter' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnRep_AccountId
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_OnRep_AccountId final
{
public:
	class FString                                 OldId;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnRep_AccountId) == 0x000008, "Wrong alignment on DCPlayerController_OnRep_AccountId");
static_assert(sizeof(DCPlayerController_OnRep_AccountId) == 0x000010, "Wrong size on DCPlayerController_OnRep_AccountId");
static_assert(offsetof(DCPlayerController_OnRep_AccountId, OldId) == 0x000000, "Member 'DCPlayerController_OnRep_AccountId::OldId' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnRep_InspectTarget
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerController_OnRep_InspectTarget final
{
public:
	class ADCCharacterBase*                       OldInspectTarget;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnRep_InspectTarget) == 0x000008, "Wrong alignment on DCPlayerController_OnRep_InspectTarget");
static_assert(sizeof(DCPlayerController_OnRep_InspectTarget) == 0x000008, "Wrong size on DCPlayerController_OnRep_InspectTarget");
static_assert(offsetof(DCPlayerController_OnRep_InspectTarget, OldInspectTarget) == 0x000000, "Member 'DCPlayerController_OnRep_InspectTarget::OldInspectTarget' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnRep_PersonalPlayerInfo
// 0x0038 (0x0038 - 0x0000)
struct DCPlayerController_OnRep_PersonalPlayerInfo final
{
public:
	struct FDCPersonalPlayerInfo                  OldPlayerInfo;                                     // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnRep_PersonalPlayerInfo) == 0x000008, "Wrong alignment on DCPlayerController_OnRep_PersonalPlayerInfo");
static_assert(sizeof(DCPlayerController_OnRep_PersonalPlayerInfo) == 0x000038, "Wrong size on DCPlayerController_OnRep_PersonalPlayerInfo");
static_assert(offsetof(DCPlayerController_OnRep_PersonalPlayerInfo, OldPlayerInfo) == 0x000000, "Member 'DCPlayerController_OnRep_PersonalPlayerInfo::OldPlayerInfo' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnRep_ReportedInfoArray
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_OnRep_ReportedInfoArray final
{
public:
	TArray<struct FDCReportedInfo>                InOldReportedInfoArray;                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnRep_ReportedInfoArray) == 0x000008, "Wrong alignment on DCPlayerController_OnRep_ReportedInfoArray");
static_assert(sizeof(DCPlayerController_OnRep_ReportedInfoArray) == 0x000010, "Wrong size on DCPlayerController_OnRep_ReportedInfoArray");
static_assert(offsetof(DCPlayerController_OnRep_ReportedInfoArray, InOldReportedInfoArray) == 0x000000, "Member 'DCPlayerController_OnRep_ReportedInfoArray::InOldReportedInfoArray' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnServerCall
// 0x0018 (0x0018 - 0x0000)
struct DCPlayerController_OnServerCall final
{
public:
	struct FCallData                              CallData;                                          // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnServerCall) == 0x000008, "Wrong alignment on DCPlayerController_OnServerCall");
static_assert(sizeof(DCPlayerController_OnServerCall) == 0x000018, "Wrong size on DCPlayerController_OnServerCall");
static_assert(offsetof(DCPlayerController_OnServerCall, CallData) == 0x000000, "Member 'DCPlayerController_OnServerCall::CallData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnServerNotify
// 0x0020 (0x0020 - 0x0000)
struct DCPlayerController_OnServerNotify final
{
public:
	struct FNotifyData                            NotifyData;                                        // 0x0000(0x0020)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnServerNotify) == 0x000008, "Wrong alignment on DCPlayerController_OnServerNotify");
static_assert(sizeof(DCPlayerController_OnServerNotify) == 0x000020, "Wrong size on DCPlayerController_OnServerNotify");
static_assert(offsetof(DCPlayerController_OnServerNotify, NotifyData) == 0x000000, "Member 'DCPlayerController_OnServerNotify::NotifyData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnSpectateTarget
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_OnSpectateTarget final
{
public:
	struct FDCAccountId                           SpectateAccountId;                                 // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnSpectateTarget) == 0x000008, "Wrong alignment on DCPlayerController_OnSpectateTarget");
static_assert(sizeof(DCPlayerController_OnSpectateTarget) == 0x000010, "Wrong size on DCPlayerController_OnSpectateTarget");
static_assert(offsetof(DCPlayerController_OnSpectateTarget, SpectateAccountId) == 0x000000, "Member 'DCPlayerController_OnSpectateTarget::SpectateAccountId' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.OnUserExited_Client
// 0x0001 (0x0001 - 0x0000)
struct DCPlayerController_OnUserExited_Client final
{
public:
	EDCExitType                                   ExitType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_OnUserExited_Client) == 0x000001, "Wrong alignment on DCPlayerController_OnUserExited_Client");
static_assert(sizeof(DCPlayerController_OnUserExited_Client) == 0x000001, "Wrong size on DCPlayerController_OnUserExited_Client");
static_assert(offsetof(DCPlayerController_OnUserExited_Client, ExitType) == 0x000000, "Member 'DCPlayerController_OnUserExited_Client::ExitType' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.ReportPlayer_Server
// 0x0088 (0x0088 - 0x0000)
struct DCPlayerController_ReportPlayer_Server final
{
public:
	struct FDCReportPlayerInfo                    InReportPlayerInfo;                                // 0x0000(0x0088)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_ReportPlayer_Server) == 0x000008, "Wrong alignment on DCPlayerController_ReportPlayer_Server");
static_assert(sizeof(DCPlayerController_ReportPlayer_Server) == 0x000088, "Wrong size on DCPlayerController_ReportPlayer_Server");
static_assert(offsetof(DCPlayerController_ReportPlayer_Server, InReportPlayerInfo) == 0x000000, "Member 'DCPlayerController_ReportPlayer_Server::InReportPlayerInfo' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.RequestPartyChatServer
// 0x0080 (0x0080 - 0x0000)
struct DCPlayerController_RequestPartyChatServer final
{
public:
	struct FChatData                              InChatData;                                        // 0x0000(0x0080)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_RequestPartyChatServer) == 0x000008, "Wrong alignment on DCPlayerController_RequestPartyChatServer");
static_assert(sizeof(DCPlayerController_RequestPartyChatServer) == 0x000080, "Wrong size on DCPlayerController_RequestPartyChatServer");
static_assert(offsetof(DCPlayerController_RequestPartyChatServer, InChatData) == 0x000000, "Member 'DCPlayerController_RequestPartyChatServer::InChatData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.RequestPlayerCharacterLocation_Server
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_RequestPlayerCharacterLocation_Server final
{
public:
	struct FDCAccountId                           InAccountId;                                       // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_RequestPlayerCharacterLocation_Server) == 0x000008, "Wrong alignment on DCPlayerController_RequestPlayerCharacterLocation_Server");
static_assert(sizeof(DCPlayerController_RequestPlayerCharacterLocation_Server) == 0x000010, "Wrong size on DCPlayerController_RequestPlayerCharacterLocation_Server");
static_assert(offsetof(DCPlayerController_RequestPlayerCharacterLocation_Server, InAccountId) == 0x000000, "Member 'DCPlayerController_RequestPlayerCharacterLocation_Server::InAccountId' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.ServerDebugGiveGameplayEffectToTarget
// 0x0028 (0x0028 - 0x0000)
struct DCPlayerController_ServerDebugGiveGameplayEffectToTarget final
{
public:
	class FString                                 InKey;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        GameplayEffectAssetId;                             // 0x0018(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_ServerDebugGiveGameplayEffectToTarget) == 0x000008, "Wrong alignment on DCPlayerController_ServerDebugGiveGameplayEffectToTarget");
static_assert(sizeof(DCPlayerController_ServerDebugGiveGameplayEffectToTarget) == 0x000028, "Wrong size on DCPlayerController_ServerDebugGiveGameplayEffectToTarget");
static_assert(offsetof(DCPlayerController_ServerDebugGiveGameplayEffectToTarget, InKey) == 0x000000, "Member 'DCPlayerController_ServerDebugGiveGameplayEffectToTarget::InKey' has a wrong offset!");
static_assert(offsetof(DCPlayerController_ServerDebugGiveGameplayEffectToTarget, TargetActor) == 0x000010, "Member 'DCPlayerController_ServerDebugGiveGameplayEffectToTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(DCPlayerController_ServerDebugGiveGameplayEffectToTarget, GameplayEffectAssetId) == 0x000018, "Member 'DCPlayerController_ServerDebugGiveGameplayEffectToTarget::GameplayEffectAssetId' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.ServerDebugInjectItemToTarget
// 0x0018 (0x0018 - 0x0000)
struct DCPlayerController_ServerDebugInjectItemToTarget final
{
public:
	TArray<struct FItemData>                      InItemDataArray;                                   // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EInventoryType                                TargetInventoryType;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2724[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPlayerController_ServerDebugInjectItemToTarget) == 0x000008, "Wrong alignment on DCPlayerController_ServerDebugInjectItemToTarget");
static_assert(sizeof(DCPlayerController_ServerDebugInjectItemToTarget) == 0x000018, "Wrong size on DCPlayerController_ServerDebugInjectItemToTarget");
static_assert(offsetof(DCPlayerController_ServerDebugInjectItemToTarget, InItemDataArray) == 0x000000, "Member 'DCPlayerController_ServerDebugInjectItemToTarget::InItemDataArray' has a wrong offset!");
static_assert(offsetof(DCPlayerController_ServerDebugInjectItemToTarget, TargetInventoryType) == 0x000010, "Member 'DCPlayerController_ServerDebugInjectItemToTarget::TargetInventoryType' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.ServerDebugSetupTagToTarget
// 0x0028 (0x0028 - 0x0000)
struct DCPlayerController_ServerDebugSetupTagToTarget final
{
public:
	class FString                                 InKey;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TagOptionString;                                   // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_ServerDebugSetupTagToTarget) == 0x000008, "Wrong alignment on DCPlayerController_ServerDebugSetupTagToTarget");
static_assert(sizeof(DCPlayerController_ServerDebugSetupTagToTarget) == 0x000028, "Wrong size on DCPlayerController_ServerDebugSetupTagToTarget");
static_assert(offsetof(DCPlayerController_ServerDebugSetupTagToTarget, InKey) == 0x000000, "Member 'DCPlayerController_ServerDebugSetupTagToTarget::InKey' has a wrong offset!");
static_assert(offsetof(DCPlayerController_ServerDebugSetupTagToTarget, TargetActor) == 0x000010, "Member 'DCPlayerController_ServerDebugSetupTagToTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(DCPlayerController_ServerDebugSetupTagToTarget, TagOptionString) == 0x000018, "Member 'DCPlayerController_ServerDebugSetupTagToTarget::TagOptionString' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.ServerDebugSpawnItem
// 0x0028 (0x0028 - 0x0000)
struct DCPlayerController_ServerDebugSpawnItem final
{
public:
	class FString                                 InKey;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SpawnActor;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SpawnItemAssetId;                                  // 0x0018(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_ServerDebugSpawnItem) == 0x000008, "Wrong alignment on DCPlayerController_ServerDebugSpawnItem");
static_assert(sizeof(DCPlayerController_ServerDebugSpawnItem) == 0x000028, "Wrong size on DCPlayerController_ServerDebugSpawnItem");
static_assert(offsetof(DCPlayerController_ServerDebugSpawnItem, InKey) == 0x000000, "Member 'DCPlayerController_ServerDebugSpawnItem::InKey' has a wrong offset!");
static_assert(offsetof(DCPlayerController_ServerDebugSpawnItem, SpawnActor) == 0x000010, "Member 'DCPlayerController_ServerDebugSpawnItem::SpawnActor' has a wrong offset!");
static_assert(offsetof(DCPlayerController_ServerDebugSpawnItem, SpawnItemAssetId) == 0x000018, "Member 'DCPlayerController_ServerDebugSpawnItem::SpawnItemAssetId' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.ServerEventBroadcastTriggered
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_ServerEventBroadcastTriggered final
{
public:
	EDCServerTriggeredEventType                   EventType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2725[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ServerFrame;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_ServerEventBroadcastTriggered) == 0x000008, "Wrong alignment on DCPlayerController_ServerEventBroadcastTriggered");
static_assert(sizeof(DCPlayerController_ServerEventBroadcastTriggered) == 0x000010, "Wrong size on DCPlayerController_ServerEventBroadcastTriggered");
static_assert(offsetof(DCPlayerController_ServerEventBroadcastTriggered, EventType) == 0x000000, "Member 'DCPlayerController_ServerEventBroadcastTriggered::EventType' has a wrong offset!");
static_assert(offsetof(DCPlayerController_ServerEventBroadcastTriggered, ServerFrame) == 0x000008, "Member 'DCPlayerController_ServerEventBroadcastTriggered::ServerFrame' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.SetInspectTarget_Server
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerController_SetInspectTarget_Server final
{
public:
	class ADCCharacterBase*                       InInspectTarget;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_SetInspectTarget_Server) == 0x000008, "Wrong alignment on DCPlayerController_SetInspectTarget_Server");
static_assert(sizeof(DCPlayerController_SetInspectTarget_Server) == 0x000008, "Wrong size on DCPlayerController_SetInspectTarget_Server");
static_assert(offsetof(DCPlayerController_SetInspectTarget_Server, InInspectTarget) == 0x000000, "Member 'DCPlayerController_SetInspectTarget_Server::InInspectTarget' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.SpawnResurrectionCharacterForDebug_Server
// 0x0018 (0x0018 - 0x0000)
struct DCPlayerController_SpawnResurrectionCharacterForDebug_Server final
{
public:
	struct FDCAccountId                           InAccountId;                                       // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecoverItem;                                      // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2726[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LifeSpan;                                          // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_SpawnResurrectionCharacterForDebug_Server) == 0x000008, "Wrong alignment on DCPlayerController_SpawnResurrectionCharacterForDebug_Server");
static_assert(sizeof(DCPlayerController_SpawnResurrectionCharacterForDebug_Server) == 0x000018, "Wrong size on DCPlayerController_SpawnResurrectionCharacterForDebug_Server");
static_assert(offsetof(DCPlayerController_SpawnResurrectionCharacterForDebug_Server, InAccountId) == 0x000000, "Member 'DCPlayerController_SpawnResurrectionCharacterForDebug_Server::InAccountId' has a wrong offset!");
static_assert(offsetof(DCPlayerController_SpawnResurrectionCharacterForDebug_Server, bRecoverItem) == 0x000010, "Member 'DCPlayerController_SpawnResurrectionCharacterForDebug_Server::bRecoverItem' has a wrong offset!");
static_assert(offsetof(DCPlayerController_SpawnResurrectionCharacterForDebug_Server, LifeSpan) == 0x000014, "Member 'DCPlayerController_SpawnResurrectionCharacterForDebug_Server::LifeSpan' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.StartToWearItem_Client
// 0x0128 (0x0128 - 0x0000)
struct DCPlayerController_StartToWearItem_Client final
{
public:
	struct FItemData                              InWearingItemData;                                 // 0x0000(0x0100)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 InWearingActor;                                    // 0x0100(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDuration;                                        // 0x0108(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2727[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InDescription;                                     // 0x0110(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_StartToWearItem_Client) == 0x000008, "Wrong alignment on DCPlayerController_StartToWearItem_Client");
static_assert(sizeof(DCPlayerController_StartToWearItem_Client) == 0x000128, "Wrong size on DCPlayerController_StartToWearItem_Client");
static_assert(offsetof(DCPlayerController_StartToWearItem_Client, InWearingItemData) == 0x000000, "Member 'DCPlayerController_StartToWearItem_Client::InWearingItemData' has a wrong offset!");
static_assert(offsetof(DCPlayerController_StartToWearItem_Client, InWearingActor) == 0x000100, "Member 'DCPlayerController_StartToWearItem_Client::InWearingActor' has a wrong offset!");
static_assert(offsetof(DCPlayerController_StartToWearItem_Client, InDuration) == 0x000108, "Member 'DCPlayerController_StartToWearItem_Client::InDuration' has a wrong offset!");
static_assert(offsetof(DCPlayerController_StartToWearItem_Client, InDescription) == 0x000110, "Member 'DCPlayerController_StartToWearItem_Client::InDescription' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.TravelFloorMatchmaking_Client
// 0x0030 (0x0030 - 0x0000)
struct DCPlayerController_TravelFloorMatchmaking_Client final
{
public:
	struct FDCGameLiftSessionId                   SessionId;                                         // 0x0000(0x0010)(ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Address;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServiceUrl;                                        // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_TravelFloorMatchmaking_Client) == 0x000008, "Wrong alignment on DCPlayerController_TravelFloorMatchmaking_Client");
static_assert(sizeof(DCPlayerController_TravelFloorMatchmaking_Client) == 0x000030, "Wrong size on DCPlayerController_TravelFloorMatchmaking_Client");
static_assert(offsetof(DCPlayerController_TravelFloorMatchmaking_Client, SessionId) == 0x000000, "Member 'DCPlayerController_TravelFloorMatchmaking_Client::SessionId' has a wrong offset!");
static_assert(offsetof(DCPlayerController_TravelFloorMatchmaking_Client, Address) == 0x000010, "Member 'DCPlayerController_TravelFloorMatchmaking_Client::Address' has a wrong offset!");
static_assert(offsetof(DCPlayerController_TravelFloorMatchmaking_Client, ServiceUrl) == 0x000020, "Member 'DCPlayerController_TravelFloorMatchmaking_Client::ServiceUrl' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerController_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_UnbindMsg) == 0x000008, "Wrong alignment on DCPlayerController_UnbindMsg");
static_assert(sizeof(DCPlayerController_UnbindMsg) == 0x000010, "Wrong size on DCPlayerController_UnbindMsg");
static_assert(offsetof(DCPlayerController_UnbindMsg, InMsgType) == 0x000000, "Member 'DCPlayerController_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCPlayerController_UnbindMsg, InObject) == 0x000008, "Member 'DCPlayerController_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerController_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_UnbindMsgAll) == 0x000008, "Wrong alignment on DCPlayerController_UnbindMsgAll");
static_assert(sizeof(DCPlayerController_UnbindMsgAll) == 0x000008, "Wrong size on DCPlayerController_UnbindMsgAll");
static_assert(offsetof(DCPlayerController_UnbindMsgAll, InObject) == 0x000000, "Member 'DCPlayerController_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.GetAccountSessionData
// 0x0118 (0x0118 - 0x0000)
struct DCPlayerController_GetAccountSessionData final
{
public:
	struct FAccountSessionData                    ReturnValue;                                       // 0x0000(0x0118)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_GetAccountSessionData) == 0x000008, "Wrong alignment on DCPlayerController_GetAccountSessionData");
static_assert(sizeof(DCPlayerController_GetAccountSessionData) == 0x000118, "Wrong size on DCPlayerController_GetAccountSessionData");
static_assert(offsetof(DCPlayerController_GetAccountSessionData, ReturnValue) == 0x000000, "Member 'DCPlayerController_GetAccountSessionData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.GetExpressmanComponent
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerController_GetExpressmanComponent final
{
public:
	class UDCExpressmanComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_GetExpressmanComponent) == 0x000008, "Wrong alignment on DCPlayerController_GetExpressmanComponent");
static_assert(sizeof(DCPlayerController_GetExpressmanComponent) == 0x000008, "Wrong size on DCPlayerController_GetExpressmanComponent");
static_assert(offsetof(DCPlayerController_GetExpressmanComponent, ReturnValue) == 0x000000, "Member 'DCPlayerController_GetExpressmanComponent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.GetLootComponent
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerController_GetLootComponent final
{
public:
	class UDCLootComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_GetLootComponent) == 0x000008, "Wrong alignment on DCPlayerController_GetLootComponent");
static_assert(sizeof(DCPlayerController_GetLootComponent) == 0x000008, "Wrong size on DCPlayerController_GetLootComponent");
static_assert(offsetof(DCPlayerController_GetLootComponent, ReturnValue) == 0x000000, "Member 'DCPlayerController_GetLootComponent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.GetPersonalPlayerInfo
// 0x0038 (0x0038 - 0x0000)
struct DCPlayerController_GetPersonalPlayerInfo final
{
public:
	struct FDCPersonalPlayerInfo                  ReturnValue;                                       // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_GetPersonalPlayerInfo) == 0x000008, "Wrong alignment on DCPlayerController_GetPersonalPlayerInfo");
static_assert(sizeof(DCPlayerController_GetPersonalPlayerInfo) == 0x000038, "Wrong size on DCPlayerController_GetPersonalPlayerInfo");
static_assert(offsetof(DCPlayerController_GetPersonalPlayerInfo, ReturnValue) == 0x000000, "Member 'DCPlayerController_GetPersonalPlayerInfo::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerController.IsDungeonResultShowResult
// 0x0001 (0x0001 - 0x0000)
struct DCPlayerController_IsDungeonResultShowResult final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerController_IsDungeonResultShowResult) == 0x000001, "Wrong alignment on DCPlayerController_IsDungeonResultShowResult");
static_assert(sizeof(DCPlayerController_IsDungeonResultShowResult) == 0x000001, "Wrong size on DCPlayerController_IsDungeonResultShowResult");
static_assert(offsetof(DCPlayerController_IsDungeonResultShowResult, ReturnValue) == 0x000000, "Member 'DCPlayerController_IsDungeonResultShowResult::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMetaPlayerController.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCMetaPlayerController_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMetaPlayerController_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCMetaPlayerController_BroadcastMsgBlueprint");
static_assert(sizeof(DCMetaPlayerController_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCMetaPlayerController_BroadcastMsgBlueprint");
static_assert(offsetof(DCMetaPlayerController_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCMetaPlayerController_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCMetaPlayerController.GetAccountSessionData
// 0x0118 (0x0118 - 0x0000)
struct DCMetaPlayerController_GetAccountSessionData final
{
public:
	struct FAccountSessionData                    ReturnValue;                                       // 0x0000(0x0118)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMetaPlayerController_GetAccountSessionData) == 0x000008, "Wrong alignment on DCMetaPlayerController_GetAccountSessionData");
static_assert(sizeof(DCMetaPlayerController_GetAccountSessionData) == 0x000118, "Wrong size on DCMetaPlayerController_GetAccountSessionData");
static_assert(offsetof(DCMetaPlayerController_GetAccountSessionData, ReturnValue) == 0x000000, "Member 'DCMetaPlayerController_GetAccountSessionData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMetaPlayerController.Gm
// 0x0010 (0x0010 - 0x0000)
struct DCMetaPlayerController_Gm final
{
public:
	class FString                                 InCmd;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMetaPlayerController_Gm) == 0x000008, "Wrong alignment on DCMetaPlayerController_Gm");
static_assert(sizeof(DCMetaPlayerController_Gm) == 0x000010, "Wrong size on DCMetaPlayerController_Gm");
static_assert(offsetof(DCMetaPlayerController_Gm, InCmd) == 0x000000, "Member 'DCMetaPlayerController_Gm::InCmd' has a wrong offset!");

// Function DungeonCrawler.DCMetaPlayerController.OnExitConfirmed
// 0x0001 (0x0001 - 0x0000)
struct DCMetaPlayerController_OnExitConfirmed final
{
public:
	EPopupResult                                  PopupResult;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMetaPlayerController_OnExitConfirmed) == 0x000001, "Wrong alignment on DCMetaPlayerController_OnExitConfirmed");
static_assert(sizeof(DCMetaPlayerController_OnExitConfirmed) == 0x000001, "Wrong size on DCMetaPlayerController_OnExitConfirmed");
static_assert(offsetof(DCMetaPlayerController_OnExitConfirmed, PopupResult) == 0x000000, "Member 'DCMetaPlayerController_OnExitConfirmed::PopupResult' has a wrong offset!");

// Function DungeonCrawler.DCMetaPlayerController.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCMetaPlayerController_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMetaPlayerController_UnbindMsg) == 0x000008, "Wrong alignment on DCMetaPlayerController_UnbindMsg");
static_assert(sizeof(DCMetaPlayerController_UnbindMsg) == 0x000010, "Wrong size on DCMetaPlayerController_UnbindMsg");
static_assert(offsetof(DCMetaPlayerController_UnbindMsg, InMsgType) == 0x000000, "Member 'DCMetaPlayerController_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCMetaPlayerController_UnbindMsg, InObject) == 0x000008, "Member 'DCMetaPlayerController_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCMetaPlayerController.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCMetaPlayerController_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMetaPlayerController_UnbindMsgAll) == 0x000008, "Wrong alignment on DCMetaPlayerController_UnbindMsgAll");
static_assert(sizeof(DCMetaPlayerController_UnbindMsgAll) == 0x000008, "Wrong size on DCMetaPlayerController_UnbindMsgAll");
static_assert(offsetof(DCMetaPlayerController_UnbindMsgAll, InObject) == 0x000000, "Member 'DCMetaPlayerController_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCMetaPlayerController.UpdateGameState
// 0x0008 (0x0008 - 0x0000)
struct DCMetaPlayerController_UpdateGameState final
{
public:
	struct FGameStateData                         InGameStateData;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMetaPlayerController_UpdateGameState) == 0x000004, "Wrong alignment on DCMetaPlayerController_UpdateGameState");
static_assert(sizeof(DCMetaPlayerController_UpdateGameState) == 0x000008, "Wrong size on DCMetaPlayerController_UpdateGameState");
static_assert(offsetof(DCMetaPlayerController_UpdateGameState, InGameStateData) == 0x000000, "Member 'DCMetaPlayerController_UpdateGameState::InGameStateData' has a wrong offset!");

// Function DungeonCrawler.DCTradePhaseDealWidget.OnLocalTraderCheckBoxStateChanged
// 0x0001 (0x0001 - 0x0000)
struct DCTradePhaseDealWidget_OnLocalTraderCheckBoxStateChanged final
{
public:
	bool                                          bIsChecked;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTradePhaseDealWidget_OnLocalTraderCheckBoxStateChanged) == 0x000001, "Wrong alignment on DCTradePhaseDealWidget_OnLocalTraderCheckBoxStateChanged");
static_assert(sizeof(DCTradePhaseDealWidget_OnLocalTraderCheckBoxStateChanged) == 0x000001, "Wrong size on DCTradePhaseDealWidget_OnLocalTraderCheckBoxStateChanged");
static_assert(offsetof(DCTradePhaseDealWidget_OnLocalTraderCheckBoxStateChanged, bIsChecked) == 0x000000, "Member 'DCTradePhaseDealWidget_OnLocalTraderCheckBoxStateChanged::bIsChecked' has a wrong offset!");

// Function DungeonCrawler.DCTradePhaseDealWidget.OnResponseLocalTraderRequestRequestResult
// 0x0001 (0x0001 - 0x0000)
struct DCTradePhaseDealWidget_OnResponseLocalTraderRequestRequestResult final
{
public:
	bool                                          bRequestSucceed;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTradePhaseDealWidget_OnResponseLocalTraderRequestRequestResult) == 0x000001, "Wrong alignment on DCTradePhaseDealWidget_OnResponseLocalTraderRequestRequestResult");
static_assert(sizeof(DCTradePhaseDealWidget_OnResponseLocalTraderRequestRequestResult) == 0x000001, "Wrong size on DCTradePhaseDealWidget_OnResponseLocalTraderRequestRequestResult");
static_assert(offsetof(DCTradePhaseDealWidget_OnResponseLocalTraderRequestRequestResult, bRequestSucceed) == 0x000000, "Member 'DCTradePhaseDealWidget_OnResponseLocalTraderRequestRequestResult::bRequestSucceed' has a wrong offset!");

// Function DungeonCrawler.MetaComponentBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct MetaComponentBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MetaComponentBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on MetaComponentBase_BroadcastMsgBlueprint");
static_assert(sizeof(MetaComponentBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on MetaComponentBase_BroadcastMsgBlueprint");
static_assert(offsetof(MetaComponentBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'MetaComponentBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.MetaComponentBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct MetaComponentBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MetaComponentBase_UnbindMsg) == 0x000008, "Wrong alignment on MetaComponentBase_UnbindMsg");
static_assert(sizeof(MetaComponentBase_UnbindMsg) == 0x000010, "Wrong size on MetaComponentBase_UnbindMsg");
static_assert(offsetof(MetaComponentBase_UnbindMsg, InMsgType) == 0x000000, "Member 'MetaComponentBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(MetaComponentBase_UnbindMsg, InObject) == 0x000008, "Member 'MetaComponentBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.MetaComponentBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct MetaComponentBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MetaComponentBase_UnbindMsgAll) == 0x000008, "Wrong alignment on MetaComponentBase_UnbindMsgAll");
static_assert(sizeof(MetaComponentBase_UnbindMsgAll) == 0x000008, "Wrong size on MetaComponentBase_UnbindMsgAll");
static_assert(offsetof(MetaComponentBase_UnbindMsgAll, InObject) == 0x000000, "Member 'MetaComponentBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCTrainingCharacterSlotWidgetBase.IsSetMaster
// 0x0001 (0x0001 - 0x0000)
struct DCTrainingCharacterSlotWidgetBase_IsSetMaster final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTrainingCharacterSlotWidgetBase_IsSetMaster) == 0x000001, "Wrong alignment on DCTrainingCharacterSlotWidgetBase_IsSetMaster");
static_assert(sizeof(DCTrainingCharacterSlotWidgetBase_IsSetMaster) == 0x000001, "Wrong size on DCTrainingCharacterSlotWidgetBase_IsSetMaster");
static_assert(offsetof(DCTrainingCharacterSlotWidgetBase_IsSetMaster, ReturnValue) == 0x000000, "Member 'DCTrainingCharacterSlotWidgetBase_IsSetMaster::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAIController.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCMonsterAIController_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAIController_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCMonsterAIController_BroadcastMsgBlueprint");
static_assert(sizeof(DCMonsterAIController_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCMonsterAIController_BroadcastMsgBlueprint");
static_assert(offsetof(DCMonsterAIController_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCMonsterAIController_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAIController.ForceSightAll
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterAIController_ForceSightAll final
{
public:
	bool                                          bIsForce;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAIController_ForceSightAll) == 0x000001, "Wrong alignment on DCMonsterAIController_ForceSightAll");
static_assert(sizeof(DCMonsterAIController_ForceSightAll) == 0x000001, "Wrong size on DCMonsterAIController_ForceSightAll");
static_assert(offsetof(DCMonsterAIController_ForceSightAll, bIsForce) == 0x000000, "Member 'DCMonsterAIController_ForceSightAll::bIsForce' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAIController.OnPerceptionUpdated
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterAIController_OnPerceptionUpdated final
{
public:
	TArray<class AActor*>                         UpdatedActors;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAIController_OnPerceptionUpdated) == 0x000008, "Wrong alignment on DCMonsterAIController_OnPerceptionUpdated");
static_assert(sizeof(DCMonsterAIController_OnPerceptionUpdated) == 0x000010, "Wrong size on DCMonsterAIController_OnPerceptionUpdated");
static_assert(offsetof(DCMonsterAIController_OnPerceptionUpdated, UpdatedActors) == 0x000000, "Member 'DCMonsterAIController_OnPerceptionUpdated::UpdatedActors' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAIController.OnTargetPerceptionInfoUpdated
// 0x0068 (0x0068 - 0x0000)
struct DCMonsterAIController_OnTargetPerceptionInfoUpdated final
{
public:
	struct FActorPerceptionUpdateInfo             UpdateInfo;                                        // 0x0000(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAIController_OnTargetPerceptionInfoUpdated) == 0x000008, "Wrong alignment on DCMonsterAIController_OnTargetPerceptionInfoUpdated");
static_assert(sizeof(DCMonsterAIController_OnTargetPerceptionInfoUpdated) == 0x000068, "Wrong size on DCMonsterAIController_OnTargetPerceptionInfoUpdated");
static_assert(offsetof(DCMonsterAIController_OnTargetPerceptionInfoUpdated, UpdateInfo) == 0x000000, "Member 'DCMonsterAIController_OnTargetPerceptionInfoUpdated::UpdateInfo' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAIController.OnTargetPerceptionUpdated
// 0x0060 (0x0060 - 0x0000)
struct DCMonsterAIController_OnTargetPerceptionUpdated final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIStimulus                            Stimulus;                                          // 0x0008(0x0058)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAIController_OnTargetPerceptionUpdated) == 0x000008, "Wrong alignment on DCMonsterAIController_OnTargetPerceptionUpdated");
static_assert(sizeof(DCMonsterAIController_OnTargetPerceptionUpdated) == 0x000060, "Wrong size on DCMonsterAIController_OnTargetPerceptionUpdated");
static_assert(offsetof(DCMonsterAIController_OnTargetPerceptionUpdated, Actor) == 0x000000, "Member 'DCMonsterAIController_OnTargetPerceptionUpdated::Actor' has a wrong offset!");
static_assert(offsetof(DCMonsterAIController_OnTargetPerceptionUpdated, Stimulus) == 0x000008, "Member 'DCMonsterAIController_OnTargetPerceptionUpdated::Stimulus' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAIController.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterAIController_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAIController_UnbindMsg) == 0x000008, "Wrong alignment on DCMonsterAIController_UnbindMsg");
static_assert(sizeof(DCMonsterAIController_UnbindMsg) == 0x000010, "Wrong size on DCMonsterAIController_UnbindMsg");
static_assert(offsetof(DCMonsterAIController_UnbindMsg, InMsgType) == 0x000000, "Member 'DCMonsterAIController_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCMonsterAIController_UnbindMsg, InObject) == 0x000008, "Member 'DCMonsterAIController_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAIController.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCMonsterAIController_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAIController_UnbindMsgAll) == 0x000008, "Wrong alignment on DCMonsterAIController_UnbindMsgAll");
static_assert(sizeof(DCMonsterAIController_UnbindMsgAll) == 0x000008, "Wrong size on DCMonsterAIController_UnbindMsgAll");
static_assert(offsetof(DCMonsterAIController_UnbindMsgAll, InObject) == 0x000000, "Member 'DCMonsterAIController_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.AddAggro
// 0x0018 (0x0018 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_AddAggro final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       Target;                                            // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Point;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2737[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_AddAggro) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_AddAggro");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_AddAggro) == 0x000018, "Wrong size on DCMonsterAISystemBlueprintLibrary_AddAggro");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_AddAggro, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_AddAggro::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_AddAggro, Target) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_AddAggro::Target' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_AddAggro, Point) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_AddAggro::Point' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_AddAggro, ReturnValue) == 0x000014, "Member 'DCMonsterAISystemBlueprintLibrary_AddAggro::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.ExcludeSummonerAndPartyMembers
// 0x0018 (0x0018 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_ExcludeSummonerAndPartyMembers final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_ExcludeSummonerAndPartyMembers) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_ExcludeSummonerAndPartyMembers");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_ExcludeSummonerAndPartyMembers) == 0x000018, "Wrong size on DCMonsterAISystemBlueprintLibrary_ExcludeSummonerAndPartyMembers");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_ExcludeSummonerAndPartyMembers, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_ExcludeSummonerAndPartyMembers::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_ExcludeSummonerAndPartyMembers, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_ExcludeSummonerAndPartyMembers::TargetArray' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterMonsterTargets
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterMonsterTargets final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterMonsterTargets) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterMonsterTargets");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterMonsterTargets) == 0x000010, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterMonsterTargets");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterMonsterTargets, TargetArray) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterMonsterTargets::TargetArray' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterMonsterTargetsByID
// 0x0028 (0x0028 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ID;                                                // 0x0010(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2738[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID) == 0x000028, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID, TargetArray) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID, ID) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID::ID' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID, ReturnValue) == 0x000020, "Member 'DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterPlayerCharacterTargets
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterPlayerCharacterTargets final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterPlayerCharacterTargets) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterPlayerCharacterTargets");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterPlayerCharacterTargets) == 0x000010, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterPlayerCharacterTargets");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterPlayerCharacterTargets, TargetArray) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterPlayerCharacterTargets::TargetArray' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTagedTargets
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterTagedTargets final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2739[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterTagedTargets) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterTagedTargets");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterTagedTargets) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterTagedTargets");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTagedTargets, TargetArray) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTagedTargets::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTagedTargets, GameplayTag) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTagedTargets::GameplayTag' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTagedTargets, ReturnValue) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTagedTargets::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverDistance
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273A[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance, Distance) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance::Distance' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance, ReturnValue) == 0x00001C, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverXYRange
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         XYRange;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273B[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange, XYRange) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange::XYRange' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange, ReturnValue) == 0x00001C, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverZRange
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ZRange;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273C[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange, ZRange) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange::ZRange' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange, ReturnValue) == 0x00001C, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDirectionAngleAndAllowedAngle
// 0x0028 (0x0028 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         DirectionalAngle;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedAngle;                                      // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273D[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle) == 0x000028, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle, DirectionalAngle) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle::DirectionalAngle' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle, AllowedAngle) == 0x00001C, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle::AllowedAngle' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle, ReturnValue) == 0x000020, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDistance
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273E[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance, Distance) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance::Distance' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance, ReturnValue) == 0x00001C, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle
// 0x0028 (0x0028 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalAngle;                                  // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedAngle;                                      // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_273F[0x3];                                     // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle) == 0x000028, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle, Distance) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle::Distance' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle, DirectionalAngle) == 0x00001C, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle::DirectionalAngle' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle, AllowedAngle) == 0x000020, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle::AllowedAngle' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle, ReturnValue) == 0x000024, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinXYRange
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         XYRange;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2740[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange, XYRange) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange::XYRange' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange, ReturnValue) == 0x00001C, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle
// 0x0030 (0x0030 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         XYRange;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZRange;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalAngle;                                  // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedAngle;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2741[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle) == 0x000030, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle, XYRange) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle::XYRange' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle, ZRange) == 0x00001C, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle::ZRange' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle, DirectionalAngle) == 0x000020, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle::DirectionalAngle' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle, AllowedAngle) == 0x000024, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle::AllowedAngle' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle, ReturnValue) == 0x000028, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinZRange
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ZRange;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2742[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange, ZRange) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange::ZRange' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange, ReturnValue) == 0x00001C, "Member 'DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterUnTagedTargets
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2743[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets, TargetArray) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets, GameplayTag) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets::GameplayTag' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets, ReturnValue) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAggroMonster
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_GetAggroMonster final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCMonsterBase*>                 TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2744[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_GetAggroMonster) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_GetAggroMonster");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_GetAggroMonster) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_GetAggroMonster");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetAggroMonster, DCCharacterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_GetAggroMonster::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetAggroMonster, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_GetAggroMonster::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetAggroMonster, ReturnValue) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_GetAggroMonster::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAggroPoint
// 0x0018 (0x0018 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_GetAggroPoint final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       Target;                                            // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccessfully;                                     // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2745[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_GetAggroPoint) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_GetAggroPoint");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_GetAggroPoint) == 0x000018, "Wrong size on DCMonsterAISystemBlueprintLibrary_GetAggroPoint");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetAggroPoint, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_GetAggroPoint::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetAggroPoint, Target) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_GetAggroPoint::Target' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetAggroPoint, bSuccessfully) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_GetAggroPoint::bSuccessfully' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetAggroPoint, ReturnValue) == 0x000014, "Member 'DCMonsterAISystemBlueprintLibrary_GetAggroPoint::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAllTargetArray
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_GetAllTargetArray final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2746[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_GetAllTargetArray) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_GetAllTargetArray");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_GetAllTargetArray) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_GetAllTargetArray");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetAllTargetArray, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_GetAllTargetArray::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetAllTargetArray, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_GetAllTargetArray::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetAllTargetArray, ReturnValue) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_GetAllTargetArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetBaseAttributeValue
// 0x0048 (0x0048 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     GameplayAttribute;                                 // 0x0008(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccessfully;                                     // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2747[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0044(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue) == 0x000048, "Wrong size on DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue, DCCharacterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue, GameplayAttribute) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue::GameplayAttribute' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue, bSuccessfully) == 0x000040, "Member 'DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue::bSuccessfully' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue, ReturnValue) == 0x000044, "Member 'DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetCurrentAttributeValue
// 0x0048 (0x0048 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     GameplayAttribute;                                 // 0x0008(0x0038)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccessfully;                                     // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2748[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0044(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue) == 0x000048, "Wrong size on DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue, DCCharacterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue, GameplayAttribute) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue::GameplayAttribute' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue, bSuccessfully) == 0x000040, "Member 'DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue::bSuccessfully' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue, ReturnValue) == 0x000044, "Member 'DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetDamageTargetArray
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2749[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray, ReturnValue) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetHearingTargetArray
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274A[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray, ReturnValue) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetMinionCount
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_GetMinionCount final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274B[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_GetMinionCount) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_GetMinionCount");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_GetMinionCount) == 0x000010, "Wrong size on DCMonsterAISystemBlueprintLibrary_GetMinionCount");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetMinionCount, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_GetMinionCount::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetMinionCount, ReturnValue) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_GetMinionCount::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetSightTargetArray
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_GetSightTargetArray final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274C[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_GetSightTargetArray) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_GetSightTargetArray");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_GetSightTargetArray) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_GetSightTargetArray");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetSightTargetArray, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_GetSightTargetArray::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetSightTargetArray, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_GetSightTargetArray::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetSightTargetArray, ReturnValue) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_GetSightTargetArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetSummoner
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_GetSummoner final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_GetSummoner) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_GetSummoner");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_GetSummoner) == 0x000010, "Wrong size on DCMonsterAISystemBlueprintLibrary_GetSummoner");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetSummoner, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_GetSummoner::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_GetSummoner, ReturnValue) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_GetSummoner::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.IsAvailablePath
// 0x0028 (0x0028 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_IsAvailablePath final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DstLocation;                                       // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274D[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_IsAvailablePath) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_IsAvailablePath");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_IsAvailablePath) == 0x000028, "Wrong size on DCMonsterAISystemBlueprintLibrary_IsAvailablePath");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_IsAvailablePath, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_IsAvailablePath::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_IsAvailablePath, DstLocation) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_IsAvailablePath::DstLocation' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_IsAvailablePath, ReturnValue) == 0x000020, "Member 'DCMonsterAISystemBlueprintLibrary_IsAvailablePath::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.JumpToActor
// 0x0018 (0x0018 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_JumpToActor final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DstActor;                                          // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFavorHighArc;                                     // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274E[0x2];                                     // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_JumpToActor) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_JumpToActor");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_JumpToActor) == 0x000018, "Wrong size on DCMonsterAISystemBlueprintLibrary_JumpToActor");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_JumpToActor, DCCharacterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_JumpToActor::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_JumpToActor, DstActor) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_JumpToActor::DstActor' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_JumpToActor, Power) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_JumpToActor::Power' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_JumpToActor, bFavorHighArc) == 0x000014, "Member 'DCMonsterAISystemBlueprintLibrary_JumpToActor::bFavorHighArc' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_JumpToActor, ReturnValue) == 0x000015, "Member 'DCMonsterAISystemBlueprintLibrary_JumpToActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.JumpToLocation
// 0x0028 (0x0028 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_JumpToLocation final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DstLocation;                                       // 0x0008(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFavorHighArc;                                     // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0025(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274F[0x2];                                     // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_JumpToLocation) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_JumpToLocation");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_JumpToLocation) == 0x000028, "Wrong size on DCMonsterAISystemBlueprintLibrary_JumpToLocation");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_JumpToLocation, DCCharacterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_JumpToLocation::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_JumpToLocation, DstLocation) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_JumpToLocation::DstLocation' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_JumpToLocation, Power) == 0x000020, "Member 'DCMonsterAISystemBlueprintLibrary_JumpToLocation::Power' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_JumpToLocation, bFavorHighArc) == 0x000024, "Member 'DCMonsterAISystemBlueprintLibrary_JumpToLocation::bFavorHighArc' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_JumpToLocation, ReturnValue) == 0x000025, "Member 'DCMonsterAISystemBlueprintLibrary_JumpToLocation::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.MulAggro
// 0x0018 (0x0018 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_MulAggro final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       Target;                                            // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Point;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2750[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_MulAggro) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_MulAggro");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_MulAggro) == 0x000018, "Wrong size on DCMonsterAISystemBlueprintLibrary_MulAggro");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_MulAggro, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_MulAggro::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_MulAggro, Target) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_MulAggro::Target' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_MulAggro, Point) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_MulAggro::Point' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_MulAggro, ReturnValue) == 0x000014, "Member 'DCMonsterAISystemBlueprintLibrary_MulAggro::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickRandomTarget
// 0x0018 (0x0018 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_PickRandomTarget final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_PickRandomTarget) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_PickRandomTarget");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_PickRandomTarget) == 0x000018, "Wrong size on DCMonsterAISystemBlueprintLibrary_PickRandomTarget");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_PickRandomTarget, TargetArray) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_PickRandomTarget::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_PickRandomTarget, ReturnValue) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_PickRandomTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickTarget
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_PickTarget final
{
public:
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2751[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCCharacterBase*                       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_PickTarget) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_PickTarget");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_PickTarget) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_PickTarget");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_PickTarget, TargetArray) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_PickTarget::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_PickTarget, Param_Index) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_PickTarget::Param_Index' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_PickTarget, ReturnValue) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_PickTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickTopAggroTarget
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget, ReturnValue) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.RemoveAggro
// 0x0018 (0x0018 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_RemoveAggro final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       Target;                                            // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2752[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_RemoveAggro) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_RemoveAggro");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_RemoveAggro) == 0x000018, "Wrong size on DCMonsterAISystemBlueprintLibrary_RemoveAggro");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_RemoveAggro, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_RemoveAggro::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_RemoveAggro, Target) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_RemoveAggro::Target' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_RemoveAggro, ReturnValue) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_RemoveAggro::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.RemoveAggroAll
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_RemoveAggroAll final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2753[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_RemoveAggroAll) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_RemoveAggroAll");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_RemoveAggroAll) == 0x000010, "Wrong size on DCMonsterAISystemBlueprintLibrary_RemoveAggroAll");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_RemoveAggroAll, DCCharacterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_RemoveAggroAll::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_RemoveAggroAll, ReturnValue) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_RemoveAggroAll::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SetAggro
// 0x0018 (0x0018 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_SetAggro final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       Target;                                            // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Point;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2754[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_SetAggro) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_SetAggro");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_SetAggro) == 0x000018, "Wrong size on DCMonsterAISystemBlueprintLibrary_SetAggro");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SetAggro, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_SetAggro::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SetAggro, Target) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_SetAggro::Target' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SetAggro, Point) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_SetAggro::Point' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SetAggro, ReturnValue) == 0x000014, "Member 'DCMonsterAISystemBlueprintLibrary_SetAggro::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SetAggroRate
// 0x0018 (0x0018 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_SetAggroRate final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2755[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_SetAggroRate) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_SetAggroRate");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_SetAggroRate) == 0x000018, "Wrong size on DCMonsterAISystemBlueprintLibrary_SetAggroRate");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SetAggroRate, DCCharacterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_SetAggroRate::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SetAggroRate, Time) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_SetAggroRate::Time' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SetAggroRate, Rate) == 0x00000C, "Member 'DCMonsterAISystemBlueprintLibrary_SetAggroRate::Rate' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SetAggroRate, ReturnValue) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_SetAggroRate::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByAggro
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EMonsterFilterSortingType                     MonsterFilterSortingType;                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2756[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro, MonsterFilterSortingType) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro::MonsterFilterSortingType' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro, ReturnValue) == 0x000019, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByDistance
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EMonsterFilterSortingType                     MonsterFilterSortingType;                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2757[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance, MonsterFilterSortingType) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance::MonsterFilterSortingType' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance, ReturnValue) == 0x000019, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByDistanceAndPickTarget
// 0x0028 (0x0028 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EMonsterFilterSortingType                     MonsterFilterSortingType;                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2758[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Param_Index;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget) == 0x000028, "Wrong size on DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget, MonsterFilterSortingType) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget::MonsterFilterSortingType' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget, Param_Index) == 0x00001C, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget::Param_Index' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget, ReturnValue) == 0x000020, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByXYRange
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EMonsterFilterSortingType                     MonsterFilterSortingType;                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2759[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange, MonsterFilterSortingType) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange::MonsterFilterSortingType' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange, ReturnValue) == 0x000019, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByZRange
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADCCharacterBase*>               TargetArray;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EMonsterFilterSortingType                     MonsterFilterSortingType;                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275A[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange, TargetArray) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange::TargetArray' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange, MonsterFilterSortingType) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange::MonsterFilterSortingType' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange, ReturnValue) == 0x000019, "Member 'DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SpawnMinion
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_SpawnMinion final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADCMonsterBase>             MinionClass;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XYRange;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccessfully;                                     // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275B[0x3];                                     // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCCharacterBase*                       ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_SpawnMinion) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_SpawnMinion");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_SpawnMinion) == 0x000020, "Wrong size on DCMonsterAISystemBlueprintLibrary_SpawnMinion");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SpawnMinion, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_SpawnMinion::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SpawnMinion, MinionClass) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_SpawnMinion::MinionClass' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SpawnMinion, XYRange) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_SpawnMinion::XYRange' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SpawnMinion, bSuccessfully) == 0x000014, "Member 'DCMonsterAISystemBlueprintLibrary_SpawnMinion::bSuccessfully' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SpawnMinion, ReturnValue) == 0x000018, "Member 'DCMonsterAISystemBlueprintLibrary_SpawnMinion::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SubAggro
// 0x0018 (0x0018 - 0x0000)
struct DCMonsterAISystemBlueprintLibrary_SubAggro final
{
public:
	class ADCMonsterBase*                         DCMonsterBase;                                     // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCCharacterBase*                       Target;                                            // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Point;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275C[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterAISystemBlueprintLibrary_SubAggro) == 0x000008, "Wrong alignment on DCMonsterAISystemBlueprintLibrary_SubAggro");
static_assert(sizeof(DCMonsterAISystemBlueprintLibrary_SubAggro) == 0x000018, "Wrong size on DCMonsterAISystemBlueprintLibrary_SubAggro");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SubAggro, DCMonsterBase) == 0x000000, "Member 'DCMonsterAISystemBlueprintLibrary_SubAggro::DCMonsterBase' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SubAggro, Target) == 0x000008, "Member 'DCMonsterAISystemBlueprintLibrary_SubAggro::Target' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SubAggro, Point) == 0x000010, "Member 'DCMonsterAISystemBlueprintLibrary_SubAggro::Point' has a wrong offset!");
static_assert(offsetof(DCMonsterAISystemBlueprintLibrary_SubAggro, ReturnValue) == 0x000014, "Member 'DCMonsterAISystemBlueprintLibrary_SubAggro::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.BeforeDeath
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_BeforeDeath final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_BeforeDeath) == 0x000001, "Wrong alignment on DCMonsterBase_BeforeDeath");
static_assert(sizeof(DCMonsterBase_BeforeDeath) == 0x000001, "Wrong size on DCMonsterBase_BeforeDeath");
static_assert(offsetof(DCMonsterBase_BeforeDeath, ReturnValue) == 0x000000, "Member 'DCMonsterBase_BeforeDeath::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.Burrow
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_Burrow final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_Burrow) == 0x000001, "Wrong alignment on DCMonsterBase_Burrow");
static_assert(sizeof(DCMonsterBase_Burrow) == 0x000001, "Wrong size on DCMonsterBase_Burrow");
static_assert(offsetof(DCMonsterBase_Burrow, ReturnValue) == 0x000000, "Member 'DCMonsterBase_Burrow::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.ChangeOrientRotationToMovement
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_ChangeOrientRotationToMovement final
{
public:
	uint8                                         Value;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_ChangeOrientRotationToMovement) == 0x000001, "Wrong alignment on DCMonsterBase_ChangeOrientRotationToMovement");
static_assert(sizeof(DCMonsterBase_ChangeOrientRotationToMovement) == 0x000001, "Wrong size on DCMonsterBase_ChangeOrientRotationToMovement");
static_assert(offsetof(DCMonsterBase_ChangeOrientRotationToMovement, Value) == 0x000000, "Member 'DCMonsterBase_ChangeOrientRotationToMovement::Value' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.ChangePauseAnims
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_ChangePauseAnims final
{
public:
	uint8                                         Value;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_ChangePauseAnims) == 0x000001, "Wrong alignment on DCMonsterBase_ChangePauseAnims");
static_assert(sizeof(DCMonsterBase_ChangePauseAnims) == 0x000001, "Wrong size on DCMonsterBase_ChangePauseAnims");
static_assert(offsetof(DCMonsterBase_ChangePauseAnims, Value) == 0x000000, "Member 'DCMonsterBase_ChangePauseAnims::Value' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.CheckClassType
// 0x000C (0x000C - 0x0000)
struct DCMonsterBase_CheckClassType final
{
public:
	struct FGameplayTag                           InClassTypeTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_276A[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterBase_CheckClassType) == 0x000004, "Wrong alignment on DCMonsterBase_CheckClassType");
static_assert(sizeof(DCMonsterBase_CheckClassType) == 0x00000C, "Wrong size on DCMonsterBase_CheckClassType");
static_assert(offsetof(DCMonsterBase_CheckClassType, InClassTypeTag) == 0x000000, "Member 'DCMonsterBase_CheckClassType::InClassTypeTag' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_CheckClassType, ReturnValue) == 0x000008, "Member 'DCMonsterBase_CheckClassType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.CheckGradeType
// 0x000C (0x000C - 0x0000)
struct DCMonsterBase_CheckGradeType final
{
public:
	struct FGameplayTag                           InGradeTypeTag;                                    // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_276B[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterBase_CheckGradeType) == 0x000004, "Wrong alignment on DCMonsterBase_CheckGradeType");
static_assert(sizeof(DCMonsterBase_CheckGradeType) == 0x00000C, "Wrong size on DCMonsterBase_CheckGradeType");
static_assert(offsetof(DCMonsterBase_CheckGradeType, InGradeTypeTag) == 0x000000, "Member 'DCMonsterBase_CheckGradeType::InGradeTypeTag' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_CheckGradeType, ReturnValue) == 0x000008, "Member 'DCMonsterBase_CheckGradeType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.Death
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_Death final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_Death) == 0x000001, "Wrong alignment on DCMonsterBase_Death");
static_assert(sizeof(DCMonsterBase_Death) == 0x000001, "Wrong size on DCMonsterBase_Death");
static_assert(offsetof(DCMonsterBase_Death, ReturnValue) == 0x000000, "Member 'DCMonsterBase_Death::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.Fly
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_Fly final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_Fly) == 0x000001, "Wrong alignment on DCMonsterBase_Fly");
static_assert(sizeof(DCMonsterBase_Fly) == 0x000001, "Wrong size on DCMonsterBase_Fly");
static_assert(offsetof(DCMonsterBase_Fly, ReturnValue) == 0x000000, "Member 'DCMonsterBase_Fly::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.GetDesignDataMonster
// 0x00C0 (0x00C0 - 0x0000)
struct DCMonsterBase_GetDesignDataMonster final
{
public:
	struct FDesignDataMonster                     ReturnValue;                                       // 0x0000(0x00C0)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_GetDesignDataMonster) == 0x000008, "Wrong alignment on DCMonsterBase_GetDesignDataMonster");
static_assert(sizeof(DCMonsterBase_GetDesignDataMonster) == 0x0000C0, "Wrong size on DCMonsterBase_GetDesignDataMonster");
static_assert(offsetof(DCMonsterBase_GetDesignDataMonster, ReturnValue) == 0x000000, "Member 'DCMonsterBase_GetDesignDataMonster::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.GetMonsterId
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterBase_GetMonsterId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_GetMonsterId) == 0x000004, "Wrong alignment on DCMonsterBase_GetMonsterId");
static_assert(sizeof(DCMonsterBase_GetMonsterId) == 0x000010, "Wrong size on DCMonsterBase_GetMonsterId");
static_assert(offsetof(DCMonsterBase_GetMonsterId, ReturnValue) == 0x000000, "Member 'DCMonsterBase_GetMonsterId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.Interactable
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_Interactable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_Interactable) == 0x000001, "Wrong alignment on DCMonsterBase_Interactable");
static_assert(sizeof(DCMonsterBase_Interactable) == 0x000001, "Wrong size on DCMonsterBase_Interactable");
static_assert(offsetof(DCMonsterBase_Interactable, ReturnValue) == 0x000000, "Member 'DCMonsterBase_Interactable::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.InteractableOnly
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_InteractableOnly final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_InteractableOnly) == 0x000001, "Wrong alignment on DCMonsterBase_InteractableOnly");
static_assert(sizeof(DCMonsterBase_InteractableOnly) == 0x000001, "Wrong size on DCMonsterBase_InteractableOnly");
static_assert(offsetof(DCMonsterBase_InteractableOnly, ReturnValue) == 0x000000, "Member 'DCMonsterBase_InteractableOnly::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.InteractableWithoutHit
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_InteractableWithoutHit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_InteractableWithoutHit) == 0x000001, "Wrong alignment on DCMonsterBase_InteractableWithoutHit");
static_assert(sizeof(DCMonsterBase_InteractableWithoutHit) == 0x000001, "Wrong size on DCMonsterBase_InteractableWithoutHit");
static_assert(offsetof(DCMonsterBase_InteractableWithoutHit, ReturnValue) == 0x000000, "Member 'DCMonsterBase_InteractableWithoutHit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.Normal
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_Normal final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_Normal) == 0x000001, "Wrong alignment on DCMonsterBase_Normal");
static_assert(sizeof(DCMonsterBase_Normal) == 0x000001, "Wrong size on DCMonsterBase_Normal");
static_assert(offsetof(DCMonsterBase_Normal, ReturnValue) == 0x000000, "Member 'DCMonsterBase_Normal::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.NormalPhysics
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_NormalPhysics final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_NormalPhysics) == 0x000001, "Wrong alignment on DCMonsterBase_NormalPhysics");
static_assert(sizeof(DCMonsterBase_NormalPhysics) == 0x000001, "Wrong size on DCMonsterBase_NormalPhysics");
static_assert(offsetof(DCMonsterBase_NormalPhysics, ReturnValue) == 0x000000, "Member 'DCMonsterBase_NormalPhysics::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnDamaged
// 0x0008 (0x0008 - 0x0000)
struct DCMonsterBase_OnDamaged final
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnDamaged) == 0x000008, "Wrong alignment on DCMonsterBase_OnDamaged");
static_assert(sizeof(DCMonsterBase_OnDamaged) == 0x000008, "Wrong size on DCMonsterBase_OnDamaged");
static_assert(offsetof(DCMonsterBase_OnDamaged, DCCharacterBase) == 0x000000, "Member 'DCMonsterBase_OnDamaged::DCCharacterBase' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnFMsgGASAttributeNotifyBlueprint
// 0x0720 (0x0720 - 0x0000)
struct DCMonsterBase_OnFMsgGASAttributeNotifyBlueprint final
{
public:
	struct FMsgGASAttributeNotify                 InMsg;                                             // 0x0000(0x0720)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnFMsgGASAttributeNotifyBlueprint) == 0x000008, "Wrong alignment on DCMonsterBase_OnFMsgGASAttributeNotifyBlueprint");
static_assert(sizeof(DCMonsterBase_OnFMsgGASAttributeNotifyBlueprint) == 0x000720, "Wrong size on DCMonsterBase_OnFMsgGASAttributeNotifyBlueprint");
static_assert(offsetof(DCMonsterBase_OnFMsgGASAttributeNotifyBlueprint, InMsg) == 0x000000, "Member 'DCMonsterBase_OnFMsgGASAttributeNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnLostTarget
// 0x0008 (0x0008 - 0x0000)
struct DCMonsterBase_OnLostTarget final
{
public:
	class ADCCharacterBase*                       InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnLostTarget) == 0x000008, "Wrong alignment on DCMonsterBase_OnLostTarget");
static_assert(sizeof(DCMonsterBase_OnLostTarget) == 0x000008, "Wrong size on DCMonsterBase_OnLostTarget");
static_assert(offsetof(DCMonsterBase_OnLostTarget, InTarget) == 0x000000, "Member 'DCMonsterBase_OnLostTarget::InTarget' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnNewTarget
// 0x0008 (0x0008 - 0x0000)
struct DCMonsterBase_OnNewTarget final
{
public:
	class ADCCharacterBase*                       InTarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnNewTarget) == 0x000008, "Wrong alignment on DCMonsterBase_OnNewTarget");
static_assert(sizeof(DCMonsterBase_OnNewTarget) == 0x000008, "Wrong size on DCMonsterBase_OnNewTarget");
static_assert(offsetof(DCMonsterBase_OnNewTarget, InTarget) == 0x000000, "Member 'DCMonsterBase_OnNewTarget::InTarget' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnOverlapBegin
// 0x0108 (0x0108 - 0x0000)
struct DCMonsterBase_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_276C[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnOverlapBegin) == 0x000008, "Wrong alignment on DCMonsterBase_OnOverlapBegin");
static_assert(sizeof(DCMonsterBase_OnOverlapBegin) == 0x000108, "Wrong size on DCMonsterBase_OnOverlapBegin");
static_assert(offsetof(DCMonsterBase_OnOverlapBegin, OverlappedComponent) == 0x000000, "Member 'DCMonsterBase_OnOverlapBegin::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_OnOverlapBegin, OtherActor) == 0x000008, "Member 'DCMonsterBase_OnOverlapBegin::OtherActor' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_OnOverlapBegin, OtherComp) == 0x000010, "Member 'DCMonsterBase_OnOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_OnOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'DCMonsterBase_OnOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'DCMonsterBase_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_OnOverlapBegin, SweepResult) == 0x000020, "Member 'DCMonsterBase_OnOverlapBegin::SweepResult' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct DCMonsterBase_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_276D[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCMonsterBase_OnOverlapEnd) == 0x000008, "Wrong alignment on DCMonsterBase_OnOverlapEnd");
static_assert(sizeof(DCMonsterBase_OnOverlapEnd) == 0x000020, "Wrong size on DCMonsterBase_OnOverlapEnd");
static_assert(offsetof(DCMonsterBase_OnOverlapEnd, OverlappedComponent) == 0x000000, "Member 'DCMonsterBase_OnOverlapEnd::OverlappedComponent' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_OnOverlapEnd, OtherActor) == 0x000008, "Member 'DCMonsterBase_OnOverlapEnd::OtherActor' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_OnOverlapEnd, OtherComp) == 0x000010, "Member 'DCMonsterBase_OnOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_OnOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'DCMonsterBase_OnOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnRep_bIsRepRootMotionActive
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_OnRep_bIsRepRootMotionActive final
{
public:
	bool                                          InOldbIsRepRootMotionActive;                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnRep_bIsRepRootMotionActive) == 0x000001, "Wrong alignment on DCMonsterBase_OnRep_bIsRepRootMotionActive");
static_assert(sizeof(DCMonsterBase_OnRep_bIsRepRootMotionActive) == 0x000001, "Wrong size on DCMonsterBase_OnRep_bIsRepRootMotionActive");
static_assert(offsetof(DCMonsterBase_OnRep_bIsRepRootMotionActive, InOldbIsRepRootMotionActive) == 0x000000, "Member 'DCMonsterBase_OnRep_bIsRepRootMotionActive::InOldbIsRepRootMotionActive' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnRep_MonsterCollisionProfile
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_OnRep_MonsterCollisionProfile final
{
public:
	uint8                                         OldMonsterCollisionProfile;                        // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnRep_MonsterCollisionProfile) == 0x000001, "Wrong alignment on DCMonsterBase_OnRep_MonsterCollisionProfile");
static_assert(sizeof(DCMonsterBase_OnRep_MonsterCollisionProfile) == 0x000001, "Wrong size on DCMonsterBase_OnRep_MonsterCollisionProfile");
static_assert(offsetof(DCMonsterBase_OnRep_MonsterCollisionProfile, OldMonsterCollisionProfile) == 0x000000, "Member 'DCMonsterBase_OnRep_MonsterCollisionProfile::OldMonsterCollisionProfile' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnRep_MonsterId
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterBase_OnRep_MonsterId final
{
public:
	struct FPrimaryAssetId                        InOldMonsterId;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnRep_MonsterId) == 0x000004, "Wrong alignment on DCMonsterBase_OnRep_MonsterId");
static_assert(sizeof(DCMonsterBase_OnRep_MonsterId) == 0x000010, "Wrong size on DCMonsterBase_OnRep_MonsterId");
static_assert(offsetof(DCMonsterBase_OnRep_MonsterId, InOldMonsterId) == 0x000000, "Member 'DCMonsterBase_OnRep_MonsterId::InOldMonsterId' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnRep_OrientRotationToMovement
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_OnRep_OrientRotationToMovement final
{
public:
	uint8                                         OldOrientRotationToMovement;                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnRep_OrientRotationToMovement) == 0x000001, "Wrong alignment on DCMonsterBase_OnRep_OrientRotationToMovement");
static_assert(sizeof(DCMonsterBase_OnRep_OrientRotationToMovement) == 0x000001, "Wrong size on DCMonsterBase_OnRep_OrientRotationToMovement");
static_assert(offsetof(DCMonsterBase_OnRep_OrientRotationToMovement, OldOrientRotationToMovement) == 0x000000, "Member 'DCMonsterBase_OnRep_OrientRotationToMovement::OldOrientRotationToMovement' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnRep_PauseAnims
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_OnRep_PauseAnims final
{
public:
	uint8                                         OldPauseAnims;                                     // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnRep_PauseAnims) == 0x000001, "Wrong alignment on DCMonsterBase_OnRep_PauseAnims");
static_assert(sizeof(DCMonsterBase_OnRep_PauseAnims) == 0x000001, "Wrong size on DCMonsterBase_OnRep_PauseAnims");
static_assert(offsetof(DCMonsterBase_OnRep_PauseAnims, OldPauseAnims) == 0x000000, "Member 'DCMonsterBase_OnRep_PauseAnims::OldPauseAnims' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.OnStuckByShield
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterBase_OnStuckByShield final
{
public:
	class ADCCharacterBase*                       InInstigator;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 InEffectCauser;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_OnStuckByShield) == 0x000008, "Wrong alignment on DCMonsterBase_OnStuckByShield");
static_assert(sizeof(DCMonsterBase_OnStuckByShield) == 0x000010, "Wrong size on DCMonsterBase_OnStuckByShield");
static_assert(offsetof(DCMonsterBase_OnStuckByShield, InInstigator) == 0x000000, "Member 'DCMonsterBase_OnStuckByShield::InInstigator' has a wrong offset!");
static_assert(offsetof(DCMonsterBase_OnStuckByShield, InEffectCauser) == 0x000008, "Member 'DCMonsterBase_OnStuckByShield::InEffectCauser' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.SetDelayDeathStatus
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_SetDelayDeathStatus final
{
public:
	bool                                          bStatus;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_SetDelayDeathStatus) == 0x000001, "Wrong alignment on DCMonsterBase_SetDelayDeathStatus");
static_assert(sizeof(DCMonsterBase_SetDelayDeathStatus) == 0x000001, "Wrong size on DCMonsterBase_SetDelayDeathStatus");
static_assert(offsetof(DCMonsterBase_SetDelayDeathStatus, bStatus) == 0x000000, "Member 'DCMonsterBase_SetDelayDeathStatus::bStatus' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.SetMonsterId
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterBase_SetMonsterId final
{
public:
	struct FPrimaryAssetId                        InMonsterId;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_SetMonsterId) == 0x000004, "Wrong alignment on DCMonsterBase_SetMonsterId");
static_assert(sizeof(DCMonsterBase_SetMonsterId) == 0x000010, "Wrong size on DCMonsterBase_SetMonsterId");
static_assert(offsetof(DCMonsterBase_SetMonsterId, InMonsterId) == 0x000000, "Member 'DCMonsterBase_SetMonsterId::InMonsterId' has a wrong offset!");

// Function DungeonCrawler.DCMonsterBase.GetDelayDeathStatus
// 0x0001 (0x0001 - 0x0000)
struct DCMonsterBase_GetDelayDeathStatus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterBase_GetDelayDeathStatus) == 0x000001, "Wrong alignment on DCMonsterBase_GetDelayDeathStatus");
static_assert(sizeof(DCMonsterBase_GetDelayDeathStatus) == 0x000001, "Wrong size on DCMonsterBase_GetDelayDeathStatus");
static_assert(offsetof(DCMonsterBase_GetDelayDeathStatus, ReturnValue) == 0x000000, "Member 'DCMonsterBase_GetDelayDeathStatus::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCTrainingOptionWidgetBase.OnSetTrainingRewardInfo
// 0x0002 (0x0002 - 0x0000)
struct DCTrainingOptionWidgetBase_OnSetTrainingRewardInfo final
{
public:
	EDCTrainingState                              TrainingState;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCTrainingClassAbilityType                   ClassAbilityType;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTrainingOptionWidgetBase_OnSetTrainingRewardInfo) == 0x000001, "Wrong alignment on DCTrainingOptionWidgetBase_OnSetTrainingRewardInfo");
static_assert(sizeof(DCTrainingOptionWidgetBase_OnSetTrainingRewardInfo) == 0x000002, "Wrong size on DCTrainingOptionWidgetBase_OnSetTrainingRewardInfo");
static_assert(offsetof(DCTrainingOptionWidgetBase_OnSetTrainingRewardInfo, TrainingState) == 0x000000, "Member 'DCTrainingOptionWidgetBase_OnSetTrainingRewardInfo::TrainingState' has a wrong offset!");
static_assert(offsetof(DCTrainingOptionWidgetBase_OnSetTrainingRewardInfo, ClassAbilityType) == 0x000001, "Member 'DCTrainingOptionWidgetBase_OnSetTrainingRewardInfo::ClassAbilityType' has a wrong offset!");

// Function DungeonCrawler.DCMonsterGameplayAbilityBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct DCMonsterGameplayAbilityBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterGameplayAbilityBase_AbilityActivated) == 0x000008, "Wrong alignment on DCMonsterGameplayAbilityBase_AbilityActivated");
static_assert(sizeof(DCMonsterGameplayAbilityBase_AbilityActivated) == 0x0000B0, "Wrong size on DCMonsterGameplayAbilityBase_AbilityActivated");
static_assert(offsetof(DCMonsterGameplayAbilityBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'DCMonsterGameplayAbilityBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.DCMonsterSpawner.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCMonsterSpawner_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterSpawner_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCMonsterSpawner_BroadcastMsgBlueprint");
static_assert(sizeof(DCMonsterSpawner_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCMonsterSpawner_BroadcastMsgBlueprint");
static_assert(offsetof(DCMonsterSpawner_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCMonsterSpawner_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCMonsterSpawner.Spawns
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterSpawner_Spawns final
{
public:
	TArray<class ADCMonsterBase*>                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterSpawner_Spawns) == 0x000008, "Wrong alignment on DCMonsterSpawner_Spawns");
static_assert(sizeof(DCMonsterSpawner_Spawns) == 0x000010, "Wrong size on DCMonsterSpawner_Spawns");
static_assert(offsetof(DCMonsterSpawner_Spawns, ReturnValue) == 0x000000, "Member 'DCMonsterSpawner_Spawns::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMonsterSpawner.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCMonsterSpawner_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterSpawner_UnbindMsg) == 0x000008, "Wrong alignment on DCMonsterSpawner_UnbindMsg");
static_assert(sizeof(DCMonsterSpawner_UnbindMsg) == 0x000010, "Wrong size on DCMonsterSpawner_UnbindMsg");
static_assert(offsetof(DCMonsterSpawner_UnbindMsg, InMsgType) == 0x000000, "Member 'DCMonsterSpawner_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCMonsterSpawner_UnbindMsg, InObject) == 0x000008, "Member 'DCMonsterSpawner_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCMonsterSpawner.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCMonsterSpawner_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterSpawner_UnbindMsgAll) == 0x000008, "Wrong alignment on DCMonsterSpawner_UnbindMsgAll");
static_assert(sizeof(DCMonsterSpawner_UnbindMsgAll) == 0x000008, "Wrong size on DCMonsterSpawner_UnbindMsgAll");
static_assert(offsetof(DCMonsterSpawner_UnbindMsgAll, InObject) == 0x000000, "Member 'DCMonsterSpawner_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCMonsterSpawner.UpdateGameState
// 0x0008 (0x0008 - 0x0000)
struct DCMonsterSpawner_UpdateGameState final
{
public:
	struct FGameStateData                         InGameStateData;                                   // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMonsterSpawner_UpdateGameState) == 0x000004, "Wrong alignment on DCMonsterSpawner_UpdateGameState");
static_assert(sizeof(DCMonsterSpawner_UpdateGameState) == 0x000008, "Wrong size on DCMonsterSpawner_UpdateGameState");
static_assert(offsetof(DCMonsterSpawner_UpdateGameState, InGameStateData) == 0x000000, "Member 'DCMonsterSpawner_UpdateGameState::InGameStateData' has a wrong offset!");

// Function DungeonCrawler.DCMovementModeInterface.SetLadderMode
// 0x0008 (0x0008 - 0x0000)
struct DCMovementModeInterface_SetLadderMode final
{
public:
	class UBoxComponent*                          InLadderBoxComponent;                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMovementModeInterface_SetLadderMode) == 0x000008, "Wrong alignment on DCMovementModeInterface_SetLadderMode");
static_assert(sizeof(DCMovementModeInterface_SetLadderMode) == 0x000008, "Wrong size on DCMovementModeInterface_SetLadderMode");
static_assert(offsetof(DCMovementModeInterface_SetLadderMode, InLadderBoxComponent) == 0x000000, "Member 'DCMovementModeInterface_SetLadderMode::InLadderBoxComponent' has a wrong offset!");

// Function DungeonCrawler.DCMovementModeInterface.IsLadderMode
// 0x0001 (0x0001 - 0x0000)
struct DCMovementModeInterface_IsLadderMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMovementModeInterface_IsLadderMode) == 0x000001, "Wrong alignment on DCMovementModeInterface_IsLadderMode");
static_assert(sizeof(DCMovementModeInterface_IsLadderMode) == 0x000001, "Wrong size on DCMovementModeInterface_IsLadderMode");
static_assert(offsetof(DCMovementModeInterface_IsLadderMode, ReturnValue) == 0x000000, "Member 'DCMovementModeInterface_IsLadderMode::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMultiLineEditableTextBox.Goto
// 0x0008 (0x0008 - 0x0000)
struct DCMultiLineEditableTextBox_Goto final
{
public:
	int32                                         InLineIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InOffset;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMultiLineEditableTextBox_Goto) == 0x000004, "Wrong alignment on DCMultiLineEditableTextBox_Goto");
static_assert(sizeof(DCMultiLineEditableTextBox_Goto) == 0x000008, "Wrong size on DCMultiLineEditableTextBox_Goto");
static_assert(offsetof(DCMultiLineEditableTextBox_Goto, InLineIndex) == 0x000000, "Member 'DCMultiLineEditableTextBox_Goto::InLineIndex' has a wrong offset!");
static_assert(offsetof(DCMultiLineEditableTextBox_Goto, InOffset) == 0x000004, "Member 'DCMultiLineEditableTextBox_Goto::InOffset' has a wrong offset!");

// Function DungeonCrawler.DCMultiLineEditableTextBox.AnyTextSelected
// 0x0001 (0x0001 - 0x0000)
struct DCMultiLineEditableTextBox_AnyTextSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMultiLineEditableTextBox_AnyTextSelected) == 0x000001, "Wrong alignment on DCMultiLineEditableTextBox_AnyTextSelected");
static_assert(sizeof(DCMultiLineEditableTextBox_AnyTextSelected) == 0x000001, "Wrong size on DCMultiLineEditableTextBox_AnyTextSelected");
static_assert(offsetof(DCMultiLineEditableTextBox_AnyTextSelected, ReturnValue) == 0x000000, "Member 'DCMultiLineEditableTextBox_AnyTextSelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMultiLineEditableTextBox.InsertTextAtCursor
// 0x0010 (0x0010 - 0x0000)
struct DCMultiLineEditableTextBox_InsertTextAtCursor final
{
public:
	class FString                                 InText;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMultiLineEditableTextBox_InsertTextAtCursor) == 0x000008, "Wrong alignment on DCMultiLineEditableTextBox_InsertTextAtCursor");
static_assert(sizeof(DCMultiLineEditableTextBox_InsertTextAtCursor) == 0x000010, "Wrong size on DCMultiLineEditableTextBox_InsertTextAtCursor");
static_assert(offsetof(DCMultiLineEditableTextBox_InsertTextAtCursor, InText) == 0x000000, "Member 'DCMultiLineEditableTextBox_InsertTextAtCursor::InText' has a wrong offset!");

// Function DungeonCrawler.DCTooltipWidget.SetTooltipData
// 0x0030 (0x0030 - 0x0000)
struct DCTooltipWidget_SetTooltipData final
{
public:
	class FText                                   InNameText;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InDescriptionText;                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTooltipWidget_SetTooltipData) == 0x000008, "Wrong alignment on DCTooltipWidget_SetTooltipData");
static_assert(sizeof(DCTooltipWidget_SetTooltipData) == 0x000030, "Wrong size on DCTooltipWidget_SetTooltipData");
static_assert(offsetof(DCTooltipWidget_SetTooltipData, InNameText) == 0x000000, "Member 'DCTooltipWidget_SetTooltipData::InNameText' has a wrong offset!");
static_assert(offsetof(DCTooltipWidget_SetTooltipData, InDescriptionText) == 0x000018, "Member 'DCTooltipWidget_SetTooltipData::InDescriptionText' has a wrong offset!");

// Function DungeonCrawler.DCMusicTooltipWidget.SetType
// 0x0008 (0x0008 - 0x0000)
struct DCMusicTooltipWidget_SetType final
{
public:
	struct FGameplayTag                           SourceTypeTag;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMusicTooltipWidget_SetType) == 0x000004, "Wrong alignment on DCMusicTooltipWidget_SetType");
static_assert(sizeof(DCMusicTooltipWidget_SetType) == 0x000008, "Wrong size on DCMusicTooltipWidget_SetType");
static_assert(offsetof(DCMusicTooltipWidget_SetType, SourceTypeTag) == 0x000000, "Member 'DCMusicTooltipWidget_SetType::SourceTypeTag' has a wrong offset!");

// Function DungeonCrawler.DCMusicWidgetBase.GetMusicTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCMusicWidgetBase_GetMusicTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMusicWidgetBase_GetMusicTooltipWidget) == 0x000008, "Wrong alignment on DCMusicWidgetBase_GetMusicTooltipWidget");
static_assert(sizeof(DCMusicWidgetBase_GetMusicTooltipWidget) == 0x000008, "Wrong size on DCMusicWidgetBase_GetMusicTooltipWidget");
static_assert(offsetof(DCMusicWidgetBase_GetMusicTooltipWidget, ReturnValue) == 0x000000, "Member 'DCMusicWidgetBase_GetMusicTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCMusicWidgetBase.OnArtDataSet
// 0x0008 (0x0008 - 0x0000)
struct DCMusicWidgetBase_OnArtDataSet final
{
public:
	const class UArtDataMusic*                    ArtData;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCMusicWidgetBase_OnArtDataSet) == 0x000008, "Wrong alignment on DCMusicWidgetBase_OnArtDataSet");
static_assert(sizeof(DCMusicWidgetBase_OnArtDataSet) == 0x000008, "Wrong size on DCMusicWidgetBase_OnArtDataSet");
static_assert(offsetof(DCMusicWidgetBase_OnArtDataSet, ArtData) == 0x000000, "Member 'DCMusicWidgetBase_OnArtDataSet::ArtData' has a wrong offset!");

// Function DungeonCrawler.DCNavigationSystem.FindPathToLocation
// 0x0050 (0x0050 - 0x0000)
struct DCNavigationSystem_FindPathToLocation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathStart;                                         // 0x0008(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathEnd;                                           // 0x0020(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PathfindingContext;                                // 0x0038(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0040(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2775[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCNavigationSystem_FindPathToLocation) == 0x000008, "Wrong alignment on DCNavigationSystem_FindPathToLocation");
static_assert(sizeof(DCNavigationSystem_FindPathToLocation) == 0x000050, "Wrong size on DCNavigationSystem_FindPathToLocation");
static_assert(offsetof(DCNavigationSystem_FindPathToLocation, WorldContextObject) == 0x000000, "Member 'DCNavigationSystem_FindPathToLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCNavigationSystem_FindPathToLocation, PathStart) == 0x000008, "Member 'DCNavigationSystem_FindPathToLocation::PathStart' has a wrong offset!");
static_assert(offsetof(DCNavigationSystem_FindPathToLocation, PathEnd) == 0x000020, "Member 'DCNavigationSystem_FindPathToLocation::PathEnd' has a wrong offset!");
static_assert(offsetof(DCNavigationSystem_FindPathToLocation, PathfindingContext) == 0x000038, "Member 'DCNavigationSystem_FindPathToLocation::PathfindingContext' has a wrong offset!");
static_assert(offsetof(DCNavigationSystem_FindPathToLocation, FilterClass) == 0x000040, "Member 'DCNavigationSystem_FindPathToLocation::FilterClass' has a wrong offset!");
static_assert(offsetof(DCNavigationSystem_FindPathToLocation, ReturnValue) == 0x000048, "Member 'DCNavigationSystem_FindPathToLocation::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShapeShiftWidgetBase.GetShapeShiftTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCShapeShiftWidgetBase_GetShapeShiftTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShapeShiftWidgetBase_GetShapeShiftTooltipWidget) == 0x000008, "Wrong alignment on DCShapeShiftWidgetBase_GetShapeShiftTooltipWidget");
static_assert(sizeof(DCShapeShiftWidgetBase_GetShapeShiftTooltipWidget) == 0x000008, "Wrong size on DCShapeShiftWidgetBase_GetShapeShiftTooltipWidget");
static_assert(offsetof(DCShapeShiftWidgetBase_GetShapeShiftTooltipWidget, ReturnValue) == 0x000000, "Member 'DCShapeShiftWidgetBase_GetShapeShiftTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShapeShiftWidgetBase.OnArtDataSet
// 0x0008 (0x0008 - 0x0000)
struct DCShapeShiftWidgetBase_OnArtDataSet final
{
public:
	const class UDCCharacterShapeShiftArtData*    ArtData;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShapeShiftWidgetBase_OnArtDataSet) == 0x000008, "Wrong alignment on DCShapeShiftWidgetBase_OnArtDataSet");
static_assert(sizeof(DCShapeShiftWidgetBase_OnArtDataSet) == 0x000008, "Wrong size on DCShapeShiftWidgetBase_OnArtDataSet");
static_assert(offsetof(DCShapeShiftWidgetBase_OnArtDataSet, ArtData) == 0x000000, "Member 'DCShapeShiftWidgetBase_OnArtDataSet::ArtData' has a wrong offset!");

// Function DungeonCrawler.DCNPCExpressman.ExpressReaction
// 0x0001 (0x0001 - 0x0000)
struct DCNPCExpressman_ExpressReaction final
{
public:
	bool                                          bIsReaction;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCNPCExpressman_ExpressReaction) == 0x000001, "Wrong alignment on DCNPCExpressman_ExpressReaction");
static_assert(sizeof(DCNPCExpressman_ExpressReaction) == 0x000001, "Wrong size on DCNPCExpressman_ExpressReaction");
static_assert(offsetof(DCNPCExpressman_ExpressReaction, bIsReaction) == 0x000000, "Member 'DCNPCExpressman_ExpressReaction::bIsReaction' has a wrong offset!");

// Function DungeonCrawler.DCPartyManager.Add
// 0x0020 (0x0020 - 0x0000)
struct DCPartyManager_Add final
{
public:
	struct FDCPartyId                             PartyId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCAccountId                           AccountId;                                         // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPartyManager_Add) == 0x000008, "Wrong alignment on DCPartyManager_Add");
static_assert(sizeof(DCPartyManager_Add) == 0x000020, "Wrong size on DCPartyManager_Add");
static_assert(offsetof(DCPartyManager_Add, PartyId) == 0x000000, "Member 'DCPartyManager_Add::PartyId' has a wrong offset!");
static_assert(offsetof(DCPartyManager_Add, AccountId) == 0x000010, "Member 'DCPartyManager_Add::AccountId' has a wrong offset!");

// Function DungeonCrawler.DCPartyManager.OnPlayerAdded
// 0x00E0 (0x00E0 - 0x0000)
struct DCPartyManager_OnPlayerAdded final
{
public:
	struct FDCPlayerInfo                          Info;                                              // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPartyManager_OnPlayerAdded) == 0x000008, "Wrong alignment on DCPartyManager_OnPlayerAdded");
static_assert(sizeof(DCPartyManager_OnPlayerAdded) == 0x0000E0, "Wrong size on DCPartyManager_OnPlayerAdded");
static_assert(offsetof(DCPartyManager_OnPlayerAdded, Info) == 0x000000, "Member 'DCPartyManager_OnPlayerAdded::Info' has a wrong offset!");

// Function DungeonCrawler.DCPartyManager.OnPlayerRemoved
// 0x00E0 (0x00E0 - 0x0000)
struct DCPartyManager_OnPlayerRemoved final
{
public:
	struct FDCPlayerInfo                          RemovedPlayer;                                     // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPartyManager_OnPlayerRemoved) == 0x000008, "Wrong alignment on DCPartyManager_OnPlayerRemoved");
static_assert(sizeof(DCPartyManager_OnPlayerRemoved) == 0x0000E0, "Wrong size on DCPartyManager_OnPlayerRemoved");
static_assert(offsetof(DCPartyManager_OnPlayerRemoved, RemovedPlayer) == 0x000000, "Member 'DCPartyManager_OnPlayerRemoved::RemovedPlayer' has a wrong offset!");

// Function DungeonCrawler.DCPartyManager.OnPlayerUpdated
// 0x01C0 (0x01C0 - 0x0000)
struct DCPartyManager_OnPlayerUpdated final
{
public:
	struct FDCPlayerInfo                          NewInfo;                                           // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FDCPlayerInfo                          OldInfo;                                           // 0x00E0(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPartyManager_OnPlayerUpdated) == 0x000008, "Wrong alignment on DCPartyManager_OnPlayerUpdated");
static_assert(sizeof(DCPartyManager_OnPlayerUpdated) == 0x0001C0, "Wrong size on DCPartyManager_OnPlayerUpdated");
static_assert(offsetof(DCPartyManager_OnPlayerUpdated, NewInfo) == 0x000000, "Member 'DCPartyManager_OnPlayerUpdated::NewInfo' has a wrong offset!");
static_assert(offsetof(DCPartyManager_OnPlayerUpdated, OldInfo) == 0x0000E0, "Member 'DCPartyManager_OnPlayerUpdated::OldInfo' has a wrong offset!");

// Function DungeonCrawler.DCPartyManager.Remove
// 0x0020 (0x0020 - 0x0000)
struct DCPartyManager_Remove final
{
public:
	struct FDCPartyId                             PartyId;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCAccountId                           AccountId;                                         // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPartyManager_Remove) == 0x000008, "Wrong alignment on DCPartyManager_Remove");
static_assert(sizeof(DCPartyManager_Remove) == 0x000020, "Wrong size on DCPartyManager_Remove");
static_assert(offsetof(DCPartyManager_Remove, PartyId) == 0x000000, "Member 'DCPartyManager_Remove::PartyId' has a wrong offset!");
static_assert(offsetof(DCPartyManager_Remove, AccountId) == 0x000010, "Member 'DCPartyManager_Remove::AccountId' has a wrong offset!");

// Function DungeonCrawler.DCPartyManager.Update
// 0x00E0 (0x00E0 - 0x0000)
struct DCPartyManager_Update final
{
public:
	struct FDCPlayerInfo                          Info;                                              // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPartyManager_Update) == 0x000008, "Wrong alignment on DCPartyManager_Update");
static_assert(sizeof(DCPartyManager_Update) == 0x0000E0, "Wrong size on DCPartyManager_Update");
static_assert(offsetof(DCPartyManager_Update, Info) == 0x000000, "Member 'DCPartyManager_Update::Info' has a wrong offset!");

// Function DungeonCrawler.DCPartyManager.GetParties
// 0x0010 (0x0010 - 0x0000)
struct DCPartyManager_GetParties final
{
public:
	TArray<struct FDCPartyId>                     ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPartyManager_GetParties) == 0x000008, "Wrong alignment on DCPartyManager_GetParties");
static_assert(sizeof(DCPartyManager_GetParties) == 0x000010, "Wrong size on DCPartyManager_GetParties");
static_assert(offsetof(DCPartyManager_GetParties, ReturnValue) == 0x000000, "Member 'DCPartyManager_GetParties::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPedestalPortal.OnBlizzardData
// 0x0040 (0x0040 - 0x0000)
struct DCPedestalPortal_OnBlizzardData final
{
public:
	struct FGameBlizzardData                      InBlizzardData;                                    // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPedestalPortal_OnBlizzardData) == 0x000008, "Wrong alignment on DCPedestalPortal_OnBlizzardData");
static_assert(sizeof(DCPedestalPortal_OnBlizzardData) == 0x000040, "Wrong size on DCPedestalPortal_OnBlizzardData");
static_assert(offsetof(DCPedestalPortal_OnBlizzardData, InBlizzardData) == 0x000000, "Member 'DCPedestalPortal_OnBlizzardData::InBlizzardData' has a wrong offset!");

// Function DungeonCrawler.DCPedestalPortal.OnDeathSwarmData
// 0x0080 (0x0080 - 0x0000)
struct DCPedestalPortal_OnDeathSwarmData final
{
public:
	struct FGameDeathSwarmData                    InDeathSwarmData;                                  // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPedestalPortal_OnDeathSwarmData) == 0x000008, "Wrong alignment on DCPedestalPortal_OnDeathSwarmData");
static_assert(sizeof(DCPedestalPortal_OnDeathSwarmData) == 0x000080, "Wrong size on DCPedestalPortal_OnDeathSwarmData");
static_assert(offsetof(DCPedestalPortal_OnDeathSwarmData, InDeathSwarmData) == 0x000000, "Member 'DCPedestalPortal_OnDeathSwarmData::InDeathSwarmData' has a wrong offset!");

// Function DungeonCrawler.DCPedestalPortal.OnFloorRuleData
// 0x0040 (0x0040 - 0x0000)
struct DCPedestalPortal_OnFloorRuleData final
{
public:
	struct FGameFloorRuleData                     InFloorRuleData;                                   // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPedestalPortal_OnFloorRuleData) == 0x000008, "Wrong alignment on DCPedestalPortal_OnFloorRuleData");
static_assert(sizeof(DCPedestalPortal_OnFloorRuleData) == 0x000040, "Wrong size on DCPedestalPortal_OnFloorRuleData");
static_assert(offsetof(DCPedestalPortal_OnFloorRuleData, InFloorRuleData) == 0x000000, "Member 'DCPedestalPortal_OnFloorRuleData::InFloorRuleData' has a wrong offset!");

// Function DungeonCrawler.DCPedestalPortal.OnRep_ConfirmedPedestalPortalScrollType
// 0x0001 (0x0001 - 0x0000)
struct DCPedestalPortal_OnRep_ConfirmedPedestalPortalScrollType final
{
public:
	EDCPortalScrollType                           InOldConfirmedPedestalPortalScrollType;            // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPedestalPortal_OnRep_ConfirmedPedestalPortalScrollType) == 0x000001, "Wrong alignment on DCPedestalPortal_OnRep_ConfirmedPedestalPortalScrollType");
static_assert(sizeof(DCPedestalPortal_OnRep_ConfirmedPedestalPortalScrollType) == 0x000001, "Wrong size on DCPedestalPortal_OnRep_ConfirmedPedestalPortalScrollType");
static_assert(offsetof(DCPedestalPortal_OnRep_ConfirmedPedestalPortalScrollType, InOldConfirmedPedestalPortalScrollType) == 0x000000, "Member 'DCPedestalPortal_OnRep_ConfirmedPedestalPortalScrollType::InOldConfirmedPedestalPortalScrollType' has a wrong offset!");

// Function DungeonCrawler.DCPedestalPortalScrollBase.BeginOverlapPortal
// 0x0108 (0x0108 - 0x0000)
struct DCPedestalPortalScrollBase_BeginOverlapPortal final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndx;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2782[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPedestalPortalScrollBase_BeginOverlapPortal) == 0x000008, "Wrong alignment on DCPedestalPortalScrollBase_BeginOverlapPortal");
static_assert(sizeof(DCPedestalPortalScrollBase_BeginOverlapPortal) == 0x000108, "Wrong size on DCPedestalPortalScrollBase_BeginOverlapPortal");
static_assert(offsetof(DCPedestalPortalScrollBase_BeginOverlapPortal, OverlappedComp) == 0x000000, "Member 'DCPedestalPortalScrollBase_BeginOverlapPortal::OverlappedComp' has a wrong offset!");
static_assert(offsetof(DCPedestalPortalScrollBase_BeginOverlapPortal, OtherActor) == 0x000008, "Member 'DCPedestalPortalScrollBase_BeginOverlapPortal::OtherActor' has a wrong offset!");
static_assert(offsetof(DCPedestalPortalScrollBase_BeginOverlapPortal, OtherComp) == 0x000010, "Member 'DCPedestalPortalScrollBase_BeginOverlapPortal::OtherComp' has a wrong offset!");
static_assert(offsetof(DCPedestalPortalScrollBase_BeginOverlapPortal, OtherBodyIndx) == 0x000018, "Member 'DCPedestalPortalScrollBase_BeginOverlapPortal::OtherBodyIndx' has a wrong offset!");
static_assert(offsetof(DCPedestalPortalScrollBase_BeginOverlapPortal, bFromSweep) == 0x00001C, "Member 'DCPedestalPortalScrollBase_BeginOverlapPortal::bFromSweep' has a wrong offset!");
static_assert(offsetof(DCPedestalPortalScrollBase_BeginOverlapPortal, SweepResult) == 0x000020, "Member 'DCPedestalPortalScrollBase_BeginOverlapPortal::SweepResult' has a wrong offset!");

// Function DungeonCrawler.DCPedestalPortalScrollBase.ClosePortalScroll
// 0x0008 (0x0008 - 0x0000)
struct DCPedestalPortalScrollBase_ClosePortalScroll final
{
public:
	class ADCPlayerCharacterBase*                 Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPedestalPortalScrollBase_ClosePortalScroll) == 0x000008, "Wrong alignment on DCPedestalPortalScrollBase_ClosePortalScroll");
static_assert(sizeof(DCPedestalPortalScrollBase_ClosePortalScroll) == 0x000008, "Wrong size on DCPedestalPortalScrollBase_ClosePortalScroll");
static_assert(offsetof(DCPedestalPortalScrollBase_ClosePortalScroll, Character) == 0x000000, "Member 'DCPedestalPortalScrollBase_ClosePortalScroll::Character' has a wrong offset!");

// Function DungeonCrawler.DCPerkDataComponent.OnRep_PerkDataIds
// 0x0010 (0x0010 - 0x0000)
struct DCPerkDataComponent_OnRep_PerkDataIds final
{
public:
	TArray<struct FPrimaryAssetId>                OldValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPerkDataComponent_OnRep_PerkDataIds) == 0x000008, "Wrong alignment on DCPerkDataComponent_OnRep_PerkDataIds");
static_assert(sizeof(DCPerkDataComponent_OnRep_PerkDataIds) == 0x000010, "Wrong size on DCPerkDataComponent_OnRep_PerkDataIds");
static_assert(offsetof(DCPerkDataComponent_OnRep_PerkDataIds, OldValue) == 0x000000, "Member 'DCPerkDataComponent_OnRep_PerkDataIds::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerBlueprintFunctionLibrary.GetCurrentPlayerPawn
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn) == 0x000008, "Wrong alignment on DCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn");
static_assert(sizeof(DCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn) == 0x000010, "Wrong size on DCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn");
static_assert(offsetof(DCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn, WorldContextObject) == 0x000000, "Member 'DCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn, ReturnValue) == 0x000008, "Member 'DCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerBlueprintFunctionLibrary.Log
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerBlueprintFunctionLibrary_Log final
{
public:
	class FString                                 Str;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerBlueprintFunctionLibrary_Log) == 0x000008, "Wrong alignment on DCPlayerBlueprintFunctionLibrary_Log");
static_assert(sizeof(DCPlayerBlueprintFunctionLibrary_Log) == 0x000010, "Wrong size on DCPlayerBlueprintFunctionLibrary_Log");
static_assert(offsetof(DCPlayerBlueprintFunctionLibrary_Log, Str) == 0x000000, "Member 'DCPlayerBlueprintFunctionLibrary_Log::Str' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.ChangeGender_Server
// 0x0001 (0x0001 - 0x0000)
struct DCPlayerCharacterBase_ChangeGender_Server final
{
public:
	EDCGender                                     Gender;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_ChangeGender_Server) == 0x000001, "Wrong alignment on DCPlayerCharacterBase_ChangeGender_Server");
static_assert(sizeof(DCPlayerCharacterBase_ChangeGender_Server) == 0x000001, "Wrong size on DCPlayerCharacterBase_ChangeGender_Server");
static_assert(offsetof(DCPlayerCharacterBase_ChangeGender_Server, Gender) == 0x000000, "Member 'DCPlayerCharacterBase_ChangeGender_Server::Gender' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.ClientShowSystemMessage
// 0x0018 (0x0018 - 0x0000)
struct DCPlayerCharacterBase_ClientShowSystemMessage final
{
public:
	class FText                                   MessageText;                                       // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_ClientShowSystemMessage) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_ClientShowSystemMessage");
static_assert(sizeof(DCPlayerCharacterBase_ClientShowSystemMessage) == 0x000018, "Wrong size on DCPlayerCharacterBase_ClientShowSystemMessage");
static_assert(offsetof(DCPlayerCharacterBase_ClientShowSystemMessage, MessageText) == 0x000000, "Member 'DCPlayerCharacterBase_ClientShowSystemMessage::MessageText' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.GetFootstepLocationWithGameplayTag
// 0x0100 (0x0100 - 0x0000)
struct DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InFootstepTag;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0010(0x00E8)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2792[0x7];                                     // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag");
static_assert(sizeof(DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag) == 0x000100, "Wrong size on DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag");
static_assert(offsetof(DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag, WorldContextObject) == 0x000000, "Member 'DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag, InFootstepTag) == 0x000008, "Member 'DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag::InFootstepTag' has a wrong offset!");
static_assert(offsetof(DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag, HitResult) == 0x000010, "Member 'DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag::HitResult' has a wrong offset!");
static_assert(offsetof(DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag, ReturnValue) == 0x0000F8, "Member 'DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.GetHoldingItemActors
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerCharacterBase_GetHoldingItemActors final
{
public:
	TArray<class AItemActor*>                     OutItemActors;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_GetHoldingItemActors) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_GetHoldingItemActors");
static_assert(sizeof(DCPlayerCharacterBase_GetHoldingItemActors) == 0x000010, "Wrong size on DCPlayerCharacterBase_GetHoldingItemActors");
static_assert(offsetof(DCPlayerCharacterBase_GetHoldingItemActors, OutItemActors) == 0x000000, "Member 'DCPlayerCharacterBase_GetHoldingItemActors::OutItemActors' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.OnActionSkinChanged
// 0x0010 (0x0010 - 0x0000)
struct DCPlayerCharacterBase_OnActionSkinChanged final
{
public:
	const class UDCActionSkinDataAsset*           ActionSkinData;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquipped;                                       // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2793[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCPlayerCharacterBase_OnActionSkinChanged) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_OnActionSkinChanged");
static_assert(sizeof(DCPlayerCharacterBase_OnActionSkinChanged) == 0x000010, "Wrong size on DCPlayerCharacterBase_OnActionSkinChanged");
static_assert(offsetof(DCPlayerCharacterBase_OnActionSkinChanged, ActionSkinData) == 0x000000, "Member 'DCPlayerCharacterBase_OnActionSkinChanged::ActionSkinData' has a wrong offset!");
static_assert(offsetof(DCPlayerCharacterBase_OnActionSkinChanged, bIsEquipped) == 0x000008, "Member 'DCPlayerCharacterBase_OnActionSkinChanged::bIsEquipped' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.OnRep_CharacterKey
// 0x0002 (0x0002 - 0x0000)
struct DCPlayerCharacterBase_OnRep_CharacterKey final
{
public:
	struct FDCPlayerCharacterKey                  Old;                                               // 0x0000(0x0002)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_OnRep_CharacterKey) == 0x000001, "Wrong alignment on DCPlayerCharacterBase_OnRep_CharacterKey");
static_assert(sizeof(DCPlayerCharacterBase_OnRep_CharacterKey) == 0x000002, "Wrong size on DCPlayerCharacterBase_OnRep_CharacterKey");
static_assert(offsetof(DCPlayerCharacterBase_OnRep_CharacterKey, Old) == 0x000000, "Member 'DCPlayerCharacterBase_OnRep_CharacterKey::Old' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.ResetDungeonModuleData
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerCharacterBase_ResetDungeonModuleData final
{
public:
	const class UDCDungeonModuleDataAsset*        InDungeonModuleData;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_ResetDungeonModuleData) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_ResetDungeonModuleData");
static_assert(sizeof(DCPlayerCharacterBase_ResetDungeonModuleData) == 0x000008, "Wrong size on DCPlayerCharacterBase_ResetDungeonModuleData");
static_assert(offsetof(DCPlayerCharacterBase_ResetDungeonModuleData, InDungeonModuleData) == 0x000000, "Member 'DCPlayerCharacterBase_ResetDungeonModuleData::InDungeonModuleData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.SetDungeonModuleData
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerCharacterBase_SetDungeonModuleData final
{
public:
	const class UDCDungeonModuleDataAsset*        InDungeonModuleData;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_SetDungeonModuleData) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_SetDungeonModuleData");
static_assert(sizeof(DCPlayerCharacterBase_SetDungeonModuleData) == 0x000008, "Wrong size on DCPlayerCharacterBase_SetDungeonModuleData");
static_assert(offsetof(DCPlayerCharacterBase_SetDungeonModuleData, InDungeonModuleData) == 0x000000, "Member 'DCPlayerCharacterBase_SetDungeonModuleData::InDungeonModuleData' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.SetWindforceToMovement
// 0x0018 (0x0018 - 0x0000)
struct DCPlayerCharacterBase_SetWindforceToMovement final
{
public:
	struct FVector                                WindVector;                                        // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_SetWindforceToMovement) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_SetWindforceToMovement");
static_assert(sizeof(DCPlayerCharacterBase_SetWindforceToMovement) == 0x000018, "Wrong size on DCPlayerCharacterBase_SetWindforceToMovement");
static_assert(offsetof(DCPlayerCharacterBase_SetWindforceToMovement, WindVector) == 0x000000, "Member 'DCPlayerCharacterBase_SetWindforceToMovement::WindVector' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.SetWindforceVector
// 0x0018 (0x0018 - 0x0000)
struct DCPlayerCharacterBase_SetWindforceVector final
{
public:
	struct FVector                                WindforceVec;                                      // 0x0000(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_SetWindforceVector) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_SetWindforceVector");
static_assert(sizeof(DCPlayerCharacterBase_SetWindforceVector) == 0x000018, "Wrong size on DCPlayerCharacterBase_SetWindforceVector");
static_assert(offsetof(DCPlayerCharacterBase_SetWindforceVector, WindforceVec) == 0x000000, "Member 'DCPlayerCharacterBase_SetWindforceVector::WindforceVec' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.GetEquipmentComponentV2
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerCharacterBase_GetEquipmentComponentV2 final
{
public:
	class UDCEquipmentComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_GetEquipmentComponentV2) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_GetEquipmentComponentV2");
static_assert(sizeof(DCPlayerCharacterBase_GetEquipmentComponentV2) == 0x000008, "Wrong size on DCPlayerCharacterBase_GetEquipmentComponentV2");
static_assert(offsetof(DCPlayerCharacterBase_GetEquipmentComponentV2, ReturnValue) == 0x000000, "Member 'DCPlayerCharacterBase_GetEquipmentComponentV2::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.GetGender
// 0x0001 (0x0001 - 0x0000)
struct DCPlayerCharacterBase_GetGender final
{
public:
	EDCGender                                     ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_GetGender) == 0x000001, "Wrong alignment on DCPlayerCharacterBase_GetGender");
static_assert(sizeof(DCPlayerCharacterBase_GetGender) == 0x000001, "Wrong size on DCPlayerCharacterBase_GetGender");
static_assert(offsetof(DCPlayerCharacterBase_GetGender, ReturnValue) == 0x000000, "Member 'DCPlayerCharacterBase_GetGender::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.GetPerkDataComponent
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerCharacterBase_GetPerkDataComponent final
{
public:
	class UDCPerkDataComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_GetPerkDataComponent) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_GetPerkDataComponent");
static_assert(sizeof(DCPlayerCharacterBase_GetPerkDataComponent) == 0x000008, "Wrong size on DCPlayerCharacterBase_GetPerkDataComponent");
static_assert(offsetof(DCPlayerCharacterBase_GetPerkDataComponent, ReturnValue) == 0x000000, "Member 'DCPlayerCharacterBase_GetPerkDataComponent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterBase.ShowHitDirectionUIMessage
// 0x0020 (0x0020 - 0x0000)
struct DCPlayerCharacterBase_ShowHitDirectionUIMessage final
{
public:
	const class AActor*                           SourceActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0008(0x0018)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterBase_ShowHitDirectionUIMessage) == 0x000008, "Wrong alignment on DCPlayerCharacterBase_ShowHitDirectionUIMessage");
static_assert(sizeof(DCPlayerCharacterBase_ShowHitDirectionUIMessage) == 0x000020, "Wrong size on DCPlayerCharacterBase_ShowHitDirectionUIMessage");
static_assert(offsetof(DCPlayerCharacterBase_ShowHitDirectionUIMessage, SourceActor) == 0x000000, "Member 'DCPlayerCharacterBase_ShowHitDirectionUIMessage::SourceActor' has a wrong offset!");
static_assert(offsetof(DCPlayerCharacterBase_ShowHitDirectionUIMessage, HitDirection) == 0x000008, "Member 'DCPlayerCharacterBase_ShowHitDirectionUIMessage::HitDirection' has a wrong offset!");

// Function DungeonCrawler.DCPlayerCharacterInterface.GetPartHeadMeshAsset
// 0x0008 (0x0008 - 0x0000)
struct DCPlayerCharacterInterface_GetPartHeadMeshAsset final
{
public:
	class USkeletalMesh*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerCharacterInterface_GetPartHeadMeshAsset) == 0x000008, "Wrong alignment on DCPlayerCharacterInterface_GetPartHeadMeshAsset");
static_assert(sizeof(DCPlayerCharacterInterface_GetPartHeadMeshAsset) == 0x000008, "Wrong size on DCPlayerCharacterInterface_GetPartHeadMeshAsset");
static_assert(offsetof(DCPlayerCharacterInterface_GetPartHeadMeshAsset, ReturnValue) == 0x000000, "Member 'DCPlayerCharacterInterface_GetPartHeadMeshAsset::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCReligionBlessingLevelWidget.SetBlessingWidgetInfo
// 0x0040 (0x0040 - 0x0000)
struct DCReligionBlessingLevelWidget_SetBlessingWidgetInfo final
{
public:
	bool                                          bIsActivate;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279B[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   BlessingName;                                      // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         BlessingLevel;                                     // 0x0020(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279C[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   BlessingDesc;                                      // 0x0028(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionBlessingLevelWidget_SetBlessingWidgetInfo) == 0x000008, "Wrong alignment on DCReligionBlessingLevelWidget_SetBlessingWidgetInfo");
static_assert(sizeof(DCReligionBlessingLevelWidget_SetBlessingWidgetInfo) == 0x000040, "Wrong size on DCReligionBlessingLevelWidget_SetBlessingWidgetInfo");
static_assert(offsetof(DCReligionBlessingLevelWidget_SetBlessingWidgetInfo, bIsActivate) == 0x000000, "Member 'DCReligionBlessingLevelWidget_SetBlessingWidgetInfo::bIsActivate' has a wrong offset!");
static_assert(offsetof(DCReligionBlessingLevelWidget_SetBlessingWidgetInfo, BlessingName) == 0x000008, "Member 'DCReligionBlessingLevelWidget_SetBlessingWidgetInfo::BlessingName' has a wrong offset!");
static_assert(offsetof(DCReligionBlessingLevelWidget_SetBlessingWidgetInfo, BlessingLevel) == 0x000020, "Member 'DCReligionBlessingLevelWidget_SetBlessingWidgetInfo::BlessingLevel' has a wrong offset!");
static_assert(offsetof(DCReligionBlessingLevelWidget_SetBlessingWidgetInfo, BlessingDesc) == 0x000028, "Member 'DCReligionBlessingLevelWidget_SetBlessingWidgetInfo::BlessingDesc' has a wrong offset!");

// Function DungeonCrawler.DCPlayerInfoHolder.OnRep_PlayerInfo
// 0x00E0 (0x00E0 - 0x0000)
struct DCPlayerInfoHolder_OnRep_PlayerInfo final
{
public:
	struct FDCPlayerInfo                          OldPlayerInfo;                                     // 0x0000(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCPlayerInfoHolder_OnRep_PlayerInfo) == 0x000008, "Wrong alignment on DCPlayerInfoHolder_OnRep_PlayerInfo");
static_assert(sizeof(DCPlayerInfoHolder_OnRep_PlayerInfo) == 0x0000E0, "Wrong size on DCPlayerInfoHolder_OnRep_PlayerInfo");
static_assert(offsetof(DCPlayerInfoHolder_OnRep_PlayerInfo, OldPlayerInfo) == 0x000000, "Member 'DCPlayerInfoHolder_OnRep_PlayerInfo::OldPlayerInfo' has a wrong offset!");

// Function DungeonCrawler.DCQuestListEntryWidget.IsSelected
// 0x0001 (0x0001 - 0x0000)
struct DCQuestListEntryWidget_IsSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestListEntryWidget_IsSelected) == 0x000001, "Wrong alignment on DCQuestListEntryWidget_IsSelected");
static_assert(sizeof(DCQuestListEntryWidget_IsSelected) == 0x000001, "Wrong size on DCQuestListEntryWidget_IsSelected");
static_assert(offsetof(DCQuestListEntryWidget_IsSelected, ReturnValue) == 0x000000, "Member 'DCQuestListEntryWidget_IsSelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCQuestLogContentsListEntry.IsSelected
// 0x0001 (0x0001 - 0x0000)
struct DCQuestLogContentsListEntry_IsSelected final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestLogContentsListEntry_IsSelected) == 0x000001, "Wrong alignment on DCQuestLogContentsListEntry_IsSelected");
static_assert(sizeof(DCQuestLogContentsListEntry_IsSelected) == 0x000001, "Wrong size on DCQuestLogContentsListEntry_IsSelected");
static_assert(offsetof(DCQuestLogContentsListEntry_IsSelected, ReturnValue) == 0x000000, "Member 'DCQuestLogContentsListEntry_IsSelected::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCQuestLogWidgetBase.OnAcceptAllButtonEnable
// 0x0001 (0x0001 - 0x0000)
struct DCQuestLogWidgetBase_OnAcceptAllButtonEnable final
{
public:
	bool                                          IsEnable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestLogWidgetBase_OnAcceptAllButtonEnable) == 0x000001, "Wrong alignment on DCQuestLogWidgetBase_OnAcceptAllButtonEnable");
static_assert(sizeof(DCQuestLogWidgetBase_OnAcceptAllButtonEnable) == 0x000001, "Wrong size on DCQuestLogWidgetBase_OnAcceptAllButtonEnable");
static_assert(offsetof(DCQuestLogWidgetBase_OnAcceptAllButtonEnable, IsEnable) == 0x000000, "Member 'DCQuestLogWidgetBase_OnAcceptAllButtonEnable::IsEnable' has a wrong offset!");

// Function DungeonCrawler.DCQuestLogWidgetBase.OnQuestLogVisibilityChange
// 0x0001 (0x0001 - 0x0000)
struct DCQuestLogWidgetBase_OnQuestLogVisibilityChange final
{
public:
	bool                                          bIsEmpty;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestLogWidgetBase_OnQuestLogVisibilityChange) == 0x000001, "Wrong alignment on DCQuestLogWidgetBase_OnQuestLogVisibilityChange");
static_assert(sizeof(DCQuestLogWidgetBase_OnQuestLogVisibilityChange) == 0x000001, "Wrong size on DCQuestLogWidgetBase_OnQuestLogVisibilityChange");
static_assert(offsetof(DCQuestLogWidgetBase_OnQuestLogVisibilityChange, bIsEmpty) == 0x000000, "Member 'DCQuestLogWidgetBase_OnQuestLogVisibilityChange::bIsEmpty' has a wrong offset!");

// Function DungeonCrawler.DCQuestLogWidgetBase.SetIsActivated
// 0x0001 (0x0001 - 0x0000)
struct DCQuestLogWidgetBase_SetIsActivated final
{
public:
	bool                                          bIsActivate;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCQuestLogWidgetBase_SetIsActivated) == 0x000001, "Wrong alignment on DCQuestLogWidgetBase_SetIsActivated");
static_assert(sizeof(DCQuestLogWidgetBase_SetIsActivated) == 0x000001, "Wrong size on DCQuestLogWidgetBase_SetIsActivated");
static_assert(offsetof(DCQuestLogWidgetBase_SetIsActivated, bIsActivate) == 0x000000, "Member 'DCQuestLogWidgetBase_SetIsActivated::bIsActivate' has a wrong offset!");

// Function DungeonCrawler.DCReligionBurfPopup.SetBlessingLevel
// 0x0004 (0x0004 - 0x0000)
struct DCReligionBurfPopup_SetBlessingLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionBurfPopup_SetBlessingLevel) == 0x000004, "Wrong alignment on DCReligionBurfPopup_SetBlessingLevel");
static_assert(sizeof(DCReligionBurfPopup_SetBlessingLevel) == 0x000004, "Wrong size on DCReligionBurfPopup_SetBlessingLevel");
static_assert(offsetof(DCReligionBurfPopup_SetBlessingLevel, Level) == 0x000000, "Member 'DCReligionBurfPopup_SetBlessingLevel::Level' has a wrong offset!");

// Function DungeonCrawler.DCReligionBurfPopup.SetReligionTimer
// 0x0010 (0x0010 - 0x0000)
struct DCReligionBurfPopup_SetReligionTimer final
{
public:
	struct FReligionRankTimerInfo                 Info;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionBurfPopup_SetReligionTimer) == 0x000004, "Wrong alignment on DCReligionBurfPopup_SetReligionTimer");
static_assert(sizeof(DCReligionBurfPopup_SetReligionTimer) == 0x000010, "Wrong size on DCReligionBurfPopup_SetReligionTimer");
static_assert(offsetof(DCReligionBurfPopup_SetReligionTimer, Info) == 0x000000, "Member 'DCReligionBurfPopup_SetReligionTimer::Info' has a wrong offset!");

// Function DungeonCrawler.DCReligionRankEntryMine.OnFMsgWidgetStreamingModeNotifyBlueprint
// 0x0020 (0x0020 - 0x0000)
struct DCReligionRankEntryMine_OnFMsgWidgetStreamingModeNotifyBlueprint final
{
public:
	struct FMsgWidgetStreamingModeNotify          InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionRankEntryMine_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000008, "Wrong alignment on DCReligionRankEntryMine_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(sizeof(DCReligionRankEntryMine_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000020, "Wrong size on DCReligionRankEntryMine_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(offsetof(DCReligionRankEntryMine_OnFMsgWidgetStreamingModeNotifyBlueprint, InMsg) == 0x000000, "Member 'DCReligionRankEntryMine_OnFMsgWidgetStreamingModeNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCReligionRankEntryMine.OnReligionRankRecordMineData
// 0x0090 (0x0090 - 0x0000)
struct DCReligionRankEntryMine_OnReligionRankRecordMineData final
{
public:
	struct FReligionRankRecordMineData            NewValue;                                          // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FReligionRankRecordMineData            OldValue;                                          // 0x0048(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionRankEntryMine_OnReligionRankRecordMineData) == 0x000008, "Wrong alignment on DCReligionRankEntryMine_OnReligionRankRecordMineData");
static_assert(sizeof(DCReligionRankEntryMine_OnReligionRankRecordMineData) == 0x000090, "Wrong size on DCReligionRankEntryMine_OnReligionRankRecordMineData");
static_assert(offsetof(DCReligionRankEntryMine_OnReligionRankRecordMineData, NewValue) == 0x000000, "Member 'DCReligionRankEntryMine_OnReligionRankRecordMineData::NewValue' has a wrong offset!");
static_assert(offsetof(DCReligionRankEntryMine_OnReligionRankRecordMineData, OldValue) == 0x000048, "Member 'DCReligionRankEntryMine_OnReligionRankRecordMineData::OldValue' has a wrong offset!");

// Function DungeonCrawler.DCReligionRankEntryMine.SetOfferCountToWidget
// 0x0004 (0x0004 - 0x0000)
struct DCReligionRankEntryMine_SetOfferCountToWidget final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReligionRankEntryMine_SetOfferCountToWidget) == 0x000004, "Wrong alignment on DCReligionRankEntryMine_SetOfferCountToWidget");
static_assert(sizeof(DCReligionRankEntryMine_SetOfferCountToWidget) == 0x000004, "Wrong size on DCReligionRankEntryMine_SetOfferCountToWidget");
static_assert(offsetof(DCReligionRankEntryMine_SetOfferCountToWidget, Count) == 0x000000, "Member 'DCReligionRankEntryMine_SetOfferCountToWidget::Count' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerResultPopup.GetPermanentBanListText
// 0x0018 (0x0018 - 0x0000)
struct DCReportPlayerResultPopup_GetPermanentBanListText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerResultPopup_GetPermanentBanListText) == 0x000008, "Wrong alignment on DCReportPlayerResultPopup_GetPermanentBanListText");
static_assert(sizeof(DCReportPlayerResultPopup_GetPermanentBanListText) == 0x000018, "Wrong size on DCReportPlayerResultPopup_GetPermanentBanListText");
static_assert(offsetof(DCReportPlayerResultPopup_GetPermanentBanListText, ReturnValue) == 0x000000, "Member 'DCReportPlayerResultPopup_GetPermanentBanListText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCReportPlayerResultPopup.GetTemporaryBanListText
// 0x0018 (0x0018 - 0x0000)
struct DCReportPlayerResultPopup_GetTemporaryBanListText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCReportPlayerResultPopup_GetTemporaryBanListText) == 0x000008, "Wrong alignment on DCReportPlayerResultPopup_GetTemporaryBanListText");
static_assert(sizeof(DCReportPlayerResultPopup_GetTemporaryBanListText) == 0x000018, "Wrong size on DCReportPlayerResultPopup_GetTemporaryBanListText");
static_assert(offsetof(DCReportPlayerResultPopup_GetTemporaryBanListText, ReturnValue) == 0x000000, "Member 'DCReportPlayerResultPopup_GetTemporaryBanListText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopCurrencyTypeSlotWidgetBase.HasNotEnoughCurrency
// 0x0001 (0x0001 - 0x0000)
struct DCShopCurrencyTypeSlotWidgetBase_HasNotEnoughCurrency final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopCurrencyTypeSlotWidgetBase_HasNotEnoughCurrency) == 0x000001, "Wrong alignment on DCShopCurrencyTypeSlotWidgetBase_HasNotEnoughCurrency");
static_assert(sizeof(DCShopCurrencyTypeSlotWidgetBase_HasNotEnoughCurrency) == 0x000001, "Wrong size on DCShopCurrencyTypeSlotWidgetBase_HasNotEnoughCurrency");
static_assert(offsetof(DCShopCurrencyTypeSlotWidgetBase_HasNotEnoughCurrency, ReturnValue) == 0x000000, "Member 'DCShopCurrencyTypeSlotWidgetBase_HasNotEnoughCurrency::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopCurrencyTypeSlotWidgetBase.IsBluestoneShardType
// 0x0001 (0x0001 - 0x0000)
struct DCShopCurrencyTypeSlotWidgetBase_IsBluestoneShardType final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopCurrencyTypeSlotWidgetBase_IsBluestoneShardType) == 0x000001, "Wrong alignment on DCShopCurrencyTypeSlotWidgetBase_IsBluestoneShardType");
static_assert(sizeof(DCShopCurrencyTypeSlotWidgetBase_IsBluestoneShardType) == 0x000001, "Wrong size on DCShopCurrencyTypeSlotWidgetBase_IsBluestoneShardType");
static_assert(offsetof(DCShopCurrencyTypeSlotWidgetBase_IsBluestoneShardType, ReturnValue) == 0x000000, "Member 'DCShopCurrencyTypeSlotWidgetBase_IsBluestoneShardType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopCurrencyTypeSlotWidgetBase.IsRedstoneShardType
// 0x0001 (0x0001 - 0x0000)
struct DCShopCurrencyTypeSlotWidgetBase_IsRedstoneShardType final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopCurrencyTypeSlotWidgetBase_IsRedstoneShardType) == 0x000001, "Wrong alignment on DCShopCurrencyTypeSlotWidgetBase_IsRedstoneShardType");
static_assert(sizeof(DCShopCurrencyTypeSlotWidgetBase_IsRedstoneShardType) == 0x000001, "Wrong size on DCShopCurrencyTypeSlotWidgetBase_IsRedstoneShardType");
static_assert(offsetof(DCShopCurrencyTypeSlotWidgetBase_IsRedstoneShardType, ReturnValue) == 0x000000, "Member 'DCShopCurrencyTypeSlotWidgetBase_IsRedstoneShardType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopCurrencyTypeSlotWidgetBase.OnChangedCheckState
// 0x0001 (0x0001 - 0x0000)
struct DCShopCurrencyTypeSlotWidgetBase_OnChangedCheckState final
{
public:
	bool                                          bNewState;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopCurrencyTypeSlotWidgetBase_OnChangedCheckState) == 0x000001, "Wrong alignment on DCShopCurrencyTypeSlotWidgetBase_OnChangedCheckState");
static_assert(sizeof(DCShopCurrencyTypeSlotWidgetBase_OnChangedCheckState) == 0x000001, "Wrong size on DCShopCurrencyTypeSlotWidgetBase_OnChangedCheckState");
static_assert(offsetof(DCShopCurrencyTypeSlotWidgetBase_OnChangedCheckState, bNewState) == 0x000000, "Member 'DCShopCurrencyTypeSlotWidgetBase_OnChangedCheckState::bNewState' has a wrong offset!");

// Function DungeonCrawler.DCShopItemSlotWidget.GetShopItemState
// 0x0001 (0x0001 - 0x0000)
struct DCShopItemSlotWidget_GetShopItemState final
{
public:
	EDCShopItemState                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopItemSlotWidget_GetShopItemState) == 0x000001, "Wrong alignment on DCShopItemSlotWidget_GetShopItemState");
static_assert(sizeof(DCShopItemSlotWidget_GetShopItemState) == 0x000001, "Wrong size on DCShopItemSlotWidget_GetShopItemState");
static_assert(offsetof(DCShopItemSlotWidget_GetShopItemState, ReturnValue) == 0x000000, "Member 'DCShopItemSlotWidget_GetShopItemState::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopItemSlotWidget.GetTooltipWidget
// 0x0008 (0x0008 - 0x0000)
struct DCShopItemSlotWidget_GetTooltipWidget final
{
public:
	class UUserWidget*                            ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopItemSlotWidget_GetTooltipWidget) == 0x000008, "Wrong alignment on DCShopItemSlotWidget_GetTooltipWidget");
static_assert(sizeof(DCShopItemSlotWidget_GetTooltipWidget) == 0x000008, "Wrong size on DCShopItemSlotWidget_GetTooltipWidget");
static_assert(offsetof(DCShopItemSlotWidget_GetTooltipWidget, ReturnValue) == 0x000000, "Member 'DCShopItemSlotWidget_GetTooltipWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopWidgetBase.OnPreviewSwitched
// 0x0001 (0x0001 - 0x0000)
struct DCShopWidgetBase_OnPreviewSwitched final
{
public:
	EDCShopItemType                               ItemType;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopWidgetBase_OnPreviewSwitched) == 0x000001, "Wrong alignment on DCShopWidgetBase_OnPreviewSwitched");
static_assert(sizeof(DCShopWidgetBase_OnPreviewSwitched) == 0x000001, "Wrong size on DCShopWidgetBase_OnPreviewSwitched");
static_assert(offsetof(DCShopWidgetBase_OnPreviewSwitched, ItemType) == 0x000000, "Member 'DCShopWidgetBase_OnPreviewSwitched::ItemType' has a wrong offset!");

// Function DungeonCrawler.DCShopWidgetBase.OnSelectedShopCategoryTabChanged
// 0x0008 (0x0008 - 0x0000)
struct DCShopWidgetBase_OnSelectedShopCategoryTabChanged final
{
public:
	class FName                                   SelectedTabId;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopWidgetBase_OnSelectedShopCategoryTabChanged) == 0x000004, "Wrong alignment on DCShopWidgetBase_OnSelectedShopCategoryTabChanged");
static_assert(sizeof(DCShopWidgetBase_OnSelectedShopCategoryTabChanged) == 0x000008, "Wrong size on DCShopWidgetBase_OnSelectedShopCategoryTabChanged");
static_assert(offsetof(DCShopWidgetBase_OnSelectedShopCategoryTabChanged, SelectedTabId) == 0x000000, "Member 'DCShopWidgetBase_OnSelectedShopCategoryTabChanged::SelectedTabId' has a wrong offset!");

// Function DungeonCrawler.DCShopWidgetBase.CanPurchase
// 0x0001 (0x0001 - 0x0000)
struct DCShopWidgetBase_CanPurchase final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopWidgetBase_CanPurchase) == 0x000001, "Wrong alignment on DCShopWidgetBase_CanPurchase");
static_assert(sizeof(DCShopWidgetBase_CanPurchase) == 0x000001, "Wrong size on DCShopWidgetBase_CanPurchase");
static_assert(offsetof(DCShopWidgetBase_CanPurchase, ReturnValue) == 0x000000, "Member 'DCShopWidgetBase_CanPurchase::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopWidgetBase.GetDiscountRate
// 0x0004 (0x0004 - 0x0000)
struct DCShopWidgetBase_GetDiscountRate final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopWidgetBase_GetDiscountRate) == 0x000004, "Wrong alignment on DCShopWidgetBase_GetDiscountRate");
static_assert(sizeof(DCShopWidgetBase_GetDiscountRate) == 0x000004, "Wrong size on DCShopWidgetBase_GetDiscountRate");
static_assert(offsetof(DCShopWidgetBase_GetDiscountRate, ReturnValue) == 0x000000, "Member 'DCShopWidgetBase_GetDiscountRate::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopWidgetBase.HasSelectedShopItemAnyPrice
// 0x0001 (0x0001 - 0x0000)
struct DCShopWidgetBase_HasSelectedShopItemAnyPrice final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopWidgetBase_HasSelectedShopItemAnyPrice) == 0x000001, "Wrong alignment on DCShopWidgetBase_HasSelectedShopItemAnyPrice");
static_assert(sizeof(DCShopWidgetBase_HasSelectedShopItemAnyPrice) == 0x000001, "Wrong size on DCShopWidgetBase_HasSelectedShopItemAnyPrice");
static_assert(offsetof(DCShopWidgetBase_HasSelectedShopItemAnyPrice, ReturnValue) == 0x000000, "Member 'DCShopWidgetBase_HasSelectedShopItemAnyPrice::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopWidgetBase.HasSelectedShopItemBluestoneShardPrice
// 0x0001 (0x0001 - 0x0000)
struct DCShopWidgetBase_HasSelectedShopItemBluestoneShardPrice final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopWidgetBase_HasSelectedShopItemBluestoneShardPrice) == 0x000001, "Wrong alignment on DCShopWidgetBase_HasSelectedShopItemBluestoneShardPrice");
static_assert(sizeof(DCShopWidgetBase_HasSelectedShopItemBluestoneShardPrice) == 0x000001, "Wrong size on DCShopWidgetBase_HasSelectedShopItemBluestoneShardPrice");
static_assert(offsetof(DCShopWidgetBase_HasSelectedShopItemBluestoneShardPrice, ReturnValue) == 0x000000, "Member 'DCShopWidgetBase_HasSelectedShopItemBluestoneShardPrice::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCShopWidgetBase.HasSelectedShopItemRedstoneShardPrice
// 0x0001 (0x0001 - 0x0000)
struct DCShopWidgetBase_HasSelectedShopItemRedstoneShardPrice final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCShopWidgetBase_HasSelectedShopItemRedstoneShardPrice) == 0x000001, "Wrong alignment on DCShopWidgetBase_HasSelectedShopItemRedstoneShardPrice");
static_assert(sizeof(DCShopWidgetBase_HasSelectedShopItemRedstoneShardPrice) == 0x000001, "Wrong size on DCShopWidgetBase_HasSelectedShopItemRedstoneShardPrice");
static_assert(offsetof(DCShopWidgetBase_HasSelectedShopItemRedstoneShardPrice, ReturnValue) == 0x000000, "Member 'DCShopWidgetBase_HasSelectedShopItemRedstoneShardPrice::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCSimpleTooltipWidget.GetTooltipColor
// 0x0014 (0x0014 - 0x0000)
struct DCSimpleTooltipWidget_GetTooltipColor final
{
public:
	struct FSlateColor                            ReturnValue;                                       // 0x0000(0x0014)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSimpleTooltipWidget_GetTooltipColor) == 0x000004, "Wrong alignment on DCSimpleTooltipWidget_GetTooltipColor");
static_assert(sizeof(DCSimpleTooltipWidget_GetTooltipColor) == 0x000014, "Wrong size on DCSimpleTooltipWidget_GetTooltipColor");
static_assert(offsetof(DCSimpleTooltipWidget_GetTooltipColor, ReturnValue) == 0x000000, "Member 'DCSimpleTooltipWidget_GetTooltipColor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCSimpleTooltipWidget.SetTooltipData
// 0x0030 (0x0030 - 0x0000)
struct DCSimpleTooltipWidget_SetTooltipData final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FSlateColor                            TextColor;                                         // 0x0018(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_27D0[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCSimpleTooltipWidget_SetTooltipData) == 0x000008, "Wrong alignment on DCSimpleTooltipWidget_SetTooltipData");
static_assert(sizeof(DCSimpleTooltipWidget_SetTooltipData) == 0x000030, "Wrong size on DCSimpleTooltipWidget_SetTooltipData");
static_assert(offsetof(DCSimpleTooltipWidget_SetTooltipData, Text) == 0x000000, "Member 'DCSimpleTooltipWidget_SetTooltipData::Text' has a wrong offset!");
static_assert(offsetof(DCSimpleTooltipWidget_SetTooltipData, TextColor) == 0x000018, "Member 'DCSimpleTooltipWidget_SetTooltipData::TextColor' has a wrong offset!");

// Function DungeonCrawler.DCSortButtonWidget.GetCurrentSortStateIcon
// 0x0008 (0x0008 - 0x0000)
struct DCSortButtonWidget_GetCurrentSortStateIcon final
{
public:
	const class UTexture2D*                       ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSortButtonWidget_GetCurrentSortStateIcon) == 0x000008, "Wrong alignment on DCSortButtonWidget_GetCurrentSortStateIcon");
static_assert(sizeof(DCSortButtonWidget_GetCurrentSortStateIcon) == 0x000008, "Wrong size on DCSortButtonWidget_GetCurrentSortStateIcon");
static_assert(offsetof(DCSortButtonWidget_GetCurrentSortStateIcon, ReturnValue) == 0x000000, "Member 'DCSortButtonWidget_GetCurrentSortStateIcon::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCSortButtonWidget.IsSortable
// 0x0001 (0x0001 - 0x0000)
struct DCSortButtonWidget_IsSortable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSortButtonWidget_IsSortable) == 0x000001, "Wrong alignment on DCSortButtonWidget_IsSortable");
static_assert(sizeof(DCSortButtonWidget_IsSortable) == 0x000001, "Wrong size on DCSortButtonWidget_IsSortable");
static_assert(offsetof(DCSortButtonWidget_IsSortable, ReturnValue) == 0x000000, "Member 'DCSortButtonWidget_IsSortable::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCSpellBeamSpringArmComponent.OnRep_SpellRange
// 0x0004 (0x0004 - 0x0000)
struct DCSpellBeamSpringArmComponent_OnRep_SpellRange final
{
public:
	float                                         OldSpellRange;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSpellBeamSpringArmComponent_OnRep_SpellRange) == 0x000004, "Wrong alignment on DCSpellBeamSpringArmComponent_OnRep_SpellRange");
static_assert(sizeof(DCSpellBeamSpringArmComponent_OnRep_SpellRange) == 0x000004, "Wrong size on DCSpellBeamSpringArmComponent_OnRep_SpellRange");
static_assert(offsetof(DCSpellBeamSpringArmComponent_OnRep_SpellRange, OldSpellRange) == 0x000000, "Member 'DCSpellBeamSpringArmComponent_OnRep_SpellRange::OldSpellRange' has a wrong offset!");

// Function DungeonCrawler.DCSpellBeamSpringArmComponent.SetSpellRange
// 0x0004 (0x0004 - 0x0000)
struct DCSpellBeamSpringArmComponent_SetSpellRange final
{
public:
	float                                         InSpellRange;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCSpellBeamSpringArmComponent_SetSpellRange) == 0x000004, "Wrong alignment on DCSpellBeamSpringArmComponent_SetSpellRange");
static_assert(sizeof(DCSpellBeamSpringArmComponent_SetSpellRange) == 0x000004, "Wrong size on DCSpellBeamSpringArmComponent_SetSpellRange");
static_assert(offsetof(DCSpellBeamSpringArmComponent_SetSpellRange, InSpellRange) == 0x000000, "Member 'DCSpellBeamSpringArmComponent_SetSpellRange::InSpellRange' has a wrong offset!");

// Function DungeonCrawler.DCStaticMeshComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct DCStaticMeshComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCStaticMeshComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on DCStaticMeshComponent_BroadcastMsgBlueprint");
static_assert(sizeof(DCStaticMeshComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on DCStaticMeshComponent_BroadcastMsgBlueprint");
static_assert(offsetof(DCStaticMeshComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'DCStaticMeshComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.DCStaticMeshComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct DCStaticMeshComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCStaticMeshComponent_UnbindMsg) == 0x000008, "Wrong alignment on DCStaticMeshComponent_UnbindMsg");
static_assert(sizeof(DCStaticMeshComponent_UnbindMsg) == 0x000010, "Wrong size on DCStaticMeshComponent_UnbindMsg");
static_assert(offsetof(DCStaticMeshComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'DCStaticMeshComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(DCStaticMeshComponent_UnbindMsg, InObject) == 0x000008, "Member 'DCStaticMeshComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.DCStaticMeshComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct DCStaticMeshComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCStaticMeshComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on DCStaticMeshComponent_UnbindMsgAll");
static_assert(sizeof(DCStaticMeshComponent_UnbindMsgAll) == 0x000008, "Wrong size on DCStaticMeshComponent_UnbindMsgAll");
static_assert(offsetof(DCStaticMeshComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'DCStaticMeshComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.DCTabButtonWidgetBase.OnSelectedChanged
// 0x0001 (0x0001 - 0x0000)
struct DCTabButtonWidgetBase_OnSelectedChanged final
{
public:
	bool                                          bInIsSelected;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTabButtonWidgetBase_OnSelectedChanged) == 0x000001, "Wrong alignment on DCTabButtonWidgetBase_OnSelectedChanged");
static_assert(sizeof(DCTabButtonWidgetBase_OnSelectedChanged) == 0x000001, "Wrong size on DCTabButtonWidgetBase_OnSelectedChanged");
static_assert(offsetof(DCTabButtonWidgetBase_OnSelectedChanged, bInIsSelected) == 0x000000, "Member 'DCTabButtonWidgetBase_OnSelectedChanged::bInIsSelected' has a wrong offset!");

// Function DungeonCrawler.DCTradeBoxWidget.IsEnableCheckBox
// 0x0001 (0x0001 - 0x0000)
struct DCTradeBoxWidget_IsEnableCheckBox final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTradeBoxWidget_IsEnableCheckBox) == 0x000001, "Wrong alignment on DCTradeBoxWidget_IsEnableCheckBox");
static_assert(sizeof(DCTradeBoxWidget_IsEnableCheckBox) == 0x000001, "Wrong size on DCTradeBoxWidget_IsEnableCheckBox");
static_assert(offsetof(DCTradeBoxWidget_IsEnableCheckBox, ReturnValue) == 0x000000, "Member 'DCTradeBoxWidget_IsEnableCheckBox::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCTradeBoxWidget.SetReady
// 0x0001 (0x0001 - 0x0000)
struct DCTradeBoxWidget_SetReady final
{
public:
	bool                                          bState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCTradeBoxWidget_SetReady) == 0x000001, "Wrong alignment on DCTradeBoxWidget_SetReady");
static_assert(sizeof(DCTradeBoxWidget_SetReady) == 0x000001, "Wrong size on DCTradeBoxWidget_SetReady");
static_assert(offsetof(DCTradeBoxWidget_SetReady, bState) == 0x000000, "Member 'DCTradeBoxWidget_SetReady::bState' has a wrong offset!");

// Function DungeonCrawler.DCUpdateRateOptimizeManagerComponent.SetFreezeIdle
// 0x0001 (0x0001 - 0x0000)
struct DCUpdateRateOptimizeManagerComponent_SetFreezeIdle final
{
public:
	bool                                          bInFreezeIdle;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCUpdateRateOptimizeManagerComponent_SetFreezeIdle) == 0x000001, "Wrong alignment on DCUpdateRateOptimizeManagerComponent_SetFreezeIdle");
static_assert(sizeof(DCUpdateRateOptimizeManagerComponent_SetFreezeIdle) == 0x000001, "Wrong size on DCUpdateRateOptimizeManagerComponent_SetFreezeIdle");
static_assert(offsetof(DCUpdateRateOptimizeManagerComponent_SetFreezeIdle, bInFreezeIdle) == 0x000000, "Member 'DCUpdateRateOptimizeManagerComponent_SetFreezeIdle::bInFreezeIdle' has a wrong offset!");

// Function DungeonCrawler.DCUpdateRateOptimizeManagerComponent.SetNeverOptimize
// 0x0001 (0x0001 - 0x0000)
struct DCUpdateRateOptimizeManagerComponent_SetNeverOptimize final
{
public:
	bool                                          bInNeverOptimize;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCUpdateRateOptimizeManagerComponent_SetNeverOptimize) == 0x000001, "Wrong alignment on DCUpdateRateOptimizeManagerComponent_SetNeverOptimize");
static_assert(sizeof(DCUpdateRateOptimizeManagerComponent_SetNeverOptimize) == 0x000001, "Wrong size on DCUpdateRateOptimizeManagerComponent_SetNeverOptimize");
static_assert(offsetof(DCUpdateRateOptimizeManagerComponent_SetNeverOptimize, bInNeverOptimize) == 0x000000, "Member 'DCUpdateRateOptimizeManagerComponent_SetNeverOptimize::bInNeverOptimize' has a wrong offset!");

// Function DungeonCrawler.DCVoipComponent.InitVoip
// 0x0008 (0x0008 - 0x0000)
struct DCVoipComponent_InitVoip final
{
public:
	class UVoipAkComponent*                       InSendVoipAkComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCVoipComponent_InitVoip) == 0x000008, "Wrong alignment on DCVoipComponent_InitVoip");
static_assert(sizeof(DCVoipComponent_InitVoip) == 0x000008, "Wrong size on DCVoipComponent_InitVoip");
static_assert(offsetof(DCVoipComponent_InitVoip, InSendVoipAkComponent) == 0x000000, "Member 'DCVoipComponent_InitVoip::InSendVoipAkComponent' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.BroadcastCommonOneButtonSPopup
// 0x0028 (0x0028 - 0x0000)
struct DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup final
{
public:
	class APlayerController*                      InPlayer;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OutputMessage;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInIsBackHandler;                                  // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E8[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup");
static_assert(sizeof(DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup) == 0x000028, "Wrong size on DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup");
static_assert(offsetof(DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup, InPlayer) == 0x000000, "Member 'DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup::InPlayer' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup, OutputMessage) == 0x000008, "Member 'DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup::OutputMessage' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup, bInIsBackHandler) == 0x000020, "Member 'DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup::bInIsBackHandler' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.BroadcastSystemMessageNotify
// 0x0028 (0x0028 - 0x0000)
struct DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify final
{
public:
	class APlayerController*                      InPlayer;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OutputMessage;                                     // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E9[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify");
static_assert(sizeof(DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify) == 0x000028, "Wrong size on DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify");
static_assert(offsetof(DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify, InPlayer) == 0x000000, "Member 'DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify::InPlayer' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify, OutputMessage) == 0x000008, "Member 'DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify::OutputMessage' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify, Duration) == 0x000020, "Member 'DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify::Duration' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.ConvertLocalTimeToUtc
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_ConvertLocalTimeToUtc final
{
public:
	struct FDateTime                              LocalTime;                                         // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBlueprintLibrary_ConvertLocalTimeToUtc) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_ConvertLocalTimeToUtc");
static_assert(sizeof(DCWidgetBlueprintLibrary_ConvertLocalTimeToUtc) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_ConvertLocalTimeToUtc");
static_assert(offsetof(DCWidgetBlueprintLibrary_ConvertLocalTimeToUtc, LocalTime) == 0x000000, "Member 'DCWidgetBlueprintLibrary_ConvertLocalTimeToUtc::LocalTime' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_ConvertLocalTimeToUtc, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_ConvertLocalTimeToUtc::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.FormatQuestRichText
// 0x0038 (0x0038 - 0x0000)
struct DCWidgetBlueprintLibrary_FormatQuestRichText final
{
public:
	EDCQuestRichTextFormatType                    Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EA[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InText;                                            // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0020(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBlueprintLibrary_FormatQuestRichText) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_FormatQuestRichText");
static_assert(sizeof(DCWidgetBlueprintLibrary_FormatQuestRichText) == 0x000038, "Wrong size on DCWidgetBlueprintLibrary_FormatQuestRichText");
static_assert(offsetof(DCWidgetBlueprintLibrary_FormatQuestRichText, Type) == 0x000000, "Member 'DCWidgetBlueprintLibrary_FormatQuestRichText::Type' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_FormatQuestRichText, InText) == 0x000008, "Member 'DCWidgetBlueprintLibrary_FormatQuestRichText::InText' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_FormatQuestRichText, ReturnValue) == 0x000020, "Member 'DCWidgetBlueprintLibrary_FormatQuestRichText::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.GetArenaNumMaxRounds
// 0x0004 (0x0004 - 0x0000)
struct DCWidgetBlueprintLibrary_GetArenaNumMaxRounds final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBlueprintLibrary_GetArenaNumMaxRounds) == 0x000004, "Wrong alignment on DCWidgetBlueprintLibrary_GetArenaNumMaxRounds");
static_assert(sizeof(DCWidgetBlueprintLibrary_GetArenaNumMaxRounds) == 0x000004, "Wrong size on DCWidgetBlueprintLibrary_GetArenaNumMaxRounds");
static_assert(offsetof(DCWidgetBlueprintLibrary_GetArenaNumMaxRounds, ReturnValue) == 0x000000, "Member 'DCWidgetBlueprintLibrary_GetArenaNumMaxRounds::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.GetForceExitRemainSeconds
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_GetForceExitRemainSeconds final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EB[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_GetForceExitRemainSeconds) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_GetForceExitRemainSeconds");
static_assert(sizeof(DCWidgetBlueprintLibrary_GetForceExitRemainSeconds) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_GetForceExitRemainSeconds");
static_assert(offsetof(DCWidgetBlueprintLibrary_GetForceExitRemainSeconds, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_GetForceExitRemainSeconds::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_GetForceExitRemainSeconds, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_GetForceExitRemainSeconds::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.GetMatchElapsedTime
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_GetMatchElapsedTime final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBlueprintLibrary_GetMatchElapsedTime) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_GetMatchElapsedTime");
static_assert(sizeof(DCWidgetBlueprintLibrary_GetMatchElapsedTime) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_GetMatchElapsedTime");
static_assert(offsetof(DCWidgetBlueprintLibrary_GetMatchElapsedTime, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_GetMatchElapsedTime::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_GetMatchElapsedTime, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_GetMatchElapsedTime::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.GetVoipStatus
// 0x000C (0x000C - 0x0000)
struct DCWidgetBlueprintLibrary_GetVoipStatus final
{
public:
	struct FVoipUserData                          InVoipUserData;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	EVoipStatus                                   ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EC[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_GetVoipStatus) == 0x000004, "Wrong alignment on DCWidgetBlueprintLibrary_GetVoipStatus");
static_assert(sizeof(DCWidgetBlueprintLibrary_GetVoipStatus) == 0x00000C, "Wrong size on DCWidgetBlueprintLibrary_GetVoipStatus");
static_assert(offsetof(DCWidgetBlueprintLibrary_GetVoipStatus, InVoipUserData) == 0x000000, "Member 'DCWidgetBlueprintLibrary_GetVoipStatus::InVoipUserData' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_GetVoipStatus, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_GetVoipStatus::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsArenaEnabled
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_IsArenaEnabled final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27ED[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_IsArenaEnabled) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_IsArenaEnabled");
static_assert(sizeof(DCWidgetBlueprintLibrary_IsArenaEnabled) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_IsArenaEnabled");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsArenaEnabled, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_IsArenaEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsArenaEnabled, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_IsArenaEnabled::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsArenaFirstRound
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_IsArenaFirstRound final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EE[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_IsArenaFirstRound) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_IsArenaFirstRound");
static_assert(sizeof(DCWidgetBlueprintLibrary_IsArenaFirstRound) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_IsArenaFirstRound");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsArenaFirstRound, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_IsArenaFirstRound::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsArenaFirstRound, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_IsArenaFirstRound::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsCurrentPlayerWaitingNextFloor
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_IsCurrentPlayerWaitingNextFloor final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27EF[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_IsCurrentPlayerWaitingNextFloor) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_IsCurrentPlayerWaitingNextFloor");
static_assert(sizeof(DCWidgetBlueprintLibrary_IsCurrentPlayerWaitingNextFloor) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_IsCurrentPlayerWaitingNextFloor");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsCurrentPlayerWaitingNextFloor, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_IsCurrentPlayerWaitingNextFloor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsCurrentPlayerWaitingNextFloor, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_IsCurrentPlayerWaitingNextFloor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsDeathCamAvailable
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_IsDeathCamAvailable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F0[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_IsDeathCamAvailable) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_IsDeathCamAvailable");
static_assert(sizeof(DCWidgetBlueprintLibrary_IsDeathCamAvailable) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_IsDeathCamAvailable");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsDeathCamAvailable, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_IsDeathCamAvailable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsDeathCamAvailable, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_IsDeathCamAvailable::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsDeathCamOn
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_IsDeathCamOn final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F1[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_IsDeathCamOn) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_IsDeathCamOn");
static_assert(sizeof(DCWidgetBlueprintLibrary_IsDeathCamOn) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_IsDeathCamOn");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsDeathCamOn, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_IsDeathCamOn::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsDeathCamOn, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_IsDeathCamOn::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsFreeSpectatingEnabled
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_IsFreeSpectatingEnabled final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F2[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_IsFreeSpectatingEnabled) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_IsFreeSpectatingEnabled");
static_assert(sizeof(DCWidgetBlueprintLibrary_IsFreeSpectatingEnabled) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_IsFreeSpectatingEnabled");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsFreeSpectatingEnabled, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_IsFreeSpectatingEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsFreeSpectatingEnabled, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_IsFreeSpectatingEnabled::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsHighRoller
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_IsHighRoller final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F3[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_IsHighRoller) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_IsHighRoller");
static_assert(sizeof(DCWidgetBlueprintLibrary_IsHighRoller) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_IsHighRoller");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsHighRoller, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_IsHighRoller::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsHighRoller, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_IsHighRoller::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsUsingArena
// 0x0010 (0x0010 - 0x0000)
struct DCWidgetBlueprintLibrary_IsUsingArena final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F4[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_IsUsingArena) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_IsUsingArena");
static_assert(sizeof(DCWidgetBlueprintLibrary_IsUsingArena) == 0x000010, "Wrong size on DCWidgetBlueprintLibrary_IsUsingArena");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsUsingArena, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_IsUsingArena::WorldContextObject' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_IsUsingArena, ReturnValue) == 0x000008, "Member 'DCWidgetBlueprintLibrary_IsUsingArena::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.MakePopupDataSWidget
// 0x0028 (0x0028 - 0x0000)
struct DCWidgetBlueprintLibrary_MakePopupDataSWidget final
{
public:
	EPopupButtonType                              PopupButtonType;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F5[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DescMessage;                                       // 0x0008(0x0018)(Parm, NativeAccessSpecifierPublic)
	class UPopupDataSWidget*                      ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBlueprintLibrary_MakePopupDataSWidget) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_MakePopupDataSWidget");
static_assert(sizeof(DCWidgetBlueprintLibrary_MakePopupDataSWidget) == 0x000028, "Wrong size on DCWidgetBlueprintLibrary_MakePopupDataSWidget");
static_assert(offsetof(DCWidgetBlueprintLibrary_MakePopupDataSWidget, PopupButtonType) == 0x000000, "Member 'DCWidgetBlueprintLibrary_MakePopupDataSWidget::PopupButtonType' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_MakePopupDataSWidget, DescMessage) == 0x000008, "Member 'DCWidgetBlueprintLibrary_MakePopupDataSWidget::DescMessage' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_MakePopupDataSWidget, ReturnValue) == 0x000020, "Member 'DCWidgetBlueprintLibrary_MakePopupDataSWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.MakePopupMessageReqeust
// 0x0050 (0x0050 - 0x0000)
struct DCWidgetBlueprintLibrary_MakePopupMessageReqeust final
{
public:
	TSubclassOf<class UDCCommonActivatableWidgetBase> WidgetClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPopupDataBase*                         PopupData;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIsBackHandler;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F6[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMsgWidgetPopupMessageRequest          ReturnValue;                                       // 0x0018(0x0038)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBlueprintLibrary_MakePopupMessageReqeust) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_MakePopupMessageReqeust");
static_assert(sizeof(DCWidgetBlueprintLibrary_MakePopupMessageReqeust) == 0x000050, "Wrong size on DCWidgetBlueprintLibrary_MakePopupMessageReqeust");
static_assert(offsetof(DCWidgetBlueprintLibrary_MakePopupMessageReqeust, WidgetClass) == 0x000000, "Member 'DCWidgetBlueprintLibrary_MakePopupMessageReqeust::WidgetClass' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_MakePopupMessageReqeust, PopupData) == 0x000008, "Member 'DCWidgetBlueprintLibrary_MakePopupMessageReqeust::PopupData' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_MakePopupMessageReqeust, bInIsBackHandler) == 0x000010, "Member 'DCWidgetBlueprintLibrary_MakePopupMessageReqeust::bInIsBackHandler' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_MakePopupMessageReqeust, ReturnValue) == 0x000018, "Member 'DCWidgetBlueprintLibrary_MakePopupMessageReqeust::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.PopupMessageSWidgetNotify
// 0x0030 (0x0030 - 0x0000)
struct DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify final
{
public:
	class APlayerController*                      InPlayer;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDCCommonActivatableWidgetBase> WidgetClass;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DescMessage;                                       // 0x0010(0x0018)(Parm, NativeAccessSpecifierPublic)
	EPopupButtonType                              ButtonType;                                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIsBackHandler;                                  // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27F7[0x6];                                     // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify");
static_assert(sizeof(DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify) == 0x000030, "Wrong size on DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify");
static_assert(offsetof(DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify, InPlayer) == 0x000000, "Member 'DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify::InPlayer' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify, WidgetClass) == 0x000008, "Member 'DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify::WidgetClass' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify, DescMessage) == 0x000010, "Member 'DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify::DescMessage' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify, ButtonType) == 0x000028, "Member 'DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify::ButtonType' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify, bInIsBackHandler) == 0x000029, "Member 'DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify::bInIsBackHandler' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.SetPlayerCursorCenter
// 0x0008 (0x0008 - 0x0000)
struct DCWidgetBlueprintLibrary_SetPlayerCursorCenter final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBlueprintLibrary_SetPlayerCursorCenter) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_SetPlayerCursorCenter");
static_assert(sizeof(DCWidgetBlueprintLibrary_SetPlayerCursorCenter) == 0x000008, "Wrong size on DCWidgetBlueprintLibrary_SetPlayerCursorCenter");
static_assert(offsetof(DCWidgetBlueprintLibrary_SetPlayerCursorCenter, WorldContextObject) == 0x000000, "Member 'DCWidgetBlueprintLibrary_SetPlayerCursorCenter::WorldContextObject' has a wrong offset!");

// Function DungeonCrawler.DCWidgetBlueprintLibrary.StringToAccountId
// 0x0020 (0x0020 - 0x0000)
struct DCWidgetBlueprintLibrary_StringToAccountId final
{
public:
	class FString                                 InAccountIdStr;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCAccountId                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCWidgetBlueprintLibrary_StringToAccountId) == 0x000008, "Wrong alignment on DCWidgetBlueprintLibrary_StringToAccountId");
static_assert(sizeof(DCWidgetBlueprintLibrary_StringToAccountId) == 0x000020, "Wrong size on DCWidgetBlueprintLibrary_StringToAccountId");
static_assert(offsetof(DCWidgetBlueprintLibrary_StringToAccountId, InAccountIdStr) == 0x000000, "Member 'DCWidgetBlueprintLibrary_StringToAccountId::InAccountIdStr' has a wrong offset!");
static_assert(offsetof(DCWidgetBlueprintLibrary_StringToAccountId, ReturnValue) == 0x000010, "Member 'DCWidgetBlueprintLibrary_StringToAccountId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DeathSwarmBase.OnRep_GameDeathSwarmData
// 0x0080 (0x0080 - 0x0000)
struct DeathSwarmBase_OnRep_GameDeathSwarmData final
{
public:
	struct FGameDeathSwarmData                    InOldGameDeathSwarmData;                           // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathSwarmBase_OnRep_GameDeathSwarmData) == 0x000008, "Wrong alignment on DeathSwarmBase_OnRep_GameDeathSwarmData");
static_assert(sizeof(DeathSwarmBase_OnRep_GameDeathSwarmData) == 0x000080, "Wrong size on DeathSwarmBase_OnRep_GameDeathSwarmData");
static_assert(offsetof(DeathSwarmBase_OnRep_GameDeathSwarmData, InOldGameDeathSwarmData) == 0x000000, "Member 'DeathSwarmBase_OnRep_GameDeathSwarmData::InOldGameDeathSwarmData' has a wrong offset!");

// Function DungeonCrawler.DeathSwarmBase.OnRep_GameFloorRuleData
// 0x0040 (0x0040 - 0x0000)
struct DeathSwarmBase_OnRep_GameFloorRuleData final
{
public:
	struct FGameFloorRuleData                     InOldGameFloorRuleData;                            // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathSwarmBase_OnRep_GameFloorRuleData) == 0x000008, "Wrong alignment on DeathSwarmBase_OnRep_GameFloorRuleData");
static_assert(sizeof(DeathSwarmBase_OnRep_GameFloorRuleData) == 0x000040, "Wrong size on DeathSwarmBase_OnRep_GameFloorRuleData");
static_assert(offsetof(DeathSwarmBase_OnRep_GameFloorRuleData, InOldGameFloorRuleData) == 0x000000, "Member 'DeathSwarmBase_OnRep_GameFloorRuleData::InOldGameFloorRuleData' has a wrong offset!");

// Function DungeonCrawler.DeathSwarmInterface.BindDeathSwarmDataDelegate
// 0x0010 (0x0010 - 0x0000)
struct DeathSwarmInterface_BindDeathSwarmDataDelegate final
{
public:
	TDelegate<void(struct FGameDeathSwarmData& InDeathSwarmData)> InBindDelegate;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathSwarmInterface_BindDeathSwarmDataDelegate) == 0x000004, "Wrong alignment on DeathSwarmInterface_BindDeathSwarmDataDelegate");
static_assert(sizeof(DeathSwarmInterface_BindDeathSwarmDataDelegate) == 0x000010, "Wrong size on DeathSwarmInterface_BindDeathSwarmDataDelegate");
static_assert(offsetof(DeathSwarmInterface_BindDeathSwarmDataDelegate, InBindDelegate) == 0x000000, "Member 'DeathSwarmInterface_BindDeathSwarmDataDelegate::InBindDelegate' has a wrong offset!");

// Function DungeonCrawler.DeathSwarmInterface.UnbindDeathSwarmDataDelegate
// 0x0008 (0x0008 - 0x0000)
struct DeathSwarmInterface_UnbindDeathSwarmDataDelegate final
{
public:
	class UObject*                                InBoundObject;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathSwarmInterface_UnbindDeathSwarmDataDelegate) == 0x000008, "Wrong alignment on DeathSwarmInterface_UnbindDeathSwarmDataDelegate");
static_assert(sizeof(DeathSwarmInterface_UnbindDeathSwarmDataDelegate) == 0x000008, "Wrong size on DeathSwarmInterface_UnbindDeathSwarmDataDelegate");
static_assert(offsetof(DeathSwarmInterface_UnbindDeathSwarmDataDelegate, InBoundObject) == 0x000000, "Member 'DeathSwarmInterface_UnbindDeathSwarmDataDelegate::InBoundObject' has a wrong offset!");

// Function DungeonCrawler.DeathSwarmInterface.GetDeathSwarmData
// 0x0080 (0x0080 - 0x0000)
struct DeathSwarmInterface_GetDeathSwarmData final
{
public:
	struct FGameDeathSwarmData                    ReturnValue;                                       // 0x0000(0x0080)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathSwarmInterface_GetDeathSwarmData) == 0x000008, "Wrong alignment on DeathSwarmInterface_GetDeathSwarmData");
static_assert(sizeof(DeathSwarmInterface_GetDeathSwarmData) == 0x000080, "Wrong size on DeathSwarmInterface_GetDeathSwarmData");
static_assert(offsetof(DeathSwarmInterface_GetDeathSwarmData, ReturnValue) == 0x000000, "Member 'DeathSwarmInterface_GetDeathSwarmData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DeathSwarmInterface.LogHandleDeathSwarmData
// 0x0088 (0x0088 - 0x0000)
struct DeathSwarmInterface_LogHandleDeathSwarmData final
{
public:
	const class UObject*                          InHandler;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameDeathSwarmData                    InDeathSwarmData;                                  // 0x0008(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(DeathSwarmInterface_LogHandleDeathSwarmData) == 0x000008, "Wrong alignment on DeathSwarmInterface_LogHandleDeathSwarmData");
static_assert(sizeof(DeathSwarmInterface_LogHandleDeathSwarmData) == 0x000088, "Wrong size on DeathSwarmInterface_LogHandleDeathSwarmData");
static_assert(offsetof(DeathSwarmInterface_LogHandleDeathSwarmData, InHandler) == 0x000000, "Member 'DeathSwarmInterface_LogHandleDeathSwarmData::InHandler' has a wrong offset!");
static_assert(offsetof(DeathSwarmInterface_LogHandleDeathSwarmData, InDeathSwarmData) == 0x000008, "Member 'DeathSwarmInterface_LogHandleDeathSwarmData::InDeathSwarmData' has a wrong offset!");

// Function DungeonCrawler.DesignDataAssetItemBundleInfo.GetBundleArtAssetByCount
// 0x0014 (0x0014 - 0x0000)
struct DesignDataAssetItemBundleInfo_GetBundleArtAssetByCount final
{
public:
	int32                                         ItemCount;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0004(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DesignDataAssetItemBundleInfo_GetBundleArtAssetByCount) == 0x000004, "Wrong alignment on DesignDataAssetItemBundleInfo_GetBundleArtAssetByCount");
static_assert(sizeof(DesignDataAssetItemBundleInfo_GetBundleArtAssetByCount) == 0x000014, "Wrong size on DesignDataAssetItemBundleInfo_GetBundleArtAssetByCount");
static_assert(offsetof(DesignDataAssetItemBundleInfo_GetBundleArtAssetByCount, ItemCount) == 0x000000, "Member 'DesignDataAssetItemBundleInfo_GetBundleArtAssetByCount::ItemCount' has a wrong offset!");
static_assert(offsetof(DesignDataAssetItemBundleInfo_GetBundleArtAssetByCount, ReturnValue) == 0x000004, "Member 'DesignDataAssetItemBundleInfo_GetBundleArtAssetByCount::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectSlotWidget.OnGameUserSettingControlsChanged
// 0x0088 (0x0088 - 0x0000)
struct DungeonSelectSlotWidget_OnGameUserSettingControlsChanged final
{
public:
	struct FGameUserSettingControls               InGameUserSettingControls;                         // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameUserSettingControls               InOldGameUserSettingControls;                      // 0x0040(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInForce;                                          // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2801[0x7];                                     // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DungeonSelectSlotWidget_OnGameUserSettingControlsChanged) == 0x000008, "Wrong alignment on DungeonSelectSlotWidget_OnGameUserSettingControlsChanged");
static_assert(sizeof(DungeonSelectSlotWidget_OnGameUserSettingControlsChanged) == 0x000088, "Wrong size on DungeonSelectSlotWidget_OnGameUserSettingControlsChanged");
static_assert(offsetof(DungeonSelectSlotWidget_OnGameUserSettingControlsChanged, InGameUserSettingControls) == 0x000000, "Member 'DungeonSelectSlotWidget_OnGameUserSettingControlsChanged::InGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(DungeonSelectSlotWidget_OnGameUserSettingControlsChanged, InOldGameUserSettingControls) == 0x000040, "Member 'DungeonSelectSlotWidget_OnGameUserSettingControlsChanged::InOldGameUserSettingControls' has a wrong offset!");
static_assert(offsetof(DungeonSelectSlotWidget_OnGameUserSettingControlsChanged, bInForce) == 0x000080, "Member 'DungeonSelectSlotWidget_OnGameUserSettingControlsChanged::bInForce' has a wrong offset!");

// Function DungeonCrawler.DungeonSelectSlotWidget.SetSelectedMatchMode
// 0x0001 (0x0001 - 0x0000)
struct DungeonSelectSlotWidget_SetSelectedMatchMode final
{
public:
	EMatchMode                                    InMatchMode;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DungeonSelectSlotWidget_SetSelectedMatchMode) == 0x000001, "Wrong alignment on DungeonSelectSlotWidget_SetSelectedMatchMode");
static_assert(sizeof(DungeonSelectSlotWidget_SetSelectedMatchMode) == 0x000001, "Wrong size on DungeonSelectSlotWidget_SetSelectedMatchMode");
static_assert(offsetof(DungeonSelectSlotWidget_SetSelectedMatchMode, InMatchMode) == 0x000000, "Member 'DungeonSelectSlotWidget_SetSelectedMatchMode::InMatchMode' has a wrong offset!");

// Function DungeonCrawler.EquipmentSlotWidget.OnFinishedItemDataSet
// 0x0118 (0x0118 - 0x0000)
struct EquipmentSlotWidget_OnFinishedItemDataSet final
{
public:
	struct FItemData                              InItemData;                                        // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HandType;                                          // 0x0100(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SlotType;                                          // 0x0108(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemInventorySize                     InventorySize;                                     // 0x0110(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentSlotWidget_OnFinishedItemDataSet) == 0x000008, "Wrong alignment on EquipmentSlotWidget_OnFinishedItemDataSet");
static_assert(sizeof(EquipmentSlotWidget_OnFinishedItemDataSet) == 0x000118, "Wrong size on EquipmentSlotWidget_OnFinishedItemDataSet");
static_assert(offsetof(EquipmentSlotWidget_OnFinishedItemDataSet, InItemData) == 0x000000, "Member 'EquipmentSlotWidget_OnFinishedItemDataSet::InItemData' has a wrong offset!");
static_assert(offsetof(EquipmentSlotWidget_OnFinishedItemDataSet, HandType) == 0x000100, "Member 'EquipmentSlotWidget_OnFinishedItemDataSet::HandType' has a wrong offset!");
static_assert(offsetof(EquipmentSlotWidget_OnFinishedItemDataSet, SlotType) == 0x000108, "Member 'EquipmentSlotWidget_OnFinishedItemDataSet::SlotType' has a wrong offset!");
static_assert(offsetof(EquipmentSlotWidget_OnFinishedItemDataSet, InventorySize) == 0x000110, "Member 'EquipmentSlotWidget_OnFinishedItemDataSet::InventorySize' has a wrong offset!");

// Function DungeonCrawler.EquipmentSlotWidget.OnOverlapItemWidget
// 0x0014 (0x0014 - 0x0000)
struct EquipmentSlotWidget_OnOverlapItemWidget final
{
public:
	struct FPrimaryAssetId                        ItemId;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bValidSlot;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanEquip;                                         // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2806[0x2];                                     // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EquipmentSlotWidget_OnOverlapItemWidget) == 0x000004, "Wrong alignment on EquipmentSlotWidget_OnOverlapItemWidget");
static_assert(sizeof(EquipmentSlotWidget_OnOverlapItemWidget) == 0x000014, "Wrong size on EquipmentSlotWidget_OnOverlapItemWidget");
static_assert(offsetof(EquipmentSlotWidget_OnOverlapItemWidget, ItemId) == 0x000000, "Member 'EquipmentSlotWidget_OnOverlapItemWidget::ItemId' has a wrong offset!");
static_assert(offsetof(EquipmentSlotWidget_OnOverlapItemWidget, bValidSlot) == 0x000010, "Member 'EquipmentSlotWidget_OnOverlapItemWidget::bValidSlot' has a wrong offset!");
static_assert(offsetof(EquipmentSlotWidget_OnOverlapItemWidget, bCanEquip) == 0x000011, "Member 'EquipmentSlotWidget_OnOverlapItemWidget::bCanEquip' has a wrong offset!");

// Function DungeonCrawler.EquipmentSlotWidget.OnRemoveItem
// 0x0100 (0x0100 - 0x0000)
struct EquipmentSlotWidget_OnRemoveItem final
{
public:
	struct FItemData                              InItemData;                                        // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentSlotWidget_OnRemoveItem) == 0x000008, "Wrong alignment on EquipmentSlotWidget_OnRemoveItem");
static_assert(sizeof(EquipmentSlotWidget_OnRemoveItem) == 0x000100, "Wrong size on EquipmentSlotWidget_OnRemoveItem");
static_assert(offsetof(EquipmentSlotWidget_OnRemoveItem, InItemData) == 0x000000, "Member 'EquipmentSlotWidget_OnRemoveItem::InItemData' has a wrong offset!");

// Function DungeonCrawler.EquipmentSlotWidget.RemovePreviewItemWidget
// 0x0001 (0x0001 - 0x0000)
struct EquipmentSlotWidget_RemovePreviewItemWidget final
{
public:
	bool                                          bSetItem;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentSlotWidget_RemovePreviewItemWidget) == 0x000001, "Wrong alignment on EquipmentSlotWidget_RemovePreviewItemWidget");
static_assert(sizeof(EquipmentSlotWidget_RemovePreviewItemWidget) == 0x000001, "Wrong size on EquipmentSlotWidget_RemovePreviewItemWidget");
static_assert(offsetof(EquipmentSlotWidget_RemovePreviewItemWidget, bSetItem) == 0x000000, "Member 'EquipmentSlotWidget_RemovePreviewItemWidget::bSetItem' has a wrong offset!");

// Function DungeonCrawler.EquipmentSlotWidget.SetActiveHoverImage
// 0x0001 (0x0001 - 0x0000)
struct EquipmentSlotWidget_SetActiveHoverImage final
{
public:
	bool                                          bActivate;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentSlotWidget_SetActiveHoverImage) == 0x000001, "Wrong alignment on EquipmentSlotWidget_SetActiveHoverImage");
static_assert(sizeof(EquipmentSlotWidget_SetActiveHoverImage) == 0x000001, "Wrong size on EquipmentSlotWidget_SetActiveHoverImage");
static_assert(offsetof(EquipmentSlotWidget_SetActiveHoverImage, bActivate) == 0x000000, "Member 'EquipmentSlotWidget_SetActiveHoverImage::bActivate' has a wrong offset!");

// Function DungeonCrawler.EquipmentSlotWidget.SetPreviewItemWidget
// 0x0014 (0x0014 - 0x0000)
struct EquipmentSlotWidget_SetPreviewItemWidget final
{
public:
	struct FPrimaryAssetId                        ItemId;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentSlotWidget_SetPreviewItemWidget) == 0x000004, "Wrong alignment on EquipmentSlotWidget_SetPreviewItemWidget");
static_assert(sizeof(EquipmentSlotWidget_SetPreviewItemWidget) == 0x000014, "Wrong size on EquipmentSlotWidget_SetPreviewItemWidget");
static_assert(offsetof(EquipmentSlotWidget_SetPreviewItemWidget, ItemId) == 0x000000, "Member 'EquipmentSlotWidget_SetPreviewItemWidget::ItemId' has a wrong offset!");
static_assert(offsetof(EquipmentSlotWidget_SetPreviewItemWidget, Duration) == 0x000010, "Member 'EquipmentSlotWidget_SetPreviewItemWidget::Duration' has a wrong offset!");

// Function DungeonCrawler.EquipmentSlotWidget.GetEquipmentSlotIndex
// 0x0001 (0x0001 - 0x0000)
struct EquipmentSlotWidget_GetEquipmentSlotIndex final
{
public:
	EDCEquipmentSlotIndex                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentSlotWidget_GetEquipmentSlotIndex) == 0x000001, "Wrong alignment on EquipmentSlotWidget_GetEquipmentSlotIndex");
static_assert(sizeof(EquipmentSlotWidget_GetEquipmentSlotIndex) == 0x000001, "Wrong size on EquipmentSlotWidget_GetEquipmentSlotIndex");
static_assert(offsetof(EquipmentSlotWidget_GetEquipmentSlotIndex, ReturnValue) == 0x000000, "Member 'EquipmentSlotWidget_GetEquipmentSlotIndex::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.EquipmentWeaponSlotSetWidget.CheckAndSetActiveHoverImageBySlot
// 0x0008 (0x0008 - 0x0000)
struct EquipmentWeaponSlotSetWidget_CheckAndSetActiveHoverImageBySlot final
{
public:
	class UWidget*                                SlotUnderPointerPosition;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentWeaponSlotSetWidget_CheckAndSetActiveHoverImageBySlot) == 0x000008, "Wrong alignment on EquipmentWeaponSlotSetWidget_CheckAndSetActiveHoverImageBySlot");
static_assert(sizeof(EquipmentWeaponSlotSetWidget_CheckAndSetActiveHoverImageBySlot) == 0x000008, "Wrong size on EquipmentWeaponSlotSetWidget_CheckAndSetActiveHoverImageBySlot");
static_assert(offsetof(EquipmentWeaponSlotSetWidget_CheckAndSetActiveHoverImageBySlot, SlotUnderPointerPosition) == 0x000000, "Member 'EquipmentWeaponSlotSetWidget_CheckAndSetActiveHoverImageBySlot::SlotUnderPointerPosition' has a wrong offset!");

// Function DungeonCrawler.EquipmentWeaponSlotSetWidget.SetActivePrimaryHoverImage
// 0x0001 (0x0001 - 0x0000)
struct EquipmentWeaponSlotSetWidget_SetActivePrimaryHoverImage final
{
public:
	bool                                          bActivate;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentWeaponSlotSetWidget_SetActivePrimaryHoverImage) == 0x000001, "Wrong alignment on EquipmentWeaponSlotSetWidget_SetActivePrimaryHoverImage");
static_assert(sizeof(EquipmentWeaponSlotSetWidget_SetActivePrimaryHoverImage) == 0x000001, "Wrong size on EquipmentWeaponSlotSetWidget_SetActivePrimaryHoverImage");
static_assert(offsetof(EquipmentWeaponSlotSetWidget_SetActivePrimaryHoverImage, bActivate) == 0x000000, "Member 'EquipmentWeaponSlotSetWidget_SetActivePrimaryHoverImage::bActivate' has a wrong offset!");

// Function DungeonCrawler.EquipmentWeaponSlotSetWidget.SetActiveSecondaryHoverImage
// 0x0001 (0x0001 - 0x0000)
struct EquipmentWeaponSlotSetWidget_SetActiveSecondaryHoverImage final
{
public:
	bool                                          bActivate;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(EquipmentWeaponSlotSetWidget_SetActiveSecondaryHoverImage) == 0x000001, "Wrong alignment on EquipmentWeaponSlotSetWidget_SetActiveSecondaryHoverImage");
static_assert(sizeof(EquipmentWeaponSlotSetWidget_SetActiveSecondaryHoverImage) == 0x000001, "Wrong size on EquipmentWeaponSlotSetWidget_SetActiveSecondaryHoverImage");
static_assert(offsetof(EquipmentWeaponSlotSetWidget_SetActiveSecondaryHoverImage, bActivate) == 0x000000, "Member 'EquipmentWeaponSlotSetWidget_SetActiveSecondaryHoverImage::bActivate' has a wrong offset!");

// Function DungeonCrawler.ExpandableInventoryComponent.SetExpandable
// 0x0001 (0x0001 - 0x0000)
struct ExpandableInventoryComponent_SetExpandable final
{
public:
	bool                                          bCanExpand;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExpandableInventoryComponent_SetExpandable) == 0x000001, "Wrong alignment on ExpandableInventoryComponent_SetExpandable");
static_assert(sizeof(ExpandableInventoryComponent_SetExpandable) == 0x000001, "Wrong size on ExpandableInventoryComponent_SetExpandable");
static_assert(offsetof(ExpandableInventoryComponent_SetExpandable, bCanExpand) == 0x000000, "Member 'ExpandableInventoryComponent_SetExpandable::bCanExpand' has a wrong offset!");

// Function DungeonCrawler.FloorPortalBase.OnFloorRuleFired
// 0x0040 (0x0040 - 0x0000)
struct FloorPortalBase_OnFloorRuleFired final
{
public:
	struct FGameFloorRuleData                     InFloorRuleData;                                   // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FloorPortalBase_OnFloorRuleFired) == 0x000008, "Wrong alignment on FloorPortalBase_OnFloorRuleFired");
static_assert(sizeof(FloorPortalBase_OnFloorRuleFired) == 0x000040, "Wrong size on FloorPortalBase_OnFloorRuleFired");
static_assert(offsetof(FloorPortalBase_OnFloorRuleFired, InFloorRuleData) == 0x000000, "Member 'FloorPortalBase_OnFloorRuleFired::InFloorRuleData' has a wrong offset!");

// Function DungeonCrawler.GameAlivePlayerCountWidget.OnAlivePlayerCount
// 0x0008 (0x0008 - 0x0000)
struct GameAlivePlayerCountWidget_OnAlivePlayerCount final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameAlivePlayerCountWidget_OnAlivePlayerCount) == 0x000004, "Wrong alignment on GameAlivePlayerCountWidget_OnAlivePlayerCount");
static_assert(sizeof(GameAlivePlayerCountWidget_OnAlivePlayerCount) == 0x000008, "Wrong size on GameAlivePlayerCountWidget_OnAlivePlayerCount");
static_assert(offsetof(GameAlivePlayerCountWidget_OnAlivePlayerCount, NewValue) == 0x000000, "Member 'GameAlivePlayerCountWidget_OnAlivePlayerCount::NewValue' has a wrong offset!");
static_assert(offsetof(GameAlivePlayerCountWidget_OnAlivePlayerCount, OldValue) == 0x000004, "Member 'GameAlivePlayerCountWidget_OnAlivePlayerCount::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameAlivePlayerCountWidget.OnTotalPlayerCount
// 0x0008 (0x0008 - 0x0000)
struct GameAlivePlayerCountWidget_OnTotalPlayerCount final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameAlivePlayerCountWidget_OnTotalPlayerCount) == 0x000004, "Wrong alignment on GameAlivePlayerCountWidget_OnTotalPlayerCount");
static_assert(sizeof(GameAlivePlayerCountWidget_OnTotalPlayerCount) == 0x000008, "Wrong size on GameAlivePlayerCountWidget_OnTotalPlayerCount");
static_assert(offsetof(GameAlivePlayerCountWidget_OnTotalPlayerCount, NewValue) == 0x000000, "Member 'GameAlivePlayerCountWidget_OnTotalPlayerCount::NewValue' has a wrong offset!");
static_assert(offsetof(GameAlivePlayerCountWidget_OnTotalPlayerCount, OldValue) == 0x000004, "Member 'GameAlivePlayerCountWidget_OnTotalPlayerCount::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameCrossHairWidget.OnActivateSpellCrossHair
// 0x0001 (0x0001 - 0x0000)
struct GameCrossHairWidget_OnActivateSpellCrossHair final
{
public:
	bool                                          IsActivate;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCrossHairWidget_OnActivateSpellCrossHair) == 0x000001, "Wrong alignment on GameCrossHairWidget_OnActivateSpellCrossHair");
static_assert(sizeof(GameCrossHairWidget_OnActivateSpellCrossHair) == 0x000001, "Wrong size on GameCrossHairWidget_OnActivateSpellCrossHair");
static_assert(offsetof(GameCrossHairWidget_OnActivateSpellCrossHair, IsActivate) == 0x000000, "Member 'GameCrossHairWidget_OnActivateSpellCrossHair::IsActivate' has a wrong offset!");

// Function DungeonCrawler.GameCrossHairWidget.OnChangeCrossHairInfo
// 0x0014 (0x0014 - 0x0000)
struct GameCrossHairWidget_OnChangeCrossHairInfo final
{
public:
	struct FGameplayTag                           WeaponTypeTag;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeAngle;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPinPoint;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280F[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateTime;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCrossHairWidget_OnChangeCrossHairInfo) == 0x000004, "Wrong alignment on GameCrossHairWidget_OnChangeCrossHairInfo");
static_assert(sizeof(GameCrossHairWidget_OnChangeCrossHairInfo) == 0x000014, "Wrong size on GameCrossHairWidget_OnChangeCrossHairInfo");
static_assert(offsetof(GameCrossHairWidget_OnChangeCrossHairInfo, WeaponTypeTag) == 0x000000, "Member 'GameCrossHairWidget_OnChangeCrossHairInfo::WeaponTypeTag' has a wrong offset!");
static_assert(offsetof(GameCrossHairWidget_OnChangeCrossHairInfo, ChangeAngle) == 0x000008, "Member 'GameCrossHairWidget_OnChangeCrossHairInfo::ChangeAngle' has a wrong offset!");
static_assert(offsetof(GameCrossHairWidget_OnChangeCrossHairInfo, IsPinPoint) == 0x00000C, "Member 'GameCrossHairWidget_OnChangeCrossHairInfo::IsPinPoint' has a wrong offset!");
static_assert(offsetof(GameCrossHairWidget_OnChangeCrossHairInfo, RotateTime) == 0x000010, "Member 'GameCrossHairWidget_OnChangeCrossHairInfo::RotateTime' has a wrong offset!");

// Function DungeonCrawler.GameCrossHairWidget.OnChangeToRangeCrossHairAndPullAction
// 0x0010 (0x0010 - 0x0000)
struct GameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction final
{
public:
	struct FGameplayTag                           WeaponTypeTag;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemUtilityTag;                                    // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction) == 0x000004, "Wrong alignment on GameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction");
static_assert(sizeof(GameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction) == 0x000010, "Wrong size on GameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction");
static_assert(offsetof(GameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction, WeaponTypeTag) == 0x000000, "Member 'GameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction::WeaponTypeTag' has a wrong offset!");
static_assert(offsetof(GameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction, ItemUtilityTag) == 0x000008, "Member 'GameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction::ItemUtilityTag' has a wrong offset!");

// Function DungeonCrawler.GameCrossHairWidget.OnChangeWeaponCrossHair
// 0x001C (0x001C - 0x0000)
struct GameCrossHairWidget_OnChangeWeaponCrossHair final
{
public:
	struct FGameplayTag                           WeaponTypeTag;                                     // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemUtilityTag;                                    // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemSlotTypeTags;                                  // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAttackEnable;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2810[0x3];                                     // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameCrossHairWidget_OnChangeWeaponCrossHair) == 0x000004, "Wrong alignment on GameCrossHairWidget_OnChangeWeaponCrossHair");
static_assert(sizeof(GameCrossHairWidget_OnChangeWeaponCrossHair) == 0x00001C, "Wrong size on GameCrossHairWidget_OnChangeWeaponCrossHair");
static_assert(offsetof(GameCrossHairWidget_OnChangeWeaponCrossHair, WeaponTypeTag) == 0x000000, "Member 'GameCrossHairWidget_OnChangeWeaponCrossHair::WeaponTypeTag' has a wrong offset!");
static_assert(offsetof(GameCrossHairWidget_OnChangeWeaponCrossHair, ItemUtilityTag) == 0x000008, "Member 'GameCrossHairWidget_OnChangeWeaponCrossHair::ItemUtilityTag' has a wrong offset!");
static_assert(offsetof(GameCrossHairWidget_OnChangeWeaponCrossHair, ItemSlotTypeTags) == 0x000010, "Member 'GameCrossHairWidget_OnChangeWeaponCrossHair::ItemSlotTypeTags' has a wrong offset!");
static_assert(offsetof(GameCrossHairWidget_OnChangeWeaponCrossHair, IsAttackEnable) == 0x000018, "Member 'GameCrossHairWidget_OnChangeWeaponCrossHair::IsAttackEnable' has a wrong offset!");

// Function DungeonCrawler.GameCrossHairWidget.OnCrossHairChangeEvent
// 0x0010 (0x0010 - 0x0000)
struct GameCrossHairWidget_OnCrossHairChangeEvent final
{
public:
	TArray<class AItemActor*>                     EquipItemActors;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCrossHairWidget_OnCrossHairChangeEvent) == 0x000008, "Wrong alignment on GameCrossHairWidget_OnCrossHairChangeEvent");
static_assert(sizeof(GameCrossHairWidget_OnCrossHairChangeEvent) == 0x000010, "Wrong size on GameCrossHairWidget_OnCrossHairChangeEvent");
static_assert(offsetof(GameCrossHairWidget_OnCrossHairChangeEvent, EquipItemActors) == 0x000000, "Member 'GameCrossHairWidget_OnCrossHairChangeEvent::EquipItemActors' has a wrong offset!");

// Function DungeonCrawler.GameCrossHairWidget.OnCrossHairVisability
// 0x0002 (0x0002 - 0x0000)
struct GameCrossHairWidget_OnCrossHairVisability final
{
public:
	bool                                          IsVisablile;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SetDefault;                                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCrossHairWidget_OnCrossHairVisability) == 0x000001, "Wrong alignment on GameCrossHairWidget_OnCrossHairVisability");
static_assert(sizeof(GameCrossHairWidget_OnCrossHairVisability) == 0x000002, "Wrong size on GameCrossHairWidget_OnCrossHairVisability");
static_assert(offsetof(GameCrossHairWidget_OnCrossHairVisability, IsVisablile) == 0x000000, "Member 'GameCrossHairWidget_OnCrossHairVisability::IsVisablile' has a wrong offset!");
static_assert(offsetof(GameCrossHairWidget_OnCrossHairVisability, SetDefault) == 0x000001, "Member 'GameCrossHairWidget_OnCrossHairVisability::SetDefault' has a wrong offset!");

// Function DungeonCrawler.GameCrossHairWidget.OnPlayPullingCrossHair
// 0x0004 (0x0004 - 0x0000)
struct GameCrossHairWidget_OnPlayPullingCrossHair final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCrossHairWidget_OnPlayPullingCrossHair) == 0x000004, "Wrong alignment on GameCrossHairWidget_OnPlayPullingCrossHair");
static_assert(sizeof(GameCrossHairWidget_OnPlayPullingCrossHair) == 0x000004, "Wrong size on GameCrossHairWidget_OnPlayPullingCrossHair");
static_assert(offsetof(GameCrossHairWidget_OnPlayPullingCrossHair, Rate) == 0x000000, "Member 'GameCrossHairWidget_OnPlayPullingCrossHair::Rate' has a wrong offset!");

// Function DungeonCrawler.GameCrossHairWidget.OnPlayShootCrossHair
// 0x0004 (0x0004 - 0x0000)
struct GameCrossHairWidget_OnPlayShootCrossHair final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameCrossHairWidget_OnPlayShootCrossHair) == 0x000004, "Wrong alignment on GameCrossHairWidget_OnPlayShootCrossHair");
static_assert(sizeof(GameCrossHairWidget_OnPlayShootCrossHair) == 0x000004, "Wrong size on GameCrossHairWidget_OnPlayShootCrossHair");
static_assert(offsetof(GameCrossHairWidget_OnPlayShootCrossHair, Rate) == 0x000000, "Member 'GameCrossHairWidget_OnPlayShootCrossHair::Rate' has a wrong offset!");

// Function DungeonCrawler.GameEmoteSelectGroupWidget.OnCurrentEmoteSlotChanged
// 0x0018 (0x0018 - 0x0000)
struct GameEmoteSelectGroupWidget_OnCurrentEmoteSlotChanged final
{
public:
	class FText                                   InName;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameEmoteSelectGroupWidget_OnCurrentEmoteSlotChanged) == 0x000008, "Wrong alignment on GameEmoteSelectGroupWidget_OnCurrentEmoteSlotChanged");
static_assert(sizeof(GameEmoteSelectGroupWidget_OnCurrentEmoteSlotChanged) == 0x000018, "Wrong size on GameEmoteSelectGroupWidget_OnCurrentEmoteSlotChanged");
static_assert(offsetof(GameEmoteSelectGroupWidget_OnCurrentEmoteSlotChanged, InName) == 0x000000, "Member 'GameEmoteSelectGroupWidget_OnCurrentEmoteSlotChanged::InName' has a wrong offset!");

// Function DungeonCrawler.GameHeadupWidgetComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct GameHeadupWidgetComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameHeadupWidgetComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on GameHeadupWidgetComponent_BroadcastMsgBlueprint");
static_assert(sizeof(GameHeadupWidgetComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on GameHeadupWidgetComponent_BroadcastMsgBlueprint");
static_assert(offsetof(GameHeadupWidgetComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'GameHeadupWidgetComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.GameHeadupWidgetComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct GameHeadupWidgetComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameHeadupWidgetComponent_UnbindMsg) == 0x000008, "Wrong alignment on GameHeadupWidgetComponent_UnbindMsg");
static_assert(sizeof(GameHeadupWidgetComponent_UnbindMsg) == 0x000010, "Wrong size on GameHeadupWidgetComponent_UnbindMsg");
static_assert(offsetof(GameHeadupWidgetComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'GameHeadupWidgetComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(GameHeadupWidgetComponent_UnbindMsg, InObject) == 0x000008, "Member 'GameHeadupWidgetComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.GameHeadupWidgetComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct GameHeadupWidgetComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameHeadupWidgetComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on GameHeadupWidgetComponent_UnbindMsgAll");
static_assert(sizeof(GameHeadupWidgetComponent_UnbindMsgAll) == 0x000008, "Wrong size on GameHeadupWidgetComponent_UnbindMsgAll");
static_assert(offsetof(GameHeadupWidgetComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'GameHeadupWidgetComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.GameHitDirectionWidget.SetHitDirection
// 0x0018 (0x0018 - 0x0000)
struct GameHitDirectionWidget_SetHitDirection final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameHitDirectionWidget_SetHitDirection) == 0x000008, "Wrong alignment on GameHitDirectionWidget_SetHitDirection");
static_assert(sizeof(GameHitDirectionWidget_SetHitDirection) == 0x000018, "Wrong size on GameHitDirectionWidget_SetHitDirection");
static_assert(offsetof(GameHitDirectionWidget_SetHitDirection, Direction) == 0x000000, "Member 'GameHitDirectionWidget_SetHitDirection::Direction' has a wrong offset!");

// Function DungeonCrawler.GameInteractionDescriptionWidget.OnInputType
// 0x0002 (0x0002 - 0x0000)
struct GameInteractionDescriptionWidget_OnInputType final
{
public:
	ECommonInputType                              NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommonInputType                              OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInteractionDescriptionWidget_OnInputType) == 0x000001, "Wrong alignment on GameInteractionDescriptionWidget_OnInputType");
static_assert(sizeof(GameInteractionDescriptionWidget_OnInputType) == 0x000002, "Wrong size on GameInteractionDescriptionWidget_OnInputType");
static_assert(offsetof(GameInteractionDescriptionWidget_OnInputType, NewValue) == 0x000000, "Member 'GameInteractionDescriptionWidget_OnInputType::NewValue' has a wrong offset!");
static_assert(offsetof(GameInteractionDescriptionWidget_OnInputType, OldValue) == 0x000001, "Member 'GameInteractionDescriptionWidget_OnInputType::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameInteractionDescriptionWidget.OnInteractableDataByStateMap
// 0x00A0 (0x00A0 - 0x0000)
struct GameInteractionDescriptionWidget_OnInteractableDataByStateMap final
{
public:
	TMap<struct FGameplayTag, struct FInteractionData> NewValue;                                          // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FInteractionData> OldValue;                                          // 0x0050(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInteractionDescriptionWidget_OnInteractableDataByStateMap) == 0x000008, "Wrong alignment on GameInteractionDescriptionWidget_OnInteractableDataByStateMap");
static_assert(sizeof(GameInteractionDescriptionWidget_OnInteractableDataByStateMap) == 0x0000A0, "Wrong size on GameInteractionDescriptionWidget_OnInteractableDataByStateMap");
static_assert(offsetof(GameInteractionDescriptionWidget_OnInteractableDataByStateMap, NewValue) == 0x000000, "Member 'GameInteractionDescriptionWidget_OnInteractableDataByStateMap::NewValue' has a wrong offset!");
static_assert(offsetof(GameInteractionDescriptionWidget_OnInteractableDataByStateMap, OldValue) == 0x000050, "Member 'GameInteractionDescriptionWidget_OnInteractableDataByStateMap::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameInteractionDescriptionWidget.OnInteractTargetData
// 0x0040 (0x0040 - 0x0000)
struct GameInteractionDescriptionWidget_OnInteractTargetData final
{
public:
	struct FInteractTargetData                    NewValue;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FInteractTargetData                    OldValue;                                          // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInteractionDescriptionWidget_OnInteractTargetData) == 0x000008, "Wrong alignment on GameInteractionDescriptionWidget_OnInteractTargetData");
static_assert(sizeof(GameInteractionDescriptionWidget_OnInteractTargetData) == 0x000040, "Wrong size on GameInteractionDescriptionWidget_OnInteractTargetData");
static_assert(offsetof(GameInteractionDescriptionWidget_OnInteractTargetData, NewValue) == 0x000000, "Member 'GameInteractionDescriptionWidget_OnInteractTargetData::NewValue' has a wrong offset!");
static_assert(offsetof(GameInteractionDescriptionWidget_OnInteractTargetData, OldValue) == 0x000020, "Member 'GameInteractionDescriptionWidget_OnInteractTargetData::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameInteractionSkillCheckWidget.OnInteractSkillCheckEnd
// 0x0001 (0x0001 - 0x0000)
struct GameInteractionSkillCheckWidget_OnInteractSkillCheckEnd final
{
public:
	ESkillCheckResult                             SkillCheckResult;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInteractionSkillCheckWidget_OnInteractSkillCheckEnd) == 0x000001, "Wrong alignment on GameInteractionSkillCheckWidget_OnInteractSkillCheckEnd");
static_assert(sizeof(GameInteractionSkillCheckWidget_OnInteractSkillCheckEnd) == 0x000001, "Wrong size on GameInteractionSkillCheckWidget_OnInteractSkillCheckEnd");
static_assert(offsetof(GameInteractionSkillCheckWidget_OnInteractSkillCheckEnd, SkillCheckResult) == 0x000000, "Member 'GameInteractionSkillCheckWidget_OnInteractSkillCheckEnd::SkillCheckResult' has a wrong offset!");

// Function DungeonCrawler.GameInteractionSkillCheckWidget.OnInteractSkillCheckStart
// 0x001C (0x001C - 0x0000)
struct GameInteractionSkillCheckWidget_OnInteractSkillCheckStart final
{
public:
	struct FSkillCheckData                        SkillCheckData;                                    // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInteractionSkillCheckWidget_OnInteractSkillCheckStart) == 0x000004, "Wrong alignment on GameInteractionSkillCheckWidget_OnInteractSkillCheckStart");
static_assert(sizeof(GameInteractionSkillCheckWidget_OnInteractSkillCheckStart) == 0x00001C, "Wrong size on GameInteractionSkillCheckWidget_OnInteractSkillCheckStart");
static_assert(offsetof(GameInteractionSkillCheckWidget_OnInteractSkillCheckStart, SkillCheckData) == 0x000000, "Member 'GameInteractionSkillCheckWidget_OnInteractSkillCheckStart::SkillCheckData' has a wrong offset!");

// Function DungeonCrawler.GameMiniMapWidget.OnDeathSwarmData
// 0x0080 (0x0080 - 0x0000)
struct GameMiniMapWidget_OnDeathSwarmData final
{
public:
	struct FGameDeathSwarmData                    DeathSwarmData;                                    // 0x0000(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMiniMapWidget_OnDeathSwarmData) == 0x000008, "Wrong alignment on GameMiniMapWidget_OnDeathSwarmData");
static_assert(sizeof(GameMiniMapWidget_OnDeathSwarmData) == 0x000080, "Wrong size on GameMiniMapWidget_OnDeathSwarmData");
static_assert(offsetof(GameMiniMapWidget_OnDeathSwarmData, DeathSwarmData) == 0x000000, "Member 'GameMiniMapWidget_OnDeathSwarmData::DeathSwarmData' has a wrong offset!");

// Function DungeonCrawler.GameMiniMapWidget.OnDungeonModuleName
// 0x0030 (0x0030 - 0x0000)
struct GameMiniMapWidget_OnDungeonModuleName final
{
public:
	class FText                                   NewValue;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   OldValue;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMiniMapWidget_OnDungeonModuleName) == 0x000008, "Wrong alignment on GameMiniMapWidget_OnDungeonModuleName");
static_assert(sizeof(GameMiniMapWidget_OnDungeonModuleName) == 0x000030, "Wrong size on GameMiniMapWidget_OnDungeonModuleName");
static_assert(offsetof(GameMiniMapWidget_OnDungeonModuleName, NewValue) == 0x000000, "Member 'GameMiniMapWidget_OnDungeonModuleName::NewValue' has a wrong offset!");
static_assert(offsetof(GameMiniMapWidget_OnDungeonModuleName, OldValue) == 0x000018, "Member 'GameMiniMapWidget_OnDungeonModuleName::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameMiniMapWidget.OnFloorRuleActorRegistered
// 0x0008 (0x0008 - 0x0000)
struct GameMiniMapWidget_OnFloorRuleActorRegistered final
{
public:
	class AActor*                                 InFloorRuleActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMiniMapWidget_OnFloorRuleActorRegistered) == 0x000008, "Wrong alignment on GameMiniMapWidget_OnFloorRuleActorRegistered");
static_assert(sizeof(GameMiniMapWidget_OnFloorRuleActorRegistered) == 0x000008, "Wrong size on GameMiniMapWidget_OnFloorRuleActorRegistered");
static_assert(offsetof(GameMiniMapWidget_OnFloorRuleActorRegistered, InFloorRuleActor) == 0x000000, "Member 'GameMiniMapWidget_OnFloorRuleActorRegistered::InFloorRuleActor' has a wrong offset!");

// Function DungeonCrawler.GameMiniMapWidget.OnMiniMapDeathSwarmData
// 0x0070 (0x0070 - 0x0000)
struct GameMiniMapWidget_OnMiniMapDeathSwarmData final
{
public:
	struct FMiniMapDeathSwarmData                 NewValue;                                          // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FMiniMapDeathSwarmData                 OldValue;                                          // 0x0038(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMiniMapWidget_OnMiniMapDeathSwarmData) == 0x000008, "Wrong alignment on GameMiniMapWidget_OnMiniMapDeathSwarmData");
static_assert(sizeof(GameMiniMapWidget_OnMiniMapDeathSwarmData) == 0x000070, "Wrong size on GameMiniMapWidget_OnMiniMapDeathSwarmData");
static_assert(offsetof(GameMiniMapWidget_OnMiniMapDeathSwarmData, NewValue) == 0x000000, "Member 'GameMiniMapWidget_OnMiniMapDeathSwarmData::NewValue' has a wrong offset!");
static_assert(offsetof(GameMiniMapWidget_OnMiniMapDeathSwarmData, OldValue) == 0x000038, "Member 'GameMiniMapWidget_OnMiniMapDeathSwarmData::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameMiniMapWidget.OnMiniMapName
// 0x0020 (0x0020 - 0x0000)
struct GameMiniMapWidget_OnMiniMapName final
{
public:
	class FString                                 NewMiniMapName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OldMiniMapName;                                    // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMiniMapWidget_OnMiniMapName) == 0x000008, "Wrong alignment on GameMiniMapWidget_OnMiniMapName");
static_assert(sizeof(GameMiniMapWidget_OnMiniMapName) == 0x000020, "Wrong size on GameMiniMapWidget_OnMiniMapName");
static_assert(offsetof(GameMiniMapWidget_OnMiniMapName, NewMiniMapName) == 0x000000, "Member 'GameMiniMapWidget_OnMiniMapName::NewMiniMapName' has a wrong offset!");
static_assert(offsetof(GameMiniMapWidget_OnMiniMapName, OldMiniMapName) == 0x000010, "Member 'GameMiniMapWidget_OnMiniMapName::OldMiniMapName' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionPopupWidget.SetButtonText
// 0x0030 (0x0030 - 0x0000)
struct GameMenuOptionPopupWidget_SetButtonText final
{
public:
	class FText                                   InLeftText;                                        // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   InRightText;                                       // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionPopupWidget_SetButtonText) == 0x000008, "Wrong alignment on GameMenuOptionPopupWidget_SetButtonText");
static_assert(sizeof(GameMenuOptionPopupWidget_SetButtonText) == 0x000030, "Wrong size on GameMenuOptionPopupWidget_SetButtonText");
static_assert(offsetof(GameMenuOptionPopupWidget_SetButtonText, InLeftText) == 0x000000, "Member 'GameMenuOptionPopupWidget_SetButtonText::InLeftText' has a wrong offset!");
static_assert(offsetof(GameMenuOptionPopupWidget_SetButtonText, InRightText) == 0x000018, "Member 'GameMenuOptionPopupWidget_SetButtonText::InRightText' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionPopupWidget.SetDetailText
// 0x0018 (0x0018 - 0x0000)
struct GameMenuOptionPopupWidget_SetDetailText final
{
public:
	class FText                                   InDetailText;                                      // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionPopupWidget_SetDetailText) == 0x000008, "Wrong alignment on GameMenuOptionPopupWidget_SetDetailText");
static_assert(sizeof(GameMenuOptionPopupWidget_SetDetailText) == 0x000018, "Wrong size on GameMenuOptionPopupWidget_SetDetailText");
static_assert(offsetof(GameMenuOptionPopupWidget_SetDetailText, InDetailText) == 0x000000, "Member 'GameMenuOptionPopupWidget_SetDetailText::InDetailText' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionPopupWidget.UpdateButtonText
// 0x0030 (0x0030 - 0x0000)
struct GameMenuOptionPopupWidget_UpdateButtonText final
{
public:
	class FText                                   InLeftText;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   InRightText;                                       // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionPopupWidget_UpdateButtonText) == 0x000008, "Wrong alignment on GameMenuOptionPopupWidget_UpdateButtonText");
static_assert(sizeof(GameMenuOptionPopupWidget_UpdateButtonText) == 0x000030, "Wrong size on GameMenuOptionPopupWidget_UpdateButtonText");
static_assert(offsetof(GameMenuOptionPopupWidget_UpdateButtonText, InLeftText) == 0x000000, "Member 'GameMenuOptionPopupWidget_UpdateButtonText::InLeftText' has a wrong offset!");
static_assert(offsetof(GameMenuOptionPopupWidget_UpdateButtonText, InRightText) == 0x000018, "Member 'GameMenuOptionPopupWidget_UpdateButtonText::InRightText' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionPopupWidget.UpdateDetailText
// 0x0018 (0x0018 - 0x0000)
struct GameMenuOptionPopupWidget_UpdateDetailText final
{
public:
	class FText                                   InDetailText;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionPopupWidget_UpdateDetailText) == 0x000008, "Wrong alignment on GameMenuOptionPopupWidget_UpdateDetailText");
static_assert(sizeof(GameMenuOptionPopupWidget_UpdateDetailText) == 0x000018, "Wrong size on GameMenuOptionPopupWidget_UpdateDetailText");
static_assert(offsetof(GameMenuOptionPopupWidget_UpdateDetailText, InDetailText) == 0x000000, "Member 'GameMenuOptionPopupWidget_UpdateDetailText::InDetailText' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnAppActivateStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsAudioWidget_OnAppActivateStateChanged final
{
public:
	bool                                          IsAppActivateChange;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnAppActivateStateChanged) == 0x000001, "Wrong alignment on GameMenuOptionsAudioWidget_OnAppActivateStateChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnAppActivateStateChanged) == 0x000001, "Wrong size on GameMenuOptionsAudioWidget_OnAppActivateStateChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnAppActivateStateChanged, IsAppActivateChange) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnAppActivateStateChanged::IsAppActivateChange' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnBackgroundMusicChanged
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsAudioWidget_OnBackgroundMusicChanged final
{
public:
	bool                                          IsToggle;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnBackgroundMusicChanged) == 0x000001, "Wrong alignment on GameMenuOptionsAudioWidget_OnBackgroundMusicChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnBackgroundMusicChanged) == 0x000001, "Wrong size on GameMenuOptionsAudioWidget_OnBackgroundMusicChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnBackgroundMusicChanged, IsToggle) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnBackgroundMusicChanged::IsToggle' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnEffectVolumeValueChanged
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionsAudioWidget_OnEffectVolumeValueChanged final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnEffectVolumeValueChanged) == 0x000004, "Wrong alignment on GameMenuOptionsAudioWidget_OnEffectVolumeValueChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnEffectVolumeValueChanged) == 0x000004, "Wrong size on GameMenuOptionsAudioWidget_OnEffectVolumeValueChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnEffectVolumeValueChanged, NewValue) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnEffectVolumeValueChanged::NewValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnGameUserSettingAudiosChanged
// 0x0068 (0x0068 - 0x0000)
struct GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged final
{
public:
	struct FGameUserSettingAudios                 InGameUserSettingAudios;                           // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameUserSettingAudios                 InOldGameUserSettingAudios;                        // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bInForce;                                          // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281C[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged) == 0x000008, "Wrong alignment on GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged) == 0x000068, "Wrong size on GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged, InGameUserSettingAudios) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged::InGameUserSettingAudios' has a wrong offset!");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged, InOldGameUserSettingAudios) == 0x000030, "Member 'GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged::InOldGameUserSettingAudios' has a wrong offset!");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged, bInForce) == 0x000060, "Member 'GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged::bInForce' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnMusicVolumeValueChanged
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionsAudioWidget_OnMusicVolumeValueChanged final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnMusicVolumeValueChanged) == 0x000004, "Wrong alignment on GameMenuOptionsAudioWidget_OnMusicVolumeValueChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnMusicVolumeValueChanged) == 0x000004, "Wrong size on GameMenuOptionsAudioWidget_OnMusicVolumeValueChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnMusicVolumeValueChanged, NewValue) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnMusicVolumeValueChanged::NewValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnTotalVolumeValueChanged
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionsAudioWidget_OnTotalVolumeValueChanged final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnTotalVolumeValueChanged) == 0x000004, "Wrong alignment on GameMenuOptionsAudioWidget_OnTotalVolumeValueChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnTotalVolumeValueChanged) == 0x000004, "Wrong size on GameMenuOptionsAudioWidget_OnTotalVolumeValueChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnTotalVolumeValueChanged, NewValue) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnTotalVolumeValueChanged::NewValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnVoipInputVolumeValueChanged
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionsAudioWidget_OnVoipInputVolumeValueChanged final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnVoipInputVolumeValueChanged) == 0x000004, "Wrong alignment on GameMenuOptionsAudioWidget_OnVoipInputVolumeValueChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnVoipInputVolumeValueChanged) == 0x000004, "Wrong size on GameMenuOptionsAudioWidget_OnVoipInputVolumeValueChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnVoipInputVolumeValueChanged, NewValue) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnVoipInputVolumeValueChanged::NewValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnVoipModeChanged
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsAudioWidget_OnVoipModeChanged final
{
public:
	bool                                          IsToggle;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnVoipModeChanged) == 0x000001, "Wrong alignment on GameMenuOptionsAudioWidget_OnVoipModeChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnVoipModeChanged) == 0x000001, "Wrong size on GameMenuOptionsAudioWidget_OnVoipModeChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnVoipModeChanged, IsToggle) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnVoipModeChanged::IsToggle' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnVoipOnOffChanged
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsAudioWidget_OnVoipOnOffChanged final
{
public:
	bool                                          IsToggle;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnVoipOnOffChanged) == 0x000001, "Wrong alignment on GameMenuOptionsAudioWidget_OnVoipOnOffChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnVoipOnOffChanged) == 0x000001, "Wrong size on GameMenuOptionsAudioWidget_OnVoipOnOffChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnVoipOnOffChanged, IsToggle) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnVoipOnOffChanged::IsToggle' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnVoipOutputVolumeValueChanged
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionsAudioWidget_OnVoipOutputVolumeValueChanged final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnVoipOutputVolumeValueChanged) == 0x000004, "Wrong alignment on GameMenuOptionsAudioWidget_OnVoipOutputVolumeValueChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnVoipOutputVolumeValueChanged) == 0x000004, "Wrong size on GameMenuOptionsAudioWidget_OnVoipOutputVolumeValueChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnVoipOutputVolumeValueChanged, NewValue) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnVoipOutputVolumeValueChanged::NewValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnVoipSendModeChanged
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsAudioWidget_OnVoipSendModeChanged final
{
public:
	bool                                          IsToggle;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_OnVoipSendModeChanged) == 0x000001, "Wrong alignment on GameMenuOptionsAudioWidget_OnVoipSendModeChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_OnVoipSendModeChanged) == 0x000001, "Wrong size on GameMenuOptionsAudioWidget_OnVoipSendModeChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_OnVoipSendModeChanged, IsToggle) == 0x000000, "Member 'GameMenuOptionsAudioWidget_OnVoipSendModeChanged::IsToggle' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsAudioWidget.UpdateWindowFocusChanged
// 0x0008 (0x0008 - 0x0000)
struct GameMenuOptionsAudioWidget_UpdateWindowFocusChanged final
{
public:
	bool                                          IsFocus;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBackgroundOption;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281D[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalVolume;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsAudioWidget_UpdateWindowFocusChanged) == 0x000004, "Wrong alignment on GameMenuOptionsAudioWidget_UpdateWindowFocusChanged");
static_assert(sizeof(GameMenuOptionsAudioWidget_UpdateWindowFocusChanged) == 0x000008, "Wrong size on GameMenuOptionsAudioWidget_UpdateWindowFocusChanged");
static_assert(offsetof(GameMenuOptionsAudioWidget_UpdateWindowFocusChanged, IsFocus) == 0x000000, "Member 'GameMenuOptionsAudioWidget_UpdateWindowFocusChanged::IsFocus' has a wrong offset!");
static_assert(offsetof(GameMenuOptionsAudioWidget_UpdateWindowFocusChanged, IsBackgroundOption) == 0x000001, "Member 'GameMenuOptionsAudioWidget_UpdateWindowFocusChanged::IsBackgroundOption' has a wrong offset!");
static_assert(offsetof(GameMenuOptionsAudioWidget_UpdateWindowFocusChanged, TotalVolume) == 0x000004, "Member 'GameMenuOptionsAudioWidget_UpdateWindowFocusChanged::TotalVolume' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnGameUserSettingControls
// 0x0080 (0x0080 - 0x0000)
struct GameMenuOptionsControlsWidget_OnGameUserSettingControls final
{
public:
	struct FGameUserSettingControls               NewValue;                                          // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameUserSettingControls               OldValue;                                          // 0x0040(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_OnGameUserSettingControls) == 0x000008, "Wrong alignment on GameMenuOptionsControlsWidget_OnGameUserSettingControls");
static_assert(sizeof(GameMenuOptionsControlsWidget_OnGameUserSettingControls) == 0x000080, "Wrong size on GameMenuOptionsControlsWidget_OnGameUserSettingControls");
static_assert(offsetof(GameMenuOptionsControlsWidget_OnGameUserSettingControls, NewValue) == 0x000000, "Member 'GameMenuOptionsControlsWidget_OnGameUserSettingControls::NewValue' has a wrong offset!");
static_assert(offsetof(GameMenuOptionsControlsWidget_OnGameUserSettingControls, OldValue) == 0x000040, "Member 'GameMenuOptionsControlsWidget_OnGameUserSettingControls::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnInvertMouseHorizontalAxisClicked
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsControlsWidget_OnInvertMouseHorizontalAxisClicked final
{
public:
	bool                                          IsClick;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_OnInvertMouseHorizontalAxisClicked) == 0x000001, "Wrong alignment on GameMenuOptionsControlsWidget_OnInvertMouseHorizontalAxisClicked");
static_assert(sizeof(GameMenuOptionsControlsWidget_OnInvertMouseHorizontalAxisClicked) == 0x000001, "Wrong size on GameMenuOptionsControlsWidget_OnInvertMouseHorizontalAxisClicked");
static_assert(offsetof(GameMenuOptionsControlsWidget_OnInvertMouseHorizontalAxisClicked, IsClick) == 0x000000, "Member 'GameMenuOptionsControlsWidget_OnInvertMouseHorizontalAxisClicked::IsClick' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnInvertMouseVerticalAxisClicked
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsControlsWidget_OnInvertMouseVerticalAxisClicked final
{
public:
	bool                                          IsClick;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_OnInvertMouseVerticalAxisClicked) == 0x000001, "Wrong alignment on GameMenuOptionsControlsWidget_OnInvertMouseVerticalAxisClicked");
static_assert(sizeof(GameMenuOptionsControlsWidget_OnInvertMouseVerticalAxisClicked) == 0x000001, "Wrong size on GameMenuOptionsControlsWidget_OnInvertMouseVerticalAxisClicked");
static_assert(offsetof(GameMenuOptionsControlsWidget_OnInvertMouseVerticalAxisClicked, IsClick) == 0x000000, "Member 'GameMenuOptionsControlsWidget_OnInvertMouseVerticalAxisClicked::IsClick' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnKnightLinkClicked
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsControlsWidget_OnKnightLinkClicked final
{
public:
	bool                                          bIsVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_OnKnightLinkClicked) == 0x000001, "Wrong alignment on GameMenuOptionsControlsWidget_OnKnightLinkClicked");
static_assert(sizeof(GameMenuOptionsControlsWidget_OnKnightLinkClicked) == 0x000001, "Wrong size on GameMenuOptionsControlsWidget_OnKnightLinkClicked");
static_assert(offsetof(GameMenuOptionsControlsWidget_OnKnightLinkClicked, bIsVisible) == 0x000000, "Member 'GameMenuOptionsControlsWidget_OnKnightLinkClicked::bIsVisible' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnLowViolenceModeWidgetClicked
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsControlsWidget_OnLowViolenceModeWidgetClicked final
{
public:
	bool                                          bIsClick;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_OnLowViolenceModeWidgetClicked) == 0x000001, "Wrong alignment on GameMenuOptionsControlsWidget_OnLowViolenceModeWidgetClicked");
static_assert(sizeof(GameMenuOptionsControlsWidget_OnLowViolenceModeWidgetClicked) == 0x000001, "Wrong size on GameMenuOptionsControlsWidget_OnLowViolenceModeWidgetClicked");
static_assert(offsetof(GameMenuOptionsControlsWidget_OnLowViolenceModeWidgetClicked, bIsClick) == 0x000000, "Member 'GameMenuOptionsControlsWidget_OnLowViolenceModeWidgetClicked::bIsClick' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnMouseSensitivitySliderValueChanged
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionsControlsWidget_OnMouseSensitivitySliderValueChanged final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_OnMouseSensitivitySliderValueChanged) == 0x000004, "Wrong alignment on GameMenuOptionsControlsWidget_OnMouseSensitivitySliderValueChanged");
static_assert(sizeof(GameMenuOptionsControlsWidget_OnMouseSensitivitySliderValueChanged) == 0x000004, "Wrong size on GameMenuOptionsControlsWidget_OnMouseSensitivitySliderValueChanged");
static_assert(offsetof(GameMenuOptionsControlsWidget_OnMouseSensitivitySliderValueChanged, InValue) == 0x000000, "Member 'GameMenuOptionsControlsWidget_OnMouseSensitivitySliderValueChanged::InValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnStreamingModeClicked
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsControlsWidget_OnStreamingModeClicked final
{
public:
	bool                                          IsClick;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_OnStreamingModeClicked) == 0x000001, "Wrong alignment on GameMenuOptionsControlsWidget_OnStreamingModeClicked");
static_assert(sizeof(GameMenuOptionsControlsWidget_OnStreamingModeClicked) == 0x000001, "Wrong size on GameMenuOptionsControlsWidget_OnStreamingModeClicked");
static_assert(offsetof(GameMenuOptionsControlsWidget_OnStreamingModeClicked, IsClick) == 0x000000, "Member 'GameMenuOptionsControlsWidget_OnStreamingModeClicked::IsClick' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.SetAutoFillUtilitySlot
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsControlsWidget_SetAutoFillUtilitySlot final
{
public:
	bool                                          bState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_SetAutoFillUtilitySlot) == 0x000001, "Wrong alignment on GameMenuOptionsControlsWidget_SetAutoFillUtilitySlot");
static_assert(sizeof(GameMenuOptionsControlsWidget_SetAutoFillUtilitySlot) == 0x000001, "Wrong size on GameMenuOptionsControlsWidget_SetAutoFillUtilitySlot");
static_assert(offsetof(GameMenuOptionsControlsWidget_SetAutoFillUtilitySlot, bState) == 0x000000, "Member 'GameMenuOptionsControlsWidget_SetAutoFillUtilitySlot::bState' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.SetAutoNextUtilitySlot
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsControlsWidget_SetAutoNextUtilitySlot final
{
public:
	bool                                          bState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_SetAutoNextUtilitySlot) == 0x000001, "Wrong alignment on GameMenuOptionsControlsWidget_SetAutoNextUtilitySlot");
static_assert(sizeof(GameMenuOptionsControlsWidget_SetAutoNextUtilitySlot) == 0x000001, "Wrong size on GameMenuOptionsControlsWidget_SetAutoNextUtilitySlot");
static_assert(offsetof(GameMenuOptionsControlsWidget_SetAutoNextUtilitySlot, bState) == 0x000000, "Member 'GameMenuOptionsControlsWidget_SetAutoNextUtilitySlot::bState' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.SetDeathCam
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsControlsWidget_SetDeathCam final
{
public:
	bool                                          bState;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_SetDeathCam) == 0x000001, "Wrong alignment on GameMenuOptionsControlsWidget_SetDeathCam");
static_assert(sizeof(GameMenuOptionsControlsWidget_SetDeathCam) == 0x000001, "Wrong size on GameMenuOptionsControlsWidget_SetDeathCam");
static_assert(offsetof(GameMenuOptionsControlsWidget_SetDeathCam, bState) == 0x000000, "Member 'GameMenuOptionsControlsWidget_SetDeathCam::bState' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsControlsWidget.SetLanguageSelected
// 0x0010 (0x0010 - 0x0000)
struct GameMenuOptionsControlsWidget_SetLanguageSelected final
{
public:
	class FString                                 SelectedString;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsControlsWidget_SetLanguageSelected) == 0x000008, "Wrong alignment on GameMenuOptionsControlsWidget_SetLanguageSelected");
static_assert(sizeof(GameMenuOptionsControlsWidget_SetLanguageSelected) == 0x000010, "Wrong size on GameMenuOptionsControlsWidget_SetLanguageSelected");
static_assert(offsetof(GameMenuOptionsControlsWidget_SetLanguageSelected, SelectedString) == 0x000000, "Member 'GameMenuOptionsControlsWidget_SetLanguageSelected::SelectedString' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.ChangeBinding
// 0x0020 (0x0020 - 0x0000)
struct GameMenuOptionsInputBindSlotWidget_ChangeBinding final
{
public:
	int32                                         InKeyBindSlot;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2822[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   InKey;                                             // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsInputBindSlotWidget_ChangeBinding) == 0x000008, "Wrong alignment on GameMenuOptionsInputBindSlotWidget_ChangeBinding");
static_assert(sizeof(GameMenuOptionsInputBindSlotWidget_ChangeBinding) == 0x000020, "Wrong size on GameMenuOptionsInputBindSlotWidget_ChangeBinding");
static_assert(offsetof(GameMenuOptionsInputBindSlotWidget_ChangeBinding, InKeyBindSlot) == 0x000000, "Member 'GameMenuOptionsInputBindSlotWidget_ChangeBinding::InKeyBindSlot' has a wrong offset!");
static_assert(offsetof(GameMenuOptionsInputBindSlotWidget_ChangeBinding, InKey) == 0x000008, "Member 'GameMenuOptionsInputBindSlotWidget_ChangeBinding::InKey' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.GetPrimaryGamepadFocusWidget
// 0x0008 (0x0008 - 0x0000)
struct GameMenuOptionsInputBindSlotWidget_GetPrimaryGamepadFocusWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsInputBindSlotWidget_GetPrimaryGamepadFocusWidget) == 0x000008, "Wrong alignment on GameMenuOptionsInputBindSlotWidget_GetPrimaryGamepadFocusWidget");
static_assert(sizeof(GameMenuOptionsInputBindSlotWidget_GetPrimaryGamepadFocusWidget) == 0x000008, "Wrong size on GameMenuOptionsInputBindSlotWidget_GetPrimaryGamepadFocusWidget");
static_assert(offsetof(GameMenuOptionsInputBindSlotWidget_GetPrimaryGamepadFocusWidget, ReturnValue) == 0x000000, "Member 'GameMenuOptionsInputBindSlotWidget_GetPrimaryGamepadFocusWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.HandlePrimaryKeyPressed
// 0x0018 (0x0018 - 0x0000)
struct GameMenuOptionsInputBindSlotWidget_HandlePrimaryKeyPressed final
{
public:
	struct FKey                                   InKey;                                             // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsInputBindSlotWidget_HandlePrimaryKeyPressed) == 0x000008, "Wrong alignment on GameMenuOptionsInputBindSlotWidget_HandlePrimaryKeyPressed");
static_assert(sizeof(GameMenuOptionsInputBindSlotWidget_HandlePrimaryKeyPressed) == 0x000018, "Wrong size on GameMenuOptionsInputBindSlotWidget_HandlePrimaryKeyPressed");
static_assert(offsetof(GameMenuOptionsInputBindSlotWidget_HandlePrimaryKeyPressed, InKey) == 0x000000, "Member 'GameMenuOptionsInputBindSlotWidget_HandlePrimaryKeyPressed::InKey' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.HandleSecondaryKeyPressed
// 0x0018 (0x0018 - 0x0000)
struct GameMenuOptionsInputBindSlotWidget_HandleSecondaryKeyPressed final
{
public:
	struct FKey                                   InKey;                                             // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsInputBindSlotWidget_HandleSecondaryKeyPressed) == 0x000008, "Wrong alignment on GameMenuOptionsInputBindSlotWidget_HandleSecondaryKeyPressed");
static_assert(sizeof(GameMenuOptionsInputBindSlotWidget_HandleSecondaryKeyPressed) == 0x000018, "Wrong size on GameMenuOptionsInputBindSlotWidget_HandleSecondaryKeyPressed");
static_assert(offsetof(GameMenuOptionsInputBindSlotWidget_HandleSecondaryKeyPressed, InKey) == 0x000000, "Member 'GameMenuOptionsInputBindSlotWidget_HandleSecondaryKeyPressed::InKey' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsInputSlotWidget.GetPrimaryGamepadFocusWidget
// 0x0008 (0x0008 - 0x0000)
struct GameMenuOptionsInputSlotWidget_GetPrimaryGamepadFocusWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsInputSlotWidget_GetPrimaryGamepadFocusWidget) == 0x000008, "Wrong alignment on GameMenuOptionsInputSlotWidget_GetPrimaryGamepadFocusWidget");
static_assert(sizeof(GameMenuOptionsInputSlotWidget_GetPrimaryGamepadFocusWidget) == 0x000008, "Wrong size on GameMenuOptionsInputSlotWidget_GetPrimaryGamepadFocusWidget");
static_assert(offsetof(GameMenuOptionsInputSlotWidget_GetPrimaryGamepadFocusWidget, ReturnValue) == 0x000000, "Member 'GameMenuOptionsInputSlotWidget_GetPrimaryGamepadFocusWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionSliderWidget.ExtractOnlyNumberics
// 0x0028 (0x0028 - 0x0000)
struct GameMenuOptionSliderWidget_ExtractOnlyNumberics final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInteger;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2827[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionSliderWidget_ExtractOnlyNumberics) == 0x000008, "Wrong alignment on GameMenuOptionSliderWidget_ExtractOnlyNumberics");
static_assert(sizeof(GameMenuOptionSliderWidget_ExtractOnlyNumberics) == 0x000028, "Wrong size on GameMenuOptionSliderWidget_ExtractOnlyNumberics");
static_assert(offsetof(GameMenuOptionSliderWidget_ExtractOnlyNumberics, Message) == 0x000000, "Member 'GameMenuOptionSliderWidget_ExtractOnlyNumberics::Message' has a wrong offset!");
static_assert(offsetof(GameMenuOptionSliderWidget_ExtractOnlyNumberics, IsInteger) == 0x000010, "Member 'GameMenuOptionSliderWidget_ExtractOnlyNumberics::IsInteger' has a wrong offset!");
static_assert(offsetof(GameMenuOptionSliderWidget_ExtractOnlyNumberics, ReturnValue) == 0x000018, "Member 'GameMenuOptionSliderWidget_ExtractOnlyNumberics::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionSliderWidget.GetOptionValue
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionSliderWidget_GetOptionValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionSliderWidget_GetOptionValue) == 0x000004, "Wrong alignment on GameMenuOptionSliderWidget_GetOptionValue");
static_assert(sizeof(GameMenuOptionSliderWidget_GetOptionValue) == 0x000004, "Wrong size on GameMenuOptionSliderWidget_GetOptionValue");
static_assert(offsetof(GameMenuOptionSliderWidget_GetOptionValue, ReturnValue) == 0x000000, "Member 'GameMenuOptionSliderWidget_GetOptionValue::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionSliderWidget.GetOptionValuePercent
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionSliderWidget_GetOptionValuePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionSliderWidget_GetOptionValuePercent) == 0x000004, "Wrong alignment on GameMenuOptionSliderWidget_GetOptionValuePercent");
static_assert(sizeof(GameMenuOptionSliderWidget_GetOptionValuePercent) == 0x000004, "Wrong size on GameMenuOptionSliderWidget_GetOptionValuePercent");
static_assert(offsetof(GameMenuOptionSliderWidget_GetOptionValuePercent, ReturnValue) == 0x000000, "Member 'GameMenuOptionSliderWidget_GetOptionValuePercent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionSliderWidget.GetPrimaryGamepadFocusWidget
// 0x0008 (0x0008 - 0x0000)
struct GameMenuOptionSliderWidget_GetPrimaryGamepadFocusWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionSliderWidget_GetPrimaryGamepadFocusWidget) == 0x000008, "Wrong alignment on GameMenuOptionSliderWidget_GetPrimaryGamepadFocusWidget");
static_assert(sizeof(GameMenuOptionSliderWidget_GetPrimaryGamepadFocusWidget) == 0x000008, "Wrong size on GameMenuOptionSliderWidget_GetPrimaryGamepadFocusWidget");
static_assert(offsetof(GameMenuOptionSliderWidget_GetPrimaryGamepadFocusWidget, ReturnValue) == 0x000000, "Member 'GameMenuOptionSliderWidget_GetPrimaryGamepadFocusWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionSliderWidget.SetOptionValue
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionSliderWidget_SetOptionValue final
{
public:
	float                                         InValue;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionSliderWidget_SetOptionValue) == 0x000004, "Wrong alignment on GameMenuOptionSliderWidget_SetOptionValue");
static_assert(sizeof(GameMenuOptionSliderWidget_SetOptionValue) == 0x000004, "Wrong size on GameMenuOptionSliderWidget_SetOptionValue");
static_assert(offsetof(GameMenuOptionSliderWidget_SetOptionValue, InValue) == 0x000000, "Member 'GameMenuOptionSliderWidget_SetOptionValue::InValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionSliderWidget.SetSliderMinMaxValue
// 0x000C (0x000C - 0x0000)
struct GameMenuOptionSliderWidget_SetSliderMinMaxValue final
{
public:
	float                                         InMinValue;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InMaxValue;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InStepSize;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionSliderWidget_SetSliderMinMaxValue) == 0x000004, "Wrong alignment on GameMenuOptionSliderWidget_SetSliderMinMaxValue");
static_assert(sizeof(GameMenuOptionSliderWidget_SetSliderMinMaxValue) == 0x00000C, "Wrong size on GameMenuOptionSliderWidget_SetSliderMinMaxValue");
static_assert(offsetof(GameMenuOptionSliderWidget_SetSliderMinMaxValue, InMinValue) == 0x000000, "Member 'GameMenuOptionSliderWidget_SetSliderMinMaxValue::InMinValue' has a wrong offset!");
static_assert(offsetof(GameMenuOptionSliderWidget_SetSliderMinMaxValue, InMaxValue) == 0x000004, "Member 'GameMenuOptionSliderWidget_SetSliderMinMaxValue::InMaxValue' has a wrong offset!");
static_assert(offsetof(GameMenuOptionSliderWidget_SetSliderMinMaxValue, InStepSize) == 0x000008, "Member 'GameMenuOptionSliderWidget_SetSliderMinMaxValue::InStepSize' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionSliderWidget.SetTitle
// 0x0018 (0x0018 - 0x0000)
struct GameMenuOptionSliderWidget_SetTitle final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionSliderWidget_SetTitle) == 0x000008, "Wrong alignment on GameMenuOptionSliderWidget_SetTitle");
static_assert(sizeof(GameMenuOptionSliderWidget_SetTitle) == 0x000018, "Wrong size on GameMenuOptionSliderWidget_SetTitle");
static_assert(offsetof(GameMenuOptionSliderWidget_SetTitle, InText) == 0x000000, "Member 'GameMenuOptionSliderWidget_SetTitle::InText' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionSliderWidget.UpdateSliderValue
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionSliderWidget_UpdateSliderValue final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionSliderWidget_UpdateSliderValue) == 0x000004, "Wrong alignment on GameMenuOptionSliderWidget_UpdateSliderValue");
static_assert(sizeof(GameMenuOptionSliderWidget_UpdateSliderValue) == 0x000004, "Wrong size on GameMenuOptionSliderWidget_UpdateSliderValue");
static_assert(offsetof(GameMenuOptionSliderWidget_UpdateSliderValue, NewValue) == 0x000000, "Member 'GameMenuOptionSliderWidget_UpdateSliderValue::NewValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionSlotWidget.OnSelectedSlotIdx
// 0x0008 (0x0008 - 0x0000)
struct GameMenuOptionSlotWidget_OnSelectedSlotIdx final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldValue;                                          // 0x0004(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionSlotWidget_OnSelectedSlotIdx) == 0x000004, "Wrong alignment on GameMenuOptionSlotWidget_OnSelectedSlotIdx");
static_assert(sizeof(GameMenuOptionSlotWidget_OnSelectedSlotIdx) == 0x000008, "Wrong size on GameMenuOptionSlotWidget_OnSelectedSlotIdx");
static_assert(offsetof(GameMenuOptionSlotWidget_OnSelectedSlotIdx, NewValue) == 0x000000, "Member 'GameMenuOptionSlotWidget_OnSelectedSlotIdx::NewValue' has a wrong offset!");
static_assert(offsetof(GameMenuOptionSlotWidget_OnSelectedSlotIdx, OldValue) == 0x000004, "Member 'GameMenuOptionSlotWidget_OnSelectedSlotIdx::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionSlotWidget.SetSelectedSlotIdx
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionSlotWidget_SetSelectedSlotIdx final
{
public:
	int32                                         InSlotIdx;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionSlotWidget_SetSelectedSlotIdx) == 0x000004, "Wrong alignment on GameMenuOptionSlotWidget_SetSelectedSlotIdx");
static_assert(sizeof(GameMenuOptionSlotWidget_SetSelectedSlotIdx) == 0x000004, "Wrong size on GameMenuOptionSlotWidget_SetSelectedSlotIdx");
static_assert(offsetof(GameMenuOptionSlotWidget_SetSelectedSlotIdx, InSlotIdx) == 0x000000, "Member 'GameMenuOptionSlotWidget_SetSelectedSlotIdx::InSlotIdx' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsPlatformWidget.OnLinkCodeWidgetCheckStateChanged
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsPlatformWidget_OnLinkCodeWidgetCheckStateChanged final
{
public:
	bool                                          bIsChecked;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsPlatformWidget_OnLinkCodeWidgetCheckStateChanged) == 0x000001, "Wrong alignment on GameMenuOptionsPlatformWidget_OnLinkCodeWidgetCheckStateChanged");
static_assert(sizeof(GameMenuOptionsPlatformWidget_OnLinkCodeWidgetCheckStateChanged) == 0x000001, "Wrong size on GameMenuOptionsPlatformWidget_OnLinkCodeWidgetCheckStateChanged");
static_assert(offsetof(GameMenuOptionsPlatformWidget_OnLinkCodeWidgetCheckStateChanged, bIsChecked) == 0x000000, "Member 'GameMenuOptionsPlatformWidget_OnLinkCodeWidgetCheckStateChanged::bIsChecked' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsVideoWidget.UpdateAntiAliasingSuperResolution
// 0x0004 (0x0004 - 0x0000)
struct GameMenuOptionsVideoWidget_UpdateAntiAliasingSuperResolution final
{
public:
	int32                                         InSlotIdx;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsVideoWidget_UpdateAntiAliasingSuperResolution) == 0x000004, "Wrong alignment on GameMenuOptionsVideoWidget_UpdateAntiAliasingSuperResolution");
static_assert(sizeof(GameMenuOptionsVideoWidget_UpdateAntiAliasingSuperResolution) == 0x000004, "Wrong size on GameMenuOptionsVideoWidget_UpdateAntiAliasingSuperResolution");
static_assert(offsetof(GameMenuOptionsVideoWidget_UpdateAntiAliasingSuperResolution, InSlotIdx) == 0x000000, "Member 'GameMenuOptionsVideoWidget_UpdateAntiAliasingSuperResolution::InSlotIdx' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsWidget.OnToggled
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsWidget_OnToggled final
{
public:
	ESlateVisibility                              Invisibility;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsWidget_OnToggled) == 0x000001, "Wrong alignment on GameMenuOptionsWidget_OnToggled");
static_assert(sizeof(GameMenuOptionsWidget_OnToggled) == 0x000001, "Wrong size on GameMenuOptionsWidget_OnToggled");
static_assert(offsetof(GameMenuOptionsWidget_OnToggled, Invisibility) == 0x000000, "Member 'GameMenuOptionsWidget_OnToggled::Invisibility' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionsWidget.OnWidgetToggleNotify
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionsWidget_OnWidgetToggleNotify final
{
public:
	ESlateVisibility                              Invisibility;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionsWidget_OnWidgetToggleNotify) == 0x000001, "Wrong alignment on GameMenuOptionsWidget_OnWidgetToggleNotify");
static_assert(sizeof(GameMenuOptionsWidget_OnWidgetToggleNotify) == 0x000001, "Wrong size on GameMenuOptionsWidget_OnWidgetToggleNotify");
static_assert(offsetof(GameMenuOptionsWidget_OnWidgetToggleNotify, Invisibility) == 0x000000, "Member 'GameMenuOptionsWidget_OnWidgetToggleNotify::Invisibility' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.GetPrimaryGamepadFocusWidget
// 0x0008 (0x0008 - 0x0000)
struct GameMenuOptionToggleSwitchWidget_GetPrimaryGamepadFocusWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionToggleSwitchWidget_GetPrimaryGamepadFocusWidget) == 0x000008, "Wrong alignment on GameMenuOptionToggleSwitchWidget_GetPrimaryGamepadFocusWidget");
static_assert(sizeof(GameMenuOptionToggleSwitchWidget_GetPrimaryGamepadFocusWidget) == 0x000008, "Wrong size on GameMenuOptionToggleSwitchWidget_GetPrimaryGamepadFocusWidget");
static_assert(offsetof(GameMenuOptionToggleSwitchWidget_GetPrimaryGamepadFocusWidget, ReturnValue) == 0x000000, "Member 'GameMenuOptionToggleSwitchWidget_GetPrimaryGamepadFocusWidget::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.GetToggleSwitch
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionToggleSwitchWidget_GetToggleSwitch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionToggleSwitchWidget_GetToggleSwitch) == 0x000001, "Wrong alignment on GameMenuOptionToggleSwitchWidget_GetToggleSwitch");
static_assert(sizeof(GameMenuOptionToggleSwitchWidget_GetToggleSwitch) == 0x000001, "Wrong size on GameMenuOptionToggleSwitchWidget_GetToggleSwitch");
static_assert(offsetof(GameMenuOptionToggleSwitchWidget_GetToggleSwitch, ReturnValue) == 0x000000, "Member 'GameMenuOptionToggleSwitchWidget_GetToggleSwitch::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.OnToggleSwitch
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionToggleSwitchWidget_OnToggleSwitch final
{
public:
	bool                                          InSwitch;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionToggleSwitchWidget_OnToggleSwitch) == 0x000001, "Wrong alignment on GameMenuOptionToggleSwitchWidget_OnToggleSwitch");
static_assert(sizeof(GameMenuOptionToggleSwitchWidget_OnToggleSwitch) == 0x000001, "Wrong size on GameMenuOptionToggleSwitchWidget_OnToggleSwitch");
static_assert(offsetof(GameMenuOptionToggleSwitchWidget_OnToggleSwitch, InSwitch) == 0x000000, "Member 'GameMenuOptionToggleSwitchWidget_OnToggleSwitch::InSwitch' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetButtonText
// 0x0030 (0x0030 - 0x0000)
struct GameMenuOptionToggleSwitchWidget_SetButtonText final
{
public:
	class FText                                   LeftText;                                          // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   RightText;                                         // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionToggleSwitchWidget_SetButtonText) == 0x000008, "Wrong alignment on GameMenuOptionToggleSwitchWidget_SetButtonText");
static_assert(sizeof(GameMenuOptionToggleSwitchWidget_SetButtonText) == 0x000030, "Wrong size on GameMenuOptionToggleSwitchWidget_SetButtonText");
static_assert(offsetof(GameMenuOptionToggleSwitchWidget_SetButtonText, LeftText) == 0x000000, "Member 'GameMenuOptionToggleSwitchWidget_SetButtonText::LeftText' has a wrong offset!");
static_assert(offsetof(GameMenuOptionToggleSwitchWidget_SetButtonText, RightText) == 0x000018, "Member 'GameMenuOptionToggleSwitchWidget_SetButtonText::RightText' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetTitle
// 0x0018 (0x0018 - 0x0000)
struct GameMenuOptionToggleSwitchWidget_SetTitle final
{
public:
	class FText                                   InTitle;                                           // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionToggleSwitchWidget_SetTitle) == 0x000008, "Wrong alignment on GameMenuOptionToggleSwitchWidget_SetTitle");
static_assert(sizeof(GameMenuOptionToggleSwitchWidget_SetTitle) == 0x000018, "Wrong size on GameMenuOptionToggleSwitchWidget_SetTitle");
static_assert(offsetof(GameMenuOptionToggleSwitchWidget_SetTitle, InTitle) == 0x000000, "Member 'GameMenuOptionToggleSwitchWidget_SetTitle::InTitle' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetToggleSwitch
// 0x0001 (0x0001 - 0x0000)
struct GameMenuOptionToggleSwitchWidget_SetToggleSwitch final
{
public:
	bool                                          InSwitch;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionToggleSwitchWidget_SetToggleSwitch) == 0x000001, "Wrong alignment on GameMenuOptionToggleSwitchWidget_SetToggleSwitch");
static_assert(sizeof(GameMenuOptionToggleSwitchWidget_SetToggleSwitch) == 0x000001, "Wrong size on GameMenuOptionToggleSwitchWidget_SetToggleSwitch");
static_assert(offsetof(GameMenuOptionToggleSwitchWidget_SetToggleSwitch, InSwitch) == 0x000000, "Member 'GameMenuOptionToggleSwitchWidget_SetToggleSwitch::InSwitch' has a wrong offset!");

// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.UpdateButtonText
// 0x0030 (0x0030 - 0x0000)
struct GameMenuOptionToggleSwitchWidget_UpdateButtonText final
{
public:
	class FText                                   LeftText;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   RightText;                                         // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuOptionToggleSwitchWidget_UpdateButtonText) == 0x000008, "Wrong alignment on GameMenuOptionToggleSwitchWidget_UpdateButtonText");
static_assert(sizeof(GameMenuOptionToggleSwitchWidget_UpdateButtonText) == 0x000030, "Wrong size on GameMenuOptionToggleSwitchWidget_UpdateButtonText");
static_assert(offsetof(GameMenuOptionToggleSwitchWidget_UpdateButtonText, LeftText) == 0x000000, "Member 'GameMenuOptionToggleSwitchWidget_UpdateButtonText::LeftText' has a wrong offset!");
static_assert(offsetof(GameMenuOptionToggleSwitchWidget_UpdateButtonText, RightText) == 0x000018, "Member 'GameMenuOptionToggleSwitchWidget_UpdateButtonText::RightText' has a wrong offset!");

// Function DungeonCrawler.GameMenuWidget.OnDisplayTotalPlaytime
// 0x0008 (0x0008 - 0x0000)
struct GameMenuWidget_OnDisplayTotalPlaytime final
{
public:
	struct FTimespan                              CurrentTotalPlayTime;                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuWidget_OnDisplayTotalPlaytime) == 0x000008, "Wrong alignment on GameMenuWidget_OnDisplayTotalPlaytime");
static_assert(sizeof(GameMenuWidget_OnDisplayTotalPlaytime) == 0x000008, "Wrong size on GameMenuWidget_OnDisplayTotalPlaytime");
static_assert(offsetof(GameMenuWidget_OnDisplayTotalPlaytime, CurrentTotalPlayTime) == 0x000000, "Member 'GameMenuWidget_OnDisplayTotalPlaytime::CurrentTotalPlayTime' has a wrong offset!");

// Function DungeonCrawler.GameMenuWidget.OnVisibleReportButton
// 0x0001 (0x0001 - 0x0000)
struct GameMenuWidget_OnVisibleReportButton final
{
public:
	bool                                          bIsVisible;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuWidget_OnVisibleReportButton) == 0x000001, "Wrong alignment on GameMenuWidget_OnVisibleReportButton");
static_assert(sizeof(GameMenuWidget_OnVisibleReportButton) == 0x000001, "Wrong size on GameMenuWidget_OnVisibleReportButton");
static_assert(offsetof(GameMenuWidget_OnVisibleReportButton, bIsVisible) == 0x000000, "Member 'GameMenuWidget_OnVisibleReportButton::bIsVisible' has a wrong offset!");

// Function DungeonCrawler.GameMenuWidget.IsLobby
// 0x0001 (0x0001 - 0x0000)
struct GameMenuWidget_IsLobby final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMenuWidget_IsLobby) == 0x000001, "Wrong alignment on GameMenuWidget_IsLobby");
static_assert(sizeof(GameMenuWidget_IsLobby) == 0x000001, "Wrong size on GameMenuWidget_IsLobby");
static_assert(offsetof(GameMenuWidget_IsLobby, ReturnValue) == 0x000000, "Member 'GameMenuWidget_IsLobby::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameMusicCurrentSlotWidget.OnMusicDataChanged
// 0x00F0 (0x00F0 - 0x0000)
struct GameMusicCurrentSlotWidget_OnMusicDataChanged final
{
public:
	struct FMusicData                             InMusicData;                                       // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2830[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesignDataMusic                       InDesignDataMusic;                                 // 0x0028(0x00C8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMusicCurrentSlotWidget_OnMusicDataChanged) == 0x000008, "Wrong alignment on GameMusicCurrentSlotWidget_OnMusicDataChanged");
static_assert(sizeof(GameMusicCurrentSlotWidget_OnMusicDataChanged) == 0x0000F0, "Wrong size on GameMusicCurrentSlotWidget_OnMusicDataChanged");
static_assert(offsetof(GameMusicCurrentSlotWidget_OnMusicDataChanged, InMusicData) == 0x000000, "Member 'GameMusicCurrentSlotWidget_OnMusicDataChanged::InMusicData' has a wrong offset!");
static_assert(offsetof(GameMusicCurrentSlotWidget_OnMusicDataChanged, InDesignDataMusic) == 0x000028, "Member 'GameMusicCurrentSlotWidget_OnMusicDataChanged::InDesignDataMusic' has a wrong offset!");

// Function DungeonCrawler.GameMusicCurrentSlotWidget.SetMusicData
// 0x00F0 (0x00F0 - 0x0000)
struct GameMusicCurrentSlotWidget_SetMusicData final
{
public:
	struct FMusicData                             InMusicData;                                       // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2831[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDesignDataMusic                       InDesignDataMusic;                                 // 0x0028(0x00C8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMusicCurrentSlotWidget_SetMusicData) == 0x000008, "Wrong alignment on GameMusicCurrentSlotWidget_SetMusicData");
static_assert(sizeof(GameMusicCurrentSlotWidget_SetMusicData) == 0x0000F0, "Wrong size on GameMusicCurrentSlotWidget_SetMusicData");
static_assert(offsetof(GameMusicCurrentSlotWidget_SetMusicData, InMusicData) == 0x000000, "Member 'GameMusicCurrentSlotWidget_SetMusicData::InMusicData' has a wrong offset!");
static_assert(offsetof(GameMusicCurrentSlotWidget_SetMusicData, InDesignDataMusic) == 0x000028, "Member 'GameMusicCurrentSlotWidget_SetMusicData::InDesignDataMusic' has a wrong offset!");

// Function DungeonCrawler.GameMusicPlayBarWidget.OnMusicChannelingStart
// 0x0001 (0x0001 - 0x0000)
struct GameMusicPlayBarWidget_OnMusicChannelingStart final
{
public:
	EMusicPlaySectionJudgement                    Judge;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMusicPlayBarWidget_OnMusicChannelingStart) == 0x000001, "Wrong alignment on GameMusicPlayBarWidget_OnMusicChannelingStart");
static_assert(sizeof(GameMusicPlayBarWidget_OnMusicChannelingStart) == 0x000001, "Wrong size on GameMusicPlayBarWidget_OnMusicChannelingStart");
static_assert(offsetof(GameMusicPlayBarWidget_OnMusicChannelingStart, Judge) == 0x000000, "Member 'GameMusicPlayBarWidget_OnMusicChannelingStart::Judge' has a wrong offset!");

// Function DungeonCrawler.GameMusicPlayBarWidget.OnMusicJudgeNotify
// 0x0010 (0x0010 - 0x0000)
struct GameMusicPlayBarWidget_OnMusicJudgeNotify final
{
public:
	EMusicPlaySectionJudgement                    Judge;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2834[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PastSectionRatio;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextSectionRatio;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JudgePositionRatio;                                // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMusicPlayBarWidget_OnMusicJudgeNotify) == 0x000004, "Wrong alignment on GameMusicPlayBarWidget_OnMusicJudgeNotify");
static_assert(sizeof(GameMusicPlayBarWidget_OnMusicJudgeNotify) == 0x000010, "Wrong size on GameMusicPlayBarWidget_OnMusicJudgeNotify");
static_assert(offsetof(GameMusicPlayBarWidget_OnMusicJudgeNotify, Judge) == 0x000000, "Member 'GameMusicPlayBarWidget_OnMusicJudgeNotify::Judge' has a wrong offset!");
static_assert(offsetof(GameMusicPlayBarWidget_OnMusicJudgeNotify, PastSectionRatio) == 0x000004, "Member 'GameMusicPlayBarWidget_OnMusicJudgeNotify::PastSectionRatio' has a wrong offset!");
static_assert(offsetof(GameMusicPlayBarWidget_OnMusicJudgeNotify, NextSectionRatio) == 0x000008, "Member 'GameMusicPlayBarWidget_OnMusicJudgeNotify::NextSectionRatio' has a wrong offset!");
static_assert(offsetof(GameMusicPlayBarWidget_OnMusicJudgeNotify, JudgePositionRatio) == 0x00000C, "Member 'GameMusicPlayBarWidget_OnMusicJudgeNotify::JudgePositionRatio' has a wrong offset!");

// Function DungeonCrawler.GameMusicPlayBarWidget.OnMusicPlaySucceed
// 0x0001 (0x0001 - 0x0000)
struct GameMusicPlayBarWidget_OnMusicPlaySucceed final
{
public:
	EMusicPlaySectionJudgement                    Judge;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMusicPlayBarWidget_OnMusicPlaySucceed) == 0x000001, "Wrong alignment on GameMusicPlayBarWidget_OnMusicPlaySucceed");
static_assert(sizeof(GameMusicPlayBarWidget_OnMusicPlaySucceed) == 0x000001, "Wrong size on GameMusicPlayBarWidget_OnMusicPlaySucceed");
static_assert(offsetof(GameMusicPlayBarWidget_OnMusicPlaySucceed, Judge) == 0x000000, "Member 'GameMusicPlayBarWidget_OnMusicPlaySucceed::Judge' has a wrong offset!");

// Function DungeonCrawler.GameMusicSlotWidget.OnSelectionChanged
// 0x0001 (0x0001 - 0x0000)
struct GameMusicSlotWidget_OnSelectionChanged final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMusicSlotWidget_OnSelectionChanged) == 0x000001, "Wrong alignment on GameMusicSlotWidget_OnSelectionChanged");
static_assert(sizeof(GameMusicSlotWidget_OnSelectionChanged) == 0x000001, "Wrong size on GameMusicSlotWidget_OnSelectionChanged");
static_assert(offsetof(GameMusicSlotWidget_OnSelectionChanged, bIsSelected) == 0x000000, "Member 'GameMusicSlotWidget_OnSelectionChanged::bIsSelected' has a wrong offset!");

// Function DungeonCrawler.GameMusicSlotWidget.SelectionChange
// 0x0001 (0x0001 - 0x0000)
struct GameMusicSlotWidget_SelectionChange final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMusicSlotWidget_SelectionChange) == 0x000001, "Wrong alignment on GameMusicSlotWidget_SelectionChange");
static_assert(sizeof(GameMusicSlotWidget_SelectionChange) == 0x000001, "Wrong size on GameMusicSlotWidget_SelectionChange");
static_assert(offsetof(GameMusicSlotWidget_SelectionChange, bIsSelected) == 0x000000, "Member 'GameMusicSlotWidget_SelectionChange::bIsSelected' has a wrong offset!");

// Function DungeonCrawler.GamePartyManagePartyMemberWidget.OnAccountDataReplication
// 0x0120 (0x0120 - 0x0000)
struct GamePartyManagePartyMemberWidget_OnAccountDataReplication final
{
public:
	struct FAccountDataReplication                NewValue;                                          // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FAccountDataReplication                OldValue;                                          // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GamePartyManagePartyMemberWidget_OnAccountDataReplication) == 0x000008, "Wrong alignment on GamePartyManagePartyMemberWidget_OnAccountDataReplication");
static_assert(sizeof(GamePartyManagePartyMemberWidget_OnAccountDataReplication) == 0x000120, "Wrong size on GamePartyManagePartyMemberWidget_OnAccountDataReplication");
static_assert(offsetof(GamePartyManagePartyMemberWidget_OnAccountDataReplication, NewValue) == 0x000000, "Member 'GamePartyManagePartyMemberWidget_OnAccountDataReplication::NewValue' has a wrong offset!");
static_assert(offsetof(GamePartyManagePartyMemberWidget_OnAccountDataReplication, OldValue) == 0x000090, "Member 'GamePartyManagePartyMemberWidget_OnAccountDataReplication::OldValue' has a wrong offset!");

// Function DungeonCrawler.GamePartyManagePartyWidget.OnPartyData
// 0x0040 (0x0040 - 0x0000)
struct GamePartyManagePartyWidget_OnPartyData final
{
public:
	struct FPartyData                             NewValue;                                          // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FPartyData                             OldValue;                                          // 0x0020(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GamePartyManagePartyWidget_OnPartyData) == 0x000008, "Wrong alignment on GamePartyManagePartyWidget_OnPartyData");
static_assert(sizeof(GamePartyManagePartyWidget_OnPartyData) == 0x000040, "Wrong size on GamePartyManagePartyWidget_OnPartyData");
static_assert(offsetof(GamePartyManagePartyWidget_OnPartyData, NewValue) == 0x000000, "Member 'GamePartyManagePartyWidget_OnPartyData::NewValue' has a wrong offset!");
static_assert(offsetof(GamePartyManagePartyWidget_OnPartyData, OldValue) == 0x000020, "Member 'GamePartyManagePartyWidget_OnPartyData::OldValue' has a wrong offset!");

// Function DungeonCrawler.GamePlayerCharacterWidget.OnCampfireChanged
// 0x0001 (0x0001 - 0x0000)
struct GamePlayerCharacterWidget_OnCampfireChanged final
{
public:
	bool                                          bInCampfire;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GamePlayerCharacterWidget_OnCampfireChanged) == 0x000001, "Wrong alignment on GamePlayerCharacterWidget_OnCampfireChanged");
static_assert(sizeof(GamePlayerCharacterWidget_OnCampfireChanged) == 0x000001, "Wrong size on GamePlayerCharacterWidget_OnCampfireChanged");
static_assert(offsetof(GamePlayerCharacterWidget_OnCampfireChanged, bInCampfire) == 0x000000, "Member 'GamePlayerCharacterWidget_OnCampfireChanged::bInCampfire' has a wrong offset!");

// Function DungeonCrawler.GamePlayerCharacterWidget.OnCharacterClass
// 0x0001 (0x0001 - 0x0000)
struct GamePlayerCharacterWidget_OnCharacterClass final
{
public:
	EDCCharacterClass                             InCharacterClass;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GamePlayerCharacterWidget_OnCharacterClass) == 0x000001, "Wrong alignment on GamePlayerCharacterWidget_OnCharacterClass");
static_assert(sizeof(GamePlayerCharacterWidget_OnCharacterClass) == 0x000001, "Wrong size on GamePlayerCharacterWidget_OnCharacterClass");
static_assert(offsetof(GamePlayerCharacterWidget_OnCharacterClass, InCharacterClass) == 0x000000, "Member 'GamePlayerCharacterWidget_OnCharacterClass::InCharacterClass' has a wrong offset!");

// Function DungeonCrawler.GamePlayerCharacterWidget.OnCurrentActiveSlot
// 0x0008 (0x0008 - 0x0000)
struct GamePlayerCharacterWidget_OnCurrentActiveSlot final
{
public:
	const class UEquipmentSlotWidget*             CurrentActiveWidget;                               // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GamePlayerCharacterWidget_OnCurrentActiveSlot) == 0x000008, "Wrong alignment on GamePlayerCharacterWidget_OnCurrentActiveSlot");
static_assert(sizeof(GamePlayerCharacterWidget_OnCurrentActiveSlot) == 0x000008, "Wrong size on GamePlayerCharacterWidget_OnCurrentActiveSlot");
static_assert(offsetof(GamePlayerCharacterWidget_OnCurrentActiveSlot, CurrentActiveWidget) == 0x000000, "Member 'GamePlayerCharacterWidget_OnCurrentActiveSlot::CurrentActiveWidget' has a wrong offset!");

// Function DungeonCrawler.GamePlayerEquipSlotWidget.OnQuickSlotDataChanged
// 0x0008 (0x0008 - 0x0000)
struct GamePlayerEquipSlotWidget_OnQuickSlotDataChanged final
{
public:
	EEquipmentQuickSlotType                       Type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_283F[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Param_Index;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GamePlayerEquipSlotWidget_OnQuickSlotDataChanged) == 0x000004, "Wrong alignment on GamePlayerEquipSlotWidget_OnQuickSlotDataChanged");
static_assert(sizeof(GamePlayerEquipSlotWidget_OnQuickSlotDataChanged) == 0x000008, "Wrong size on GamePlayerEquipSlotWidget_OnQuickSlotDataChanged");
static_assert(offsetof(GamePlayerEquipSlotWidget_OnQuickSlotDataChanged, Type) == 0x000000, "Member 'GamePlayerEquipSlotWidget_OnQuickSlotDataChanged::Type' has a wrong offset!");
static_assert(offsetof(GamePlayerEquipSlotWidget_OnQuickSlotDataChanged, Param_Index) == 0x000004, "Member 'GamePlayerEquipSlotWidget_OnQuickSlotDataChanged::Param_Index' has a wrong offset!");

// Function DungeonCrawler.GameShapeShiftSelectGroupWidget.OnCurrentShapeShiftSlotChanged
// 0x0008 (0x0008 - 0x0000)
struct GameShapeShiftSelectGroupWidget_OnCurrentShapeShiftSlotChanged final
{
public:
	class UGameShapeShiftSlotWidget*              InSelectedSlot;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameShapeShiftSelectGroupWidget_OnCurrentShapeShiftSlotChanged) == 0x000008, "Wrong alignment on GameShapeShiftSelectGroupWidget_OnCurrentShapeShiftSlotChanged");
static_assert(sizeof(GameShapeShiftSelectGroupWidget_OnCurrentShapeShiftSlotChanged) == 0x000008, "Wrong size on GameShapeShiftSelectGroupWidget_OnCurrentShapeShiftSlotChanged");
static_assert(offsetof(GameShapeShiftSelectGroupWidget_OnCurrentShapeShiftSlotChanged, InSelectedSlot) == 0x000000, "Member 'GameShapeShiftSelectGroupWidget_OnCurrentShapeShiftSlotChanged::InSelectedSlot' has a wrong offset!");

// Function DungeonCrawler.GameShapeShiftSlotWidget.OnSelectionChanged
// 0x0001 (0x0001 - 0x0000)
struct GameShapeShiftSlotWidget_OnSelectionChanged final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameShapeShiftSlotWidget_OnSelectionChanged) == 0x000001, "Wrong alignment on GameShapeShiftSlotWidget_OnSelectionChanged");
static_assert(sizeof(GameShapeShiftSlotWidget_OnSelectionChanged) == 0x000001, "Wrong size on GameShapeShiftSlotWidget_OnSelectionChanged");
static_assert(offsetof(GameShapeShiftSlotWidget_OnSelectionChanged, bIsSelected) == 0x000000, "Member 'GameShapeShiftSlotWidget_OnSelectionChanged::bIsSelected' has a wrong offset!");

// Function DungeonCrawler.GameShapeShiftSlotWidget.SelectionChange
// 0x0001 (0x0001 - 0x0000)
struct GameShapeShiftSlotWidget_SelectionChange final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameShapeShiftSlotWidget_SelectionChange) == 0x000001, "Wrong alignment on GameShapeShiftSlotWidget_SelectionChange");
static_assert(sizeof(GameShapeShiftSlotWidget_SelectionChange) == 0x000001, "Wrong size on GameShapeShiftSlotWidget_SelectionChange");
static_assert(offsetof(GameShapeShiftSlotWidget_SelectionChange, bIsSelected) == 0x000000, "Member 'GameShapeShiftSlotWidget_SelectionChange::bIsSelected' has a wrong offset!");

// Function DungeonCrawler.GameSkillSlotWidget.GetSkillSlotCooldownDuration
// 0x0004 (0x0004 - 0x0000)
struct GameSkillSlotWidget_GetSkillSlotCooldownDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSkillSlotWidget_GetSkillSlotCooldownDuration) == 0x000004, "Wrong alignment on GameSkillSlotWidget_GetSkillSlotCooldownDuration");
static_assert(sizeof(GameSkillSlotWidget_GetSkillSlotCooldownDuration) == 0x000004, "Wrong size on GameSkillSlotWidget_GetSkillSlotCooldownDuration");
static_assert(offsetof(GameSkillSlotWidget_GetSkillSlotCooldownDuration, ReturnValue) == 0x000000, "Member 'GameSkillSlotWidget_GetSkillSlotCooldownDuration::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameSkillSlotWidget.GetSkillSlotCooldownPercent
// 0x0004 (0x0004 - 0x0000)
struct GameSkillSlotWidget_GetSkillSlotCooldownPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSkillSlotWidget_GetSkillSlotCooldownPercent) == 0x000004, "Wrong alignment on GameSkillSlotWidget_GetSkillSlotCooldownPercent");
static_assert(sizeof(GameSkillSlotWidget_GetSkillSlotCooldownPercent) == 0x000004, "Wrong size on GameSkillSlotWidget_GetSkillSlotCooldownPercent");
static_assert(offsetof(GameSkillSlotWidget_GetSkillSlotCooldownPercent, ReturnValue) == 0x000000, "Member 'GameSkillSlotWidget_GetSkillSlotCooldownPercent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameSkillSlotWidget.OnLinkedPawnDestroyed
// 0x0008 (0x0008 - 0x0000)
struct GameSkillSlotWidget_OnLinkedPawnDestroyed final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSkillSlotWidget_OnLinkedPawnDestroyed) == 0x000008, "Wrong alignment on GameSkillSlotWidget_OnLinkedPawnDestroyed");
static_assert(sizeof(GameSkillSlotWidget_OnLinkedPawnDestroyed) == 0x000008, "Wrong size on GameSkillSlotWidget_OnLinkedPawnDestroyed");
static_assert(offsetof(GameSkillSlotWidget_OnLinkedPawnDestroyed, InActor) == 0x000000, "Member 'GameSkillSlotWidget_OnLinkedPawnDestroyed::InActor' has a wrong offset!");

// Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillArtData
// 0x0008 (0x0008 - 0x0000)
struct GameSkillSlotWidget_OnUpdateSkillArtData final
{
public:
	class UArtDataSkill*                          SkillArtData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSkillSlotWidget_OnUpdateSkillArtData) == 0x000008, "Wrong alignment on GameSkillSlotWidget_OnUpdateSkillArtData");
static_assert(sizeof(GameSkillSlotWidget_OnUpdateSkillArtData) == 0x000008, "Wrong size on GameSkillSlotWidget_OnUpdateSkillArtData");
static_assert(offsetof(GameSkillSlotWidget_OnUpdateSkillArtData, SkillArtData) == 0x000000, "Member 'GameSkillSlotWidget_OnUpdateSkillArtData::SkillArtData' has a wrong offset!");

// Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillData
// 0x0110 (0x0110 - 0x0000)
struct GameSkillSlotWidget_OnUpdateSkillData final
{
public:
	struct FSkillData                             InSkillData;                                       // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FDesignDataSkill                       InDesignDataSkill;                                 // 0x0030(0x00E0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSkillSlotWidget_OnUpdateSkillData) == 0x000008, "Wrong alignment on GameSkillSlotWidget_OnUpdateSkillData");
static_assert(sizeof(GameSkillSlotWidget_OnUpdateSkillData) == 0x000110, "Wrong size on GameSkillSlotWidget_OnUpdateSkillData");
static_assert(offsetof(GameSkillSlotWidget_OnUpdateSkillData, InSkillData) == 0x000000, "Member 'GameSkillSlotWidget_OnUpdateSkillData::InSkillData' has a wrong offset!");
static_assert(offsetof(GameSkillSlotWidget_OnUpdateSkillData, InDesignDataSkill) == 0x000030, "Member 'GameSkillSlotWidget_OnUpdateSkillData::InDesignDataSkill' has a wrong offset!");

// Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillDesc
// 0x0030 (0x0030 - 0x0000)
struct GameSkillSlotWidget_OnUpdateSkillDesc final
{
public:
	class FText                                   SkillName;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   SkillDesc;                                         // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSkillSlotWidget_OnUpdateSkillDesc) == 0x000008, "Wrong alignment on GameSkillSlotWidget_OnUpdateSkillDesc");
static_assert(sizeof(GameSkillSlotWidget_OnUpdateSkillDesc) == 0x000030, "Wrong size on GameSkillSlotWidget_OnUpdateSkillDesc");
static_assert(offsetof(GameSkillSlotWidget_OnUpdateSkillDesc, SkillName) == 0x000000, "Member 'GameSkillSlotWidget_OnUpdateSkillDesc::SkillName' has a wrong offset!");
static_assert(offsetof(GameSkillSlotWidget_OnUpdateSkillDesc, SkillDesc) == 0x000018, "Member 'GameSkillSlotWidget_OnUpdateSkillDesc::SkillDesc' has a wrong offset!");

// Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillSlot
// 0x000C (0x000C - 0x0000)
struct GameSkillSlotWidget_OnUpdateSkillSlot final
{
public:
	struct FGameplayTag                           SkillTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSkillSlotWidget_OnUpdateSkillSlot) == 0x000004, "Wrong alignment on GameSkillSlotWidget_OnUpdateSkillSlot");
static_assert(sizeof(GameSkillSlotWidget_OnUpdateSkillSlot) == 0x00000C, "Wrong size on GameSkillSlotWidget_OnUpdateSkillSlot");
static_assert(offsetof(GameSkillSlotWidget_OnUpdateSkillSlot, SkillTag) == 0x000000, "Member 'GameSkillSlotWidget_OnUpdateSkillSlot::SkillTag' has a wrong offset!");
static_assert(offsetof(GameSkillSlotWidget_OnUpdateSkillSlot, Duration) == 0x000008, "Member 'GameSkillSlotWidget_OnUpdateSkillSlot::Duration' has a wrong offset!");

// Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillSlotVisible
// 0x0001 (0x0001 - 0x0000)
struct GameSkillSlotWidget_OnUpdateSkillSlotVisible final
{
public:
	bool                                          IsVisibility;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSkillSlotWidget_OnUpdateSkillSlotVisible) == 0x000001, "Wrong alignment on GameSkillSlotWidget_OnUpdateSkillSlotVisible");
static_assert(sizeof(GameSkillSlotWidget_OnUpdateSkillSlotVisible) == 0x000001, "Wrong size on GameSkillSlotWidget_OnUpdateSkillSlotVisible");
static_assert(offsetof(GameSkillSlotWidget_OnUpdateSkillSlotVisible, IsVisibility) == 0x000000, "Member 'GameSkillSlotWidget_OnUpdateSkillSlotVisible::IsVisibility' has a wrong offset!");

// Function DungeonCrawler.GameSkillSlotWidget.GetSkillChargedPercent
// 0x0004 (0x0004 - 0x0000)
struct GameSkillSlotWidget_GetSkillChargedPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSkillSlotWidget_GetSkillChargedPercent) == 0x000004, "Wrong alignment on GameSkillSlotWidget_GetSkillChargedPercent");
static_assert(sizeof(GameSkillSlotWidget_GetSkillChargedPercent) == 0x000004, "Wrong size on GameSkillSlotWidget_GetSkillChargedPercent");
static_assert(offsetof(GameSkillSlotWidget_GetSkillChargedPercent, ReturnValue) == 0x000000, "Member 'GameSkillSlotWidget_GetSkillChargedPercent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameSpellSelectGroupWidget.OnCurrentSpellSlotChanged
// 0x0008 (0x0008 - 0x0000)
struct GameSpellSelectGroupWidget_OnCurrentSpellSlotChanged final
{
public:
	class UGameSpellSlotWidget*                   InSelectedSlot;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSpellSelectGroupWidget_OnCurrentSpellSlotChanged) == 0x000008, "Wrong alignment on GameSpellSelectGroupWidget_OnCurrentSpellSlotChanged");
static_assert(sizeof(GameSpellSelectGroupWidget_OnCurrentSpellSlotChanged) == 0x000008, "Wrong size on GameSpellSelectGroupWidget_OnCurrentSpellSlotChanged");
static_assert(offsetof(GameSpellSelectGroupWidget_OnCurrentSpellSlotChanged, InSelectedSlot) == 0x000000, "Member 'GameSpellSelectGroupWidget_OnCurrentSpellSlotChanged::InSelectedSlot' has a wrong offset!");

// Function DungeonCrawler.GameSpellSlotWidget.GetSpellHealthCost
// 0x0004 (0x0004 - 0x0000)
struct GameSpellSlotWidget_GetSpellHealthCost final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSpellSlotWidget_GetSpellHealthCost) == 0x000004, "Wrong alignment on GameSpellSlotWidget_GetSpellHealthCost");
static_assert(sizeof(GameSpellSlotWidget_GetSpellHealthCost) == 0x000004, "Wrong size on GameSpellSlotWidget_GetSpellHealthCost");
static_assert(offsetof(GameSpellSlotWidget_GetSpellHealthCost, ReturnValue) == 0x000000, "Member 'GameSpellSlotWidget_GetSpellHealthCost::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameSpellSlotWidget.OnSelectionChanged
// 0x0001 (0x0001 - 0x0000)
struct GameSpellSlotWidget_OnSelectionChanged final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSpellSlotWidget_OnSelectionChanged) == 0x000001, "Wrong alignment on GameSpellSlotWidget_OnSelectionChanged");
static_assert(sizeof(GameSpellSlotWidget_OnSelectionChanged) == 0x000001, "Wrong size on GameSpellSlotWidget_OnSelectionChanged");
static_assert(offsetof(GameSpellSlotWidget_OnSelectionChanged, bIsSelected) == 0x000000, "Member 'GameSpellSlotWidget_OnSelectionChanged::bIsSelected' has a wrong offset!");

// Function DungeonCrawler.GameSpellSlotWidget.SelectionChange
// 0x0001 (0x0001 - 0x0000)
struct GameSpellSlotWidget_SelectionChange final
{
public:
	bool                                          bIsSelected;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSpellSlotWidget_SelectionChange) == 0x000001, "Wrong alignment on GameSpellSlotWidget_SelectionChange");
static_assert(sizeof(GameSpellSlotWidget_SelectionChange) == 0x000001, "Wrong size on GameSpellSlotWidget_SelectionChange");
static_assert(offsetof(GameSpellSlotWidget_SelectionChange, bIsSelected) == 0x000000, "Member 'GameSpellSlotWidget_SelectionChange::bIsSelected' has a wrong offset!");

// Function DungeonCrawler.GameSpellSlotWidget.GetSpellChargedPercent
// 0x0004 (0x0004 - 0x0000)
struct GameSpellSlotWidget_GetSpellChargedPercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameSpellSlotWidget_GetSpellChargedPercent) == 0x000004, "Wrong alignment on GameSpellSlotWidget_GetSpellChargedPercent");
static_assert(sizeof(GameSpellSlotWidget_GetSpellChargedPercent) == 0x000004, "Wrong size on GameSpellSlotWidget_GetSpellChargedPercent");
static_assert(offsetof(GameSpellSlotWidget_GetSpellChargedPercent, ReturnValue) == 0x000000, "Member 'GameSpellSlotWidget_GetSpellChargedPercent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GameTavernStartTimerWidget.OnPlayerCount
// 0x0008 (0x0008 - 0x0000)
struct GameTavernStartTimerWidget_OnPlayerCount final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTavernStartTimerWidget_OnPlayerCount) == 0x000004, "Wrong alignment on GameTavernStartTimerWidget_OnPlayerCount");
static_assert(sizeof(GameTavernStartTimerWidget_OnPlayerCount) == 0x000008, "Wrong size on GameTavernStartTimerWidget_OnPlayerCount");
static_assert(offsetof(GameTavernStartTimerWidget_OnPlayerCount, NewValue) == 0x000000, "Member 'GameTavernStartTimerWidget_OnPlayerCount::NewValue' has a wrong offset!");
static_assert(offsetof(GameTavernStartTimerWidget_OnPlayerCount, OldValue) == 0x000004, "Member 'GameTavernStartTimerWidget_OnPlayerCount::OldValue' has a wrong offset!");

// Function DungeonCrawler.GameTavernStartTimerWidget.OnPlayerLimit
// 0x0008 (0x0008 - 0x0000)
struct GameTavernStartTimerWidget_OnPlayerLimit final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OldValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameTavernStartTimerWidget_OnPlayerLimit) == 0x000004, "Wrong alignment on GameTavernStartTimerWidget_OnPlayerLimit");
static_assert(sizeof(GameTavernStartTimerWidget_OnPlayerLimit) == 0x000008, "Wrong size on GameTavernStartTimerWidget_OnPlayerLimit");
static_assert(offsetof(GameTavernStartTimerWidget_OnPlayerLimit, NewValue) == 0x000000, "Member 'GameTavernStartTimerWidget_OnPlayerLimit::NewValue' has a wrong offset!");
static_assert(offsetof(GameTavernStartTimerWidget_OnPlayerLimit, OldValue) == 0x000004, "Member 'GameTavernStartTimerWidget_OnPlayerLimit::OldValue' has a wrong offset!");

// Function DungeonCrawler.GA_ActivateItemBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_ActivateItemBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ActivateItemBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_ActivateItemBase_AbilityActivated");
static_assert(sizeof(GA_ActivateItemBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_ActivateItemBase_AbilityActivated");
static_assert(offsetof(GA_ActivateItemBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_ActivateItemBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_ActivateItemBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ActivateItemBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ActivateItemBase_EventReceived) == 0x000008, "Wrong alignment on GA_ActivateItemBase_EventReceived");
static_assert(sizeof(GA_ActivateItemBase_EventReceived) == 0x0000B8, "Wrong size on GA_ActivateItemBase_EventReceived");
static_assert(offsetof(GA_ActivateItemBase_EventReceived, EventTag) == 0x000000, "Member 'GA_ActivateItemBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ActivateItemBase_EventReceived, EventData) == 0x000008, "Member 'GA_ActivateItemBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ActivateItemBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ActivateItemBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ActivateItemBase_OnCancelled) == 0x000008, "Wrong alignment on GA_ActivateItemBase_OnCancelled");
static_assert(sizeof(GA_ActivateItemBase_OnCancelled) == 0x0000B8, "Wrong size on GA_ActivateItemBase_OnCancelled");
static_assert(offsetof(GA_ActivateItemBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_ActivateItemBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ActivateItemBase_OnCancelled, EventData) == 0x000008, "Member 'GA_ActivateItemBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ActivateItemBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ActivateItemBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ActivateItemBase_OnCompleted) == 0x000008, "Wrong alignment on GA_ActivateItemBase_OnCompleted");
static_assert(sizeof(GA_ActivateItemBase_OnCompleted) == 0x0000B8, "Wrong size on GA_ActivateItemBase_OnCompleted");
static_assert(offsetof(GA_ActivateItemBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_ActivateItemBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ActivateItemBase_OnCompleted, EventData) == 0x000008, "Member 'GA_ActivateItemBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ActivateItemBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ActivateItemBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ActivateItemBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_ActivateItemBase_ReceivedEvent");
static_assert(sizeof(GA_ActivateItemBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_ActivateItemBase_ReceivedEvent");
static_assert(offsetof(GA_ActivateItemBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_ActivateItemBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ActivateItemBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_ActivateItemBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_AuraBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_AuraBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_AuraBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_AuraBase_AbilityActivated");
static_assert(sizeof(GA_AuraBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_AuraBase_AbilityActivated");
static_assert(offsetof(GA_AuraBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_AuraBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_AuraBase.OnAntiAuraOverlapBegin
// 0x0108 (0x0108 - 0x0000)
struct GA_AuraBase_OnAntiAuraOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2849[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_AuraBase_OnAntiAuraOverlapBegin) == 0x000008, "Wrong alignment on GA_AuraBase_OnAntiAuraOverlapBegin");
static_assert(sizeof(GA_AuraBase_OnAntiAuraOverlapBegin) == 0x000108, "Wrong size on GA_AuraBase_OnAntiAuraOverlapBegin");
static_assert(offsetof(GA_AuraBase_OnAntiAuraOverlapBegin, OverlappedComp) == 0x000000, "Member 'GA_AuraBase_OnAntiAuraOverlapBegin::OverlappedComp' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAntiAuraOverlapBegin, Other) == 0x000008, "Member 'GA_AuraBase_OnAntiAuraOverlapBegin::Other' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAntiAuraOverlapBegin, OtherComp) == 0x000010, "Member 'GA_AuraBase_OnAntiAuraOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAntiAuraOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'GA_AuraBase_OnAntiAuraOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAntiAuraOverlapBegin, bFromSweep) == 0x00001C, "Member 'GA_AuraBase_OnAntiAuraOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAntiAuraOverlapBegin, SweepResult) == 0x000020, "Member 'GA_AuraBase_OnAntiAuraOverlapBegin::SweepResult' has a wrong offset!");

// Function DungeonCrawler.GA_AuraBase.OnAntiAuraOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct GA_AuraBase_OnAntiAuraOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284A[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_AuraBase_OnAntiAuraOverlapEnd) == 0x000008, "Wrong alignment on GA_AuraBase_OnAntiAuraOverlapEnd");
static_assert(sizeof(GA_AuraBase_OnAntiAuraOverlapEnd) == 0x000020, "Wrong size on GA_AuraBase_OnAntiAuraOverlapEnd");
static_assert(offsetof(GA_AuraBase_OnAntiAuraOverlapEnd, OverlappedComp) == 0x000000, "Member 'GA_AuraBase_OnAntiAuraOverlapEnd::OverlappedComp' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAntiAuraOverlapEnd, Other) == 0x000008, "Member 'GA_AuraBase_OnAntiAuraOverlapEnd::Other' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAntiAuraOverlapEnd, OtherComp) == 0x000010, "Member 'GA_AuraBase_OnAntiAuraOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAntiAuraOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'GA_AuraBase_OnAntiAuraOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DungeonCrawler.GA_AuraBase.OnAuraOverlapBegin
// 0x0108 (0x0108 - 0x0000)
struct GA_AuraBase_OnAuraOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284B[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_AuraBase_OnAuraOverlapBegin) == 0x000008, "Wrong alignment on GA_AuraBase_OnAuraOverlapBegin");
static_assert(sizeof(GA_AuraBase_OnAuraOverlapBegin) == 0x000108, "Wrong size on GA_AuraBase_OnAuraOverlapBegin");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapBegin, OverlappedComp) == 0x000000, "Member 'GA_AuraBase_OnAuraOverlapBegin::OverlappedComp' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapBegin, Other) == 0x000008, "Member 'GA_AuraBase_OnAuraOverlapBegin::Other' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapBegin, OtherComp) == 0x000010, "Member 'GA_AuraBase_OnAuraOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'GA_AuraBase_OnAuraOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapBegin, bFromSweep) == 0x00001C, "Member 'GA_AuraBase_OnAuraOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapBegin, SweepResult) == 0x000020, "Member 'GA_AuraBase_OnAuraOverlapBegin::SweepResult' has a wrong offset!");

// Function DungeonCrawler.GA_AuraBase.OnAuraOverlapBeginEvent
// 0x0008 (0x0008 - 0x0000)
struct GA_AuraBase_OnAuraOverlapBeginEvent final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_AuraBase_OnAuraOverlapBeginEvent) == 0x000008, "Wrong alignment on GA_AuraBase_OnAuraOverlapBeginEvent");
static_assert(sizeof(GA_AuraBase_OnAuraOverlapBeginEvent) == 0x000008, "Wrong size on GA_AuraBase_OnAuraOverlapBeginEvent");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapBeginEvent, TargetActor) == 0x000000, "Member 'GA_AuraBase_OnAuraOverlapBeginEvent::TargetActor' has a wrong offset!");

// Function DungeonCrawler.GA_AuraBase.OnAuraOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct GA_AuraBase_OnAuraOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284C[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_AuraBase_OnAuraOverlapEnd) == 0x000008, "Wrong alignment on GA_AuraBase_OnAuraOverlapEnd");
static_assert(sizeof(GA_AuraBase_OnAuraOverlapEnd) == 0x000020, "Wrong size on GA_AuraBase_OnAuraOverlapEnd");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapEnd, OverlappedComp) == 0x000000, "Member 'GA_AuraBase_OnAuraOverlapEnd::OverlappedComp' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapEnd, Other) == 0x000008, "Member 'GA_AuraBase_OnAuraOverlapEnd::Other' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapEnd, OtherComp) == 0x000010, "Member 'GA_AuraBase_OnAuraOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'GA_AuraBase_OnAuraOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DungeonCrawler.GA_AuraBase.OnAuraOverlapEndEvent
// 0x0008 (0x0008 - 0x0000)
struct GA_AuraBase_OnAuraOverlapEndEvent final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_AuraBase_OnAuraOverlapEndEvent) == 0x000008, "Wrong alignment on GA_AuraBase_OnAuraOverlapEndEvent");
static_assert(sizeof(GA_AuraBase_OnAuraOverlapEndEvent) == 0x000008, "Wrong size on GA_AuraBase_OnAuraOverlapEndEvent");
static_assert(offsetof(GA_AuraBase_OnAuraOverlapEndEvent, TargetActor) == 0x000000, "Member 'GA_AuraBase_OnAuraOverlapEndEvent::TargetActor' has a wrong offset!");

// Function DungeonCrawler.GA_AuraBase.OnAuraTargetGameplayTag
// 0x0018 (0x0018 - 0x0000)
struct GA_AuraBase_OnAuraTargetGameplayTag final
{
public:
	class AActor*                                 InTargetActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGameplayTag;                                     // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284D[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_AuraBase_OnAuraTargetGameplayTag) == 0x000008, "Wrong alignment on GA_AuraBase_OnAuraTargetGameplayTag");
static_assert(sizeof(GA_AuraBase_OnAuraTargetGameplayTag) == 0x000018, "Wrong size on GA_AuraBase_OnAuraTargetGameplayTag");
static_assert(offsetof(GA_AuraBase_OnAuraTargetGameplayTag, InTargetActor) == 0x000000, "Member 'GA_AuraBase_OnAuraTargetGameplayTag::InTargetActor' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAuraTargetGameplayTag, InGameplayTag) == 0x000008, "Member 'GA_AuraBase_OnAuraTargetGameplayTag::InGameplayTag' has a wrong offset!");
static_assert(offsetof(GA_AuraBase_OnAuraTargetGameplayTag, InCount) == 0x000010, "Member 'GA_AuraBase_OnAuraTargetGameplayTag::InCount' has a wrong offset!");

// Function DungeonCrawler.GA_CharacterJump.EventReceived
// 0x00B0 (0x00B0 - 0x0000)
struct GA_CharacterJump_EventReceived final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_CharacterJump_EventReceived) == 0x000008, "Wrong alignment on GA_CharacterJump_EventReceived");
static_assert(sizeof(GA_CharacterJump_EventReceived) == 0x0000B0, "Wrong size on GA_CharacterJump_EventReceived");
static_assert(offsetof(GA_CharacterJump_EventReceived, EventData) == 0x000000, "Member 'GA_CharacterJump_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_CharacterJump.OnMovementModeChange
// 0x0001 (0x0001 - 0x0000)
struct GA_CharacterJump_OnMovementModeChange final
{
public:
	EMovementMode                                 MovementMode;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_CharacterJump_OnMovementModeChange) == 0x000001, "Wrong alignment on GA_CharacterJump_OnMovementModeChange");
static_assert(sizeof(GA_CharacterJump_OnMovementModeChange) == 0x000001, "Wrong size on GA_CharacterJump_OnMovementModeChange");
static_assert(offsetof(GA_CharacterJump_OnMovementModeChange, MovementMode) == 0x000000, "Member 'GA_CharacterJump_OnMovementModeChange::MovementMode' has a wrong offset!");

// Function DungeonCrawler.GA_Drawbridge.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_Drawbridge_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_Drawbridge_AbilityActivated) == 0x000008, "Wrong alignment on GA_Drawbridge_AbilityActivated");
static_assert(sizeof(GA_Drawbridge_AbilityActivated) == 0x0000B0, "Wrong size on GA_Drawbridge_AbilityActivated");
static_assert(offsetof(GA_Drawbridge_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_Drawbridge_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_Drawbridge.OnBlendOut
// 0x00B8 (0x00B8 - 0x0000)
struct GA_Drawbridge_OnBlendOut final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_Drawbridge_OnBlendOut) == 0x000008, "Wrong alignment on GA_Drawbridge_OnBlendOut");
static_assert(sizeof(GA_Drawbridge_OnBlendOut) == 0x0000B8, "Wrong size on GA_Drawbridge_OnBlendOut");
static_assert(offsetof(GA_Drawbridge_OnBlendOut, EventTag) == 0x000000, "Member 'GA_Drawbridge_OnBlendOut::EventTag' has a wrong offset!");
static_assert(offsetof(GA_Drawbridge_OnBlendOut, EventData) == 0x000008, "Member 'GA_Drawbridge_OnBlendOut::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_Drawbridge.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_Drawbridge_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_Drawbridge_OnCompleted) == 0x000008, "Wrong alignment on GA_Drawbridge_OnCompleted");
static_assert(sizeof(GA_Drawbridge_OnCompleted) == 0x0000B8, "Wrong size on GA_Drawbridge_OnCompleted");
static_assert(offsetof(GA_Drawbridge_OnCompleted, EventTag) == 0x000000, "Member 'GA_Drawbridge_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_Drawbridge_OnCompleted, EventData) == 0x000008, "Member 'GA_Drawbridge_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_PlayMontageAndWaitForEvent_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayMontageAndWaitForEvent_AbilityActivated) == 0x000008, "Wrong alignment on GA_PlayMontageAndWaitForEvent_AbilityActivated");
static_assert(sizeof(GA_PlayMontageAndWaitForEvent_AbilityActivated) == 0x0000B0, "Wrong size on GA_PlayMontageAndWaitForEvent_AbilityActivated");
static_assert(offsetof(GA_PlayMontageAndWaitForEvent_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_PlayMontageAndWaitForEvent_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayMontageAndWaitForEvent_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayMontageAndWaitForEvent_EventReceived) == 0x000008, "Wrong alignment on GA_PlayMontageAndWaitForEvent_EventReceived");
static_assert(sizeof(GA_PlayMontageAndWaitForEvent_EventReceived) == 0x0000B8, "Wrong size on GA_PlayMontageAndWaitForEvent_EventReceived");
static_assert(offsetof(GA_PlayMontageAndWaitForEvent_EventReceived, EventTag) == 0x000000, "Member 'GA_PlayMontageAndWaitForEvent_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayMontageAndWaitForEvent_EventReceived, EventData) == 0x000008, "Member 'GA_PlayMontageAndWaitForEvent_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayMontageAndWaitForEvent_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayMontageAndWaitForEvent_OnCancelled) == 0x000008, "Wrong alignment on GA_PlayMontageAndWaitForEvent_OnCancelled");
static_assert(sizeof(GA_PlayMontageAndWaitForEvent_OnCancelled) == 0x0000B8, "Wrong size on GA_PlayMontageAndWaitForEvent_OnCancelled");
static_assert(offsetof(GA_PlayMontageAndWaitForEvent_OnCancelled, EventTag) == 0x000000, "Member 'GA_PlayMontageAndWaitForEvent_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayMontageAndWaitForEvent_OnCancelled, EventData) == 0x000008, "Member 'GA_PlayMontageAndWaitForEvent_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayMontageAndWaitForEvent_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayMontageAndWaitForEvent_OnCompleted) == 0x000008, "Wrong alignment on GA_PlayMontageAndWaitForEvent_OnCompleted");
static_assert(sizeof(GA_PlayMontageAndWaitForEvent_OnCompleted) == 0x0000B8, "Wrong size on GA_PlayMontageAndWaitForEvent_OnCompleted");
static_assert(offsetof(GA_PlayMontageAndWaitForEvent_OnCompleted, EventTag) == 0x000000, "Member 'GA_PlayMontageAndWaitForEvent_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayMontageAndWaitForEvent_OnCompleted, EventData) == 0x000008, "Member 'GA_PlayMontageAndWaitForEvent_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayMontageAndWaitForEvent_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayMontageAndWaitForEvent_ReceivedEvent) == 0x000008, "Wrong alignment on GA_PlayMontageAndWaitForEvent_ReceivedEvent");
static_assert(sizeof(GA_PlayMontageAndWaitForEvent_ReceivedEvent) == 0x0000B8, "Wrong size on GA_PlayMontageAndWaitForEvent_ReceivedEvent");
static_assert(offsetof(GA_PlayMontageAndWaitForEvent_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_PlayMontageAndWaitForEvent_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayMontageAndWaitForEvent_ReceivedEvent, EventData) == 0x000008, "Member 'GA_PlayMontageAndWaitForEvent_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_Equip.OnMontageEventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_Equip_OnMontageEventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_Equip_OnMontageEventReceived) == 0x000008, "Wrong alignment on GA_Equip_OnMontageEventReceived");
static_assert(sizeof(GA_Equip_OnMontageEventReceived) == 0x0000B8, "Wrong size on GA_Equip_OnMontageEventReceived");
static_assert(offsetof(GA_Equip_OnMontageEventReceived, EventTag) == 0x000000, "Member 'GA_Equip_OnMontageEventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_Equip_OnMontageEventReceived, EventData) == 0x000008, "Member 'GA_Equip_OnMontageEventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_Equip.OnMontageFinished
// 0x00B8 (0x00B8 - 0x0000)
struct GA_Equip_OnMontageFinished final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_Equip_OnMontageFinished) == 0x000008, "Wrong alignment on GA_Equip_OnMontageFinished");
static_assert(sizeof(GA_Equip_OnMontageFinished) == 0x0000B8, "Wrong size on GA_Equip_OnMontageFinished");
static_assert(offsetof(GA_Equip_OnMontageFinished, EventTag) == 0x000000, "Member 'GA_Equip_OnMontageFinished::EventTag' has a wrong offset!");
static_assert(offsetof(GA_Equip_OnMontageFinished, EventData) == 0x000008, "Member 'GA_Equip_OnMontageFinished::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_HuntingTrapDisarmPassiveBase.OnTargetGameplayTagChange
// 0x000C (0x000C - 0x0000)
struct GA_HuntingTrapDisarmPassiveBase_OnTargetGameplayTagChange final
{
public:
	struct FGameplayTag                           InGameplayTag;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_HuntingTrapDisarmPassiveBase_OnTargetGameplayTagChange) == 0x000004, "Wrong alignment on GA_HuntingTrapDisarmPassiveBase_OnTargetGameplayTagChange");
static_assert(sizeof(GA_HuntingTrapDisarmPassiveBase_OnTargetGameplayTagChange) == 0x00000C, "Wrong size on GA_HuntingTrapDisarmPassiveBase_OnTargetGameplayTagChange");
static_assert(offsetof(GA_HuntingTrapDisarmPassiveBase_OnTargetGameplayTagChange, InGameplayTag) == 0x000000, "Member 'GA_HuntingTrapDisarmPassiveBase_OnTargetGameplayTagChange::InGameplayTag' has a wrong offset!");
static_assert(offsetof(GA_HuntingTrapDisarmPassiveBase_OnTargetGameplayTagChange, InCount) == 0x000008, "Member 'GA_HuntingTrapDisarmPassiveBase_OnTargetGameplayTagChange::InCount' has a wrong offset!");

// Function DungeonCrawler.GA_HuntingTrapDisarmPassiveBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_HuntingTrapDisarmPassiveBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_HuntingTrapDisarmPassiveBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_HuntingTrapDisarmPassiveBase_ReceivedEvent");
static_assert(sizeof(GA_HuntingTrapDisarmPassiveBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_HuntingTrapDisarmPassiveBase_ReceivedEvent");
static_assert(offsetof(GA_HuntingTrapDisarmPassiveBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_HuntingTrapDisarmPassiveBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_HuntingTrapDisarmPassiveBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_HuntingTrapDisarmPassiveBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_HuntingTrapDisarmPassiveBase.SetDisarmTarget
// 0x0008 (0x0008 - 0x0000)
struct GA_HuntingTrapDisarmPassiveBase_SetDisarmTarget final
{
public:
	class APropsActorBase*                        TargetHuntingTrap;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_HuntingTrapDisarmPassiveBase_SetDisarmTarget) == 0x000008, "Wrong alignment on GA_HuntingTrapDisarmPassiveBase_SetDisarmTarget");
static_assert(sizeof(GA_HuntingTrapDisarmPassiveBase_SetDisarmTarget) == 0x000008, "Wrong size on GA_HuntingTrapDisarmPassiveBase_SetDisarmTarget");
static_assert(offsetof(GA_HuntingTrapDisarmPassiveBase_SetDisarmTarget, TargetHuntingTrap) == 0x000000, "Member 'GA_HuntingTrapDisarmPassiveBase_SetDisarmTarget::TargetHuntingTrap' has a wrong offset!");

// Function DungeonCrawler.GA_ItemActivateBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ItemActivateBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ItemActivateBase_EventReceived) == 0x000008, "Wrong alignment on GA_ItemActivateBase_EventReceived");
static_assert(sizeof(GA_ItemActivateBase_EventReceived) == 0x0000B8, "Wrong size on GA_ItemActivateBase_EventReceived");
static_assert(offsetof(GA_ItemActivateBase_EventReceived, EventTag) == 0x000000, "Member 'GA_ItemActivateBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ItemActivateBase_EventReceived, EventData) == 0x000008, "Member 'GA_ItemActivateBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ItemActivateBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ItemActivateBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ItemActivateBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_ItemActivateBase_ReceivedEvent");
static_assert(sizeof(GA_ItemActivateBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_ItemActivateBase_ReceivedEvent");
static_assert(offsetof(GA_ItemActivateBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_ItemActivateBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ItemActivateBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_ItemActivateBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ItemConsumeBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_ItemConsumeBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ItemConsumeBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_ItemConsumeBase_AbilityActivated");
static_assert(sizeof(GA_ItemConsumeBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_ItemConsumeBase_AbilityActivated");
static_assert(offsetof(GA_ItemConsumeBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_ItemConsumeBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_ItemConsumeBase.ConsumeEventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ItemConsumeBase_ConsumeEventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ItemConsumeBase_ConsumeEventReceived) == 0x000008, "Wrong alignment on GA_ItemConsumeBase_ConsumeEventReceived");
static_assert(sizeof(GA_ItemConsumeBase_ConsumeEventReceived) == 0x0000B8, "Wrong size on GA_ItemConsumeBase_ConsumeEventReceived");
static_assert(offsetof(GA_ItemConsumeBase_ConsumeEventReceived, EventTag) == 0x000000, "Member 'GA_ItemConsumeBase_ConsumeEventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ItemConsumeBase_ConsumeEventReceived, EventData) == 0x000008, "Member 'GA_ItemConsumeBase_ConsumeEventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ItemConsumeBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ItemConsumeBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ItemConsumeBase_EventReceived) == 0x000008, "Wrong alignment on GA_ItemConsumeBase_EventReceived");
static_assert(sizeof(GA_ItemConsumeBase_EventReceived) == 0x0000B8, "Wrong size on GA_ItemConsumeBase_EventReceived");
static_assert(offsetof(GA_ItemConsumeBase_EventReceived, EventTag) == 0x000000, "Member 'GA_ItemConsumeBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ItemConsumeBase_EventReceived, EventData) == 0x000008, "Member 'GA_ItemConsumeBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeMontageCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ItemConsumeBase_OnConsumeMontageCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ItemConsumeBase_OnConsumeMontageCompleted) == 0x000008, "Wrong alignment on GA_ItemConsumeBase_OnConsumeMontageCompleted");
static_assert(sizeof(GA_ItemConsumeBase_OnConsumeMontageCompleted) == 0x0000B8, "Wrong size on GA_ItemConsumeBase_OnConsumeMontageCompleted");
static_assert(offsetof(GA_ItemConsumeBase_OnConsumeMontageCompleted, EventTag) == 0x000000, "Member 'GA_ItemConsumeBase_OnConsumeMontageCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ItemConsumeBase_OnConsumeMontageCompleted, EventData) == 0x000008, "Member 'GA_ItemConsumeBase_OnConsumeMontageCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeStartEventReceived
// 0x0004 (0x0004 - 0x0000)
struct GA_ItemConsumeBase_OnConsumeStartEventReceived final
{
public:
	float                                         ConsumeDuration;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ItemConsumeBase_OnConsumeStartEventReceived) == 0x000004, "Wrong alignment on GA_ItemConsumeBase_OnConsumeStartEventReceived");
static_assert(sizeof(GA_ItemConsumeBase_OnConsumeStartEventReceived) == 0x000004, "Wrong size on GA_ItemConsumeBase_OnConsumeStartEventReceived");
static_assert(offsetof(GA_ItemConsumeBase_OnConsumeStartEventReceived, ConsumeDuration) == 0x000000, "Member 'GA_ItemConsumeBase_OnConsumeStartEventReceived::ConsumeDuration' has a wrong offset!");

// Function DungeonCrawler.GA_MusicInstantBase.OnTargetActorOverlap
// 0x0010 (0x0010 - 0x0000)
struct GA_MusicInstantBase_OnTargetActorOverlap final
{
public:
	TArray<class AActor*>                         InTargetActors;                                    // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_MusicInstantBase_OnTargetActorOverlap) == 0x000008, "Wrong alignment on GA_MusicInstantBase_OnTargetActorOverlap");
static_assert(sizeof(GA_MusicInstantBase_OnTargetActorOverlap) == 0x000010, "Wrong size on GA_MusicInstantBase_OnTargetActorOverlap");
static_assert(offsetof(GA_MusicInstantBase_OnTargetActorOverlap, InTargetActors) == 0x000000, "Member 'GA_MusicInstantBase_OnTargetActorOverlap::InTargetActors' has a wrong offset!");

// Function DungeonCrawler.GA_PaviseInstall.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_PaviseInstall_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PaviseInstall_AbilityActivated) == 0x000008, "Wrong alignment on GA_PaviseInstall_AbilityActivated");
static_assert(sizeof(GA_PaviseInstall_AbilityActivated) == 0x0000B0, "Wrong size on GA_PaviseInstall_AbilityActivated");
static_assert(offsetof(GA_PaviseInstall_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_PaviseInstall_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_PaviseInstall.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PaviseInstall_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PaviseInstall_EventReceived) == 0x000008, "Wrong alignment on GA_PaviseInstall_EventReceived");
static_assert(sizeof(GA_PaviseInstall_EventReceived) == 0x0000B8, "Wrong size on GA_PaviseInstall_EventReceived");
static_assert(offsetof(GA_PaviseInstall_EventReceived, EventTag) == 0x000000, "Member 'GA_PaviseInstall_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PaviseInstall_EventReceived, EventData) == 0x000008, "Member 'GA_PaviseInstall_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PaviseInstall.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PaviseInstall_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PaviseInstall_OnCompleted) == 0x000008, "Wrong alignment on GA_PaviseInstall_OnCompleted");
static_assert(sizeof(GA_PaviseInstall_OnCompleted) == 0x0000B8, "Wrong size on GA_PaviseInstall_OnCompleted");
static_assert(offsetof(GA_PaviseInstall_OnCompleted, EventTag) == 0x000000, "Member 'GA_PaviseInstall_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PaviseInstall_OnCompleted, EventData) == 0x000008, "Member 'GA_PaviseInstall_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PaviseInstall.OnInterrupted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PaviseInstall_OnInterrupted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PaviseInstall_OnInterrupted) == 0x000008, "Wrong alignment on GA_PaviseInstall_OnInterrupted");
static_assert(sizeof(GA_PaviseInstall_OnInterrupted) == 0x0000B8, "Wrong size on GA_PaviseInstall_OnInterrupted");
static_assert(offsetof(GA_PaviseInstall_OnInterrupted, EventTag) == 0x000000, "Member 'GA_PaviseInstall_OnInterrupted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PaviseInstall_OnInterrupted, EventData) == 0x000008, "Member 'GA_PaviseInstall_OnInterrupted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PaviseInstall.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PaviseInstall_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PaviseInstall_ReceivedEvent) == 0x000008, "Wrong alignment on GA_PaviseInstall_ReceivedEvent");
static_assert(sizeof(GA_PaviseInstall_ReceivedEvent) == 0x0000B8, "Wrong size on GA_PaviseInstall_ReceivedEvent");
static_assert(offsetof(GA_PaviseInstall_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_PaviseInstall_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PaviseInstall_ReceivedEvent, EventData) == 0x000008, "Member 'GA_PaviseInstall_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.ReceivedServerTargetData
// 0x0028 (0x0028 - 0x0000)
struct GA_PlayerCharMeleeAttackBase_ReceivedServerTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerCharMeleeAttackBase_ReceivedServerTargetData) == 0x000008, "Wrong alignment on GA_PlayerCharMeleeAttackBase_ReceivedServerTargetData");
static_assert(sizeof(GA_PlayerCharMeleeAttackBase_ReceivedServerTargetData) == 0x000028, "Wrong size on GA_PlayerCharMeleeAttackBase_ReceivedServerTargetData");
static_assert(offsetof(GA_PlayerCharMeleeAttackBase_ReceivedServerTargetData, InData) == 0x000000, "Member 'GA_PlayerCharMeleeAttackBase_ReceivedServerTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_PlayerMagicWandUseBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_PlayerMagicWandUseBase_AbilityActivated");
static_assert(sizeof(GA_PlayerMagicWandUseBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_PlayerMagicWandUseBase_AbilityActivated");
static_assert(offsetof(GA_PlayerMagicWandUseBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.ClientReceivedTargetData
// 0x0038 (0x0038 - 0x0000)
struct GA_PlayerMagicWandUseBase_ClientReceivedTargetData final
{
public:
	struct FGameplayTag                           InEffectTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InChannelTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_ClientReceivedTargetData) == 0x000008, "Wrong alignment on GA_PlayerMagicWandUseBase_ClientReceivedTargetData");
static_assert(sizeof(GA_PlayerMagicWandUseBase_ClientReceivedTargetData) == 0x000038, "Wrong size on GA_PlayerMagicWandUseBase_ClientReceivedTargetData");
static_assert(offsetof(GA_PlayerMagicWandUseBase_ClientReceivedTargetData, InEffectTag) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_ClientReceivedTargetData::InEffectTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMagicWandUseBase_ClientReceivedTargetData, InChannelTag) == 0x000008, "Member 'GA_PlayerMagicWandUseBase_ClientReceivedTargetData::InChannelTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMagicWandUseBase_ClientReceivedTargetData, InData) == 0x000010, "Member 'GA_PlayerMagicWandUseBase_ClientReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerMagicWandUseBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_EventReceived) == 0x000008, "Wrong alignment on GA_PlayerMagicWandUseBase_EventReceived");
static_assert(sizeof(GA_PlayerMagicWandUseBase_EventReceived) == 0x0000B8, "Wrong size on GA_PlayerMagicWandUseBase_EventReceived");
static_assert(offsetof(GA_PlayerMagicWandUseBase_EventReceived, EventTag) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMagicWandUseBase_EventReceived, EventData) == 0x000008, "Member 'GA_PlayerMagicWandUseBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnBlendOut
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerMagicWandUseBase_OnBlendOut final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_OnBlendOut) == 0x000008, "Wrong alignment on GA_PlayerMagicWandUseBase_OnBlendOut");
static_assert(sizeof(GA_PlayerMagicWandUseBase_OnBlendOut) == 0x0000B8, "Wrong size on GA_PlayerMagicWandUseBase_OnBlendOut");
static_assert(offsetof(GA_PlayerMagicWandUseBase_OnBlendOut, EventTag) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_OnBlendOut::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMagicWandUseBase_OnBlendOut, EventData) == 0x000008, "Member 'GA_PlayerMagicWandUseBase_OnBlendOut::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerMagicWandUseBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_OnCancelled) == 0x000008, "Wrong alignment on GA_PlayerMagicWandUseBase_OnCancelled");
static_assert(sizeof(GA_PlayerMagicWandUseBase_OnCancelled) == 0x0000B8, "Wrong size on GA_PlayerMagicWandUseBase_OnCancelled");
static_assert(offsetof(GA_PlayerMagicWandUseBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMagicWandUseBase_OnCancelled, EventData) == 0x000008, "Member 'GA_PlayerMagicWandUseBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnChannelingAction
// 0x0004 (0x0004 - 0x0000)
struct GA_PlayerMagicWandUseBase_OnChannelingAction final
{
public:
	int32                                         ActionCounter;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_OnChannelingAction) == 0x000004, "Wrong alignment on GA_PlayerMagicWandUseBase_OnChannelingAction");
static_assert(sizeof(GA_PlayerMagicWandUseBase_OnChannelingAction) == 0x000004, "Wrong size on GA_PlayerMagicWandUseBase_OnChannelingAction");
static_assert(offsetof(GA_PlayerMagicWandUseBase_OnChannelingAction, ActionCounter) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_OnChannelingAction::ActionCounter' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerMagicWandUseBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_OnCompleted) == 0x000008, "Wrong alignment on GA_PlayerMagicWandUseBase_OnCompleted");
static_assert(sizeof(GA_PlayerMagicWandUseBase_OnCompleted) == 0x0000B8, "Wrong size on GA_PlayerMagicWandUseBase_OnCompleted");
static_assert(offsetof(GA_PlayerMagicWandUseBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMagicWandUseBase_OnCompleted, EventData) == 0x000008, "Member 'GA_PlayerMagicWandUseBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnInterrupted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerMagicWandUseBase_OnInterrupted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_OnInterrupted) == 0x000008, "Wrong alignment on GA_PlayerMagicWandUseBase_OnInterrupted");
static_assert(sizeof(GA_PlayerMagicWandUseBase_OnInterrupted) == 0x0000B8, "Wrong size on GA_PlayerMagicWandUseBase_OnInterrupted");
static_assert(offsetof(GA_PlayerMagicWandUseBase_OnInterrupted, EventTag) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_OnInterrupted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMagicWandUseBase_OnInterrupted, EventData) == 0x000008, "Member 'GA_PlayerMagicWandUseBase_OnInterrupted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerMagicWandUseBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_PlayerMagicWandUseBase_ReceivedEvent");
static_assert(sizeof(GA_PlayerMagicWandUseBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_PlayerMagicWandUseBase_ReceivedEvent");
static_assert(offsetof(GA_PlayerMagicWandUseBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMagicWandUseBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_PlayerMagicWandUseBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.ReceivedTargetData
// 0x0028 (0x0028 - 0x0000)
struct GA_PlayerMagicWandUseBase_ReceivedTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_ReceivedTargetData) == 0x000008, "Wrong alignment on GA_PlayerMagicWandUseBase_ReceivedTargetData");
static_assert(sizeof(GA_PlayerMagicWandUseBase_ReceivedTargetData) == 0x000028, "Wrong size on GA_PlayerMagicWandUseBase_ReceivedTargetData");
static_assert(offsetof(GA_PlayerMagicWandUseBase_ReceivedTargetData, InData) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_ReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMagicWandUseBase.ServerReceivedTargetData
// 0x0038 (0x0038 - 0x0000)
struct GA_PlayerMagicWandUseBase_ServerReceivedTargetData final
{
public:
	struct FGameplayTag                           InEffectTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InChannelTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMagicWandUseBase_ServerReceivedTargetData) == 0x000008, "Wrong alignment on GA_PlayerMagicWandUseBase_ServerReceivedTargetData");
static_assert(sizeof(GA_PlayerMagicWandUseBase_ServerReceivedTargetData) == 0x000038, "Wrong size on GA_PlayerMagicWandUseBase_ServerReceivedTargetData");
static_assert(offsetof(GA_PlayerMagicWandUseBase_ServerReceivedTargetData, InEffectTag) == 0x000000, "Member 'GA_PlayerMagicWandUseBase_ServerReceivedTargetData::InEffectTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMagicWandUseBase_ServerReceivedTargetData, InChannelTag) == 0x000008, "Member 'GA_PlayerMagicWandUseBase_ServerReceivedTargetData::InChannelTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMagicWandUseBase_ServerReceivedTargetData, InData) == 0x000010, "Member 'GA_PlayerMagicWandUseBase_ServerReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMusicPlayBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_PlayerMusicPlayBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMusicPlayBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_PlayerMusicPlayBase_AbilityActivated");
static_assert(sizeof(GA_PlayerMusicPlayBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_PlayerMusicPlayBase_AbilityActivated");
static_assert(offsetof(GA_PlayerMusicPlayBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_PlayerMusicPlayBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMusicPlayBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerMusicPlayBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMusicPlayBase_EventReceived) == 0x000008, "Wrong alignment on GA_PlayerMusicPlayBase_EventReceived");
static_assert(sizeof(GA_PlayerMusicPlayBase_EventReceived) == 0x0000B8, "Wrong size on GA_PlayerMusicPlayBase_EventReceived");
static_assert(offsetof(GA_PlayerMusicPlayBase_EventReceived, EventTag) == 0x000000, "Member 'GA_PlayerMusicPlayBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMusicPlayBase_EventReceived, EventData) == 0x000008, "Member 'GA_PlayerMusicPlayBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnChannelingAction
// 0x0004 (0x0004 - 0x0000)
struct GA_PlayerMusicPlayBase_OnChannelingAction final
{
public:
	int32                                         ActionCounter;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMusicPlayBase_OnChannelingAction) == 0x000004, "Wrong alignment on GA_PlayerMusicPlayBase_OnChannelingAction");
static_assert(sizeof(GA_PlayerMusicPlayBase_OnChannelingAction) == 0x000004, "Wrong size on GA_PlayerMusicPlayBase_OnChannelingAction");
static_assert(offsetof(GA_PlayerMusicPlayBase_OnChannelingAction, ActionCounter) == 0x000000, "Member 'GA_PlayerMusicPlayBase_OnChannelingAction::ActionCounter' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerMusicPlayBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerMusicPlayBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerMusicPlayBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_PlayerMusicPlayBase_ReceivedEvent");
static_assert(sizeof(GA_PlayerMusicPlayBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_PlayerMusicPlayBase_ReceivedEvent");
static_assert(offsetof(GA_PlayerMusicPlayBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_PlayerMusicPlayBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerMusicPlayBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_PlayerMusicPlayBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.StatisticsPopup.OnSeasonComboBoxSelected
// 0x0008 (0x0008 - 0x0000)
struct StatisticsPopup_OnSeasonComboBoxSelected final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatisticsPopup_OnSeasonComboBoxSelected) == 0x000008, "Wrong alignment on StatisticsPopup_OnSeasonComboBoxSelected");
static_assert(sizeof(StatisticsPopup_OnSeasonComboBoxSelected) == 0x000008, "Wrong size on StatisticsPopup_OnSeasonComboBoxSelected");
static_assert(offsetof(StatisticsPopup_OnSeasonComboBoxSelected, InItem) == 0x000000, "Member 'StatisticsPopup_OnSeasonComboBoxSelected::InItem' has a wrong offset!");

// Function DungeonCrawler.StatisticsPopup.OnSheetComboBoxSelected
// 0x0008 (0x0008 - 0x0000)
struct StatisticsPopup_OnSheetComboBoxSelected final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StatisticsPopup_OnSheetComboBoxSelected) == 0x000008, "Wrong alignment on StatisticsPopup_OnSheetComboBoxSelected");
static_assert(sizeof(StatisticsPopup_OnSheetComboBoxSelected) == 0x000008, "Wrong size on StatisticsPopup_OnSheetComboBoxSelected");
static_assert(offsetof(StatisticsPopup_OnSheetComboBoxSelected, InItem) == 0x000000, "Member 'StatisticsPopup_OnSheetComboBoxSelected::InItem' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_PlayerShapeShiftSpellCastBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftSpellCastBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftSpellCastBase_AbilityActivated");
static_assert(sizeof(GA_PlayerShapeShiftSpellCastBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_PlayerShapeShiftSpellCastBase_AbilityActivated");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_PlayerShapeShiftSpellCastBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.ClientReceivedTargetData
// 0x0038 (0x0038 - 0x0000)
struct GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData final
{
public:
	struct FGameplayTag                           InEffectTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InChannelTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData");
static_assert(sizeof(GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData) == 0x000038, "Wrong size on GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData, InEffectTag) == 0x000000, "Member 'GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData::InEffectTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData, InChannelTag) == 0x000008, "Member 'GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData::InChannelTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData, InData) == 0x000010, "Member 'GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftSpellCastBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftSpellCastBase_EventReceived) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftSpellCastBase_EventReceived");
static_assert(sizeof(GA_PlayerShapeShiftSpellCastBase_EventReceived) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftSpellCastBase_EventReceived");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_EventReceived, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftSpellCastBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_EventReceived, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftSpellCastBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnBlendOut
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftSpellCastBase_OnBlendOut final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftSpellCastBase_OnBlendOut) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftSpellCastBase_OnBlendOut");
static_assert(sizeof(GA_PlayerShapeShiftSpellCastBase_OnBlendOut) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftSpellCastBase_OnBlendOut");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_OnBlendOut, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftSpellCastBase_OnBlendOut::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_OnBlendOut, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftSpellCastBase_OnBlendOut::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftSpellCastBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftSpellCastBase_OnCancelled) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftSpellCastBase_OnCancelled");
static_assert(sizeof(GA_PlayerShapeShiftSpellCastBase_OnCancelled) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftSpellCastBase_OnCancelled");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftSpellCastBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_OnCancelled, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftSpellCastBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftSpellCastBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftSpellCastBase_OnCompleted) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftSpellCastBase_OnCompleted");
static_assert(sizeof(GA_PlayerShapeShiftSpellCastBase_OnCompleted) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftSpellCastBase_OnCompleted");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftSpellCastBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_OnCompleted, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftSpellCastBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnInterrupted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftSpellCastBase_OnInterrupted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftSpellCastBase_OnInterrupted) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftSpellCastBase_OnInterrupted");
static_assert(sizeof(GA_PlayerShapeShiftSpellCastBase_OnInterrupted) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftSpellCastBase_OnInterrupted");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_OnInterrupted, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftSpellCastBase_OnInterrupted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_OnInterrupted, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftSpellCastBase_OnInterrupted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerShapeShiftSpellCastBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftSpellCastBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftSpellCastBase_ReceivedEvent");
static_assert(sizeof(GA_PlayerShapeShiftSpellCastBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_PlayerShapeShiftSpellCastBase_ReceivedEvent");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_PlayerShapeShiftSpellCastBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_PlayerShapeShiftSpellCastBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.ReceivedTargetData
// 0x0028 (0x0028 - 0x0000)
struct GA_PlayerShapeShiftSpellCastBase_ReceivedTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftSpellCastBase_ReceivedTargetData) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftSpellCastBase_ReceivedTargetData");
static_assert(sizeof(GA_PlayerShapeShiftSpellCastBase_ReceivedTargetData) == 0x000028, "Wrong size on GA_PlayerShapeShiftSpellCastBase_ReceivedTargetData");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_ReceivedTargetData, InData) == 0x000000, "Member 'GA_PlayerShapeShiftSpellCastBase_ReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.ServerReceivedTargetData
// 0x0038 (0x0038 - 0x0000)
struct GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData final
{
public:
	struct FGameplayTag                           InEffectTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InChannelTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData) == 0x000008, "Wrong alignment on GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData");
static_assert(sizeof(GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData) == 0x000038, "Wrong size on GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData, InEffectTag) == 0x000000, "Member 'GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData::InEffectTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData, InChannelTag) == 0x000008, "Member 'GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData::InChannelTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData, InData) == 0x000010, "Member 'GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillChannelingBase.ServerOnChannelingAction
// 0x0004 (0x0004 - 0x0000)
struct GA_PlayerSkillChannelingBase_ServerOnChannelingAction final
{
public:
	int32                                         ActionCount;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillChannelingBase_ServerOnChannelingAction) == 0x000004, "Wrong alignment on GA_PlayerSkillChannelingBase_ServerOnChannelingAction");
static_assert(sizeof(GA_PlayerSkillChannelingBase_ServerOnChannelingAction) == 0x000004, "Wrong size on GA_PlayerSkillChannelingBase_ServerOnChannelingAction");
static_assert(offsetof(GA_PlayerSkillChannelingBase_ServerOnChannelingAction, ActionCount) == 0x000000, "Member 'GA_PlayerSkillChannelingBase_ServerOnChannelingAction::ActionCount' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillChannelingBase.ServerOnChannelingAction_BP
// 0x0190 (0x0190 - 0x0000)
struct GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 CueParams;                                         // 0x00B0(0x00D8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ActionCount;                                       // 0x0188(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2864[0x4];                                     // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP) == 0x000008, "Wrong alignment on GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP");
static_assert(sizeof(GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP) == 0x000190, "Wrong size on GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP");
static_assert(offsetof(GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP, EventData) == 0x000000, "Member 'GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP::EventData' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP, CueParams) == 0x0000B0, "Member 'GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP::CueParams' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP, ActionCount) == 0x000188, "Member 'GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP::ActionCount' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillChannelingBase.ServerOnChannelingStart
// 0x0188 (0x0188 - 0x0000)
struct GA_PlayerSkillChannelingBase_ServerOnChannelingStart final
{
public:
	struct FGameplayEventData                     EventData;                                         // 0x0000(0x00B0)(Parm, NativeAccessSpecifierPublic)
	struct FGameplayCueParameters                 CueParams;                                         // 0x00B0(0x00D8)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillChannelingBase_ServerOnChannelingStart) == 0x000008, "Wrong alignment on GA_PlayerSkillChannelingBase_ServerOnChannelingStart");
static_assert(sizeof(GA_PlayerSkillChannelingBase_ServerOnChannelingStart) == 0x000188, "Wrong size on GA_PlayerSkillChannelingBase_ServerOnChannelingStart");
static_assert(offsetof(GA_PlayerSkillChannelingBase_ServerOnChannelingStart, EventData) == 0x000000, "Member 'GA_PlayerSkillChannelingBase_ServerOnChannelingStart::EventData' has a wrong offset!");
static_assert(offsetof(GA_PlayerSkillChannelingBase_ServerOnChannelingStart, CueParams) == 0x0000B0, "Member 'GA_PlayerSkillChannelingBase_ServerOnChannelingStart::CueParams' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSkillInstantAndWaitForEndBase.OnSkillBuffTagRemoved
// 0x0004 (0x0004 - 0x0000)
struct GA_PlayerSkillInstantAndWaitForEndBase_OnSkillBuffTagRemoved final
{
public:
	int32                                         NewCount;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSkillInstantAndWaitForEndBase_OnSkillBuffTagRemoved) == 0x000004, "Wrong alignment on GA_PlayerSkillInstantAndWaitForEndBase_OnSkillBuffTagRemoved");
static_assert(sizeof(GA_PlayerSkillInstantAndWaitForEndBase_OnSkillBuffTagRemoved) == 0x000004, "Wrong size on GA_PlayerSkillInstantAndWaitForEndBase_OnSkillBuffTagRemoved");
static_assert(offsetof(GA_PlayerSkillInstantAndWaitForEndBase_OnSkillBuffTagRemoved, NewCount) == 0x000000, "Member 'GA_PlayerSkillInstantAndWaitForEndBase_OnSkillBuffTagRemoved::NewCount' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_PlayerSpellCastBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_AbilityActivated");
static_assert(sizeof(GA_PlayerSpellCastBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_PlayerSpellCastBase_AbilityActivated");
static_assert(offsetof(GA_PlayerSpellCastBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_PlayerSpellCastBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.ClientReceivedTargetData
// 0x0038 (0x0038 - 0x0000)
struct GA_PlayerSpellCastBase_ClientReceivedTargetData final
{
public:
	struct FGameplayTag                           InEffectTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InChannelTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_ClientReceivedTargetData) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_ClientReceivedTargetData");
static_assert(sizeof(GA_PlayerSpellCastBase_ClientReceivedTargetData) == 0x000038, "Wrong size on GA_PlayerSpellCastBase_ClientReceivedTargetData");
static_assert(offsetof(GA_PlayerSpellCastBase_ClientReceivedTargetData, InEffectTag) == 0x000000, "Member 'GA_PlayerSpellCastBase_ClientReceivedTargetData::InEffectTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSpellCastBase_ClientReceivedTargetData, InChannelTag) == 0x000008, "Member 'GA_PlayerSpellCastBase_ClientReceivedTargetData::InChannelTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSpellCastBase_ClientReceivedTargetData, InData) == 0x000010, "Member 'GA_PlayerSpellCastBase_ClientReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSpellCastBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_EventReceived) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_EventReceived");
static_assert(sizeof(GA_PlayerSpellCastBase_EventReceived) == 0x0000B8, "Wrong size on GA_PlayerSpellCastBase_EventReceived");
static_assert(offsetof(GA_PlayerSpellCastBase_EventReceived, EventTag) == 0x000000, "Member 'GA_PlayerSpellCastBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSpellCastBase_EventReceived, EventData) == 0x000008, "Member 'GA_PlayerSpellCastBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.OnBlendOut
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSpellCastBase_OnBlendOut final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_OnBlendOut) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_OnBlendOut");
static_assert(sizeof(GA_PlayerSpellCastBase_OnBlendOut) == 0x0000B8, "Wrong size on GA_PlayerSpellCastBase_OnBlendOut");
static_assert(offsetof(GA_PlayerSpellCastBase_OnBlendOut, EventTag) == 0x000000, "Member 'GA_PlayerSpellCastBase_OnBlendOut::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSpellCastBase_OnBlendOut, EventData) == 0x000008, "Member 'GA_PlayerSpellCastBase_OnBlendOut::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSpellCastBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_OnCancelled) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_OnCancelled");
static_assert(sizeof(GA_PlayerSpellCastBase_OnCancelled) == 0x0000B8, "Wrong size on GA_PlayerSpellCastBase_OnCancelled");
static_assert(offsetof(GA_PlayerSpellCastBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_PlayerSpellCastBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSpellCastBase_OnCancelled, EventData) == 0x000008, "Member 'GA_PlayerSpellCastBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingAction
// 0x0004 (0x0004 - 0x0000)
struct GA_PlayerSpellCastBase_OnChannelingAction final
{
public:
	int32                                         ActionCounter;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_OnChannelingAction) == 0x000004, "Wrong alignment on GA_PlayerSpellCastBase_OnChannelingAction");
static_assert(sizeof(GA_PlayerSpellCastBase_OnChannelingAction) == 0x000004, "Wrong size on GA_PlayerSpellCastBase_OnChannelingAction");
static_assert(offsetof(GA_PlayerSpellCastBase_OnChannelingAction, ActionCounter) == 0x000000, "Member 'GA_PlayerSpellCastBase_OnChannelingAction::ActionCounter' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingWithoutInterval
// 0x0004 (0x0004 - 0x0000)
struct GA_PlayerSpellCastBase_OnChannelingWithoutInterval final
{
public:
	int32                                         ActionCounter;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_OnChannelingWithoutInterval) == 0x000004, "Wrong alignment on GA_PlayerSpellCastBase_OnChannelingWithoutInterval");
static_assert(sizeof(GA_PlayerSpellCastBase_OnChannelingWithoutInterval) == 0x000004, "Wrong size on GA_PlayerSpellCastBase_OnChannelingWithoutInterval");
static_assert(offsetof(GA_PlayerSpellCastBase_OnChannelingWithoutInterval, ActionCounter) == 0x000000, "Member 'GA_PlayerSpellCastBase_OnChannelingWithoutInterval::ActionCounter' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSpellCastBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_OnCompleted) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_OnCompleted");
static_assert(sizeof(GA_PlayerSpellCastBase_OnCompleted) == 0x0000B8, "Wrong size on GA_PlayerSpellCastBase_OnCompleted");
static_assert(offsetof(GA_PlayerSpellCastBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_PlayerSpellCastBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSpellCastBase_OnCompleted, EventData) == 0x000008, "Member 'GA_PlayerSpellCastBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.OnInterrupted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSpellCastBase_OnInterrupted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_OnInterrupted) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_OnInterrupted");
static_assert(sizeof(GA_PlayerSpellCastBase_OnInterrupted) == 0x0000B8, "Wrong size on GA_PlayerSpellCastBase_OnInterrupted");
static_assert(offsetof(GA_PlayerSpellCastBase_OnInterrupted, EventTag) == 0x000000, "Member 'GA_PlayerSpellCastBase_OnInterrupted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSpellCastBase_OnInterrupted, EventData) == 0x000008, "Member 'GA_PlayerSpellCastBase_OnInterrupted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.ReceivedAreaTargetData
// 0x0028 (0x0028 - 0x0000)
struct GA_PlayerSpellCastBase_ReceivedAreaTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_ReceivedAreaTargetData) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_ReceivedAreaTargetData");
static_assert(sizeof(GA_PlayerSpellCastBase_ReceivedAreaTargetData) == 0x000028, "Wrong size on GA_PlayerSpellCastBase_ReceivedAreaTargetData");
static_assert(offsetof(GA_PlayerSpellCastBase_ReceivedAreaTargetData, InData) == 0x000000, "Member 'GA_PlayerSpellCastBase_ReceivedAreaTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_PlayerSpellCastBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_ReceivedEvent");
static_assert(sizeof(GA_PlayerSpellCastBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_PlayerSpellCastBase_ReceivedEvent");
static_assert(offsetof(GA_PlayerSpellCastBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_PlayerSpellCastBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSpellCastBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_PlayerSpellCastBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.ReceivedTargetData
// 0x0028 (0x0028 - 0x0000)
struct GA_PlayerSpellCastBase_ReceivedTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_ReceivedTargetData) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_ReceivedTargetData");
static_assert(sizeof(GA_PlayerSpellCastBase_ReceivedTargetData) == 0x000028, "Wrong size on GA_PlayerSpellCastBase_ReceivedTargetData");
static_assert(offsetof(GA_PlayerSpellCastBase_ReceivedTargetData, InData) == 0x000000, "Member 'GA_PlayerSpellCastBase_ReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.SendActivateSpellCrossHairNotify
// 0x0001 (0x0001 - 0x0000)
struct GA_PlayerSpellCastBase_SendActivateSpellCrossHairNotify final
{
public:
	bool                                          IsActivate;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_SendActivateSpellCrossHairNotify) == 0x000001, "Wrong alignment on GA_PlayerSpellCastBase_SendActivateSpellCrossHairNotify");
static_assert(sizeof(GA_PlayerSpellCastBase_SendActivateSpellCrossHairNotify) == 0x000001, "Wrong size on GA_PlayerSpellCastBase_SendActivateSpellCrossHairNotify");
static_assert(offsetof(GA_PlayerSpellCastBase_SendActivateSpellCrossHairNotify, IsActivate) == 0x000000, "Member 'GA_PlayerSpellCastBase_SendActivateSpellCrossHairNotify::IsActivate' has a wrong offset!");

// Function DungeonCrawler.GA_PlayerSpellCastBase.ServerReceivedTargetData
// 0x0038 (0x0038 - 0x0000)
struct GA_PlayerSpellCastBase_ServerReceivedTargetData final
{
public:
	struct FGameplayTag                           InEffectTag;                                       // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InChannelTag;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       InData;                                            // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_PlayerSpellCastBase_ServerReceivedTargetData) == 0x000008, "Wrong alignment on GA_PlayerSpellCastBase_ServerReceivedTargetData");
static_assert(sizeof(GA_PlayerSpellCastBase_ServerReceivedTargetData) == 0x000038, "Wrong size on GA_PlayerSpellCastBase_ServerReceivedTargetData");
static_assert(offsetof(GA_PlayerSpellCastBase_ServerReceivedTargetData, InEffectTag) == 0x000000, "Member 'GA_PlayerSpellCastBase_ServerReceivedTargetData::InEffectTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSpellCastBase_ServerReceivedTargetData, InChannelTag) == 0x000008, "Member 'GA_PlayerSpellCastBase_ServerReceivedTargetData::InChannelTag' has a wrong offset!");
static_assert(offsetof(GA_PlayerSpellCastBase_ServerReceivedTargetData, InData) == 0x000010, "Member 'GA_PlayerSpellCastBase_ServerReceivedTargetData::InData' has a wrong offset!");

// Function DungeonCrawler.GA_ProjectileCollision.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_ProjectileCollision_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ProjectileCollision_AbilityActivated) == 0x000008, "Wrong alignment on GA_ProjectileCollision_AbilityActivated");
static_assert(sizeof(GA_ProjectileCollision_AbilityActivated) == 0x0000B0, "Wrong size on GA_ProjectileCollision_AbilityActivated");
static_assert(offsetof(GA_ProjectileCollision_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_ProjectileCollision_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_ProjectileCollision.ReceivedTargetData
// 0x0028 (0x0028 - 0x0000)
struct GA_ProjectileCollision_ReceivedTargetData final
{
public:
	struct FGameplayAbilityTargetDataHandle       Data;                                              // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ProjectileCollision_ReceivedTargetData) == 0x000008, "Wrong alignment on GA_ProjectileCollision_ReceivedTargetData");
static_assert(sizeof(GA_ProjectileCollision_ReceivedTargetData) == 0x000028, "Wrong size on GA_ProjectileCollision_ReceivedTargetData");
static_assert(offsetof(GA_ProjectileCollision_ReceivedTargetData, Data) == 0x000000, "Member 'GA_ProjectileCollision_ReceivedTargetData::Data' has a wrong offset!");

// Function DungeonCrawler.GA_ProjectileCollision.TargetDataReceived
// 0x00E8 (0x00E8 - 0x0000)
struct GA_ProjectileCollision_TargetDataReceived final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ProjectileCollision_TargetDataReceived) == 0x000008, "Wrong alignment on GA_ProjectileCollision_TargetDataReceived");
static_assert(sizeof(GA_ProjectileCollision_TargetDataReceived) == 0x0000E8, "Wrong size on GA_ProjectileCollision_TargetDataReceived");
static_assert(offsetof(GA_ProjectileCollision_TargetDataReceived, Hit) == 0x000000, "Member 'GA_ProjectileCollision_TargetDataReceived::Hit' has a wrong offset!");

// Function DungeonCrawler.GA_ProjectileCollision.UpdateIgnoreActors
// 0x0008 (0x0008 - 0x0000)
struct GA_ProjectileCollision_UpdateIgnoreActors final
{
public:
	class AActor*                                 InCheckActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ProjectileCollision_UpdateIgnoreActors) == 0x000008, "Wrong alignment on GA_ProjectileCollision_UpdateIgnoreActors");
static_assert(sizeof(GA_ProjectileCollision_UpdateIgnoreActors) == 0x000008, "Wrong size on GA_ProjectileCollision_UpdateIgnoreActors");
static_assert(offsetof(GA_ProjectileCollision_UpdateIgnoreActors, InCheckActor) == 0x000000, "Member 'GA_ProjectileCollision_UpdateIgnoreActors::InCheckActor' has a wrong offset!");

// Function DungeonCrawler.GA_ReloadAmmoBase.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_ReloadAmmoBase_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ReloadAmmoBase_AbilityActivated) == 0x000008, "Wrong alignment on GA_ReloadAmmoBase_AbilityActivated");
static_assert(sizeof(GA_ReloadAmmoBase_AbilityActivated) == 0x0000B0, "Wrong size on GA_ReloadAmmoBase_AbilityActivated");
static_assert(offsetof(GA_ReloadAmmoBase_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_ReloadAmmoBase_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_ReloadAmmoBase.ActivateCrossHairPullAnimationByCrossbow
// 0x0004 (0x0004 - 0x0000)
struct GA_ReloadAmmoBase_ActivateCrossHairPullAnimationByCrossbow final
{
public:
	float                                         ActionSpeed;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ReloadAmmoBase_ActivateCrossHairPullAnimationByCrossbow) == 0x000004, "Wrong alignment on GA_ReloadAmmoBase_ActivateCrossHairPullAnimationByCrossbow");
static_assert(sizeof(GA_ReloadAmmoBase_ActivateCrossHairPullAnimationByCrossbow) == 0x000004, "Wrong size on GA_ReloadAmmoBase_ActivateCrossHairPullAnimationByCrossbow");
static_assert(offsetof(GA_ReloadAmmoBase_ActivateCrossHairPullAnimationByCrossbow, ActionSpeed) == 0x000000, "Member 'GA_ReloadAmmoBase_ActivateCrossHairPullAnimationByCrossbow::ActionSpeed' has a wrong offset!");

// Function DungeonCrawler.GA_ReloadAmmoBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ReloadAmmoBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ReloadAmmoBase_EventReceived) == 0x000008, "Wrong alignment on GA_ReloadAmmoBase_EventReceived");
static_assert(sizeof(GA_ReloadAmmoBase_EventReceived) == 0x0000B8, "Wrong size on GA_ReloadAmmoBase_EventReceived");
static_assert(offsetof(GA_ReloadAmmoBase_EventReceived, EventTag) == 0x000000, "Member 'GA_ReloadAmmoBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ReloadAmmoBase_EventReceived, EventData) == 0x000008, "Member 'GA_ReloadAmmoBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ReloadAmmoBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ReloadAmmoBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ReloadAmmoBase_OnCancelled) == 0x000008, "Wrong alignment on GA_ReloadAmmoBase_OnCancelled");
static_assert(sizeof(GA_ReloadAmmoBase_OnCancelled) == 0x0000B8, "Wrong size on GA_ReloadAmmoBase_OnCancelled");
static_assert(offsetof(GA_ReloadAmmoBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_ReloadAmmoBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ReloadAmmoBase_OnCancelled, EventData) == 0x000008, "Member 'GA_ReloadAmmoBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ReloadAmmoBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ReloadAmmoBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ReloadAmmoBase_OnCompleted) == 0x000008, "Wrong alignment on GA_ReloadAmmoBase_OnCompleted");
static_assert(sizeof(GA_ReloadAmmoBase_OnCompleted) == 0x0000B8, "Wrong size on GA_ReloadAmmoBase_OnCompleted");
static_assert(offsetof(GA_ReloadAmmoBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_ReloadAmmoBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ReloadAmmoBase_OnCompleted, EventData) == 0x000008, "Member 'GA_ReloadAmmoBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ReloadAmmoBase.ReceivedEvent
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ReloadAmmoBase_ReceivedEvent final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ReloadAmmoBase_ReceivedEvent) == 0x000008, "Wrong alignment on GA_ReloadAmmoBase_ReceivedEvent");
static_assert(sizeof(GA_ReloadAmmoBase_ReceivedEvent) == 0x0000B8, "Wrong size on GA_ReloadAmmoBase_ReceivedEvent");
static_assert(offsetof(GA_ReloadAmmoBase_ReceivedEvent, EventTag) == 0x000000, "Member 'GA_ReloadAmmoBase_ReceivedEvent::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ReloadAmmoBase_ReceivedEvent, EventData) == 0x000008, "Member 'GA_ReloadAmmoBase_ReceivedEvent::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ReversibleChangeIdle.AbilityActivated
// 0x00B0 (0x00B0 - 0x0000)
struct GA_ReversibleChangeIdle_AbilityActivated final
{
public:
	struct FGameplayEventData                     TriggerEventData;                                  // 0x0000(0x00B0)(ConstParm, Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ReversibleChangeIdle_AbilityActivated) == 0x000008, "Wrong alignment on GA_ReversibleChangeIdle_AbilityActivated");
static_assert(sizeof(GA_ReversibleChangeIdle_AbilityActivated) == 0x0000B0, "Wrong size on GA_ReversibleChangeIdle_AbilityActivated");
static_assert(offsetof(GA_ReversibleChangeIdle_AbilityActivated, TriggerEventData) == 0x000000, "Member 'GA_ReversibleChangeIdle_AbilityActivated::TriggerEventData' has a wrong offset!");

// Function DungeonCrawler.GA_ReversibleChangeIdle.OnBlendOut
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ReversibleChangeIdle_OnBlendOut final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ReversibleChangeIdle_OnBlendOut) == 0x000008, "Wrong alignment on GA_ReversibleChangeIdle_OnBlendOut");
static_assert(sizeof(GA_ReversibleChangeIdle_OnBlendOut) == 0x0000B8, "Wrong size on GA_ReversibleChangeIdle_OnBlendOut");
static_assert(offsetof(GA_ReversibleChangeIdle_OnBlendOut, EventTag) == 0x000000, "Member 'GA_ReversibleChangeIdle_OnBlendOut::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ReversibleChangeIdle_OnBlendOut, EventData) == 0x000008, "Member 'GA_ReversibleChangeIdle_OnBlendOut::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ReversibleChangeIdle.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ReversibleChangeIdle_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ReversibleChangeIdle_OnCompleted) == 0x000008, "Wrong alignment on GA_ReversibleChangeIdle_OnCompleted");
static_assert(sizeof(GA_ReversibleChangeIdle_OnCompleted) == 0x0000B8, "Wrong size on GA_ReversibleChangeIdle_OnCompleted");
static_assert(offsetof(GA_ReversibleChangeIdle_OnCompleted, EventTag) == 0x000000, "Member 'GA_ReversibleChangeIdle_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ReversibleChangeIdle_OnCompleted, EventData) == 0x000008, "Member 'GA_ReversibleChangeIdle_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_SequenceDamageBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_SequenceDamageBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SequenceDamageBase_EventReceived) == 0x000008, "Wrong alignment on GA_SequenceDamageBase_EventReceived");
static_assert(sizeof(GA_SequenceDamageBase_EventReceived) == 0x0000B8, "Wrong size on GA_SequenceDamageBase_EventReceived");
static_assert(offsetof(GA_SequenceDamageBase_EventReceived, EventTag) == 0x000000, "Member 'GA_SequenceDamageBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_SequenceDamageBase_EventReceived, EventData) == 0x000008, "Member 'GA_SequenceDamageBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_SequenceDamageBase.OnDamageEvent
// 0x0008 (0x0008 - 0x0000)
struct GA_SequenceDamageBase_OnDamageEvent final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SequenceDamageBase_OnDamageEvent) == 0x000008, "Wrong alignment on GA_SequenceDamageBase_OnDamageEvent");
static_assert(sizeof(GA_SequenceDamageBase_OnDamageEvent) == 0x000008, "Wrong size on GA_SequenceDamageBase_OnDamageEvent");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageEvent, TargetActor) == 0x000000, "Member 'GA_SequenceDamageBase_OnDamageEvent::TargetActor' has a wrong offset!");

// Function DungeonCrawler.GA_SequenceDamageBase.OnDamageOverlapBegin
// 0x0108 (0x0108 - 0x0000)
struct GA_SequenceDamageBase_OnDamageOverlapBegin final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286A[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SequenceDamageBase_OnDamageOverlapBegin) == 0x000008, "Wrong alignment on GA_SequenceDamageBase_OnDamageOverlapBegin");
static_assert(sizeof(GA_SequenceDamageBase_OnDamageOverlapBegin) == 0x000108, "Wrong size on GA_SequenceDamageBase_OnDamageOverlapBegin");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageOverlapBegin, OverlappedComp) == 0x000000, "Member 'GA_SequenceDamageBase_OnDamageOverlapBegin::OverlappedComp' has a wrong offset!");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageOverlapBegin, Other) == 0x000008, "Member 'GA_SequenceDamageBase_OnDamageOverlapBegin::Other' has a wrong offset!");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageOverlapBegin, OtherComp) == 0x000010, "Member 'GA_SequenceDamageBase_OnDamageOverlapBegin::OtherComp' has a wrong offset!");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageOverlapBegin, OtherBodyIndex) == 0x000018, "Member 'GA_SequenceDamageBase_OnDamageOverlapBegin::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageOverlapBegin, bFromSweep) == 0x00001C, "Member 'GA_SequenceDamageBase_OnDamageOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageOverlapBegin, SweepResult) == 0x000020, "Member 'GA_SequenceDamageBase_OnDamageOverlapBegin::SweepResult' has a wrong offset!");

// Function DungeonCrawler.GA_SequenceDamageBase.OnDamageOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct GA_SequenceDamageBase_OnDamageOverlapEnd final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286B[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GA_SequenceDamageBase_OnDamageOverlapEnd) == 0x000008, "Wrong alignment on GA_SequenceDamageBase_OnDamageOverlapEnd");
static_assert(sizeof(GA_SequenceDamageBase_OnDamageOverlapEnd) == 0x000020, "Wrong size on GA_SequenceDamageBase_OnDamageOverlapEnd");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageOverlapEnd, OverlappedComp) == 0x000000, "Member 'GA_SequenceDamageBase_OnDamageOverlapEnd::OverlappedComp' has a wrong offset!");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageOverlapEnd, Other) == 0x000008, "Member 'GA_SequenceDamageBase_OnDamageOverlapEnd::Other' has a wrong offset!");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageOverlapEnd, OtherComp) == 0x000010, "Member 'GA_SequenceDamageBase_OnDamageOverlapEnd::OtherComp' has a wrong offset!");
static_assert(offsetof(GA_SequenceDamageBase_OnDamageOverlapEnd, OtherBodyIndex) == 0x000018, "Member 'GA_SequenceDamageBase_OnDamageOverlapEnd::OtherBodyIndex' has a wrong offset!");

// Function DungeonCrawler.GA_ShapeShiftEndBase.OnCancelled
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ShapeShiftEndBase_OnCancelled final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ShapeShiftEndBase_OnCancelled) == 0x000008, "Wrong alignment on GA_ShapeShiftEndBase_OnCancelled");
static_assert(sizeof(GA_ShapeShiftEndBase_OnCancelled) == 0x0000B8, "Wrong size on GA_ShapeShiftEndBase_OnCancelled");
static_assert(offsetof(GA_ShapeShiftEndBase_OnCancelled, EventTag) == 0x000000, "Member 'GA_ShapeShiftEndBase_OnCancelled::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ShapeShiftEndBase_OnCancelled, EventData) == 0x000008, "Member 'GA_ShapeShiftEndBase_OnCancelled::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_ShapeShiftEndBase.OnCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_ShapeShiftEndBase_OnCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_ShapeShiftEndBase_OnCompleted) == 0x000008, "Wrong alignment on GA_ShapeShiftEndBase_OnCompleted");
static_assert(sizeof(GA_ShapeShiftEndBase_OnCompleted) == 0x0000B8, "Wrong size on GA_ShapeShiftEndBase_OnCompleted");
static_assert(offsetof(GA_ShapeShiftEndBase_OnCompleted, EventTag) == 0x000000, "Member 'GA_ShapeShiftEndBase_OnCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_ShapeShiftEndBase_OnCompleted, EventData) == 0x000008, "Member 'GA_ShapeShiftEndBase_OnCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_SpellCastingAndInstallBase.ActivateInstalledSpell
// 0x0008 (0x0008 - 0x0000)
struct GA_SpellCastingAndInstallBase_ActivateInstalledSpell final
{
public:
	struct FGameplayTag                           OptionalEffectContainerTag;                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellCastingAndInstallBase_ActivateInstalledSpell) == 0x000004, "Wrong alignment on GA_SpellCastingAndInstallBase_ActivateInstalledSpell");
static_assert(sizeof(GA_SpellCastingAndInstallBase_ActivateInstalledSpell) == 0x000008, "Wrong size on GA_SpellCastingAndInstallBase_ActivateInstalledSpell");
static_assert(offsetof(GA_SpellCastingAndInstallBase_ActivateInstalledSpell, OptionalEffectContainerTag) == 0x000000, "Member 'GA_SpellCastingAndInstallBase_ActivateInstalledSpell::OptionalEffectContainerTag' has a wrong offset!");

// Function DungeonCrawler.GA_SpellCastingAndInstallBase.InstallOnGround
// 0x0001 (0x0001 - 0x0000)
struct GA_SpellCastingAndInstallBase_InstallOnGround final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellCastingAndInstallBase_InstallOnGround) == 0x000001, "Wrong alignment on GA_SpellCastingAndInstallBase_InstallOnGround");
static_assert(sizeof(GA_SpellCastingAndInstallBase_InstallOnGround) == 0x000001, "Wrong size on GA_SpellCastingAndInstallBase_InstallOnGround");
static_assert(offsetof(GA_SpellCastingAndInstallBase_InstallOnGround, ReturnValue) == 0x000000, "Member 'GA_SpellCastingAndInstallBase_InstallOnGround::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.GA_SpellCastingAndInstallBase.OnSpellBlasted
// 0x00C0 (0x00C0 - 0x0000)
struct GA_SpellCastingAndInstallBase_OnSpellBlasted final
{
public:
	TArray<struct FActiveGameplayEffectHandle>    EffectHandles;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0010(0x00B0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellCastingAndInstallBase_OnSpellBlasted) == 0x000008, "Wrong alignment on GA_SpellCastingAndInstallBase_OnSpellBlasted");
static_assert(sizeof(GA_SpellCastingAndInstallBase_OnSpellBlasted) == 0x0000C0, "Wrong size on GA_SpellCastingAndInstallBase_OnSpellBlasted");
static_assert(offsetof(GA_SpellCastingAndInstallBase_OnSpellBlasted, EffectHandles) == 0x000000, "Member 'GA_SpellCastingAndInstallBase_OnSpellBlasted::EffectHandles' has a wrong offset!");
static_assert(offsetof(GA_SpellCastingAndInstallBase_OnSpellBlasted, EventData) == 0x000010, "Member 'GA_SpellCastingAndInstallBase_OnSpellBlasted::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_SpellCastingAndInstallBase.SetTargetActorFromBoxOverlapActors
// 0x0028 (0x0028 - 0x0000)
struct GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             InTargetClasses;                                   // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         InIgnoreActors;                                    // 0x0018(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors) == 0x000008, "Wrong alignment on GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors");
static_assert(sizeof(GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors) == 0x000028, "Wrong size on GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors");
static_assert(offsetof(GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors, WorldContextObject) == 0x000000, "Member 'GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors, InTargetClasses) == 0x000008, "Member 'GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors::InTargetClasses' has a wrong offset!");
static_assert(offsetof(GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors, InIgnoreActors) == 0x000018, "Member 'GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors::InIgnoreActors' has a wrong offset!");

// Function DungeonCrawler.GA_SpellCastingAndInstallBase.SetTargetActorFromCylinderOverlapActors
// 0x0028 (0x0028 - 0x0000)
struct GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             InTargetClasses;                                   // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         InIgnoreActors;                                    // 0x0018(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors) == 0x000008, "Wrong alignment on GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors");
static_assert(sizeof(GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors) == 0x000028, "Wrong size on GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors");
static_assert(offsetof(GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors, WorldContextObject) == 0x000000, "Member 'GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors, InTargetClasses) == 0x000008, "Member 'GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors::InTargetClasses' has a wrong offset!");
static_assert(offsetof(GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors, InIgnoreActors) == 0x000018, "Member 'GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors::InIgnoreActors' has a wrong offset!");

// Function DungeonCrawler.GA_SpellCastingAndInstallBase.SetTargetActorFromSphereOverlapActors
// 0x0028 (0x0028 - 0x0000)
struct GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             InTargetClasses;                                   // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         InIgnoreActors;                                    // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors) == 0x000008, "Wrong alignment on GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors");
static_assert(sizeof(GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors) == 0x000028, "Wrong size on GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors");
static_assert(offsetof(GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors, WorldContextObject) == 0x000000, "Member 'GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors, InTargetClasses) == 0x000008, "Member 'GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors::InTargetClasses' has a wrong offset!");
static_assert(offsetof(GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors, InIgnoreActors) == 0x000018, "Member 'GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors::InIgnoreActors' has a wrong offset!");

// Function DungeonCrawler.GA_SpellChannelingBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_SpellChannelingBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellChannelingBase_EventReceived) == 0x000008, "Wrong alignment on GA_SpellChannelingBase_EventReceived");
static_assert(sizeof(GA_SpellChannelingBase_EventReceived) == 0x0000B8, "Wrong size on GA_SpellChannelingBase_EventReceived");
static_assert(offsetof(GA_SpellChannelingBase_EventReceived, EventTag) == 0x000000, "Member 'GA_SpellChannelingBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_SpellChannelingBase_EventReceived, EventData) == 0x000008, "Member 'GA_SpellChannelingBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_SpellChannelingBase.OnChannelingAction
// 0x0004 (0x0004 - 0x0000)
struct GA_SpellChannelingBase_OnChannelingAction final
{
public:
	int32                                         ChannelingActionCount;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellChannelingBase_OnChannelingAction) == 0x000004, "Wrong alignment on GA_SpellChannelingBase_OnChannelingAction");
static_assert(sizeof(GA_SpellChannelingBase_OnChannelingAction) == 0x000004, "Wrong size on GA_SpellChannelingBase_OnChannelingAction");
static_assert(offsetof(GA_SpellChannelingBase_OnChannelingAction, ChannelingActionCount) == 0x000000, "Member 'GA_SpellChannelingBase_OnChannelingAction::ChannelingActionCount' has a wrong offset!");

// Function DungeonCrawler.GA_SpellGrantingAbilityBase.SetGrantingAbilityDatas
// 0x0018 (0x0018 - 0x0000)
struct GA_SpellGrantingAbilityBase_SetGrantingAbilityDatas final
{
public:
	struct FPrimaryAssetId                        InGrantingAbilityId;                               // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InGrantedAbilityTag;                               // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_SpellGrantingAbilityBase_SetGrantingAbilityDatas) == 0x000004, "Wrong alignment on GA_SpellGrantingAbilityBase_SetGrantingAbilityDatas");
static_assert(sizeof(GA_SpellGrantingAbilityBase_SetGrantingAbilityDatas) == 0x000018, "Wrong size on GA_SpellGrantingAbilityBase_SetGrantingAbilityDatas");
static_assert(offsetof(GA_SpellGrantingAbilityBase_SetGrantingAbilityDatas, InGrantingAbilityId) == 0x000000, "Member 'GA_SpellGrantingAbilityBase_SetGrantingAbilityDatas::InGrantingAbilityId' has a wrong offset!");
static_assert(offsetof(GA_SpellGrantingAbilityBase_SetGrantingAbilityDatas, InGrantedAbilityTag) == 0x000010, "Member 'GA_SpellGrantingAbilityBase_SetGrantingAbilityDatas::InGrantedAbilityTag' has a wrong offset!");

// Function DungeonCrawler.GA_WearBase.EventReceived
// 0x00B8 (0x00B8 - 0x0000)
struct GA_WearBase_EventReceived final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_WearBase_EventReceived) == 0x000008, "Wrong alignment on GA_WearBase_EventReceived");
static_assert(sizeof(GA_WearBase_EventReceived) == 0x0000B8, "Wrong size on GA_WearBase_EventReceived");
static_assert(offsetof(GA_WearBase_EventReceived, EventTag) == 0x000000, "Member 'GA_WearBase_EventReceived::EventTag' has a wrong offset!");
static_assert(offsetof(GA_WearBase_EventReceived, EventData) == 0x000008, "Member 'GA_WearBase_EventReceived::EventData' has a wrong offset!");

// Function DungeonCrawler.GA_WearBase.OnChangingMontageCompleted
// 0x00B8 (0x00B8 - 0x0000)
struct GA_WearBase_OnChangingMontageCompleted final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEventData                     EventData;                                         // 0x0008(0x00B0)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GA_WearBase_OnChangingMontageCompleted) == 0x000008, "Wrong alignment on GA_WearBase_OnChangingMontageCompleted");
static_assert(sizeof(GA_WearBase_OnChangingMontageCompleted) == 0x0000B8, "Wrong size on GA_WearBase_OnChangingMontageCompleted");
static_assert(offsetof(GA_WearBase_OnChangingMontageCompleted, EventTag) == 0x000000, "Member 'GA_WearBase_OnChangingMontageCompleted::EventTag' has a wrong offset!");
static_assert(offsetof(GA_WearBase_OnChangingMontageCompleted, EventData) == 0x000008, "Member 'GA_WearBase_OnChangingMontageCompleted::EventData' has a wrong offset!");

// Function DungeonCrawler.MonsterSpawnableInterface.Spawn
// 0x0010 (0x0010 - 0x0000)
struct MonsterSpawnableInterface_Spawn final
{
public:
	TSubclassOf<class ADCMonsterBase>             Monster;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCMonsterBase*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MonsterSpawnableInterface_Spawn) == 0x000008, "Wrong alignment on MonsterSpawnableInterface_Spawn");
static_assert(sizeof(MonsterSpawnableInterface_Spawn) == 0x000010, "Wrong size on MonsterSpawnableInterface_Spawn");
static_assert(offsetof(MonsterSpawnableInterface_Spawn, Monster) == 0x000000, "Member 'MonsterSpawnableInterface_Spawn::Monster' has a wrong offset!");
static_assert(offsetof(MonsterSpawnableInterface_Spawn, ReturnValue) == 0x000008, "Member 'MonsterSpawnableInterface_Spawn::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ImpactableComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct ImpactableComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImpactableComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on ImpactableComponent_BroadcastMsgBlueprint");
static_assert(sizeof(ImpactableComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on ImpactableComponent_BroadcastMsgBlueprint");
static_assert(offsetof(ImpactableComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'ImpactableComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ImpactableComponent.SetImpactableQuery
// 0x0010 (0x0010 - 0x0000)
struct ImpactableComponent_SetImpactableQuery final
{
public:
	TArray<struct FPrimaryAssetId>                TagQueryDatas;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImpactableComponent_SetImpactableQuery) == 0x000008, "Wrong alignment on ImpactableComponent_SetImpactableQuery");
static_assert(sizeof(ImpactableComponent_SetImpactableQuery) == 0x000010, "Wrong size on ImpactableComponent_SetImpactableQuery");
static_assert(offsetof(ImpactableComponent_SetImpactableQuery, TagQueryDatas) == 0x000000, "Member 'ImpactableComponent_SetImpactableQuery::TagQueryDatas' has a wrong offset!");

// Function DungeonCrawler.ImpactableComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct ImpactableComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImpactableComponent_UnbindMsg) == 0x000008, "Wrong alignment on ImpactableComponent_UnbindMsg");
static_assert(sizeof(ImpactableComponent_UnbindMsg) == 0x000010, "Wrong size on ImpactableComponent_UnbindMsg");
static_assert(offsetof(ImpactableComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'ImpactableComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(ImpactableComponent_UnbindMsg, InObject) == 0x000008, "Member 'ImpactableComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.ImpactableComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct ImpactableComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImpactableComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on ImpactableComponent_UnbindMsgAll");
static_assert(sizeof(ImpactableComponent_UnbindMsgAll) == 0x000008, "Wrong size on ImpactableComponent_UnbindMsgAll");
static_assert(offsetof(ImpactableComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'ImpactableComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.ImpactableComponent.GetImpactableTagQueryArray
// 0x0010 (0x0010 - 0x0000)
struct ImpactableComponent_GetImpactableTagQueryArray final
{
public:
	TArray<class UTagQueryData*>                  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImpactableComponent_GetImpactableTagQueryArray) == 0x000008, "Wrong alignment on ImpactableComponent_GetImpactableTagQueryArray");
static_assert(sizeof(ImpactableComponent_GetImpactableTagQueryArray) == 0x000010, "Wrong size on ImpactableComponent_GetImpactableTagQueryArray");
static_assert(offsetof(ImpactableComponent_GetImpactableTagQueryArray, ReturnValue) == 0x000000, "Member 'ImpactableComponent_GetImpactableTagQueryArray::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.IMUtilBlueprintLibrary.GetProjectVersion
// 0x0010 (0x0010 - 0x0000)
struct IMUtilBlueprintLibrary_GetProjectVersion final
{
public:
	class FString                                 OutVersion;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(IMUtilBlueprintLibrary_GetProjectVersion) == 0x000008, "Wrong alignment on IMUtilBlueprintLibrary_GetProjectVersion");
static_assert(sizeof(IMUtilBlueprintLibrary_GetProjectVersion) == 0x000010, "Wrong size on IMUtilBlueprintLibrary_GetProjectVersion");
static_assert(offsetof(IMUtilBlueprintLibrary_GetProjectVersion, OutVersion) == 0x000000, "Member 'IMUtilBlueprintLibrary_GetProjectVersion::OutVersion' has a wrong offset!");

// Function DungeonCrawler.IMUtilBlueprintLibrary.GetServerWorldTimeSeconds
// 0x0010 (0x0010 - 0x0000)
struct IMUtilBlueprintLibrary_GetServerWorldTimeSeconds final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2872[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(IMUtilBlueprintLibrary_GetServerWorldTimeSeconds) == 0x000008, "Wrong alignment on IMUtilBlueprintLibrary_GetServerWorldTimeSeconds");
static_assert(sizeof(IMUtilBlueprintLibrary_GetServerWorldTimeSeconds) == 0x000010, "Wrong size on IMUtilBlueprintLibrary_GetServerWorldTimeSeconds");
static_assert(offsetof(IMUtilBlueprintLibrary_GetServerWorldTimeSeconds, WorldContextObject) == 0x000000, "Member 'IMUtilBlueprintLibrary_GetServerWorldTimeSeconds::WorldContextObject' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_GetServerWorldTimeSeconds, ReturnValue) == 0x000008, "Member 'IMUtilBlueprintLibrary_GetServerWorldTimeSeconds::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.IMUtilBlueprintLibrary.IsServer
// 0x0010 (0x0010 - 0x0000)
struct IMUtilBlueprintLibrary_IsServer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2873[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(IMUtilBlueprintLibrary_IsServer) == 0x000008, "Wrong alignment on IMUtilBlueprintLibrary_IsServer");
static_assert(sizeof(IMUtilBlueprintLibrary_IsServer) == 0x000010, "Wrong size on IMUtilBlueprintLibrary_IsServer");
static_assert(offsetof(IMUtilBlueprintLibrary_IsServer, WorldContextObject) == 0x000000, "Member 'IMUtilBlueprintLibrary_IsServer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_IsServer, ReturnValue) == 0x000008, "Member 'IMUtilBlueprintLibrary_IsServer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.IMUtilBlueprintLibrary.MakeTextwithParam1
// 0x0048 (0x0048 - 0x0000)
struct IMUtilBlueprintLibrary_MakeTextwithParam1 final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param1;                                            // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0030(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IMUtilBlueprintLibrary_MakeTextwithParam1) == 0x000008, "Wrong alignment on IMUtilBlueprintLibrary_MakeTextwithParam1");
static_assert(sizeof(IMUtilBlueprintLibrary_MakeTextwithParam1) == 0x000048, "Wrong size on IMUtilBlueprintLibrary_MakeTextwithParam1");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam1, Text) == 0x000000, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam1::Text' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam1, Param1) == 0x000018, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam1::Param1' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam1, ReturnValue) == 0x000030, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam1::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.IMUtilBlueprintLibrary.MakeTextwithParam2
// 0x0060 (0x0060 - 0x0000)
struct IMUtilBlueprintLibrary_MakeTextwithParam2 final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param1;                                            // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param2;                                            // 0x0030(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0048(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IMUtilBlueprintLibrary_MakeTextwithParam2) == 0x000008, "Wrong alignment on IMUtilBlueprintLibrary_MakeTextwithParam2");
static_assert(sizeof(IMUtilBlueprintLibrary_MakeTextwithParam2) == 0x000060, "Wrong size on IMUtilBlueprintLibrary_MakeTextwithParam2");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam2, Text) == 0x000000, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam2::Text' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam2, Param1) == 0x000018, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam2::Param1' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam2, Param2) == 0x000030, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam2::Param2' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam2, ReturnValue) == 0x000048, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam2::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.IMUtilBlueprintLibrary.MakeTextwithParam3
// 0x0078 (0x0078 - 0x0000)
struct IMUtilBlueprintLibrary_MakeTextwithParam3 final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param1;                                            // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param2;                                            // 0x0030(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param3;                                            // 0x0048(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0060(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IMUtilBlueprintLibrary_MakeTextwithParam3) == 0x000008, "Wrong alignment on IMUtilBlueprintLibrary_MakeTextwithParam3");
static_assert(sizeof(IMUtilBlueprintLibrary_MakeTextwithParam3) == 0x000078, "Wrong size on IMUtilBlueprintLibrary_MakeTextwithParam3");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam3, Text) == 0x000000, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam3::Text' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam3, Param1) == 0x000018, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam3::Param1' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam3, Param2) == 0x000030, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam3::Param2' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam3, Param3) == 0x000048, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam3::Param3' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam3, ReturnValue) == 0x000060, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam3::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.IMUtilBlueprintLibrary.MakeTextwithParam4
// 0x0090 (0x0090 - 0x0000)
struct IMUtilBlueprintLibrary_MakeTextwithParam4 final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param1;                                            // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param2;                                            // 0x0030(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param3;                                            // 0x0048(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param4;                                            // 0x0060(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0078(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IMUtilBlueprintLibrary_MakeTextwithParam4) == 0x000008, "Wrong alignment on IMUtilBlueprintLibrary_MakeTextwithParam4");
static_assert(sizeof(IMUtilBlueprintLibrary_MakeTextwithParam4) == 0x000090, "Wrong size on IMUtilBlueprintLibrary_MakeTextwithParam4");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam4, Text) == 0x000000, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam4::Text' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam4, Param1) == 0x000018, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam4::Param1' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam4, Param2) == 0x000030, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam4::Param2' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam4, Param3) == 0x000048, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam4::Param3' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam4, Param4) == 0x000060, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam4::Param4' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam4, ReturnValue) == 0x000078, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam4::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.IMUtilBlueprintLibrary.MakeTextwithParam5
// 0x00A8 (0x00A8 - 0x0000)
struct IMUtilBlueprintLibrary_MakeTextwithParam5 final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param1;                                            // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param2;                                            // 0x0030(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param3;                                            // 0x0048(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param4;                                            // 0x0060(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   Param5;                                            // 0x0078(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0090(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(IMUtilBlueprintLibrary_MakeTextwithParam5) == 0x000008, "Wrong alignment on IMUtilBlueprintLibrary_MakeTextwithParam5");
static_assert(sizeof(IMUtilBlueprintLibrary_MakeTextwithParam5) == 0x0000A8, "Wrong size on IMUtilBlueprintLibrary_MakeTextwithParam5");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam5, Text) == 0x000000, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam5::Text' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam5, Param1) == 0x000018, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam5::Param1' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam5, Param2) == 0x000030, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam5::Param2' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam5, Param3) == 0x000048, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam5::Param3' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam5, Param4) == 0x000060, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam5::Param4' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam5, Param5) == 0x000078, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam5::Param5' has a wrong offset!");
static_assert(offsetof(IMUtilBlueprintLibrary_MakeTextwithParam5, ReturnValue) == 0x000090, "Member 'IMUtilBlueprintLibrary_MakeTextwithParam5::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.InventoryLootingWidget.OnLootingPlayerSet
// 0x000C (0x000C - 0x0000)
struct InventoryLootingWidget_OnLootingPlayerSet final
{
public:
	bool                                          bSetTargetPlayer;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_287E[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetPlayerName;                                  // 0x0004(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryLootingWidget_OnLootingPlayerSet) == 0x000004, "Wrong alignment on InventoryLootingWidget_OnLootingPlayerSet");
static_assert(sizeof(InventoryLootingWidget_OnLootingPlayerSet) == 0x00000C, "Wrong size on InventoryLootingWidget_OnLootingPlayerSet");
static_assert(offsetof(InventoryLootingWidget_OnLootingPlayerSet, bSetTargetPlayer) == 0x000000, "Member 'InventoryLootingWidget_OnLootingPlayerSet::bSetTargetPlayer' has a wrong offset!");
static_assert(offsetof(InventoryLootingWidget_OnLootingPlayerSet, TargetPlayerName) == 0x000004, "Member 'InventoryLootingWidget_OnLootingPlayerSet::TargetPlayerName' has a wrong offset!");

// Function DungeonCrawler.InventoryLootingWidget.OnLootingTargetCountChanged
// 0x0004 (0x0004 - 0x0000)
struct InventoryLootingWidget_OnLootingTargetCountChanged final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryLootingWidget_OnLootingTargetCountChanged) == 0x000004, "Wrong alignment on InventoryLootingWidget_OnLootingTargetCountChanged");
static_assert(sizeof(InventoryLootingWidget_OnLootingTargetCountChanged) == 0x000004, "Wrong size on InventoryLootingWidget_OnLootingTargetCountChanged");
static_assert(offsetof(InventoryLootingWidget_OnLootingTargetCountChanged, Count) == 0x000000, "Member 'InventoryLootingWidget_OnLootingTargetCountChanged::Count' has a wrong offset!");

// Function DungeonCrawler.InventoryLootingWidget.RequestInventoryWidgetVisible
// 0x0001 (0x0001 - 0x0000)
struct InventoryLootingWidget_RequestInventoryWidgetVisible final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryLootingWidget_RequestInventoryWidgetVisible) == 0x000001, "Wrong alignment on InventoryLootingWidget_RequestInventoryWidgetVisible");
static_assert(sizeof(InventoryLootingWidget_RequestInventoryWidgetVisible) == 0x000001, "Wrong size on InventoryLootingWidget_RequestInventoryWidgetVisible");
static_assert(offsetof(InventoryLootingWidget_RequestInventoryWidgetVisible, bVisible) == 0x000000, "Member 'InventoryLootingWidget_RequestInventoryWidgetVisible::bVisible' has a wrong offset!");

// Function DungeonCrawler.InventoryTabWidgetBase.OnChangeActiveState
// 0x0001 (0x0001 - 0x0000)
struct InventoryTabWidgetBase_OnChangeActiveState final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InventoryTabWidgetBase_OnChangeActiveState) == 0x000001, "Wrong alignment on InventoryTabWidgetBase_OnChangeActiveState");
static_assert(sizeof(InventoryTabWidgetBase_OnChangeActiveState) == 0x000001, "Wrong size on InventoryTabWidgetBase_OnChangeActiveState");
static_assert(offsetof(InventoryTabWidgetBase_OnChangeActiveState, bActive) == 0x000000, "Member 'InventoryTabWidgetBase_OnChangeActiveState::bActive' has a wrong offset!");

// Function DungeonCrawler.Item.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct Item_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on Item_BroadcastMsgBlueprint");
static_assert(sizeof(Item_BroadcastMsgBlueprint) == 0x000004, "Wrong size on Item_BroadcastMsgBlueprint");
static_assert(offsetof(Item_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'Item_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.Item.Initialize
// 0x0100 (0x0100 - 0x0000)
struct Item_Initialize final
{
public:
	struct FItemData                              Data;                                              // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_Initialize) == 0x000008, "Wrong alignment on Item_Initialize");
static_assert(sizeof(Item_Initialize) == 0x000100, "Wrong size on Item_Initialize");
static_assert(offsetof(Item_Initialize, Data) == 0x000000, "Member 'Item_Initialize::Data' has a wrong offset!");

// Function DungeonCrawler.Item.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct Item_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_UnbindMsg) == 0x000008, "Wrong alignment on Item_UnbindMsg");
static_assert(sizeof(Item_UnbindMsg) == 0x000010, "Wrong size on Item_UnbindMsg");
static_assert(offsetof(Item_UnbindMsg, InMsgType) == 0x000000, "Member 'Item_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(Item_UnbindMsg, InObject) == 0x000008, "Member 'Item_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.Item.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct Item_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_UnbindMsgAll) == 0x000008, "Wrong alignment on Item_UnbindMsgAll");
static_assert(sizeof(Item_UnbindMsgAll) == 0x000008, "Wrong size on Item_UnbindMsgAll");
static_assert(offsetof(Item_UnbindMsgAll, InObject) == 0x000000, "Member 'Item_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.Item.GetDesignDataItem
// 0x0198 (0x0198 - 0x0000)
struct Item_GetDesignDataItem final
{
public:
	struct FDesignDataItem                        ReturnValue;                                       // 0x0000(0x0198)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_GetDesignDataItem) == 0x000008, "Wrong alignment on Item_GetDesignDataItem");
static_assert(sizeof(Item_GetDesignDataItem) == 0x000198, "Wrong size on Item_GetDesignDataItem");
static_assert(offsetof(Item_GetDesignDataItem, ReturnValue) == 0x000000, "Member 'Item_GetDesignDataItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.Item.GetItemActor
// 0x0008 (0x0008 - 0x0000)
struct Item_GetItemActor final
{
public:
	class AItemActor*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_GetItemActor) == 0x000008, "Wrong alignment on Item_GetItemActor");
static_assert(sizeof(Item_GetItemActor) == 0x000008, "Wrong size on Item_GetItemActor");
static_assert(offsetof(Item_GetItemActor, ReturnValue) == 0x000000, "Member 'Item_GetItemActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.Item.GetItemData
// 0x0100 (0x0100 - 0x0000)
struct Item_GetItemData final
{
public:
	struct FItemData                              ReturnValue;                                       // 0x0000(0x0100)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_GetItemData) == 0x000008, "Wrong alignment on Item_GetItemData");
static_assert(sizeof(Item_GetItemData) == 0x000100, "Wrong size on Item_GetItemData");
static_assert(offsetof(Item_GetItemData, ReturnValue) == 0x000000, "Member 'Item_GetItemData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.Item.GetItemDataUtilityTag
// 0x0008 (0x0008 - 0x0000)
struct Item_GetItemDataUtilityTag final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_GetItemDataUtilityTag) == 0x000004, "Wrong alignment on Item_GetItemDataUtilityTag");
static_assert(sizeof(Item_GetItemDataUtilityTag) == 0x000008, "Wrong size on Item_GetItemDataUtilityTag");
static_assert(offsetof(Item_GetItemDataUtilityTag, ReturnValue) == 0x000000, "Member 'Item_GetItemDataUtilityTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.Item.GetItemDataWeaponTypeTags
// 0x0010 (0x0010 - 0x0000)
struct Item_GetItemDataWeaponTypeTags final
{
public:
	TArray<struct FGameplayTag>                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_GetItemDataWeaponTypeTags) == 0x000008, "Wrong alignment on Item_GetItemDataWeaponTypeTags");
static_assert(sizeof(Item_GetItemDataWeaponTypeTags) == 0x000010, "Wrong size on Item_GetItemDataWeaponTypeTags");
static_assert(offsetof(Item_GetItemDataWeaponTypeTags, ReturnValue) == 0x000000, "Member 'Item_GetItemDataWeaponTypeTags::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.Item.GetItemHandType
// 0x0008 (0x0008 - 0x0000)
struct Item_GetItemHandType final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_GetItemHandType) == 0x000004, "Wrong alignment on Item_GetItemHandType");
static_assert(sizeof(Item_GetItemHandType) == 0x000008, "Wrong size on Item_GetItemHandType");
static_assert(offsetof(Item_GetItemHandType, ReturnValue) == 0x000000, "Member 'Item_GetItemHandType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.Item.GetItemIconTexture
// 0x0008 (0x0008 - 0x0000)
struct Item_GetItemIconTexture final
{
public:
	class UTexture2D*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_GetItemIconTexture) == 0x000008, "Wrong alignment on Item_GetItemIconTexture");
static_assert(sizeof(Item_GetItemIconTexture) == 0x000008, "Wrong size on Item_GetItemIconTexture");
static_assert(offsetof(Item_GetItemIconTexture, ReturnValue) == 0x000000, "Member 'Item_GetItemIconTexture::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.Item.GetItemSlotType
// 0x0008 (0x0008 - 0x0000)
struct Item_GetItemSlotType final
{
public:
	struct FGameplayTag                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_GetItemSlotType) == 0x000004, "Wrong alignment on Item_GetItemSlotType");
static_assert(sizeof(Item_GetItemSlotType) == 0x000008, "Wrong size on Item_GetItemSlotType");
static_assert(offsetof(Item_GetItemSlotType, ReturnValue) == 0x000000, "Member 'Item_GetItemSlotType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.Item.GetItemWeaponTypes
// 0x0010 (0x0010 - 0x0000)
struct Item_GetItemWeaponTypes final
{
public:
	TArray<struct FGameplayTag>                   ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Item_GetItemWeaponTypes) == 0x000008, "Wrong alignment on Item_GetItemWeaponTypes");
static_assert(sizeof(Item_GetItemWeaponTypes) == 0x000010, "Wrong size on Item_GetItemWeaponTypes");
static_assert(offsetof(Item_GetItemWeaponTypes, ReturnValue) == 0x000000, "Member 'Item_GetItemWeaponTypes::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.Item.IsItemWeaponType
// 0x000C (0x000C - 0x0000)
struct Item_IsItemWeaponType final
{
public:
	struct FGameplayTag                           WeaponType;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2884[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Item_IsItemWeaponType) == 0x000004, "Wrong alignment on Item_IsItemWeaponType");
static_assert(sizeof(Item_IsItemWeaponType) == 0x00000C, "Wrong size on Item_IsItemWeaponType");
static_assert(offsetof(Item_IsItemWeaponType, WeaponType) == 0x000000, "Member 'Item_IsItemWeaponType::WeaponType' has a wrong offset!");
static_assert(offsetof(Item_IsItemWeaponType, ReturnValue) == 0x000008, "Member 'Item_IsItemWeaponType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ItemActor.GameplayTagUpdated
// 0x000C (0x000C - 0x0000)
struct ItemActor_GameplayTagUpdated final
{
public:
	struct FGameplayTag                           InGameplayTag;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemActor_GameplayTagUpdated) == 0x000004, "Wrong alignment on ItemActor_GameplayTagUpdated");
static_assert(sizeof(ItemActor_GameplayTagUpdated) == 0x00000C, "Wrong size on ItemActor_GameplayTagUpdated");
static_assert(offsetof(ItemActor_GameplayTagUpdated, InGameplayTag) == 0x000000, "Member 'ItemActor_GameplayTagUpdated::InGameplayTag' has a wrong offset!");
static_assert(offsetof(ItemActor_GameplayTagUpdated, InCount) == 0x000008, "Member 'ItemActor_GameplayTagUpdated::InCount' has a wrong offset!");

// Function DungeonCrawler.ItemActor.ItemDataUpdated
// 0x0100 (0x0100 - 0x0000)
struct ItemActor_ItemDataUpdated final
{
public:
	struct FItemData                              InItemData;                                        // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemActor_ItemDataUpdated) == 0x000008, "Wrong alignment on ItemActor_ItemDataUpdated");
static_assert(sizeof(ItemActor_ItemDataUpdated) == 0x000100, "Wrong size on ItemActor_ItemDataUpdated");
static_assert(offsetof(ItemActor_ItemDataUpdated, InItemData) == 0x000000, "Member 'ItemActor_ItemDataUpdated::InItemData' has a wrong offset!");

// Function DungeonCrawler.ItemActor.OnHiddenInGameStateChanged
// 0x0001 (0x0001 - 0x0000)
struct ItemActor_OnHiddenInGameStateChanged final
{
public:
	bool                                          bIsHidden;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemActor_OnHiddenInGameStateChanged) == 0x000001, "Wrong alignment on ItemActor_OnHiddenInGameStateChanged");
static_assert(sizeof(ItemActor_OnHiddenInGameStateChanged) == 0x000001, "Wrong size on ItemActor_OnHiddenInGameStateChanged");
static_assert(offsetof(ItemActor_OnHiddenInGameStateChanged, bIsHidden) == 0x000000, "Member 'ItemActor_OnHiddenInGameStateChanged::bIsHidden' has a wrong offset!");

// Function DungeonCrawler.ItemActor.OnRep_AttachType
// 0x0001 (0x0001 - 0x0000)
struct ItemActor_OnRep_AttachType final
{
public:
	EDCItemAttachType                             OldAttachType;                                     // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemActor_OnRep_AttachType) == 0x000001, "Wrong alignment on ItemActor_OnRep_AttachType");
static_assert(sizeof(ItemActor_OnRep_AttachType) == 0x000001, "Wrong size on ItemActor_OnRep_AttachType");
static_assert(offsetof(ItemActor_OnRep_AttachType, OldAttachType) == 0x000000, "Member 'ItemActor_OnRep_AttachType::OldAttachType' has a wrong offset!");

// Function DungeonCrawler.ItemActor.OnRep_ForceHide
// 0x0001 (0x0001 - 0x0000)
struct ItemActor_OnRep_ForceHide final
{
public:
	bool                                          bOldForceHide;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemActor_OnRep_ForceHide) == 0x000001, "Wrong alignment on ItemActor_OnRep_ForceHide");
static_assert(sizeof(ItemActor_OnRep_ForceHide) == 0x000001, "Wrong size on ItemActor_OnRep_ForceHide");
static_assert(offsetof(ItemActor_OnRep_ForceHide, bOldForceHide) == 0x000000, "Member 'ItemActor_OnRep_ForceHide::bOldForceHide' has a wrong offset!");

// Function DungeonCrawler.ItemActor.PreReduceAmmoCount
// 0x0004 (0x0004 - 0x0000)
struct ItemActor_PreReduceAmmoCount final
{
public:
	int32                                         ReduceCount;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemActor_PreReduceAmmoCount) == 0x000004, "Wrong alignment on ItemActor_PreReduceAmmoCount");
static_assert(sizeof(ItemActor_PreReduceAmmoCount) == 0x000004, "Wrong size on ItemActor_PreReduceAmmoCount");
static_assert(offsetof(ItemActor_PreReduceAmmoCount, ReduceCount) == 0x000000, "Member 'ItemActor_PreReduceAmmoCount::ReduceCount' has a wrong offset!");

// Function DungeonCrawler.ItemActor.SetAttachType
// 0x0002 (0x0002 - 0x0000)
struct ItemActor_SetAttachType final
{
public:
	EDCItemAttachType                             InAttachType;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemActor_SetAttachType) == 0x000001, "Wrong alignment on ItemActor_SetAttachType");
static_assert(sizeof(ItemActor_SetAttachType) == 0x000002, "Wrong size on ItemActor_SetAttachType");
static_assert(offsetof(ItemActor_SetAttachType, InAttachType) == 0x000000, "Member 'ItemActor_SetAttachType::InAttachType' has a wrong offset!");
static_assert(offsetof(ItemActor_SetAttachType, ReturnValue) == 0x000001, "Member 'ItemActor_SetAttachType::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ItemActor.GetItemData
// 0x0100 (0x0100 - 0x0000)
struct ItemActor_GetItemData final
{
public:
	struct FItemData                              ReturnValue;                                       // 0x0000(0x0100)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemActor_GetItemData) == 0x000008, "Wrong alignment on ItemActor_GetItemData");
static_assert(sizeof(ItemActor_GetItemData) == 0x000100, "Wrong size on ItemActor_GetItemData");
static_assert(offsetof(ItemActor_GetItemData, ReturnValue) == 0x000000, "Member 'ItemActor_GetItemData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ItemComponentBase.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct ItemComponentBase_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemComponentBase_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on ItemComponentBase_BroadcastMsgBlueprint");
static_assert(sizeof(ItemComponentBase_BroadcastMsgBlueprint) == 0x000004, "Wrong size on ItemComponentBase_BroadcastMsgBlueprint");
static_assert(offsetof(ItemComponentBase_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'ItemComponentBase_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ItemComponentBase.ClientWearItem
// 0x0110 (0x0110 - 0x0000)
struct ItemComponentBase_ClientWearItem final
{
public:
	class AActor*                                 NewOwner;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              WearingItemData;                                   // 0x0008(0x0100)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bReserveQuickSlotType;                             // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipmentQuickSlotType                       QuickSlotType;                                     // 0x0109(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288B[0x6];                                     // 0x010A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ItemComponentBase_ClientWearItem) == 0x000008, "Wrong alignment on ItemComponentBase_ClientWearItem");
static_assert(sizeof(ItemComponentBase_ClientWearItem) == 0x000110, "Wrong size on ItemComponentBase_ClientWearItem");
static_assert(offsetof(ItemComponentBase_ClientWearItem, NewOwner) == 0x000000, "Member 'ItemComponentBase_ClientWearItem::NewOwner' has a wrong offset!");
static_assert(offsetof(ItemComponentBase_ClientWearItem, WearingItemData) == 0x000008, "Member 'ItemComponentBase_ClientWearItem::WearingItemData' has a wrong offset!");
static_assert(offsetof(ItemComponentBase_ClientWearItem, bReserveQuickSlotType) == 0x000108, "Member 'ItemComponentBase_ClientWearItem::bReserveQuickSlotType' has a wrong offset!");
static_assert(offsetof(ItemComponentBase_ClientWearItem, QuickSlotType) == 0x000109, "Member 'ItemComponentBase_ClientWearItem::QuickSlotType' has a wrong offset!");

// Function DungeonCrawler.ItemComponentBase.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct ItemComponentBase_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemComponentBase_UnbindMsg) == 0x000008, "Wrong alignment on ItemComponentBase_UnbindMsg");
static_assert(sizeof(ItemComponentBase_UnbindMsg) == 0x000010, "Wrong size on ItemComponentBase_UnbindMsg");
static_assert(offsetof(ItemComponentBase_UnbindMsg, InMsgType) == 0x000000, "Member 'ItemComponentBase_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(ItemComponentBase_UnbindMsg, InObject) == 0x000008, "Member 'ItemComponentBase_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.ItemComponentBase.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct ItemComponentBase_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemComponentBase_UnbindMsgAll) == 0x000008, "Wrong alignment on ItemComponentBase_UnbindMsgAll");
static_assert(sizeof(ItemComponentBase_UnbindMsgAll) == 0x000008, "Wrong size on ItemComponentBase_UnbindMsgAll");
static_assert(offsetof(ItemComponentBase_UnbindMsgAll, InObject) == 0x000000, "Member 'ItemComponentBase_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.ItemCountSelectWidget.OnSliderValueChanged
// 0x0004 (0x0004 - 0x0000)
struct ItemCountSelectWidget_OnSliderValueChanged final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemCountSelectWidget_OnSliderValueChanged) == 0x000004, "Wrong alignment on ItemCountSelectWidget_OnSliderValueChanged");
static_assert(sizeof(ItemCountSelectWidget_OnSliderValueChanged) == 0x000004, "Wrong size on ItemCountSelectWidget_OnSliderValueChanged");
static_assert(offsetof(ItemCountSelectWidget_OnSliderValueChanged, Value) == 0x000000, "Member 'ItemCountSelectWidget_OnSliderValueChanged::Value' has a wrong offset!");

// Function DungeonCrawler.ItemCountSelectWidget.OnTextBlockCommitted
// 0x0020 (0x0020 - 0x0000)
struct ItemCountSelectWidget_OnTextBlockCommitted final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ETextCommit                                   CommitMethod;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288C[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ItemCountSelectWidget_OnTextBlockCommitted) == 0x000008, "Wrong alignment on ItemCountSelectWidget_OnTextBlockCommitted");
static_assert(sizeof(ItemCountSelectWidget_OnTextBlockCommitted) == 0x000020, "Wrong size on ItemCountSelectWidget_OnTextBlockCommitted");
static_assert(offsetof(ItemCountSelectWidget_OnTextBlockCommitted, Text) == 0x000000, "Member 'ItemCountSelectWidget_OnTextBlockCommitted::Text' has a wrong offset!");
static_assert(offsetof(ItemCountSelectWidget_OnTextBlockCommitted, CommitMethod) == 0x000018, "Member 'ItemCountSelectWidget_OnTextBlockCommitted::CommitMethod' has a wrong offset!");

// Function DungeonCrawler.ItemCountSelectWidget.OnTextBlockValueChanged
// 0x0018 (0x0018 - 0x0000)
struct ItemCountSelectWidget_OnTextBlockValueChanged final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemCountSelectWidget_OnTextBlockValueChanged) == 0x000008, "Wrong alignment on ItemCountSelectWidget_OnTextBlockValueChanged");
static_assert(sizeof(ItemCountSelectWidget_OnTextBlockValueChanged) == 0x000018, "Wrong size on ItemCountSelectWidget_OnTextBlockValueChanged");
static_assert(offsetof(ItemCountSelectWidget_OnTextBlockValueChanged, Text) == 0x000000, "Member 'ItemCountSelectWidget_OnTextBlockValueChanged::Text' has a wrong offset!");

// Function DungeonCrawler.DCItemDataComponent.OnLoadData_Art
// 0x0008 (0x0008 - 0x0000)
struct DCItemDataComponent_OnLoadData_Art final
{
public:
	class UObject*                                InLoadedObject;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemDataComponent_OnLoadData_Art) == 0x000008, "Wrong alignment on DCItemDataComponent_OnLoadData_Art");
static_assert(sizeof(DCItemDataComponent_OnLoadData_Art) == 0x000008, "Wrong size on DCItemDataComponent_OnLoadData_Art");
static_assert(offsetof(DCItemDataComponent_OnLoadData_Art, InLoadedObject) == 0x000000, "Member 'DCItemDataComponent_OnLoadData_Art::InLoadedObject' has a wrong offset!");

// Function DungeonCrawler.DCItemDataComponent.OnLoadData_Bundle
// 0x0008 (0x0008 - 0x0000)
struct DCItemDataComponent_OnLoadData_Bundle final
{
public:
	class UObject*                                InLoadedObject;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemDataComponent_OnLoadData_Bundle) == 0x000008, "Wrong alignment on DCItemDataComponent_OnLoadData_Bundle");
static_assert(sizeof(DCItemDataComponent_OnLoadData_Bundle) == 0x000008, "Wrong size on DCItemDataComponent_OnLoadData_Bundle");
static_assert(offsetof(DCItemDataComponent_OnLoadData_Bundle, InLoadedObject) == 0x000000, "Member 'DCItemDataComponent_OnLoadData_Bundle::InLoadedObject' has a wrong offset!");

// Function DungeonCrawler.DCItemDataComponent.OnLoadData_Sound
// 0x0008 (0x0008 - 0x0000)
struct DCItemDataComponent_OnLoadData_Sound final
{
public:
	class UObject*                                InLoadedObject;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCItemDataComponent_OnLoadData_Sound) == 0x000008, "Wrong alignment on DCItemDataComponent_OnLoadData_Sound");
static_assert(sizeof(DCItemDataComponent_OnLoadData_Sound) == 0x000008, "Wrong size on DCItemDataComponent_OnLoadData_Sound");
static_assert(offsetof(DCItemDataComponent_OnLoadData_Sound, InLoadedObject) == 0x000000, "Member 'DCItemDataComponent_OnLoadData_Sound::InLoadedObject' has a wrong offset!");

// Function DungeonCrawler.ItemGenerateInterface.GenerateItems
// 0x0004 (0x0004 - 0x0000)
struct ItemGenerateInterface_GenerateItems final
{
public:
	float                                         InLuck;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemGenerateInterface_GenerateItems) == 0x000004, "Wrong alignment on ItemGenerateInterface_GenerateItems");
static_assert(sizeof(ItemGenerateInterface_GenerateItems) == 0x000004, "Wrong size on ItemGenerateInterface_GenerateItems");
static_assert(offsetof(ItemGenerateInterface_GenerateItems, InLuck) == 0x000000, "Member 'ItemGenerateInterface_GenerateItems::InLuck' has a wrong offset!");

// Function DungeonCrawler.ItemMoveValidatorComponent.ClientMoveItemEnd
// 0x0018 (0x0018 - 0x0000)
struct ItemMoveValidatorComponent_ClientMoveItemEnd final
{
public:
	bool                                          bMoveSucceed;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2890[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      MovedItemDataArray;                                // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemMoveValidatorComponent_ClientMoveItemEnd) == 0x000008, "Wrong alignment on ItemMoveValidatorComponent_ClientMoveItemEnd");
static_assert(sizeof(ItemMoveValidatorComponent_ClientMoveItemEnd) == 0x000018, "Wrong size on ItemMoveValidatorComponent_ClientMoveItemEnd");
static_assert(offsetof(ItemMoveValidatorComponent_ClientMoveItemEnd, bMoveSucceed) == 0x000000, "Member 'ItemMoveValidatorComponent_ClientMoveItemEnd::bMoveSucceed' has a wrong offset!");
static_assert(offsetof(ItemMoveValidatorComponent_ClientMoveItemEnd, MovedItemDataArray) == 0x000008, "Member 'ItemMoveValidatorComponent_ClientMoveItemEnd::MovedItemDataArray' has a wrong offset!");

// Function DungeonCrawler.ItemMoveValidatorComponent.ClientShowMessage
// 0x0018 (0x0018 - 0x0000)
struct ItemMoveValidatorComponent_ClientShowMessage final
{
public:
	class FText                                   OutputMessage;                                     // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemMoveValidatorComponent_ClientShowMessage) == 0x000008, "Wrong alignment on ItemMoveValidatorComponent_ClientShowMessage");
static_assert(sizeof(ItemMoveValidatorComponent_ClientShowMessage) == 0x000018, "Wrong size on ItemMoveValidatorComponent_ClientShowMessage");
static_assert(offsetof(ItemMoveValidatorComponent_ClientShowMessage, OutputMessage) == 0x000000, "Member 'ItemMoveValidatorComponent_ClientShowMessage::OutputMessage' has a wrong offset!");

// Function DungeonCrawler.ItemMoveValidatorComponent.IsEnableMoveItem
// 0x0128 (0x0128 - 0x0000)
struct ItemMoveValidatorComponent_IsEnableMoveItem final
{
public:
	struct FItemData                              OldItemData;                                       // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FItemData>                      NewItemDataArray;                                  // 0x0100(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 OldOwner;                                          // 0x0110(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NewOwner;                                          // 0x0118(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0120(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2891[0x7];                                     // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ItemMoveValidatorComponent_IsEnableMoveItem) == 0x000008, "Wrong alignment on ItemMoveValidatorComponent_IsEnableMoveItem");
static_assert(sizeof(ItemMoveValidatorComponent_IsEnableMoveItem) == 0x000128, "Wrong size on ItemMoveValidatorComponent_IsEnableMoveItem");
static_assert(offsetof(ItemMoveValidatorComponent_IsEnableMoveItem, OldItemData) == 0x000000, "Member 'ItemMoveValidatorComponent_IsEnableMoveItem::OldItemData' has a wrong offset!");
static_assert(offsetof(ItemMoveValidatorComponent_IsEnableMoveItem, NewItemDataArray) == 0x000100, "Member 'ItemMoveValidatorComponent_IsEnableMoveItem::NewItemDataArray' has a wrong offset!");
static_assert(offsetof(ItemMoveValidatorComponent_IsEnableMoveItem, OldOwner) == 0x000110, "Member 'ItemMoveValidatorComponent_IsEnableMoveItem::OldOwner' has a wrong offset!");
static_assert(offsetof(ItemMoveValidatorComponent_IsEnableMoveItem, NewOwner) == 0x000118, "Member 'ItemMoveValidatorComponent_IsEnableMoveItem::NewOwner' has a wrong offset!");
static_assert(offsetof(ItemMoveValidatorComponent_IsEnableMoveItem, ReturnValue) == 0x000120, "Member 'ItemMoveValidatorComponent_IsEnableMoveItem::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ItemMoveValidatorComponent.ServerMoveItem
// 0x0128 (0x0128 - 0x0000)
struct ItemMoveValidatorComponent_ServerMoveItem final
{
public:
	struct FItemData                              OldItemData;                                       // 0x0000(0x0100)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FItemData>                      NewItemDataArray;                                  // 0x0100(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 OldOwner;                                          // 0x0110(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NewOwner;                                          // 0x0118(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDelay;                                         // 0x0120(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2892[0x7];                                     // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ItemMoveValidatorComponent_ServerMoveItem) == 0x000008, "Wrong alignment on ItemMoveValidatorComponent_ServerMoveItem");
static_assert(sizeof(ItemMoveValidatorComponent_ServerMoveItem) == 0x000128, "Wrong size on ItemMoveValidatorComponent_ServerMoveItem");
static_assert(offsetof(ItemMoveValidatorComponent_ServerMoveItem, OldItemData) == 0x000000, "Member 'ItemMoveValidatorComponent_ServerMoveItem::OldItemData' has a wrong offset!");
static_assert(offsetof(ItemMoveValidatorComponent_ServerMoveItem, NewItemDataArray) == 0x000100, "Member 'ItemMoveValidatorComponent_ServerMoveItem::NewItemDataArray' has a wrong offset!");
static_assert(offsetof(ItemMoveValidatorComponent_ServerMoveItem, OldOwner) == 0x000110, "Member 'ItemMoveValidatorComponent_ServerMoveItem::OldOwner' has a wrong offset!");
static_assert(offsetof(ItemMoveValidatorComponent_ServerMoveItem, NewOwner) == 0x000118, "Member 'ItemMoveValidatorComponent_ServerMoveItem::NewOwner' has a wrong offset!");
static_assert(offsetof(ItemMoveValidatorComponent_ServerMoveItem, bHasDelay) == 0x000120, "Member 'ItemMoveValidatorComponent_ServerMoveItem::bHasDelay' has a wrong offset!");

// Function DungeonCrawler.ItemRandomGenerateComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct ItemRandomGenerateComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemRandomGenerateComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on ItemRandomGenerateComponent_BroadcastMsgBlueprint");
static_assert(sizeof(ItemRandomGenerateComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on ItemRandomGenerateComponent_BroadcastMsgBlueprint");
static_assert(offsetof(ItemRandomGenerateComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'ItemRandomGenerateComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ItemRandomGenerateComponent.DropAllItems
// 0x0004 (0x0004 - 0x0000)
struct ItemRandomGenerateComponent_DropAllItems final
{
public:
	float                                         InLuck;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemRandomGenerateComponent_DropAllItems) == 0x000004, "Wrong alignment on ItemRandomGenerateComponent_DropAllItems");
static_assert(sizeof(ItemRandomGenerateComponent_DropAllItems) == 0x000004, "Wrong size on ItemRandomGenerateComponent_DropAllItems");
static_assert(offsetof(ItemRandomGenerateComponent_DropAllItems, InLuck) == 0x000000, "Member 'ItemRandomGenerateComponent_DropAllItems::InLuck' has a wrong offset!");

// Function DungeonCrawler.ItemRandomGenerateComponent.DropItem
// 0x0010 (0x0010 - 0x0000)
struct ItemRandomGenerateComponent_DropItem final
{
public:
	int64                                         ItemUniqueId;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Owner;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemRandomGenerateComponent_DropItem) == 0x000008, "Wrong alignment on ItemRandomGenerateComponent_DropItem");
static_assert(sizeof(ItemRandomGenerateComponent_DropItem) == 0x000010, "Wrong size on ItemRandomGenerateComponent_DropItem");
static_assert(offsetof(ItemRandomGenerateComponent_DropItem, ItemUniqueId) == 0x000000, "Member 'ItemRandomGenerateComponent_DropItem::ItemUniqueId' has a wrong offset!");
static_assert(offsetof(ItemRandomGenerateComponent_DropItem, Owner) == 0x000008, "Member 'ItemRandomGenerateComponent_DropItem::Owner' has a wrong offset!");

// Function DungeonCrawler.ItemRandomGenerateComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct ItemRandomGenerateComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemRandomGenerateComponent_UnbindMsg) == 0x000008, "Wrong alignment on ItemRandomGenerateComponent_UnbindMsg");
static_assert(sizeof(ItemRandomGenerateComponent_UnbindMsg) == 0x000010, "Wrong size on ItemRandomGenerateComponent_UnbindMsg");
static_assert(offsetof(ItemRandomGenerateComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'ItemRandomGenerateComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(ItemRandomGenerateComponent_UnbindMsg, InObject) == 0x000008, "Member 'ItemRandomGenerateComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.ItemRandomGenerateComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct ItemRandomGenerateComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemRandomGenerateComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on ItemRandomGenerateComponent_UnbindMsgAll");
static_assert(sizeof(ItemRandomGenerateComponent_UnbindMsgAll) == 0x000008, "Wrong size on ItemRandomGenerateComponent_UnbindMsgAll");
static_assert(offsetof(ItemRandomGenerateComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'ItemRandomGenerateComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.ItemRichTextBlockDecorator.GetItemTextBlockStyle
// 0x0350 (0x0350 - 0x0000)
struct ItemRichTextBlockDecorator_GetItemTextBlockStyle final
{
public:
	struct FGameplayTag                           InRarityType;                                      // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2897[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTextBlockStyle                        ReturnValue;                                       // 0x0010(0x0340)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemRichTextBlockDecorator_GetItemTextBlockStyle) == 0x000010, "Wrong alignment on ItemRichTextBlockDecorator_GetItemTextBlockStyle");
static_assert(sizeof(ItemRichTextBlockDecorator_GetItemTextBlockStyle) == 0x000350, "Wrong size on ItemRichTextBlockDecorator_GetItemTextBlockStyle");
static_assert(offsetof(ItemRichTextBlockDecorator_GetItemTextBlockStyle, InRarityType) == 0x000000, "Member 'ItemRichTextBlockDecorator_GetItemTextBlockStyle::InRarityType' has a wrong offset!");
static_assert(offsetof(ItemRichTextBlockDecorator_GetItemTextBlockStyle, ReturnValue) == 0x000010, "Member 'ItemRichTextBlockDecorator_GetItemTextBlockStyle::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ItemTooltipRequirementWidget.OnChangedRequirementStatus
// 0x0001 (0x0001 - 0x0000)
struct ItemTooltipRequirementWidget_OnChangedRequirementStatus final
{
public:
	bool                                          bFulfilled;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemTooltipRequirementWidget_OnChangedRequirementStatus) == 0x000001, "Wrong alignment on ItemTooltipRequirementWidget_OnChangedRequirementStatus");
static_assert(sizeof(ItemTooltipRequirementWidget_OnChangedRequirementStatus) == 0x000001, "Wrong size on ItemTooltipRequirementWidget_OnChangedRequirementStatus");
static_assert(offsetof(ItemTooltipRequirementWidget_OnChangedRequirementStatus, bFulfilled) == 0x000000, "Member 'ItemTooltipRequirementWidget_OnChangedRequirementStatus::bFulfilled' has a wrong offset!");

// Function DungeonCrawler.ItemWeaponAnimInstanceBase.GameplayTagUpdated
// 0x000C (0x000C - 0x0000)
struct ItemWeaponAnimInstanceBase_GameplayTagUpdated final
{
public:
	struct FGameplayTag                           InGameplayTag;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemWeaponAnimInstanceBase_GameplayTagUpdated) == 0x000004, "Wrong alignment on ItemWeaponAnimInstanceBase_GameplayTagUpdated");
static_assert(sizeof(ItemWeaponAnimInstanceBase_GameplayTagUpdated) == 0x00000C, "Wrong size on ItemWeaponAnimInstanceBase_GameplayTagUpdated");
static_assert(offsetof(ItemWeaponAnimInstanceBase_GameplayTagUpdated, InGameplayTag) == 0x000000, "Member 'ItemWeaponAnimInstanceBase_GameplayTagUpdated::InGameplayTag' has a wrong offset!");
static_assert(offsetof(ItemWeaponAnimInstanceBase_GameplayTagUpdated, InCount) == 0x000008, "Member 'ItemWeaponAnimInstanceBase_GameplayTagUpdated::InCount' has a wrong offset!");

// Function DungeonCrawler.ItemWeaponAnimInstanceBase.OnItemDataUpdated
// 0x0100 (0x0100 - 0x0000)
struct ItemWeaponAnimInstanceBase_OnItemDataUpdated final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ItemWeaponAnimInstanceBase_OnItemDataUpdated) == 0x000008, "Wrong alignment on ItemWeaponAnimInstanceBase_OnItemDataUpdated");
static_assert(sizeof(ItemWeaponAnimInstanceBase_OnItemDataUpdated) == 0x000100, "Wrong size on ItemWeaponAnimInstanceBase_OnItemDataUpdated");
static_assert(offsetof(ItemWeaponAnimInstanceBase_OnItemDataUpdated, ItemData) == 0x000000, "Member 'ItemWeaponAnimInstanceBase_OnItemDataUpdated::ItemData' has a wrong offset!");

// Function DungeonCrawler.KarmaMemberSlotWidgetBase.OnFMsgWidgetStreamingModeNotifyBlueprint
// 0x0020 (0x0020 - 0x0000)
struct KarmaMemberSlotWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint final
{
public:
	struct FMsgWidgetStreamingModeNotify          InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KarmaMemberSlotWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000008, "Wrong alignment on KarmaMemberSlotWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(sizeof(KarmaMemberSlotWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000020, "Wrong size on KarmaMemberSlotWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(offsetof(KarmaMemberSlotWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint, InMsg) == 0x000000, "Member 'KarmaMemberSlotWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.LeaderboardDetailPopup.OnDungeonComboBoxSelected
// 0x0008 (0x0008 - 0x0000)
struct LeaderboardDetailPopup_OnDungeonComboBoxSelected final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardDetailPopup_OnDungeonComboBoxSelected) == 0x000008, "Wrong alignment on LeaderboardDetailPopup_OnDungeonComboBoxSelected");
static_assert(sizeof(LeaderboardDetailPopup_OnDungeonComboBoxSelected) == 0x000008, "Wrong size on LeaderboardDetailPopup_OnDungeonComboBoxSelected");
static_assert(offsetof(LeaderboardDetailPopup_OnDungeonComboBoxSelected, InItem) == 0x000000, "Member 'LeaderboardDetailPopup_OnDungeonComboBoxSelected::InItem' has a wrong offset!");

// Function DungeonCrawler.LeaderboardDetailPopup.OnLeaderboardDetailPopupData
// 0x0008 (0x0008 - 0x0000)
struct LeaderboardDetailPopup_OnLeaderboardDetailPopupData final
{
public:
	const class ULeaderboardDetailPopupData*      LeaderboardDetailPopupData;                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardDetailPopup_OnLeaderboardDetailPopupData) == 0x000008, "Wrong alignment on LeaderboardDetailPopup_OnLeaderboardDetailPopupData");
static_assert(sizeof(LeaderboardDetailPopup_OnLeaderboardDetailPopupData) == 0x000008, "Wrong size on LeaderboardDetailPopup_OnLeaderboardDetailPopupData");
static_assert(offsetof(LeaderboardDetailPopup_OnLeaderboardDetailPopupData, LeaderboardDetailPopupData) == 0x000000, "Member 'LeaderboardDetailPopup_OnLeaderboardDetailPopupData::LeaderboardDetailPopupData' has a wrong offset!");

// Function DungeonCrawler.LeaderboardRankGuideItemWidget.GetRequireData
// 0x0008 (0x0008 - 0x0000)
struct LeaderboardRankGuideItemWidget_GetRequireData final
{
public:
	class UObject*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardRankGuideItemWidget_GetRequireData) == 0x000008, "Wrong alignment on LeaderboardRankGuideItemWidget_GetRequireData");
static_assert(sizeof(LeaderboardRankGuideItemWidget_GetRequireData) == 0x000008, "Wrong size on LeaderboardRankGuideItemWidget_GetRequireData");
static_assert(offsetof(LeaderboardRankGuideItemWidget_GetRequireData, ReturnValue) == 0x000000, "Member 'LeaderboardRankGuideItemWidget_GetRequireData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardRankGuideItemWidget.OnLeaderboardRankGuideItemWidgetData
// 0x0010 (0x0010 - 0x0000)
struct LeaderboardRankGuideItemWidget_OnLeaderboardRankGuideItemWidgetData final
{
public:
	const class ULeaderboardRankGuideItemWidgetData* NewValue;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class ULeaderboardRankGuideItemWidgetData* OldValue;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardRankGuideItemWidget_OnLeaderboardRankGuideItemWidgetData) == 0x000008, "Wrong alignment on LeaderboardRankGuideItemWidget_OnLeaderboardRankGuideItemWidgetData");
static_assert(sizeof(LeaderboardRankGuideItemWidget_OnLeaderboardRankGuideItemWidgetData) == 0x000010, "Wrong size on LeaderboardRankGuideItemWidget_OnLeaderboardRankGuideItemWidgetData");
static_assert(offsetof(LeaderboardRankGuideItemWidget_OnLeaderboardRankGuideItemWidgetData, NewValue) == 0x000000, "Member 'LeaderboardRankGuideItemWidget_OnLeaderboardRankGuideItemWidgetData::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardRankGuideItemWidget_OnLeaderboardRankGuideItemWidgetData, OldValue) == 0x000008, "Member 'LeaderboardRankGuideItemWidget_OnLeaderboardRankGuideItemWidgetData::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardRankGuideItemWidget.OnLeaderboardRankRewardState
// 0x0002 (0x0002 - 0x0000)
struct LeaderboardRankGuideItemWidget_OnLeaderboardRankRewardState final
{
public:
	ELeaderboardRankRewardState                   NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELeaderboardRankRewardState                   OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardRankGuideItemWidget_OnLeaderboardRankRewardState) == 0x000001, "Wrong alignment on LeaderboardRankGuideItemWidget_OnLeaderboardRankRewardState");
static_assert(sizeof(LeaderboardRankGuideItemWidget_OnLeaderboardRankRewardState) == 0x000002, "Wrong size on LeaderboardRankGuideItemWidget_OnLeaderboardRankRewardState");
static_assert(offsetof(LeaderboardRankGuideItemWidget_OnLeaderboardRankRewardState, NewValue) == 0x000000, "Member 'LeaderboardRankGuideItemWidget_OnLeaderboardRankRewardState::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardRankGuideItemWidget_OnLeaderboardRankRewardState, OldValue) == 0x000001, "Member 'LeaderboardRankGuideItemWidget_OnLeaderboardRankRewardState::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardRankGuideItemWidget.OnLeaderboardState
// 0x0002 (0x0002 - 0x0000)
struct LeaderboardRankGuideItemWidget_OnLeaderboardState final
{
public:
	ELeaderboardState                             NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELeaderboardState                             OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardRankGuideItemWidget_OnLeaderboardState) == 0x000001, "Wrong alignment on LeaderboardRankGuideItemWidget_OnLeaderboardState");
static_assert(sizeof(LeaderboardRankGuideItemWidget_OnLeaderboardState) == 0x000002, "Wrong size on LeaderboardRankGuideItemWidget_OnLeaderboardState");
static_assert(offsetof(LeaderboardRankGuideItemWidget_OnLeaderboardState, NewValue) == 0x000000, "Member 'LeaderboardRankGuideItemWidget_OnLeaderboardState::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardRankGuideItemWidget_OnLeaderboardState, OldValue) == 0x000001, "Member 'LeaderboardRankGuideItemWidget_OnLeaderboardState::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardRankGuideItemWidget.SetRequiredItemData
// 0x0008 (0x0008 - 0x0000)
struct LeaderboardRankGuideItemWidget_SetRequiredItemData final
{
public:
	class UObject*                                ListItemObject;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardRankGuideItemWidget_SetRequiredItemData) == 0x000008, "Wrong alignment on LeaderboardRankGuideItemWidget_SetRequiredItemData");
static_assert(sizeof(LeaderboardRankGuideItemWidget_SetRequiredItemData) == 0x000008, "Wrong size on LeaderboardRankGuideItemWidget_SetRequiredItemData");
static_assert(offsetof(LeaderboardRankGuideItemWidget_SetRequiredItemData, ListItemObject) == 0x000000, "Member 'LeaderboardRankGuideItemWidget_SetRequiredItemData::ListItemObject' has a wrong offset!");

// Function DungeonCrawler.LeaderboardRankRecordWidget.OnFMsgWidgetStreamingModeNotifyBlueprint
// 0x0020 (0x0020 - 0x0000)
struct LeaderboardRankRecordWidget_OnFMsgWidgetStreamingModeNotifyBlueprint final
{
public:
	struct FMsgWidgetStreamingModeNotify          InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardRankRecordWidget_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000008, "Wrong alignment on LeaderboardRankRecordWidget_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(sizeof(LeaderboardRankRecordWidget_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000020, "Wrong size on LeaderboardRankRecordWidget_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(offsetof(LeaderboardRankRecordWidget_OnFMsgWidgetStreamingModeNotifyBlueprint, InMsg) == 0x000000, "Member 'LeaderboardRankRecordWidget_OnFMsgWidgetStreamingModeNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.LeaderboardRankRecordWidget.OnLeaderboardRankRecordData
// 0x00F0 (0x00F0 - 0x0000)
struct LeaderboardRankRecordWidget_OnLeaderboardRankRecordData final
{
public:
	struct FLeaderboardRankRecordData             NewValue;                                          // 0x0000(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FLeaderboardRankRecordData             OldValue;                                          // 0x0078(0x0078)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardRankRecordWidget_OnLeaderboardRankRecordData) == 0x000008, "Wrong alignment on LeaderboardRankRecordWidget_OnLeaderboardRankRecordData");
static_assert(sizeof(LeaderboardRankRecordWidget_OnLeaderboardRankRecordData) == 0x0000F0, "Wrong size on LeaderboardRankRecordWidget_OnLeaderboardRankRecordData");
static_assert(offsetof(LeaderboardRankRecordWidget_OnLeaderboardRankRecordData, NewValue) == 0x000000, "Member 'LeaderboardRankRecordWidget_OnLeaderboardRankRecordData::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardRankRecordWidget_OnLeaderboardRankRecordData, OldValue) == 0x000078, "Member 'LeaderboardRankRecordWidget_OnLeaderboardRankRecordData::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardSheetWidget.OnClassComboBoxSelected
// 0x0008 (0x0008 - 0x0000)
struct LeaderboardSheetWidget_OnClassComboBoxSelected final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardSheetWidget_OnClassComboBoxSelected) == 0x000008, "Wrong alignment on LeaderboardSheetWidget_OnClassComboBoxSelected");
static_assert(sizeof(LeaderboardSheetWidget_OnClassComboBoxSelected) == 0x000008, "Wrong size on LeaderboardSheetWidget_OnClassComboBoxSelected");
static_assert(offsetof(LeaderboardSheetWidget_OnClassComboBoxSelected, InItem) == 0x000000, "Member 'LeaderboardSheetWidget_OnClassComboBoxSelected::InItem' has a wrong offset!");

// Function DungeonCrawler.LeaderboardSheetWidget.OnLeaderboardData
// 0x0010 (0x0010 - 0x0000)
struct LeaderboardSheetWidget_OnLeaderboardData final
{
public:
	const class UDCLeaderboardDataAsset*          NewValue;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDCLeaderboardDataAsset*          OldValue;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardSheetWidget_OnLeaderboardData) == 0x000008, "Wrong alignment on LeaderboardSheetWidget_OnLeaderboardData");
static_assert(sizeof(LeaderboardSheetWidget_OnLeaderboardData) == 0x000010, "Wrong size on LeaderboardSheetWidget_OnLeaderboardData");
static_assert(offsetof(LeaderboardSheetWidget_OnLeaderboardData, NewValue) == 0x000000, "Member 'LeaderboardSheetWidget_OnLeaderboardData::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardSheetWidget_OnLeaderboardData, OldValue) == 0x000008, "Member 'LeaderboardSheetWidget_OnLeaderboardData::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardSheetWidget.OnLeaderboardSeasonInfo
// 0x00D0 (0x00D0 - 0x0000)
struct LeaderboardSheetWidget_OnLeaderboardSeasonInfo final
{
public:
	struct FLeaderboardSeasonInfo                 NewValue;                                          // 0x0000(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FLeaderboardSeasonInfo                 OldValue;                                          // 0x0068(0x0068)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardSheetWidget_OnLeaderboardSeasonInfo) == 0x000008, "Wrong alignment on LeaderboardSheetWidget_OnLeaderboardSeasonInfo");
static_assert(sizeof(LeaderboardSheetWidget_OnLeaderboardSeasonInfo) == 0x0000D0, "Wrong size on LeaderboardSheetWidget_OnLeaderboardSeasonInfo");
static_assert(offsetof(LeaderboardSheetWidget_OnLeaderboardSeasonInfo, NewValue) == 0x000000, "Member 'LeaderboardSheetWidget_OnLeaderboardSeasonInfo::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardSheetWidget_OnLeaderboardSeasonInfo, OldValue) == 0x000068, "Member 'LeaderboardSheetWidget_OnLeaderboardSeasonInfo::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardSheetWidget.OnLeaderboardSheetData
// 0x0010 (0x0010 - 0x0000)
struct LeaderboardSheetWidget_OnLeaderboardSheetData final
{
public:
	const class UDCLeaderboardSheetDataAsset*     NewValue;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDCLeaderboardSheetDataAsset*     OldValue;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardSheetWidget_OnLeaderboardSheetData) == 0x000008, "Wrong alignment on LeaderboardSheetWidget_OnLeaderboardSheetData");
static_assert(sizeof(LeaderboardSheetWidget_OnLeaderboardSheetData) == 0x000010, "Wrong size on LeaderboardSheetWidget_OnLeaderboardSheetData");
static_assert(offsetof(LeaderboardSheetWidget_OnLeaderboardSheetData, NewValue) == 0x000000, "Member 'LeaderboardSheetWidget_OnLeaderboardSheetData::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardSheetWidget_OnLeaderboardSheetData, OldValue) == 0x000008, "Member 'LeaderboardSheetWidget_OnLeaderboardSheetData::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardSheetWidget.OnPlayerCharacterData
// 0x0010 (0x0010 - 0x0000)
struct LeaderboardSheetWidget_OnPlayerCharacterData final
{
public:
	const class UDCPlayerCharacterDataAsset*      NewValue;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UDCPlayerCharacterDataAsset*      OldValue;                                          // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardSheetWidget_OnPlayerCharacterData) == 0x000008, "Wrong alignment on LeaderboardSheetWidget_OnPlayerCharacterData");
static_assert(sizeof(LeaderboardSheetWidget_OnPlayerCharacterData) == 0x000010, "Wrong size on LeaderboardSheetWidget_OnPlayerCharacterData");
static_assert(offsetof(LeaderboardSheetWidget_OnPlayerCharacterData, NewValue) == 0x000000, "Member 'LeaderboardSheetWidget_OnPlayerCharacterData::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardSheetWidget_OnPlayerCharacterData, OldValue) == 0x000008, "Member 'LeaderboardSheetWidget_OnPlayerCharacterData::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardSheetWidget.OnRankInfo
// 0x0020 (0x0020 - 0x0000)
struct LeaderboardSheetWidget_OnRankInfo final
{
public:
	struct FRankInfo                              NewValue;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FRankInfo                              OldValue;                                          // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardSheetWidget_OnRankInfo) == 0x000008, "Wrong alignment on LeaderboardSheetWidget_OnRankInfo");
static_assert(sizeof(LeaderboardSheetWidget_OnRankInfo) == 0x000020, "Wrong size on LeaderboardSheetWidget_OnRankInfo");
static_assert(offsetof(LeaderboardSheetWidget_OnRankInfo, NewValue) == 0x000000, "Member 'LeaderboardSheetWidget_OnRankInfo::NewValue' has a wrong offset!");
static_assert(offsetof(LeaderboardSheetWidget_OnRankInfo, OldValue) == 0x000010, "Member 'LeaderboardSheetWidget_OnRankInfo::OldValue' has a wrong offset!");

// Function DungeonCrawler.LeaderboardWidget.OnSeasonComboBoxSelected
// 0x0008 (0x0008 - 0x0000)
struct LeaderboardWidget_OnSeasonComboBoxSelected final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardWidget_OnSeasonComboBoxSelected) == 0x000008, "Wrong alignment on LeaderboardWidget_OnSeasonComboBoxSelected");
static_assert(sizeof(LeaderboardWidget_OnSeasonComboBoxSelected) == 0x000008, "Wrong size on LeaderboardWidget_OnSeasonComboBoxSelected");
static_assert(offsetof(LeaderboardWidget_OnSeasonComboBoxSelected, InItem) == 0x000000, "Member 'LeaderboardWidget_OnSeasonComboBoxSelected::InItem' has a wrong offset!");

// Function DungeonCrawler.LeaderboardWidget.OnSheetComboBoxSelected
// 0x0008 (0x0008 - 0x0000)
struct LeaderboardWidget_OnSheetComboBoxSelected final
{
public:
	class UObject*                                InItem;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LeaderboardWidget_OnSheetComboBoxSelected) == 0x000008, "Wrong alignment on LeaderboardWidget_OnSheetComboBoxSelected");
static_assert(sizeof(LeaderboardWidget_OnSheetComboBoxSelected) == 0x000008, "Wrong size on LeaderboardWidget_OnSheetComboBoxSelected");
static_assert(offsetof(LeaderboardWidget_OnSheetComboBoxSelected, InItem) == 0x000000, "Member 'LeaderboardWidget_OnSheetComboBoxSelected::InItem' has a wrong offset!");

// Function DungeonCrawler.LobbyWidget.OnMatchingStateChanged
// 0x0001 (0x0001 - 0x0000)
struct LobbyWidget_OnMatchingStateChanged final
{
public:
	bool                                          bMatching;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LobbyWidget_OnMatchingStateChanged) == 0x000001, "Wrong alignment on LobbyWidget_OnMatchingStateChanged");
static_assert(sizeof(LobbyWidget_OnMatchingStateChanged) == 0x000001, "Wrong size on LobbyWidget_OnMatchingStateChanged");
static_assert(offsetof(LobbyWidget_OnMatchingStateChanged, bMatching) == 0x000000, "Member 'LobbyWidget_OnMatchingStateChanged::bMatching' has a wrong offset!");

// Function DungeonCrawler.LobbyWidget.OnPlayPartyReadyStateChanged
// 0x0003 (0x0003 - 0x0000)
struct LobbyWidget_OnPlayPartyReadyStateChanged final
{
public:
	bool                                          bMine;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeader;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReady;                                            // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LobbyWidget_OnPlayPartyReadyStateChanged) == 0x000001, "Wrong alignment on LobbyWidget_OnPlayPartyReadyStateChanged");
static_assert(sizeof(LobbyWidget_OnPlayPartyReadyStateChanged) == 0x000003, "Wrong size on LobbyWidget_OnPlayPartyReadyStateChanged");
static_assert(offsetof(LobbyWidget_OnPlayPartyReadyStateChanged, bMine) == 0x000000, "Member 'LobbyWidget_OnPlayPartyReadyStateChanged::bMine' has a wrong offset!");
static_assert(offsetof(LobbyWidget_OnPlayPartyReadyStateChanged, bLeader) == 0x000001, "Member 'LobbyWidget_OnPlayPartyReadyStateChanged::bLeader' has a wrong offset!");
static_assert(offsetof(LobbyWidget_OnPlayPartyReadyStateChanged, bReady) == 0x000002, "Member 'LobbyWidget_OnPlayPartyReadyStateChanged::bReady' has a wrong offset!");

// Function DungeonCrawler.LoginWidget.OnAgeRatingType
// 0x0002 (0x0002 - 0x0000)
struct LoginWidget_OnAgeRatingType final
{
public:
	EAgeRatingType                                NewValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAgeRatingType                                OldValue;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoginWidget_OnAgeRatingType) == 0x000001, "Wrong alignment on LoginWidget_OnAgeRatingType");
static_assert(sizeof(LoginWidget_OnAgeRatingType) == 0x000002, "Wrong size on LoginWidget_OnAgeRatingType");
static_assert(offsetof(LoginWidget_OnAgeRatingType, NewValue) == 0x000000, "Member 'LoginWidget_OnAgeRatingType::NewValue' has a wrong offset!");
static_assert(offsetof(LoginWidget_OnAgeRatingType, OldValue) == 0x000001, "Member 'LoginWidget_OnAgeRatingType::OldValue' has a wrong offset!");

// Function DungeonCrawler.LoginWidget.OnSelectionChanged
// 0x0018 (0x0018 - 0x0000)
struct LoginWidget_OnSelectionChanged final
{
public:
	class FString                                 SelectedItem;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectInfo                                   SelectionType;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A5[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LoginWidget_OnSelectionChanged) == 0x000008, "Wrong alignment on LoginWidget_OnSelectionChanged");
static_assert(sizeof(LoginWidget_OnSelectionChanged) == 0x000018, "Wrong size on LoginWidget_OnSelectionChanged");
static_assert(offsetof(LoginWidget_OnSelectionChanged, SelectedItem) == 0x000000, "Member 'LoginWidget_OnSelectionChanged::SelectedItem' has a wrong offset!");
static_assert(offsetof(LoginWidget_OnSelectionChanged, SelectionType) == 0x000010, "Member 'LoginWidget_OnSelectionChanged::SelectionType' has a wrong offset!");

// Function DungeonCrawler.LoginWidget.OnTextChangedLoginId
// 0x0018 (0x0018 - 0x0000)
struct LoginWidget_OnTextChangedLoginId final
{
public:
	class FText                                   InLoginId;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoginWidget_OnTextChangedLoginId) == 0x000008, "Wrong alignment on LoginWidget_OnTextChangedLoginId");
static_assert(sizeof(LoginWidget_OnTextChangedLoginId) == 0x000018, "Wrong size on LoginWidget_OnTextChangedLoginId");
static_assert(offsetof(LoginWidget_OnTextChangedLoginId, InLoginId) == 0x000000, "Member 'LoginWidget_OnTextChangedLoginId::InLoginId' has a wrong offset!");

// Function DungeonCrawler.LoginWidget.OnTextChangedPassWord
// 0x0018 (0x0018 - 0x0000)
struct LoginWidget_OnTextChangedPassWord final
{
public:
	class FText                                   InPassWord;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoginWidget_OnTextChangedPassWord) == 0x000008, "Wrong alignment on LoginWidget_OnTextChangedPassWord");
static_assert(sizeof(LoginWidget_OnTextChangedPassWord) == 0x000018, "Wrong size on LoginWidget_OnTextChangedPassWord");
static_assert(offsetof(LoginWidget_OnTextChangedPassWord, InPassWord) == 0x000000, "Member 'LoginWidget_OnTextChangedPassWord::InPassWord' has a wrong offset!");

// Function DungeonCrawler.LoginWidget.IsUsingDevPlatform
// 0x0001 (0x0001 - 0x0000)
struct LoginWidget_IsUsingDevPlatform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoginWidget_IsUsingDevPlatform) == 0x000001, "Wrong alignment on LoginWidget_IsUsingDevPlatform");
static_assert(sizeof(LoginWidget_IsUsingDevPlatform) == 0x000001, "Wrong size on LoginWidget_IsUsingDevPlatform");
static_assert(offsetof(LoginWidget_IsUsingDevPlatform, ReturnValue) == 0x000000, "Member 'LoginWidget_IsUsingDevPlatform::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.LoginWidget.IsUsingPlatform
// 0x0001 (0x0001 - 0x0000)
struct LoginWidget_IsUsingPlatform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoginWidget_IsUsingPlatform) == 0x000001, "Wrong alignment on LoginWidget_IsUsingPlatform");
static_assert(sizeof(LoginWidget_IsUsingPlatform) == 0x000001, "Wrong size on LoginWidget_IsUsingPlatform");
static_assert(offsetof(LoginWidget_IsUsingPlatform, ReturnValue) == 0x000000, "Member 'LoginWidget_IsUsingPlatform::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.LootComponent.GetLootTargetActor
// 0x0008 (0x0008 - 0x0000)
struct LootComponent_GetLootTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootComponent_GetLootTargetActor) == 0x000008, "Wrong alignment on LootComponent_GetLootTargetActor");
static_assert(sizeof(LootComponent_GetLootTargetActor) == 0x000008, "Wrong size on LootComponent_GetLootTargetActor");
static_assert(offsetof(LootComponent_GetLootTargetActor, ReturnValue) == 0x000000, "Member 'LootComponent_GetLootTargetActor::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.LootComponent.IsLootTargetPlayer
// 0x0001 (0x0001 - 0x0000)
struct LootComponent_IsLootTargetPlayer final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootComponent_IsLootTargetPlayer) == 0x000001, "Wrong alignment on LootComponent_IsLootTargetPlayer");
static_assert(sizeof(LootComponent_IsLootTargetPlayer) == 0x000001, "Wrong size on LootComponent_IsLootTargetPlayer");
static_assert(offsetof(LootComponent_IsLootTargetPlayer, ReturnValue) == 0x000000, "Member 'LootComponent_IsLootTargetPlayer::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.LootComponent.OnRep_LootTargetActor
// 0x0008 (0x0008 - 0x0000)
struct LootComponent_OnRep_LootTargetActor final
{
public:
	const class AActor*                           OldLootTargetActor;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootComponent_OnRep_LootTargetActor) == 0x000008, "Wrong alignment on LootComponent_OnRep_LootTargetActor");
static_assert(sizeof(LootComponent_OnRep_LootTargetActor) == 0x000008, "Wrong size on LootComponent_OnRep_LootTargetActor");
static_assert(offsetof(LootComponent_OnRep_LootTargetActor, OldLootTargetActor) == 0x000000, "Member 'LootComponent_OnRep_LootTargetActor::OldLootTargetActor' has a wrong offset!");

// Function DungeonCrawler.LootComponent.ServerRemoveLootTarget
// 0x0018 (0x0018 - 0x0000)
struct LootComponent_ServerRemoveLootTarget final
{
public:
	class UInventoryComponent*                    InventoryComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemData>                      InContainingItems;                                 // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LootComponent_ServerRemoveLootTarget) == 0x000008, "Wrong alignment on LootComponent_ServerRemoveLootTarget");
static_assert(sizeof(LootComponent_ServerRemoveLootTarget) == 0x000018, "Wrong size on LootComponent_ServerRemoveLootTarget");
static_assert(offsetof(LootComponent_ServerRemoveLootTarget, InventoryComponent) == 0x000000, "Member 'LootComponent_ServerRemoveLootTarget::InventoryComponent' has a wrong offset!");
static_assert(offsetof(LootComponent_ServerRemoveLootTarget, InContainingItems) == 0x000008, "Member 'LootComponent_ServerRemoveLootTarget::InContainingItems' has a wrong offset!");

// Function DungeonCrawler.MailBoxListWidgetBase.OnPopupSWidgetInvitePartyAnswerResponse
// 0x0058 (0x0058 - 0x0000)
struct MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse final
{
public:
	EPopupResult                                  PopupResult;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A8[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnAccountID;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              SenderNickname;                                    // 0x0018(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse) == 0x000008, "Wrong alignment on MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse");
static_assert(sizeof(MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse) == 0x000058, "Wrong size on MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse");
static_assert(offsetof(MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse, PopupResult) == 0x000000, "Member 'MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse::PopupResult' has a wrong offset!");
static_assert(offsetof(MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse, ReturnAccountID) == 0x000008, "Member 'MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse::ReturnAccountID' has a wrong offset!");
static_assert(offsetof(MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse, SenderNickname) == 0x000018, "Member 'MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse::SenderNickname' has a wrong offset!");

// Function DungeonCrawler.MusicActor.OnRep_MusicData
// 0x0024 (0x0024 - 0x0000)
struct MusicActor_OnRep_MusicData final
{
public:
	struct FMusicData                             OldMusicData;                                      // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicActor_OnRep_MusicData) == 0x000004, "Wrong alignment on MusicActor_OnRep_MusicData");
static_assert(sizeof(MusicActor_OnRep_MusicData) == 0x000024, "Wrong size on MusicActor_OnRep_MusicData");
static_assert(offsetof(MusicActor_OnRep_MusicData, OldMusicData) == 0x000000, "Member 'MusicActor_OnRep_MusicData::OldMusicData' has a wrong offset!");

// Function DungeonCrawler.MusicActor.SetMusicData
// 0x0024 (0x0024 - 0x0000)
struct MusicActor_SetMusicData final
{
public:
	struct FMusicData                             NewMusicData;                                      // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicActor_SetMusicData) == 0x000004, "Wrong alignment on MusicActor_SetMusicData");
static_assert(sizeof(MusicActor_SetMusicData) == 0x000024, "Wrong size on MusicActor_SetMusicData");
static_assert(offsetof(MusicActor_SetMusicData, NewMusicData) == 0x000000, "Member 'MusicActor_SetMusicData::NewMusicData' has a wrong offset!");

// Function DungeonCrawler.MusicActor.GetArtDataMusic
// 0x0008 (0x0008 - 0x0000)
struct MusicActor_GetArtDataMusic final
{
public:
	class UArtDataMusic*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicActor_GetArtDataMusic) == 0x000008, "Wrong alignment on MusicActor_GetArtDataMusic");
static_assert(sizeof(MusicActor_GetArtDataMusic) == 0x000008, "Wrong size on MusicActor_GetArtDataMusic");
static_assert(offsetof(MusicActor_GetArtDataMusic, ReturnValue) == 0x000000, "Member 'MusicActor_GetArtDataMusic::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.MusicActor.GetDesignDataMusic
// 0x00C8 (0x00C8 - 0x0000)
struct MusicActor_GetDesignDataMusic final
{
public:
	struct FDesignDataMusic                       ReturnValue;                                       // 0x0000(0x00C8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicActor_GetDesignDataMusic) == 0x000008, "Wrong alignment on MusicActor_GetDesignDataMusic");
static_assert(sizeof(MusicActor_GetDesignDataMusic) == 0x0000C8, "Wrong size on MusicActor_GetDesignDataMusic");
static_assert(offsetof(MusicActor_GetDesignDataMusic, ReturnValue) == 0x000000, "Member 'MusicActor_GetDesignDataMusic::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.MusicActor.GetMusicData
// 0x0024 (0x0024 - 0x0000)
struct MusicActor_GetMusicData final
{
public:
	struct FMusicData                             ReturnValue;                                       // 0x0000(0x0024)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicActor_GetMusicData) == 0x000004, "Wrong alignment on MusicActor_GetMusicData");
static_assert(sizeof(MusicActor_GetMusicData) == 0x000024, "Wrong size on MusicActor_GetMusicData");
static_assert(offsetof(MusicActor_GetMusicData, ReturnValue) == 0x000000, "Member 'MusicActor_GetMusicData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.MusicActor.GetPlayMusicData
// 0x0008 (0x0008 - 0x0000)
struct MusicActor_GetPlayMusicData final
{
public:
	class UPlayMusicData*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicActor_GetPlayMusicData) == 0x000008, "Wrong alignment on MusicActor_GetPlayMusicData");
static_assert(sizeof(MusicActor_GetPlayMusicData) == 0x000008, "Wrong size on MusicActor_GetPlayMusicData");
static_assert(offsetof(MusicActor_GetPlayMusicData, ReturnValue) == 0x000000, "Member 'MusicActor_GetPlayMusicData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.MusicActor.GetSoundDataMusic
// 0x0008 (0x0008 - 0x0000)
struct MusicActor_GetSoundDataMusic final
{
public:
	class USoundData*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicActor_GetSoundDataMusic) == 0x000008, "Wrong alignment on MusicActor_GetSoundDataMusic");
static_assert(sizeof(MusicActor_GetSoundDataMusic) == 0x000008, "Wrong size on MusicActor_GetSoundDataMusic");
static_assert(offsetof(MusicActor_GetSoundDataMusic, ReturnValue) == 0x000000, "Member 'MusicActor_GetSoundDataMusic::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.MusicComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct MusicComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on MusicComponent_BroadcastMsgBlueprint");
static_assert(sizeof(MusicComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on MusicComponent_BroadcastMsgBlueprint");
static_assert(offsetof(MusicComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'MusicComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.MusicComponent.OnRep_MusicActors
// 0x0010 (0x0010 - 0x0000)
struct MusicComponent_OnRep_MusicActors final
{
public:
	TArray<class AMusicActor*>                    OldAMusicActors;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicComponent_OnRep_MusicActors) == 0x000008, "Wrong alignment on MusicComponent_OnRep_MusicActors");
static_assert(sizeof(MusicComponent_OnRep_MusicActors) == 0x000010, "Wrong size on MusicComponent_OnRep_MusicActors");
static_assert(offsetof(MusicComponent_OnRep_MusicActors, OldAMusicActors) == 0x000000, "Member 'MusicComponent_OnRep_MusicActors::OldAMusicActors' has a wrong offset!");

// Function DungeonCrawler.MusicComponent.ServerSetCurrentMusic
// 0x0008 (0x0008 - 0x0000)
struct MusicComponent_ServerSetCurrentMusic final
{
public:
	struct FGameplayTag                           MusicTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicComponent_ServerSetCurrentMusic) == 0x000004, "Wrong alignment on MusicComponent_ServerSetCurrentMusic");
static_assert(sizeof(MusicComponent_ServerSetCurrentMusic) == 0x000008, "Wrong size on MusicComponent_ServerSetCurrentMusic");
static_assert(offsetof(MusicComponent_ServerSetCurrentMusic, MusicTag) == 0x000000, "Member 'MusicComponent_ServerSetCurrentMusic::MusicTag' has a wrong offset!");

// Function DungeonCrawler.MusicComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct MusicComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicComponent_UnbindMsg) == 0x000008, "Wrong alignment on MusicComponent_UnbindMsg");
static_assert(sizeof(MusicComponent_UnbindMsg) == 0x000010, "Wrong size on MusicComponent_UnbindMsg");
static_assert(offsetof(MusicComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'MusicComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(MusicComponent_UnbindMsg, InObject) == 0x000008, "Member 'MusicComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.MusicComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct MusicComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MusicComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on MusicComponent_UnbindMsgAll");
static_assert(sizeof(MusicComponent_UnbindMsgAll) == 0x000008, "Wrong size on MusicComponent_UnbindMsgAll");
static_assert(offsetof(MusicComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'MusicComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.MyStatusWidget.SelectStatus
// 0x0004 (0x0004 - 0x0000)
struct MyStatusWidget_SelectStatus final
{
public:
	int32                                         InRadioButtonIdx;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyStatusWidget_SelectStatus) == 0x000004, "Wrong alignment on MyStatusWidget_SelectStatus");
static_assert(sizeof(MyStatusWidget_SelectStatus) == 0x000004, "Wrong size on MyStatusWidget_SelectStatus");
static_assert(offsetof(MyStatusWidget_SelectStatus, InRadioButtonIdx) == 0x000000, "Member 'MyStatusWidget_SelectStatus::InRadioButtonIdx' has a wrong offset!");

// Function DungeonCrawler.OnlineSystemEpic.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct OnlineSystemEpic_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnlineSystemEpic_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on OnlineSystemEpic_BroadcastMsgBlueprint");
static_assert(sizeof(OnlineSystemEpic_BroadcastMsgBlueprint) == 0x000004, "Wrong size on OnlineSystemEpic_BroadcastMsgBlueprint");
static_assert(offsetof(OnlineSystemEpic_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'OnlineSystemEpic_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.OnlineSystemEpic.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct OnlineSystemEpic_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnlineSystemEpic_UnbindMsg) == 0x000008, "Wrong alignment on OnlineSystemEpic_UnbindMsg");
static_assert(sizeof(OnlineSystemEpic_UnbindMsg) == 0x000010, "Wrong size on OnlineSystemEpic_UnbindMsg");
static_assert(offsetof(OnlineSystemEpic_UnbindMsg, InMsgType) == 0x000000, "Member 'OnlineSystemEpic_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(OnlineSystemEpic_UnbindMsg, InObject) == 0x000008, "Member 'OnlineSystemEpic_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.OnlineSystemEpic.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct OnlineSystemEpic_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnlineSystemEpic_UnbindMsgAll) == 0x000008, "Wrong alignment on OnlineSystemEpic_UnbindMsgAll");
static_assert(sizeof(OnlineSystemEpic_UnbindMsgAll) == 0x000008, "Wrong size on OnlineSystemEpic_UnbindMsgAll");
static_assert(offsetof(OnlineSystemEpic_UnbindMsgAll, InObject) == 0x000000, "Member 'OnlineSystemEpic_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.OnlineSystemIronmace.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct OnlineSystemIronmace_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnlineSystemIronmace_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on OnlineSystemIronmace_BroadcastMsgBlueprint");
static_assert(sizeof(OnlineSystemIronmace_BroadcastMsgBlueprint) == 0x000004, "Wrong size on OnlineSystemIronmace_BroadcastMsgBlueprint");
static_assert(offsetof(OnlineSystemIronmace_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'OnlineSystemIronmace_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.OnlineSystemIronmace.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct OnlineSystemIronmace_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnlineSystemIronmace_UnbindMsg) == 0x000008, "Wrong alignment on OnlineSystemIronmace_UnbindMsg");
static_assert(sizeof(OnlineSystemIronmace_UnbindMsg) == 0x000010, "Wrong size on OnlineSystemIronmace_UnbindMsg");
static_assert(offsetof(OnlineSystemIronmace_UnbindMsg, InMsgType) == 0x000000, "Member 'OnlineSystemIronmace_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(OnlineSystemIronmace_UnbindMsg, InObject) == 0x000008, "Member 'OnlineSystemIronmace_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.OnlineSystemIronmace.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct OnlineSystemIronmace_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnlineSystemIronmace_UnbindMsgAll) == 0x000008, "Wrong alignment on OnlineSystemIronmace_UnbindMsgAll");
static_assert(sizeof(OnlineSystemIronmace_UnbindMsgAll) == 0x000008, "Wrong size on OnlineSystemIronmace_UnbindMsgAll");
static_assert(offsetof(OnlineSystemIronmace_UnbindMsgAll, InObject) == 0x000000, "Member 'OnlineSystemIronmace_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.OnlineSystemSteam.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct OnlineSystemSteam_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnlineSystemSteam_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on OnlineSystemSteam_BroadcastMsgBlueprint");
static_assert(sizeof(OnlineSystemSteam_BroadcastMsgBlueprint) == 0x000004, "Wrong size on OnlineSystemSteam_BroadcastMsgBlueprint");
static_assert(offsetof(OnlineSystemSteam_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'OnlineSystemSteam_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.OnlineSystemSteam.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct OnlineSystemSteam_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnlineSystemSteam_UnbindMsg) == 0x000008, "Wrong alignment on OnlineSystemSteam_UnbindMsg");
static_assert(sizeof(OnlineSystemSteam_UnbindMsg) == 0x000010, "Wrong size on OnlineSystemSteam_UnbindMsg");
static_assert(offsetof(OnlineSystemSteam_UnbindMsg, InMsgType) == 0x000000, "Member 'OnlineSystemSteam_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(OnlineSystemSteam_UnbindMsg, InObject) == 0x000008, "Member 'OnlineSystemSteam_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.OnlineSystemSteam.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct OnlineSystemSteam_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(OnlineSystemSteam_UnbindMsgAll) == 0x000008, "Wrong alignment on OnlineSystemSteam_UnbindMsgAll");
static_assert(sizeof(OnlineSystemSteam_UnbindMsgAll) == 0x000008, "Wrong size on OnlineSystemSteam_UnbindMsgAll");
static_assert(offsetof(OnlineSystemSteam_UnbindMsgAll, InObject) == 0x000000, "Member 'OnlineSystemSteam_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.PartySession.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct PartySession_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PartySession_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on PartySession_BroadcastMsgBlueprint");
static_assert(sizeof(PartySession_BroadcastMsgBlueprint) == 0x000004, "Wrong size on PartySession_BroadcastMsgBlueprint");
static_assert(offsetof(PartySession_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'PartySession_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.PartySession.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct PartySession_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PartySession_UnbindMsg) == 0x000008, "Wrong alignment on PartySession_UnbindMsg");
static_assert(sizeof(PartySession_UnbindMsg) == 0x000010, "Wrong size on PartySession_UnbindMsg");
static_assert(offsetof(PartySession_UnbindMsg, InMsgType) == 0x000000, "Member 'PartySession_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(PartySession_UnbindMsg, InObject) == 0x000008, "Member 'PartySession_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.PartySession.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct PartySession_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PartySession_UnbindMsgAll) == 0x000008, "Wrong alignment on PartySession_UnbindMsgAll");
static_assert(sizeof(PartySession_UnbindMsgAll) == 0x000008, "Wrong size on PartySession_UnbindMsgAll");
static_assert(offsetof(PartySession_UnbindMsgAll, InObject) == 0x000000, "Member 'PartySession_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.PerkWidget.InitializePerkWidget
// 0x0010 (0x0010 - 0x0000)
struct PerkWidget_InitializePerkWidget final
{
public:
	struct FPrimaryAssetId                        InPerkId;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PerkWidget_InitializePerkWidget) == 0x000004, "Wrong alignment on PerkWidget_InitializePerkWidget");
static_assert(sizeof(PerkWidget_InitializePerkWidget) == 0x000010, "Wrong size on PerkWidget_InitializePerkWidget");
static_assert(offsetof(PerkWidget_InitializePerkWidget, InPerkId) == 0x000000, "Member 'PerkWidget_InitializePerkWidget::InPerkId' has a wrong offset!");

// Function DungeonCrawler.PerkWidget.SetPerkData
// 0x0030 (0x0030 - 0x0000)
struct PerkWidget_SetPerkData final
{
public:
	class FText                                   PerkName;                                          // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   PerkDesc;                                          // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PerkWidget_SetPerkData) == 0x000008, "Wrong alignment on PerkWidget_SetPerkData");
static_assert(sizeof(PerkWidget_SetPerkData) == 0x000030, "Wrong size on PerkWidget_SetPerkData");
static_assert(offsetof(PerkWidget_SetPerkData, PerkName) == 0x000000, "Member 'PerkWidget_SetPerkData::PerkName' has a wrong offset!");
static_assert(offsetof(PerkWidget_SetPerkData, PerkDesc) == 0x000018, "Member 'PerkWidget_SetPerkData::PerkDesc' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.GameplayTagUpdated
// 0x000C (0x000C - 0x0000)
struct ProjectileActor_GameplayTagUpdated final
{
public:
	struct FGameplayTag                           InGameplayTag;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_GameplayTagUpdated) == 0x000004, "Wrong alignment on ProjectileActor_GameplayTagUpdated");
static_assert(sizeof(ProjectileActor_GameplayTagUpdated) == 0x00000C, "Wrong size on ProjectileActor_GameplayTagUpdated");
static_assert(offsetof(ProjectileActor_GameplayTagUpdated, InGameplayTag) == 0x000000, "Member 'ProjectileActor_GameplayTagUpdated::InGameplayTag' has a wrong offset!");
static_assert(offsetof(ProjectileActor_GameplayTagUpdated, InCount) == 0x000008, "Member 'ProjectileActor_GameplayTagUpdated::InCount' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.GetAddEffectToGroundHit
// 0x0010 (0x0010 - 0x0000)
struct ProjectileActor_GetAddEffectToGroundHit final
{
public:
	TArray<struct FPrimaryAssetId>                ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_GetAddEffectToGroundHit) == 0x000008, "Wrong alignment on ProjectileActor_GetAddEffectToGroundHit");
static_assert(sizeof(ProjectileActor_GetAddEffectToGroundHit) == 0x000010, "Wrong size on ProjectileActor_GetAddEffectToGroundHit");
static_assert(offsetof(ProjectileActor_GetAddEffectToGroundHit, ReturnValue) == 0x000000, "Member 'ProjectileActor_GetAddEffectToGroundHit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.GetAddEffectToTargetHit
// 0x0010 (0x0010 - 0x0000)
struct ProjectileActor_GetAddEffectToTargetHit final
{
public:
	TArray<struct FPrimaryAssetId>                ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_GetAddEffectToTargetHit) == 0x000008, "Wrong alignment on ProjectileActor_GetAddEffectToTargetHit");
static_assert(sizeof(ProjectileActor_GetAddEffectToTargetHit) == 0x000010, "Wrong size on ProjectileActor_GetAddEffectToTargetHit");
static_assert(offsetof(ProjectileActor_GetAddEffectToTargetHit, ReturnValue) == 0x000000, "Member 'ProjectileActor_GetAddEffectToTargetHit::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.HandleTimelineUpdate
// 0x0004 (0x0004 - 0x0000)
struct ProjectileActor_HandleTimelineUpdate final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_HandleTimelineUpdate) == 0x000004, "Wrong alignment on ProjectileActor_HandleTimelineUpdate");
static_assert(sizeof(ProjectileActor_HandleTimelineUpdate) == 0x000004, "Wrong size on ProjectileActor_HandleTimelineUpdate");
static_assert(offsetof(ProjectileActor_HandleTimelineUpdate, Value) == 0x000000, "Member 'ProjectileActor_HandleTimelineUpdate::Value' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.InitArrivalVelocity
// 0x0018 (0x0018 - 0x0000)
struct ProjectileActor_InitArrivalVelocity final
{
public:
	struct FVector                                Velocity;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_InitArrivalVelocity) == 0x000008, "Wrong alignment on ProjectileActor_InitArrivalVelocity");
static_assert(sizeof(ProjectileActor_InitArrivalVelocity) == 0x000018, "Wrong size on ProjectileActor_InitArrivalVelocity");
static_assert(offsetof(ProjectileActor_InitArrivalVelocity, Velocity) == 0x000000, "Member 'ProjectileActor_InitArrivalVelocity::Velocity' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.InitialSpeed
// 0x0004 (0x0004 - 0x0000)
struct ProjectileActor_InitialSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_InitialSpeed) == 0x000004, "Wrong alignment on ProjectileActor_InitialSpeed");
static_assert(sizeof(ProjectileActor_InitialSpeed) == 0x000004, "Wrong size on ProjectileActor_InitialSpeed");
static_assert(offsetof(ProjectileActor_InitialSpeed, ReturnValue) == 0x000000, "Member 'ProjectileActor_InitialSpeed::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.InitVelocity
// 0x0004 (0x0004 - 0x0000)
struct ProjectileActor_InitVelocity final
{
public:
	float                                         FirePower;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_InitVelocity) == 0x000004, "Wrong alignment on ProjectileActor_InitVelocity");
static_assert(sizeof(ProjectileActor_InitVelocity) == 0x000004, "Wrong size on ProjectileActor_InitVelocity");
static_assert(offsetof(ProjectileActor_InitVelocity, FirePower) == 0x000000, "Member 'ProjectileActor_InitVelocity::FirePower' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.MatchesProjectileSourceTypeTagExact
// 0x000C (0x000C - 0x0000)
struct ProjectileActor_MatchesProjectileSourceTypeTagExact final
{
public:
	struct FGameplayTag                           CheckGameplayTag;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CD[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileActor_MatchesProjectileSourceTypeTagExact) == 0x000004, "Wrong alignment on ProjectileActor_MatchesProjectileSourceTypeTagExact");
static_assert(sizeof(ProjectileActor_MatchesProjectileSourceTypeTagExact) == 0x00000C, "Wrong size on ProjectileActor_MatchesProjectileSourceTypeTagExact");
static_assert(offsetof(ProjectileActor_MatchesProjectileSourceTypeTagExact, CheckGameplayTag) == 0x000000, "Member 'ProjectileActor_MatchesProjectileSourceTypeTagExact::CheckGameplayTag' has a wrong offset!");
static_assert(offsetof(ProjectileActor_MatchesProjectileSourceTypeTagExact, ReturnValue) == 0x000008, "Member 'ProjectileActor_MatchesProjectileSourceTypeTagExact::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.OnHomingTargetDeath
// 0x000C (0x000C - 0x0000)
struct ProjectileActor_OnHomingTargetDeath final
{
public:
	struct FGameplayTag                           InGameplayTag;                                     // 0x0000(0x0008)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InCount;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_OnHomingTargetDeath) == 0x000004, "Wrong alignment on ProjectileActor_OnHomingTargetDeath");
static_assert(sizeof(ProjectileActor_OnHomingTargetDeath) == 0x00000C, "Wrong size on ProjectileActor_OnHomingTargetDeath");
static_assert(offsetof(ProjectileActor_OnHomingTargetDeath, InGameplayTag) == 0x000000, "Member 'ProjectileActor_OnHomingTargetDeath::InGameplayTag' has a wrong offset!");
static_assert(offsetof(ProjectileActor_OnHomingTargetDeath, InCount) == 0x000008, "Member 'ProjectileActor_OnHomingTargetDeath::InCount' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.PlayPierce
// 0x000C (0x000C - 0x0000)
struct ProjectileActor_PlayPierce final
{
public:
	float                                         SetPierceCount;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SetObstaclePierce;                                 // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CE[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SetObstaclePierceDecrease;                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_PlayPierce) == 0x000004, "Wrong alignment on ProjectileActor_PlayPierce");
static_assert(sizeof(ProjectileActor_PlayPierce) == 0x00000C, "Wrong size on ProjectileActor_PlayPierce");
static_assert(offsetof(ProjectileActor_PlayPierce, SetPierceCount) == 0x000000, "Member 'ProjectileActor_PlayPierce::SetPierceCount' has a wrong offset!");
static_assert(offsetof(ProjectileActor_PlayPierce, SetObstaclePierce) == 0x000004, "Member 'ProjectileActor_PlayPierce::SetObstaclePierce' has a wrong offset!");
static_assert(offsetof(ProjectileActor_PlayPierce, SetObstaclePierceDecrease) == 0x000008, "Member 'ProjectileActor_PlayPierce::SetObstaclePierceDecrease' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.ProjectileHit
// 0x0150 (0x0150 - 0x0000)
struct ProjectileActor_ProjectileHit final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsAttached;                                       // 0x00E8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28CF[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ActorPrevTickTransform;                            // 0x00F0(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_ProjectileHit) == 0x000010, "Wrong alignment on ProjectileActor_ProjectileHit");
static_assert(sizeof(ProjectileActor_ProjectileHit) == 0x000150, "Wrong size on ProjectileActor_ProjectileHit");
static_assert(offsetof(ProjectileActor_ProjectileHit, Hit) == 0x000000, "Member 'ProjectileActor_ProjectileHit::Hit' has a wrong offset!");
static_assert(offsetof(ProjectileActor_ProjectileHit, bIsAttached) == 0x0000E8, "Member 'ProjectileActor_ProjectileHit::bIsAttached' has a wrong offset!");
static_assert(offsetof(ProjectileActor_ProjectileHit, ActorPrevTickTransform) == 0x0000F0, "Member 'ProjectileActor_ProjectileHit::ActorPrevTickTransform' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.SetAddEffectToGroundtHit
// 0x0010 (0x0010 - 0x0000)
struct ProjectileActor_SetAddEffectToGroundtHit final
{
public:
	TArray<struct FPrimaryAssetId>                AddEffectList;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_SetAddEffectToGroundtHit) == 0x000008, "Wrong alignment on ProjectileActor_SetAddEffectToGroundtHit");
static_assert(sizeof(ProjectileActor_SetAddEffectToGroundtHit) == 0x000010, "Wrong size on ProjectileActor_SetAddEffectToGroundtHit");
static_assert(offsetof(ProjectileActor_SetAddEffectToGroundtHit, AddEffectList) == 0x000000, "Member 'ProjectileActor_SetAddEffectToGroundtHit::AddEffectList' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.SetAddEffectToTargetHit
// 0x0010 (0x0010 - 0x0000)
struct ProjectileActor_SetAddEffectToTargetHit final
{
public:
	TArray<struct FPrimaryAssetId>                AddEffectList;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_SetAddEffectToTargetHit) == 0x000008, "Wrong alignment on ProjectileActor_SetAddEffectToTargetHit");
static_assert(sizeof(ProjectileActor_SetAddEffectToTargetHit) == 0x000010, "Wrong size on ProjectileActor_SetAddEffectToTargetHit");
static_assert(offsetof(ProjectileActor_SetAddEffectToTargetHit, AddEffectList) == 0x000000, "Member 'ProjectileActor_SetAddEffectToTargetHit::AddEffectList' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.SetHomingMagnitude
// 0x0004 (0x0004 - 0x0000)
struct ProjectileActor_SetHomingMagnitude final
{
public:
	float                                         InHomingMagnitude;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_SetHomingMagnitude) == 0x000004, "Wrong alignment on ProjectileActor_SetHomingMagnitude");
static_assert(sizeof(ProjectileActor_SetHomingMagnitude) == 0x000004, "Wrong size on ProjectileActor_SetHomingMagnitude");
static_assert(offsetof(ProjectileActor_SetHomingMagnitude, InHomingMagnitude) == 0x000000, "Member 'ProjectileActor_SetHomingMagnitude::InHomingMagnitude' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.SetHomingTargetComponent
// 0x0008 (0x0008 - 0x0000)
struct ProjectileActor_SetHomingTargetComponent final
{
public:
	class USceneComponent*                        InHomingTargetComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_SetHomingTargetComponent) == 0x000008, "Wrong alignment on ProjectileActor_SetHomingTargetComponent");
static_assert(sizeof(ProjectileActor_SetHomingTargetComponent) == 0x000008, "Wrong size on ProjectileActor_SetHomingTargetComponent");
static_assert(offsetof(ProjectileActor_SetHomingTargetComponent, InHomingTargetComponent) == 0x000000, "Member 'ProjectileActor_SetHomingTargetComponent::InHomingTargetComponent' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.TimelineUpdateEvent
// 0x0008 (0x0008 - 0x0000)
struct ProjectileActor_TimelineUpdateEvent final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimelinePosition;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_TimelineUpdateEvent) == 0x000004, "Wrong alignment on ProjectileActor_TimelineUpdateEvent");
static_assert(sizeof(ProjectileActor_TimelineUpdateEvent) == 0x000008, "Wrong size on ProjectileActor_TimelineUpdateEvent");
static_assert(offsetof(ProjectileActor_TimelineUpdateEvent, Value) == 0x000000, "Member 'ProjectileActor_TimelineUpdateEvent::Value' has a wrong offset!");
static_assert(offsetof(ProjectileActor_TimelineUpdateEvent, TimelinePosition) == 0x000004, "Member 'ProjectileActor_TimelineUpdateEvent::TimelinePosition' has a wrong offset!");

// Function DungeonCrawler.ProjectileActor.GetArtDataProjectile
// 0x0008 (0x0008 - 0x0000)
struct ProjectileActor_GetArtDataProjectile final
{
public:
	class UArtDataProjectile*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileActor_GetArtDataProjectile) == 0x000008, "Wrong alignment on ProjectileActor_GetArtDataProjectile");
static_assert(sizeof(ProjectileActor_GetArtDataProjectile) == 0x000008, "Wrong size on ProjectileActor_GetArtDataProjectile");
static_assert(offsetof(ProjectileActor_GetArtDataProjectile, ReturnValue) == 0x000000, "Member 'ProjectileActor_GetArtDataProjectile::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.ReligionContentsWidget.DeActivateReligionSeasonWidget
// 0x0002 (0x0002 - 0x0000)
struct ReligionContentsWidget_DeActivateReligionSeasonWidget final
{
public:
	bool                                          bIsCurrentSeason;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasReligion;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionContentsWidget_DeActivateReligionSeasonWidget) == 0x000001, "Wrong alignment on ReligionContentsWidget_DeActivateReligionSeasonWidget");
static_assert(sizeof(ReligionContentsWidget_DeActivateReligionSeasonWidget) == 0x000002, "Wrong size on ReligionContentsWidget_DeActivateReligionSeasonWidget");
static_assert(offsetof(ReligionContentsWidget_DeActivateReligionSeasonWidget, bIsCurrentSeason) == 0x000000, "Member 'ReligionContentsWidget_DeActivateReligionSeasonWidget::bIsCurrentSeason' has a wrong offset!");
static_assert(offsetof(ReligionContentsWidget_DeActivateReligionSeasonWidget, bHasReligion) == 0x000001, "Member 'ReligionContentsWidget_DeActivateReligionSeasonWidget::bHasReligion' has a wrong offset!");

// Function DungeonCrawler.ReligionContentsWidget.OnReligionInfoSetting
// 0x0040 (0x0040 - 0x0000)
struct ReligionContentsWidget_OnReligionInfoSetting final
{
public:
	struct FDCReligionInfo                        Info;                                              // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionContentsWidget_OnReligionInfoSetting) == 0x000008, "Wrong alignment on ReligionContentsWidget_OnReligionInfoSetting");
static_assert(sizeof(ReligionContentsWidget_OnReligionInfoSetting) == 0x000040, "Wrong size on ReligionContentsWidget_OnReligionInfoSetting");
static_assert(offsetof(ReligionContentsWidget_OnReligionInfoSetting, Info) == 0x000000, "Member 'ReligionContentsWidget_OnReligionInfoSetting::Info' has a wrong offset!");

// Function DungeonCrawler.ReligionContentsWidget.OnReligionPersonalRankInfoSetting
// 0x0048 (0x0048 - 0x0000)
struct ReligionContentsWidget_OnReligionPersonalRankInfoSetting final
{
public:
	struct FDCReligionRankEntryInfo               Info;                                              // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionContentsWidget_OnReligionPersonalRankInfoSetting) == 0x000008, "Wrong alignment on ReligionContentsWidget_OnReligionPersonalRankInfoSetting");
static_assert(sizeof(ReligionContentsWidget_OnReligionPersonalRankInfoSetting) == 0x000048, "Wrong size on ReligionContentsWidget_OnReligionPersonalRankInfoSetting");
static_assert(offsetof(ReligionContentsWidget_OnReligionPersonalRankInfoSetting, Info) == 0x000000, "Member 'ReligionContentsWidget_OnReligionPersonalRankInfoSetting::Info' has a wrong offset!");

// Function DungeonCrawler.ReligionContentsWidget.OnReligionRankInfoSetting
// 0x0020 (0x0020 - 0x0000)
struct ReligionContentsWidget_OnReligionRankInfoSetting final
{
public:
	struct FDCReligionRankInfo                    Info;                                              // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionContentsWidget_OnReligionRankInfoSetting) == 0x000008, "Wrong alignment on ReligionContentsWidget_OnReligionRankInfoSetting");
static_assert(sizeof(ReligionContentsWidget_OnReligionRankInfoSetting) == 0x000020, "Wrong size on ReligionContentsWidget_OnReligionRankInfoSetting");
static_assert(offsetof(ReligionContentsWidget_OnReligionRankInfoSetting, Info) == 0x000000, "Member 'ReligionContentsWidget_OnReligionRankInfoSetting::Info' has a wrong offset!");

// Function DungeonCrawler.ReligionContentsWidget.SetBlessingLevel
// 0x0004 (0x0004 - 0x0000)
struct ReligionContentsWidget_SetBlessingLevel final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionContentsWidget_SetBlessingLevel) == 0x000004, "Wrong alignment on ReligionContentsWidget_SetBlessingLevel");
static_assert(sizeof(ReligionContentsWidget_SetBlessingLevel) == 0x000004, "Wrong size on ReligionContentsWidget_SetBlessingLevel");
static_assert(offsetof(ReligionContentsWidget_SetBlessingLevel, Level) == 0x000000, "Member 'ReligionContentsWidget_SetBlessingLevel::Level' has a wrong offset!");

// Function DungeonCrawler.ReligionContentsWidget.SetButtonType
// 0x0001 (0x0001 - 0x0000)
struct ReligionContentsWidget_SetButtonType final
{
public:
	bool                                          HasReligion;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionContentsWidget_SetButtonType) == 0x000001, "Wrong alignment on ReligionContentsWidget_SetButtonType");
static_assert(sizeof(ReligionContentsWidget_SetButtonType) == 0x000001, "Wrong size on ReligionContentsWidget_SetButtonType");
static_assert(offsetof(ReligionContentsWidget_SetButtonType, HasReligion) == 0x000000, "Member 'ReligionContentsWidget_SetButtonType::HasReligion' has a wrong offset!");

// Function DungeonCrawler.ReligionContentsWidget.SetOfferingWidgetVisible
// 0x0001 (0x0001 - 0x0000)
struct ReligionContentsWidget_SetOfferingWidgetVisible final
{
public:
	bool                                          Param_IsVisible;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionContentsWidget_SetOfferingWidgetVisible) == 0x000001, "Wrong alignment on ReligionContentsWidget_SetOfferingWidgetVisible");
static_assert(sizeof(ReligionContentsWidget_SetOfferingWidgetVisible) == 0x000001, "Wrong size on ReligionContentsWidget_SetOfferingWidgetVisible");
static_assert(offsetof(ReligionContentsWidget_SetOfferingWidgetVisible, Param_IsVisible) == 0x000000, "Member 'ReligionContentsWidget_SetOfferingWidgetVisible::Param_IsVisible' has a wrong offset!");

// Function DungeonCrawler.ReligionContentsWidget.SetRankDurationSwitcherIndex
// 0x0004 (0x0004 - 0x0000)
struct ReligionContentsWidget_SetRankDurationSwitcherIndex final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionContentsWidget_SetRankDurationSwitcherIndex) == 0x000004, "Wrong alignment on ReligionContentsWidget_SetRankDurationSwitcherIndex");
static_assert(sizeof(ReligionContentsWidget_SetRankDurationSwitcherIndex) == 0x000004, "Wrong size on ReligionContentsWidget_SetRankDurationSwitcherIndex");
static_assert(offsetof(ReligionContentsWidget_SetRankDurationSwitcherIndex, Param_Index) == 0x000000, "Member 'ReligionContentsWidget_SetRankDurationSwitcherIndex::Param_Index' has a wrong offset!");

// Function DungeonCrawler.ReligionContentsWidget.SetReligionTimer
// 0x0010 (0x0010 - 0x0000)
struct ReligionContentsWidget_SetReligionTimer final
{
public:
	struct FReligionRankTimerInfo                 Info;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionContentsWidget_SetReligionTimer) == 0x000004, "Wrong alignment on ReligionContentsWidget_SetReligionTimer");
static_assert(sizeof(ReligionContentsWidget_SetReligionTimer) == 0x000010, "Wrong size on ReligionContentsWidget_SetReligionTimer");
static_assert(offsetof(ReligionContentsWidget_SetReligionTimer, Info) == 0x000000, "Member 'ReligionContentsWidget_SetReligionTimer::Info' has a wrong offset!");

// Function DungeonCrawler.ReligionRankListEntry.OnFMsgWidgetStreamingModeNotifyBlueprint
// 0x0020 (0x0020 - 0x0000)
struct ReligionRankListEntry_OnFMsgWidgetStreamingModeNotifyBlueprint final
{
public:
	struct FMsgWidgetStreamingModeNotify          InMsg;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionRankListEntry_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000008, "Wrong alignment on ReligionRankListEntry_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(sizeof(ReligionRankListEntry_OnFMsgWidgetStreamingModeNotifyBlueprint) == 0x000020, "Wrong size on ReligionRankListEntry_OnFMsgWidgetStreamingModeNotifyBlueprint");
static_assert(offsetof(ReligionRankListEntry_OnFMsgWidgetStreamingModeNotifyBlueprint, InMsg) == 0x000000, "Member 'ReligionRankListEntry_OnFMsgWidgetStreamingModeNotifyBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ReligionRankListEntry.OnReligionRankRecordData
// 0x0120 (0x0120 - 0x0000)
struct ReligionRankListEntry_OnReligionRankRecordData final
{
public:
	struct FReligionRankRecordData                NewValue;                                          // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FReligionRankRecordData                OldValue;                                          // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ReligionRankListEntry_OnReligionRankRecordData) == 0x000008, "Wrong alignment on ReligionRankListEntry_OnReligionRankRecordData");
static_assert(sizeof(ReligionRankListEntry_OnReligionRankRecordData) == 0x000120, "Wrong size on ReligionRankListEntry_OnReligionRankRecordData");
static_assert(offsetof(ReligionRankListEntry_OnReligionRankRecordData, NewValue) == 0x000000, "Member 'ReligionRankListEntry_OnReligionRankRecordData::NewValue' has a wrong offset!");
static_assert(offsetof(ReligionRankListEntry_OnReligionRankRecordData, OldValue) == 0x000090, "Member 'ReligionRankListEntry_OnReligionRankRecordData::OldValue' has a wrong offset!");

// Function DungeonCrawler.SampleSubObject.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct SampleSubObject_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SampleSubObject_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on SampleSubObject_BroadcastMsgBlueprint");
static_assert(sizeof(SampleSubObject_BroadcastMsgBlueprint) == 0x000004, "Wrong size on SampleSubObject_BroadcastMsgBlueprint");
static_assert(offsetof(SampleSubObject_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'SampleSubObject_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.SampleSubObject.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct SampleSubObject_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SampleSubObject_UnbindMsg) == 0x000008, "Wrong alignment on SampleSubObject_UnbindMsg");
static_assert(sizeof(SampleSubObject_UnbindMsg) == 0x000010, "Wrong size on SampleSubObject_UnbindMsg");
static_assert(offsetof(SampleSubObject_UnbindMsg, InMsgType) == 0x000000, "Member 'SampleSubObject_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(SampleSubObject_UnbindMsg, InObject) == 0x000008, "Member 'SampleSubObject_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.SampleSubObject.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct SampleSubObject_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SampleSubObject_UnbindMsgAll) == 0x000008, "Wrong alignment on SampleSubObject_UnbindMsgAll");
static_assert(sizeof(SampleSubObject_UnbindMsgAll) == 0x000008, "Wrong size on SampleSubObject_UnbindMsgAll");
static_assert(offsetof(SampleSubObject_UnbindMsgAll, InObject) == 0x000000, "Member 'SampleSubObject_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.SampleObject.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct SampleObject_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SampleObject_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on SampleObject_BroadcastMsgBlueprint");
static_assert(sizeof(SampleObject_BroadcastMsgBlueprint) == 0x000004, "Wrong size on SampleObject_BroadcastMsgBlueprint");
static_assert(offsetof(SampleObject_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'SampleObject_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.SampleObject.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct SampleObject_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SampleObject_UnbindMsg) == 0x000008, "Wrong alignment on SampleObject_UnbindMsg");
static_assert(sizeof(SampleObject_UnbindMsg) == 0x000010, "Wrong size on SampleObject_UnbindMsg");
static_assert(offsetof(SampleObject_UnbindMsg, InMsgType) == 0x000000, "Member 'SampleObject_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(SampleObject_UnbindMsg, InObject) == 0x000008, "Member 'SampleObject_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.SampleObject.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct SampleObject_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SampleObject_UnbindMsgAll) == 0x000008, "Wrong alignment on SampleObject_UnbindMsgAll");
static_assert(sizeof(SampleObject_UnbindMsgAll) == 0x000008, "Wrong size on SampleObject_UnbindMsgAll");
static_assert(offsetof(SampleObject_UnbindMsgAll, InObject) == 0x000000, "Member 'SampleObject_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.ServerAccountSubsystem.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct ServerAccountSubsystem_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ServerAccountSubsystem_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on ServerAccountSubsystem_BroadcastMsgBlueprint");
static_assert(sizeof(ServerAccountSubsystem_BroadcastMsgBlueprint) == 0x000004, "Wrong size on ServerAccountSubsystem_BroadcastMsgBlueprint");
static_assert(offsetof(ServerAccountSubsystem_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'ServerAccountSubsystem_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.ServerAccountSubsystem.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct ServerAccountSubsystem_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ServerAccountSubsystem_UnbindMsg) == 0x000008, "Wrong alignment on ServerAccountSubsystem_UnbindMsg");
static_assert(sizeof(ServerAccountSubsystem_UnbindMsg) == 0x000010, "Wrong size on ServerAccountSubsystem_UnbindMsg");
static_assert(offsetof(ServerAccountSubsystem_UnbindMsg, InMsgType) == 0x000000, "Member 'ServerAccountSubsystem_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(ServerAccountSubsystem_UnbindMsg, InObject) == 0x000008, "Member 'ServerAccountSubsystem_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.ServerAccountSubsystem.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct ServerAccountSubsystem_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ServerAccountSubsystem_UnbindMsgAll) == 0x000008, "Wrong alignment on ServerAccountSubsystem_UnbindMsgAll");
static_assert(sizeof(ServerAccountSubsystem_UnbindMsgAll) == 0x000008, "Wrong size on ServerAccountSubsystem_UnbindMsgAll");
static_assert(offsetof(ServerAccountSubsystem_UnbindMsgAll, InObject) == 0x000000, "Member 'ServerAccountSubsystem_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.ShapeShiftComponent.OnRep_Data
// 0x0008 (0x0008 - 0x0000)
struct ShapeShiftComponent_OnRep_Data final
{
public:
	const class UDCShapeShiftDataAsset*           OldData;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ShapeShiftComponent_OnRep_Data) == 0x000008, "Wrong alignment on ShapeShiftComponent_OnRep_Data");
static_assert(sizeof(ShapeShiftComponent_OnRep_Data) == 0x000008, "Wrong size on ShapeShiftComponent_OnRep_Data");
static_assert(offsetof(ShapeShiftComponent_OnRep_Data, OldData) == 0x000000, "Member 'ShapeShiftComponent_OnRep_Data::OldData' has a wrong offset!");

// Function DungeonCrawler.SkillComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct SkillComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on SkillComponent_BroadcastMsgBlueprint");
static_assert(sizeof(SkillComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on SkillComponent_BroadcastMsgBlueprint");
static_assert(offsetof(SkillComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'SkillComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.SkillComponent.GameplayEffectStackChanged
// 0x0018 (0x0018 - 0x0000)
struct SkillComponent_GameplayEffectStackChanged final
{
public:
	struct FGameplayTag                           EffectGameplayTag;                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewStackCount;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreviousStackCount;                                // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_GameplayEffectStackChanged) == 0x000004, "Wrong alignment on SkillComponent_GameplayEffectStackChanged");
static_assert(sizeof(SkillComponent_GameplayEffectStackChanged) == 0x000018, "Wrong size on SkillComponent_GameplayEffectStackChanged");
static_assert(offsetof(SkillComponent_GameplayEffectStackChanged, EffectGameplayTag) == 0x000000, "Member 'SkillComponent_GameplayEffectStackChanged::EffectGameplayTag' has a wrong offset!");
static_assert(offsetof(SkillComponent_GameplayEffectStackChanged, EffectHandle) == 0x000008, "Member 'SkillComponent_GameplayEffectStackChanged::EffectHandle' has a wrong offset!");
static_assert(offsetof(SkillComponent_GameplayEffectStackChanged, NewStackCount) == 0x000010, "Member 'SkillComponent_GameplayEffectStackChanged::NewStackCount' has a wrong offset!");
static_assert(offsetof(SkillComponent_GameplayEffectStackChanged, PreviousStackCount) == 0x000014, "Member 'SkillComponent_GameplayEffectStackChanged::PreviousStackCount' has a wrong offset!");

// Function DungeonCrawler.SkillComponent.OnRep_SkillActorList
// 0x0010 (0x0010 - 0x0000)
struct SkillComponent_OnRep_SkillActorList final
{
public:
	TArray<class ASkillActor*>                    OldSkillActors;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_OnRep_SkillActorList) == 0x000008, "Wrong alignment on SkillComponent_OnRep_SkillActorList");
static_assert(sizeof(SkillComponent_OnRep_SkillActorList) == 0x000010, "Wrong size on SkillComponent_OnRep_SkillActorList");
static_assert(offsetof(SkillComponent_OnRep_SkillActorList, OldSkillActors) == 0x000000, "Member 'SkillComponent_OnRep_SkillActorList::OldSkillActors' has a wrong offset!");

// Function DungeonCrawler.SkillComponent.OnRep_SkillDataList
// 0x0010 (0x0010 - 0x0000)
struct SkillComponent_OnRep_SkillDataList final
{
public:
	TArray<struct FSkillDataInfo>                 OldSkillDataList;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_OnRep_SkillDataList) == 0x000008, "Wrong alignment on SkillComponent_OnRep_SkillDataList");
static_assert(sizeof(SkillComponent_OnRep_SkillDataList) == 0x000010, "Wrong size on SkillComponent_OnRep_SkillDataList");
static_assert(offsetof(SkillComponent_OnRep_SkillDataList, OldSkillDataList) == 0x000000, "Member 'SkillComponent_OnRep_SkillDataList::OldSkillDataList' has a wrong offset!");

// Function DungeonCrawler.SkillComponent.SetCooldownForDebug_Server
// 0x0001 (0x0001 - 0x0000)
struct SkillComponent_SetCooldownForDebug_Server final
{
public:
	bool                                          bNoCooldownTime;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_SetCooldownForDebug_Server) == 0x000001, "Wrong alignment on SkillComponent_SetCooldownForDebug_Server");
static_assert(sizeof(SkillComponent_SetCooldownForDebug_Server) == 0x000001, "Wrong size on SkillComponent_SetCooldownForDebug_Server");
static_assert(offsetof(SkillComponent_SetCooldownForDebug_Server, bNoCooldownTime) == 0x000000, "Member 'SkillComponent_SetCooldownForDebug_Server::bNoCooldownTime' has a wrong offset!");

// Function DungeonCrawler.SkillComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct SkillComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_UnbindMsg) == 0x000008, "Wrong alignment on SkillComponent_UnbindMsg");
static_assert(sizeof(SkillComponent_UnbindMsg) == 0x000010, "Wrong size on SkillComponent_UnbindMsg");
static_assert(offsetof(SkillComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'SkillComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(SkillComponent_UnbindMsg, InObject) == 0x000008, "Member 'SkillComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.SkillComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct SkillComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on SkillComponent_UnbindMsgAll");
static_assert(sizeof(SkillComponent_UnbindMsgAll) == 0x000008, "Wrong size on SkillComponent_UnbindMsgAll");
static_assert(offsetof(SkillComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'SkillComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.SkillWidget.InitializeSkillWidget
// 0x0010 (0x0010 - 0x0000)
struct SkillWidget_InitializeSkillWidget final
{
public:
	struct FPrimaryAssetId                        InSkillId;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillWidget_InitializeSkillWidget) == 0x000004, "Wrong alignment on SkillWidget_InitializeSkillWidget");
static_assert(sizeof(SkillWidget_InitializeSkillWidget) == 0x000010, "Wrong size on SkillWidget_InitializeSkillWidget");
static_assert(offsetof(SkillWidget_InitializeSkillWidget, InSkillId) == 0x000000, "Member 'SkillWidget_InitializeSkillWidget::InSkillId' has a wrong offset!");

// Function DungeonCrawler.SkillWidget.SetSkillData
// 0x0030 (0x0030 - 0x0000)
struct SkillWidget_SetSkillData final
{
public:
	class FText                                   SkillName;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   SkillDesc;                                         // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkillWidget_SetSkillData) == 0x000008, "Wrong alignment on SkillWidget_SetSkillData");
static_assert(sizeof(SkillWidget_SetSkillData) == 0x000030, "Wrong size on SkillWidget_SetSkillData");
static_assert(offsetof(SkillWidget_SetSkillData, SkillName) == 0x000000, "Member 'SkillWidget_SetSkillData::SkillName' has a wrong offset!");
static_assert(offsetof(SkillWidget_SetSkillData, SkillDesc) == 0x000018, "Member 'SkillWidget_SetSkillData::SkillDesc' has a wrong offset!");

// Function DungeonCrawler.SoundBlueprintLibrary.IsMute
// 0x0001 (0x0001 - 0x0000)
struct SoundBlueprintLibrary_IsMute final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundBlueprintLibrary_IsMute) == 0x000001, "Wrong alignment on SoundBlueprintLibrary_IsMute");
static_assert(sizeof(SoundBlueprintLibrary_IsMute) == 0x000001, "Wrong size on SoundBlueprintLibrary_IsMute");
static_assert(offsetof(SoundBlueprintLibrary_IsMute, ReturnValue) == 0x000000, "Member 'SoundBlueprintLibrary_IsMute::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundBlueprintLibrary.IsSoundPlayable
// 0x0020 (0x0020 - 0x0000)
struct SoundBlueprintLibrary_IsSoundPlayable final
{
public:
	class UObject*                                InSoundPlayer;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          InSoundProvider;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InSoundEventTag;                                   // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28DC[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SoundBlueprintLibrary_IsSoundPlayable) == 0x000008, "Wrong alignment on SoundBlueprintLibrary_IsSoundPlayable");
static_assert(sizeof(SoundBlueprintLibrary_IsSoundPlayable) == 0x000020, "Wrong size on SoundBlueprintLibrary_IsSoundPlayable");
static_assert(offsetof(SoundBlueprintLibrary_IsSoundPlayable, InSoundPlayer) == 0x000000, "Member 'SoundBlueprintLibrary_IsSoundPlayable::InSoundPlayer' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_IsSoundPlayable, InSoundProvider) == 0x000008, "Member 'SoundBlueprintLibrary_IsSoundPlayable::InSoundProvider' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_IsSoundPlayable, InSoundEventTag) == 0x000010, "Member 'SoundBlueprintLibrary_IsSoundPlayable::InSoundEventTag' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_IsSoundPlayable, ReturnValue) == 0x000018, "Member 'SoundBlueprintLibrary_IsSoundPlayable::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundBlueprintLibrary.PlaySound
// 0x0018 (0x0018 - 0x0000)
struct SoundBlueprintLibrary_PlaySound final
{
public:
	class UObject*                                InSoundPlayer;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28DD[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SoundBlueprintLibrary_PlaySound) == 0x000008, "Wrong alignment on SoundBlueprintLibrary_PlaySound");
static_assert(sizeof(SoundBlueprintLibrary_PlaySound) == 0x000018, "Wrong size on SoundBlueprintLibrary_PlaySound");
static_assert(offsetof(SoundBlueprintLibrary_PlaySound, InSoundPlayer) == 0x000000, "Member 'SoundBlueprintLibrary_PlaySound::InSoundPlayer' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySound, AkEvent) == 0x000008, "Member 'SoundBlueprintLibrary_PlaySound::AkEvent' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySound, ReturnValue) == 0x000010, "Member 'SoundBlueprintLibrary_PlaySound::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundOnPlayerController
// 0x0018 (0x0018 - 0x0000)
struct SoundBlueprintLibrary_PlaySoundOnPlayerController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28DE[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SoundBlueprintLibrary_PlaySoundOnPlayerController) == 0x000008, "Wrong alignment on SoundBlueprintLibrary_PlaySoundOnPlayerController");
static_assert(sizeof(SoundBlueprintLibrary_PlaySoundOnPlayerController) == 0x000018, "Wrong size on SoundBlueprintLibrary_PlaySoundOnPlayerController");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundOnPlayerController, WorldContextObject) == 0x000000, "Member 'SoundBlueprintLibrary_PlaySoundOnPlayerController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundOnPlayerController, AkEvent) == 0x000008, "Member 'SoundBlueprintLibrary_PlaySoundOnPlayerController::AkEvent' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundOnPlayerController, ReturnValue) == 0x000010, "Member 'SoundBlueprintLibrary_PlaySoundOnPlayerController::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundWithSwitch
// 0x0050 (0x0050 - 0x0000)
struct SoundBlueprintLibrary_PlaySoundWithSwitch final
{
public:
	class UObject*                                InSoundPlayer;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEvent;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          InSoundProvider;                                   // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0018(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              Surface;                                           // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28DF[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SwitchGroup;                                       // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SwitchState;                                       // 0x0038(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E0[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SoundBlueprintLibrary_PlaySoundWithSwitch) == 0x000008, "Wrong alignment on SoundBlueprintLibrary_PlaySoundWithSwitch");
static_assert(sizeof(SoundBlueprintLibrary_PlaySoundWithSwitch) == 0x000050, "Wrong size on SoundBlueprintLibrary_PlaySoundWithSwitch");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithSwitch, InSoundPlayer) == 0x000000, "Member 'SoundBlueprintLibrary_PlaySoundWithSwitch::InSoundPlayer' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithSwitch, AkEvent) == 0x000008, "Member 'SoundBlueprintLibrary_PlaySoundWithSwitch::AkEvent' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithSwitch, InSoundProvider) == 0x000010, "Member 'SoundBlueprintLibrary_PlaySoundWithSwitch::InSoundProvider' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithSwitch, Tag) == 0x000018, "Member 'SoundBlueprintLibrary_PlaySoundWithSwitch::Tag' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithSwitch, Surface) == 0x000020, "Member 'SoundBlueprintLibrary_PlaySoundWithSwitch::Surface' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithSwitch, SwitchGroup) == 0x000028, "Member 'SoundBlueprintLibrary_PlaySoundWithSwitch::SwitchGroup' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithSwitch, SwitchState) == 0x000038, "Member 'SoundBlueprintLibrary_PlaySoundWithSwitch::SwitchState' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithSwitch, ReturnValue) == 0x000048, "Member 'SoundBlueprintLibrary_PlaySoundWithSwitch::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundWithTag
// 0x0020 (0x0020 - 0x0000)
struct SoundBlueprintLibrary_PlaySoundWithTag final
{
public:
	class UObject*                                InSoundPlayer;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UObject*                          InSoundProvider;                                   // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E1[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SoundBlueprintLibrary_PlaySoundWithTag) == 0x000008, "Wrong alignment on SoundBlueprintLibrary_PlaySoundWithTag");
static_assert(sizeof(SoundBlueprintLibrary_PlaySoundWithTag) == 0x000020, "Wrong size on SoundBlueprintLibrary_PlaySoundWithTag");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithTag, InSoundPlayer) == 0x000000, "Member 'SoundBlueprintLibrary_PlaySoundWithTag::InSoundPlayer' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithTag, InSoundProvider) == 0x000008, "Member 'SoundBlueprintLibrary_PlaySoundWithTag::InSoundProvider' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithTag, Tag) == 0x000010, "Member 'SoundBlueprintLibrary_PlaySoundWithTag::Tag' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_PlaySoundWithTag, ReturnValue) == 0x000018, "Member 'SoundBlueprintLibrary_PlaySoundWithTag::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundBlueprintLibrary.SetRTPCValue
// 0x0020 (0x0020 - 0x0000)
struct SoundBlueprintLibrary_SetRTPCValue final
{
public:
	class UObject*                                InSoundPlayer;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAkRtpc*                          RtpcValue;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterpolationTimeMs;                               // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E2[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SoundBlueprintLibrary_SetRTPCValue) == 0x000008, "Wrong alignment on SoundBlueprintLibrary_SetRTPCValue");
static_assert(sizeof(SoundBlueprintLibrary_SetRTPCValue) == 0x000020, "Wrong size on SoundBlueprintLibrary_SetRTPCValue");
static_assert(offsetof(SoundBlueprintLibrary_SetRTPCValue, InSoundPlayer) == 0x000000, "Member 'SoundBlueprintLibrary_SetRTPCValue::InSoundPlayer' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_SetRTPCValue, RtpcValue) == 0x000008, "Member 'SoundBlueprintLibrary_SetRTPCValue::RtpcValue' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_SetRTPCValue, Value) == 0x000010, "Member 'SoundBlueprintLibrary_SetRTPCValue::Value' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_SetRTPCValue, InterpolationTimeMs) == 0x000014, "Member 'SoundBlueprintLibrary_SetRTPCValue::InterpolationTimeMs' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_SetRTPCValue, ReturnValue) == 0x000018, "Member 'SoundBlueprintLibrary_SetRTPCValue::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundBlueprintLibrary.SetSwitch
// 0x0018 (0x0018 - 0x0000)
struct SoundBlueprintLibrary_SetSwitch final
{
public:
	class UObject*                                InSoundPlayer;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkSwitchValue*                         AkSwitchValue;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E3[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SoundBlueprintLibrary_SetSwitch) == 0x000008, "Wrong alignment on SoundBlueprintLibrary_SetSwitch");
static_assert(sizeof(SoundBlueprintLibrary_SetSwitch) == 0x000018, "Wrong size on SoundBlueprintLibrary_SetSwitch");
static_assert(offsetof(SoundBlueprintLibrary_SetSwitch, InSoundPlayer) == 0x000000, "Member 'SoundBlueprintLibrary_SetSwitch::InSoundPlayer' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_SetSwitch, AkSwitchValue) == 0x000008, "Member 'SoundBlueprintLibrary_SetSwitch::AkSwitchValue' has a wrong offset!");
static_assert(offsetof(SoundBlueprintLibrary_SetSwitch, ReturnValue) == 0x000010, "Member 'SoundBlueprintLibrary_SetSwitch::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundProvider.GetEvent
// 0x0010 (0x0010 - 0x0000)
struct SoundProvider_GetEvent final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundProvider_GetEvent) == 0x000008, "Wrong alignment on SoundProvider_GetEvent");
static_assert(sizeof(SoundProvider_GetEvent) == 0x000010, "Wrong size on SoundProvider_GetEvent");
static_assert(offsetof(SoundProvider_GetEvent, Tag) == 0x000000, "Member 'SoundProvider_GetEvent::Tag' has a wrong offset!");
static_assert(offsetof(SoundProvider_GetEvent, ReturnValue) == 0x000008, "Member 'SoundProvider_GetEvent::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundProvider.GetEvents
// 0x0050 (0x0050 - 0x0000)
struct SoundProvider_GetEvents final
{
public:
	TMap<struct FGameplayTag, class UAkAudioEvent*> ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundProvider_GetEvents) == 0x000008, "Wrong alignment on SoundProvider_GetEvents");
static_assert(sizeof(SoundProvider_GetEvents) == 0x000050, "Wrong size on SoundProvider_GetEvents");
static_assert(offsetof(SoundProvider_GetEvents, ReturnValue) == 0x000000, "Member 'SoundProvider_GetEvents::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundProvider.GetLastPrimaryAssetId
// 0x0010 (0x0010 - 0x0000)
struct SoundProvider_GetLastPrimaryAssetId final
{
public:
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundProvider_GetLastPrimaryAssetId) == 0x000004, "Wrong alignment on SoundProvider_GetLastPrimaryAssetId");
static_assert(sizeof(SoundProvider_GetLastPrimaryAssetId) == 0x000010, "Wrong size on SoundProvider_GetLastPrimaryAssetId");
static_assert(offsetof(SoundProvider_GetLastPrimaryAssetId, ReturnValue) == 0x000000, "Member 'SoundProvider_GetLastPrimaryAssetId::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundProvider.GetSwitch
// 0x0018 (0x0018 - 0x0000)
struct SoundProvider_GetSwitch final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              Surface;                                           // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28E4[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkSwitchValue*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundProvider_GetSwitch) == 0x000008, "Wrong alignment on SoundProvider_GetSwitch");
static_assert(sizeof(SoundProvider_GetSwitch) == 0x000018, "Wrong size on SoundProvider_GetSwitch");
static_assert(offsetof(SoundProvider_GetSwitch, Tag) == 0x000000, "Member 'SoundProvider_GetSwitch::Tag' has a wrong offset!");
static_assert(offsetof(SoundProvider_GetSwitch, Surface) == 0x000008, "Member 'SoundProvider_GetSwitch::Surface' has a wrong offset!");
static_assert(offsetof(SoundProvider_GetSwitch, ReturnValue) == 0x000010, "Member 'SoundProvider_GetSwitch::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundProvider.GetSwitches
// 0x0050 (0x0050 - 0x0000)
struct SoundProvider_GetSwitches final
{
public:
	TMap<struct FGameplayTag, struct FDCSoundDataContainer> ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundProvider_GetSwitches) == 0x000008, "Wrong alignment on SoundProvider_GetSwitches");
static_assert(sizeof(SoundProvider_GetSwitches) == 0x000050, "Wrong size on SoundProvider_GetSwitches");
static_assert(offsetof(SoundProvider_GetSwitches, ReturnValue) == 0x000000, "Member 'SoundProvider_GetSwitches::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundProvider.GetTagQueries
// 0x0050 (0x0050 - 0x0000)
struct SoundProvider_GetTagQueries final
{
public:
	TMap<struct FGameplayTag, struct FGameplayTagQuery> ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundProvider_GetTagQueries) == 0x000008, "Wrong alignment on SoundProvider_GetTagQueries");
static_assert(sizeof(SoundProvider_GetTagQueries) == 0x000050, "Wrong size on SoundProvider_GetTagQueries");
static_assert(offsetof(SoundProvider_GetTagQueries, ReturnValue) == 0x000000, "Member 'SoundProvider_GetTagQueries::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SoundProvider.GetTagQuery
// 0x0050 (0x0050 - 0x0000)
struct SoundProvider_GetTagQuery final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      ReturnValue;                                       // 0x0008(0x0048)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SoundProvider_GetTagQuery) == 0x000008, "Wrong alignment on SoundProvider_GetTagQuery");
static_assert(sizeof(SoundProvider_GetTagQuery) == 0x000050, "Wrong size on SoundProvider_GetTagQuery");
static_assert(offsetof(SoundProvider_GetTagQuery, Tag) == 0x000000, "Member 'SoundProvider_GetTagQuery::Tag' has a wrong offset!");
static_assert(offsetof(SoundProvider_GetTagQuery, ReturnValue) == 0x000008, "Member 'SoundProvider_GetTagQuery::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SpellActor.OnRep_SpellData
// 0x0040 (0x0040 - 0x0000)
struct SpellActor_OnRep_SpellData final
{
public:
	struct FSpellData                             OldSpellData;                                      // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellActor_OnRep_SpellData) == 0x000004, "Wrong alignment on SpellActor_OnRep_SpellData");
static_assert(sizeof(SpellActor_OnRep_SpellData) == 0x000040, "Wrong size on SpellActor_OnRep_SpellData");
static_assert(offsetof(SpellActor_OnRep_SpellData, OldSpellData) == 0x000000, "Member 'SpellActor_OnRep_SpellData::OldSpellData' has a wrong offset!");

// Function DungeonCrawler.SpellActor.GetArtDataSpell
// 0x0008 (0x0008 - 0x0000)
struct SpellActor_GetArtDataSpell final
{
public:
	class UArtDataSpell*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellActor_GetArtDataSpell) == 0x000008, "Wrong alignment on SpellActor_GetArtDataSpell");
static_assert(sizeof(SpellActor_GetArtDataSpell) == 0x000008, "Wrong size on SpellActor_GetArtDataSpell");
static_assert(offsetof(SpellActor_GetArtDataSpell, ReturnValue) == 0x000000, "Member 'SpellActor_GetArtDataSpell::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SpellActor.GetDesignDataSpell
// 0x00D8 (0x00D8 - 0x0000)
struct SpellActor_GetDesignDataSpell final
{
public:
	struct FDesignDataSpell                       ReturnValue;                                       // 0x0000(0x00D8)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellActor_GetDesignDataSpell) == 0x000008, "Wrong alignment on SpellActor_GetDesignDataSpell");
static_assert(sizeof(SpellActor_GetDesignDataSpell) == 0x0000D8, "Wrong size on SpellActor_GetDesignDataSpell");
static_assert(offsetof(SpellActor_GetDesignDataSpell, ReturnValue) == 0x000000, "Member 'SpellActor_GetDesignDataSpell::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SpellActor.GetSoundDataSpell
// 0x0008 (0x0008 - 0x0000)
struct SpellActor_GetSoundDataSpell final
{
public:
	class USoundData*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellActor_GetSoundDataSpell) == 0x000008, "Wrong alignment on SpellActor_GetSoundDataSpell");
static_assert(sizeof(SpellActor_GetSoundDataSpell) == 0x000008, "Wrong size on SpellActor_GetSoundDataSpell");
static_assert(offsetof(SpellActor_GetSoundDataSpell, ReturnValue) == 0x000000, "Member 'SpellActor_GetSoundDataSpell::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SpellActor.GetSpellData
// 0x0040 (0x0040 - 0x0000)
struct SpellActor_GetSpellData final
{
public:
	struct FSpellData                             ReturnValue;                                       // 0x0000(0x0040)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellActor_GetSpellData) == 0x000004, "Wrong alignment on SpellActor_GetSpellData");
static_assert(sizeof(SpellActor_GetSpellData) == 0x000040, "Wrong size on SpellActor_GetSpellData");
static_assert(offsetof(SpellActor_GetSpellData, ReturnValue) == 0x000000, "Member 'SpellActor_GetSpellData::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.SpellComponent.BroadcastMsgBlueprint
// 0x0004 (0x0004 - 0x0000)
struct SpellComponent_BroadcastMsgBlueprint final
{
public:
	int32                                         InMsg;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong alignment on SpellComponent_BroadcastMsgBlueprint");
static_assert(sizeof(SpellComponent_BroadcastMsgBlueprint) == 0x000004, "Wrong size on SpellComponent_BroadcastMsgBlueprint");
static_assert(offsetof(SpellComponent_BroadcastMsgBlueprint, InMsg) == 0x000000, "Member 'SpellComponent_BroadcastMsgBlueprint::InMsg' has a wrong offset!");

// Function DungeonCrawler.SpellComponent.OnRep_SpellActors
// 0x0010 (0x0010 - 0x0000)
struct SpellComponent_OnRep_SpellActors final
{
public:
	TArray<class ASpellActor*>                    OldASpellActors;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellComponent_OnRep_SpellActors) == 0x000008, "Wrong alignment on SpellComponent_OnRep_SpellActors");
static_assert(sizeof(SpellComponent_OnRep_SpellActors) == 0x000010, "Wrong size on SpellComponent_OnRep_SpellActors");
static_assert(offsetof(SpellComponent_OnRep_SpellActors, OldASpellActors) == 0x000000, "Member 'SpellComponent_OnRep_SpellActors::OldASpellActors' has a wrong offset!");

// Function DungeonCrawler.SpellComponent.ServerSetCurrentSpell
// 0x0008 (0x0008 - 0x0000)
struct SpellComponent_ServerSetCurrentSpell final
{
public:
	struct FGameplayTag                           SpellTag;                                          // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellComponent_ServerSetCurrentSpell) == 0x000004, "Wrong alignment on SpellComponent_ServerSetCurrentSpell");
static_assert(sizeof(SpellComponent_ServerSetCurrentSpell) == 0x000008, "Wrong size on SpellComponent_ServerSetCurrentSpell");
static_assert(offsetof(SpellComponent_ServerSetCurrentSpell, SpellTag) == 0x000000, "Member 'SpellComponent_ServerSetCurrentSpell::SpellTag' has a wrong offset!");

// Function DungeonCrawler.SpellComponent.UnbindMsg
// 0x0010 (0x0010 - 0x0000)
struct SpellComponent_UnbindMsg final
{
public:
	class UScriptStruct*                          InMsgType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellComponent_UnbindMsg) == 0x000008, "Wrong alignment on SpellComponent_UnbindMsg");
static_assert(sizeof(SpellComponent_UnbindMsg) == 0x000010, "Wrong size on SpellComponent_UnbindMsg");
static_assert(offsetof(SpellComponent_UnbindMsg, InMsgType) == 0x000000, "Member 'SpellComponent_UnbindMsg::InMsgType' has a wrong offset!");
static_assert(offsetof(SpellComponent_UnbindMsg, InObject) == 0x000008, "Member 'SpellComponent_UnbindMsg::InObject' has a wrong offset!");

// Function DungeonCrawler.SpellComponent.UnbindMsgAll
// 0x0008 (0x0008 - 0x0000)
struct SpellComponent_UnbindMsgAll final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpellComponent_UnbindMsgAll) == 0x000008, "Wrong alignment on SpellComponent_UnbindMsgAll");
static_assert(sizeof(SpellComponent_UnbindMsgAll) == 0x000008, "Wrong size on SpellComponent_UnbindMsgAll");
static_assert(offsetof(SpellComponent_UnbindMsgAll, InObject) == 0x000000, "Member 'SpellComponent_UnbindMsgAll::InObject' has a wrong offset!");

// Function DungeonCrawler.TestItemInjectionWidgetBase.OnCanEquipCheckBoxStateChanged
// 0x0001 (0x0001 - 0x0000)
struct TestItemInjectionWidgetBase_OnCanEquipCheckBoxStateChanged final
{
public:
	bool                                          bIsChecked;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestItemInjectionWidgetBase_OnCanEquipCheckBoxStateChanged) == 0x000001, "Wrong alignment on TestItemInjectionWidgetBase_OnCanEquipCheckBoxStateChanged");
static_assert(sizeof(TestItemInjectionWidgetBase_OnCanEquipCheckBoxStateChanged) == 0x000001, "Wrong size on TestItemInjectionWidgetBase_OnCanEquipCheckBoxStateChanged");
static_assert(offsetof(TestItemInjectionWidgetBase_OnCanEquipCheckBoxStateChanged, bIsChecked) == 0x000000, "Member 'TestItemInjectionWidgetBase_OnCanEquipCheckBoxStateChanged::bIsChecked' has a wrong offset!");

// Function DungeonCrawler.TestItemInjectionWidgetBase.OnGenerateCountTextChanged
// 0x0018 (0x0018 - 0x0000)
struct TestItemInjectionWidgetBase_OnGenerateCountTextChanged final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestItemInjectionWidgetBase_OnGenerateCountTextChanged) == 0x000008, "Wrong alignment on TestItemInjectionWidgetBase_OnGenerateCountTextChanged");
static_assert(sizeof(TestItemInjectionWidgetBase_OnGenerateCountTextChanged) == 0x000018, "Wrong size on TestItemInjectionWidgetBase_OnGenerateCountTextChanged");
static_assert(offsetof(TestItemInjectionWidgetBase_OnGenerateCountTextChanged, InText) == 0x000000, "Member 'TestItemInjectionWidgetBase_OnGenerateCountTextChanged::InText' has a wrong offset!");

// Function DungeonCrawler.TestItemInjectionWidgetBase.OnItemChildTypeSelected
// 0x0008 (0x0008 - 0x0000)
struct TestItemInjectionWidgetBase_OnItemChildTypeSelected final
{
public:
	class UObject*                                WidgetData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestItemInjectionWidgetBase_OnItemChildTypeSelected) == 0x000008, "Wrong alignment on TestItemInjectionWidgetBase_OnItemChildTypeSelected");
static_assert(sizeof(TestItemInjectionWidgetBase_OnItemChildTypeSelected) == 0x000008, "Wrong size on TestItemInjectionWidgetBase_OnItemChildTypeSelected");
static_assert(offsetof(TestItemInjectionWidgetBase_OnItemChildTypeSelected, WidgetData) == 0x000000, "Member 'TestItemInjectionWidgetBase_OnItemChildTypeSelected::WidgetData' has a wrong offset!");

// Function DungeonCrawler.TestItemInjectionWidgetBase.OnItemPropertySelected
// 0x0008 (0x0008 - 0x0000)
struct TestItemInjectionWidgetBase_OnItemPropertySelected final
{
public:
	class UObject*                                WidgetData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestItemInjectionWidgetBase_OnItemPropertySelected) == 0x000008, "Wrong alignment on TestItemInjectionWidgetBase_OnItemPropertySelected");
static_assert(sizeof(TestItemInjectionWidgetBase_OnItemPropertySelected) == 0x000008, "Wrong size on TestItemInjectionWidgetBase_OnItemPropertySelected");
static_assert(offsetof(TestItemInjectionWidgetBase_OnItemPropertySelected, WidgetData) == 0x000000, "Member 'TestItemInjectionWidgetBase_OnItemPropertySelected::WidgetData' has a wrong offset!");

// Function DungeonCrawler.TestItemInjectionWidgetBase.OnItemRaritySelected
// 0x0008 (0x0008 - 0x0000)
struct TestItemInjectionWidgetBase_OnItemRaritySelected final
{
public:
	class UObject*                                WidgetData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestItemInjectionWidgetBase_OnItemRaritySelected) == 0x000008, "Wrong alignment on TestItemInjectionWidgetBase_OnItemRaritySelected");
static_assert(sizeof(TestItemInjectionWidgetBase_OnItemRaritySelected) == 0x000008, "Wrong size on TestItemInjectionWidgetBase_OnItemRaritySelected");
static_assert(offsetof(TestItemInjectionWidgetBase_OnItemRaritySelected, WidgetData) == 0x000000, "Member 'TestItemInjectionWidgetBase_OnItemRaritySelected::WidgetData' has a wrong offset!");

// Function DungeonCrawler.TestItemInjectionWidgetBase.OnItemSelected
// 0x0008 (0x0008 - 0x0000)
struct TestItemInjectionWidgetBase_OnItemSelected final
{
public:
	class UObject*                                WidgetData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestItemInjectionWidgetBase_OnItemSelected) == 0x000008, "Wrong alignment on TestItemInjectionWidgetBase_OnItemSelected");
static_assert(sizeof(TestItemInjectionWidgetBase_OnItemSelected) == 0x000008, "Wrong size on TestItemInjectionWidgetBase_OnItemSelected");
static_assert(offsetof(TestItemInjectionWidgetBase_OnItemSelected, WidgetData) == 0x000000, "Member 'TestItemInjectionWidgetBase_OnItemSelected::WidgetData' has a wrong offset!");

// Function DungeonCrawler.TestItemInjectionWidgetBase.OnItemTypeSelected
// 0x0008 (0x0008 - 0x0000)
struct TestItemInjectionWidgetBase_OnItemTypeSelected final
{
public:
	class UObject*                                WidgetData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestItemInjectionWidgetBase_OnItemTypeSelected) == 0x000008, "Wrong alignment on TestItemInjectionWidgetBase_OnItemTypeSelected");
static_assert(sizeof(TestItemInjectionWidgetBase_OnItemTypeSelected) == 0x000008, "Wrong size on TestItemInjectionWidgetBase_OnItemTypeSelected");
static_assert(offsetof(TestItemInjectionWidgetBase_OnItemTypeSelected, WidgetData) == 0x000000, "Member 'TestItemInjectionWidgetBase_OnItemTypeSelected::WidgetData' has a wrong offset!");

// Function DungeonCrawler.TestItemInjectionWidgetBase.OnPropertySearchTextChanged
// 0x0018 (0x0018 - 0x0000)
struct TestItemInjectionWidgetBase_OnPropertySearchTextChanged final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestItemInjectionWidgetBase_OnPropertySearchTextChanged) == 0x000008, "Wrong alignment on TestItemInjectionWidgetBase_OnPropertySearchTextChanged");
static_assert(sizeof(TestItemInjectionWidgetBase_OnPropertySearchTextChanged) == 0x000018, "Wrong size on TestItemInjectionWidgetBase_OnPropertySearchTextChanged");
static_assert(offsetof(TestItemInjectionWidgetBase_OnPropertySearchTextChanged, InText) == 0x000000, "Member 'TestItemInjectionWidgetBase_OnPropertySearchTextChanged::InText' has a wrong offset!");

// Function DungeonCrawler.TestItemInjectionWidgetBase.OnSearchTextChanged
// 0x0018 (0x0018 - 0x0000)
struct TestItemInjectionWidgetBase_OnSearchTextChanged final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestItemInjectionWidgetBase_OnSearchTextChanged) == 0x000008, "Wrong alignment on TestItemInjectionWidgetBase_OnSearchTextChanged");
static_assert(sizeof(TestItemInjectionWidgetBase_OnSearchTextChanged) == 0x000018, "Wrong size on TestItemInjectionWidgetBase_OnSearchTextChanged");
static_assert(offsetof(TestItemInjectionWidgetBase_OnSearchTextChanged, InText) == 0x000000, "Member 'TestItemInjectionWidgetBase_OnSearchTextChanged::InText' has a wrong offset!");

// Function DungeonCrawler.TestItemInjectionWidgetBase.OnSelectedPropertyValueChanged
// 0x0014 (0x0014 - 0x0000)
struct TestItemInjectionWidgetBase_OnSelectedPropertyValueChanged final
{
public:
	struct FPrimaryAssetId                        PropertyTypeAssetId;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InPropertyValue;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestItemInjectionWidgetBase_OnSelectedPropertyValueChanged) == 0x000004, "Wrong alignment on TestItemInjectionWidgetBase_OnSelectedPropertyValueChanged");
static_assert(sizeof(TestItemInjectionWidgetBase_OnSelectedPropertyValueChanged) == 0x000014, "Wrong size on TestItemInjectionWidgetBase_OnSelectedPropertyValueChanged");
static_assert(offsetof(TestItemInjectionWidgetBase_OnSelectedPropertyValueChanged, PropertyTypeAssetId) == 0x000000, "Member 'TestItemInjectionWidgetBase_OnSelectedPropertyValueChanged::PropertyTypeAssetId' has a wrong offset!");
static_assert(offsetof(TestItemInjectionWidgetBase_OnSelectedPropertyValueChanged, InPropertyValue) == 0x000010, "Member 'TestItemInjectionWidgetBase_OnSelectedPropertyValueChanged::InPropertyValue' has a wrong offset!");

// Function DungeonCrawler.TotalGoldCountWidgetBase.CountTotalGold
// 0x0004 (0x0004 - 0x0000)
struct TotalGoldCountWidgetBase_CountTotalGold final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TotalGoldCountWidgetBase_CountTotalGold) == 0x000004, "Wrong alignment on TotalGoldCountWidgetBase_CountTotalGold");
static_assert(sizeof(TotalGoldCountWidgetBase_CountTotalGold) == 0x000004, "Wrong size on TotalGoldCountWidgetBase_CountTotalGold");
static_assert(offsetof(TotalGoldCountWidgetBase_CountTotalGold, ReturnValue) == 0x000000, "Member 'TotalGoldCountWidgetBase_CountTotalGold::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.TradeChannelButtonBase.SetChannelName
// 0x0020 (0x0020 - 0x0000)
struct TradeChannelButtonBase_SetChannelName final
{
public:
	class FText                                   InChannelName;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         InIndex;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28EB[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TradeChannelButtonBase_SetChannelName) == 0x000008, "Wrong alignment on TradeChannelButtonBase_SetChannelName");
static_assert(sizeof(TradeChannelButtonBase_SetChannelName) == 0x000020, "Wrong size on TradeChannelButtonBase_SetChannelName");
static_assert(offsetof(TradeChannelButtonBase_SetChannelName, InChannelName) == 0x000000, "Member 'TradeChannelButtonBase_SetChannelName::InChannelName' has a wrong offset!");
static_assert(offsetof(TradeChannelButtonBase_SetChannelName, InIndex) == 0x000018, "Member 'TradeChannelButtonBase_SetChannelName::InIndex' has a wrong offset!");

// Function DungeonCrawler.TradeChannelButtonBase.SetMemberText
// 0x0004 (0x0004 - 0x0000)
struct TradeChannelButtonBase_SetMemberText final
{
public:
	int32                                         InMemberCount;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelButtonBase_SetMemberText) == 0x000004, "Wrong alignment on TradeChannelButtonBase_SetMemberText");
static_assert(sizeof(TradeChannelButtonBase_SetMemberText) == 0x000004, "Wrong size on TradeChannelButtonBase_SetMemberText");
static_assert(offsetof(TradeChannelButtonBase_SetMemberText, InMemberCount) == 0x000000, "Member 'TradeChannelButtonBase_SetMemberText::InMemberCount' has a wrong offset!");

// Function DungeonCrawler.TradeChannelListWidget.CannotEnterTradingPost
// 0x0001 (0x0001 - 0x0000)
struct TradeChannelListWidget_CannotEnterTradingPost final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeChannelListWidget_CannotEnterTradingPost) == 0x000001, "Wrong alignment on TradeChannelListWidget_CannotEnterTradingPost");
static_assert(sizeof(TradeChannelListWidget_CannotEnterTradingPost) == 0x000001, "Wrong size on TradeChannelListWidget_CannotEnterTradingPost");
static_assert(offsetof(TradeChannelListWidget_CannotEnterTradingPost, ReturnValue) == 0x000000, "Member 'TradeChannelListWidget_CannotEnterTradingPost::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.TradeUserListWidget.OnTextChanged
// 0x0018 (0x0018 - 0x0000)
struct TradeUserListWidget_OnTextChanged final
{
public:
	class FText                                   FindId;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TradeUserListWidget_OnTextChanged) == 0x000008, "Wrong alignment on TradeUserListWidget_OnTextChanged");
static_assert(sizeof(TradeUserListWidget_OnTextChanged) == 0x000018, "Wrong size on TradeUserListWidget_OnTextChanged");
static_assert(offsetof(TradeUserListWidget_OnTextChanged, FindId) == 0x000000, "Member 'TradeUserListWidget_OnTextChanged::FindId' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitforOverlap.WaitForOverlap
// 0x0018 (0x0018 - 0x0000)
struct DCAT_WaitforOverlap_WaitForOverlap final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTriggerOnce;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F3[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitforOverlap*                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitforOverlap_WaitForOverlap) == 0x000008, "Wrong alignment on DCAT_WaitforOverlap_WaitForOverlap");
static_assert(sizeof(DCAT_WaitforOverlap_WaitForOverlap) == 0x000018, "Wrong size on DCAT_WaitforOverlap_WaitForOverlap");
static_assert(offsetof(DCAT_WaitforOverlap_WaitForOverlap, OwningAbility) == 0x000000, "Member 'DCAT_WaitforOverlap_WaitForOverlap::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitforOverlap_WaitForOverlap, bOnlyTriggerOnce) == 0x000008, "Member 'DCAT_WaitforOverlap_WaitForOverlap::bOnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitforOverlap_WaitForOverlap, ReturnValue) == 0x000010, "Member 'DCAT_WaitforOverlap_WaitForOverlap::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitforOverlap.WaitForOverlapByClass
// 0x0020 (0x0020 - 0x0000)
struct DCAT_WaitforOverlap_WaitForOverlapByClass final
{
public:
	class UGameplayAbility*                       OwningAbility;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyTriggerOnce;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28F4[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCAT_WaitforOverlap*                   ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitforOverlap_WaitForOverlapByClass) == 0x000008, "Wrong alignment on DCAT_WaitforOverlap_WaitForOverlapByClass");
static_assert(sizeof(DCAT_WaitforOverlap_WaitForOverlapByClass) == 0x000020, "Wrong size on DCAT_WaitforOverlap_WaitForOverlapByClass");
static_assert(offsetof(DCAT_WaitforOverlap_WaitForOverlapByClass, OwningAbility) == 0x000000, "Member 'DCAT_WaitforOverlap_WaitForOverlapByClass::OwningAbility' has a wrong offset!");
static_assert(offsetof(DCAT_WaitforOverlap_WaitForOverlapByClass, TargetActor) == 0x000008, "Member 'DCAT_WaitforOverlap_WaitForOverlapByClass::TargetActor' has a wrong offset!");
static_assert(offsetof(DCAT_WaitforOverlap_WaitForOverlapByClass, bOnlyTriggerOnce) == 0x000010, "Member 'DCAT_WaitforOverlap_WaitForOverlapByClass::bOnlyTriggerOnce' has a wrong offset!");
static_assert(offsetof(DCAT_WaitforOverlap_WaitForOverlapByClass, ReturnValue) == 0x000018, "Member 'DCAT_WaitforOverlap_WaitForOverlapByClass::ReturnValue' has a wrong offset!");

// Function DungeonCrawler.DCAT_WaitforOverlap.OnHitCallback
// 0x0118 (0x0118 - 0x0000)
struct DCAT_WaitforOverlap_OnHitCallback final
{
public:
	class UPrimitiveComponent*                    HitComp;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0030(0x00E8)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DCAT_WaitforOverlap_OnHitCallback) == 0x000008, "Wrong alignment on DCAT_WaitforOverlap_OnHitCallback");
static_assert(sizeof(DCAT_WaitforOverlap_OnHitCallback) == 0x000118, "Wrong size on DCAT_WaitforOverlap_OnHitCallback");
static_assert(offsetof(DCAT_WaitforOverlap_OnHitCallback, HitComp) == 0x000000, "Member 'DCAT_WaitforOverlap_OnHitCallback::HitComp' has a wrong offset!");
static_assert(offsetof(DCAT_WaitforOverlap_OnHitCallback, OtherActor) == 0x000008, "Member 'DCAT_WaitforOverlap_OnHitCallback::OtherActor' has a wrong offset!");
static_assert(offsetof(DCAT_WaitforOverlap_OnHitCallback, OtherComp) == 0x000010, "Member 'DCAT_WaitforOverlap_OnHitCallback::OtherComp' has a wrong offset!");
static_assert(offsetof(DCAT_WaitforOverlap_OnHitCallback, NormalImpulse) == 0x000018, "Member 'DCAT_WaitforOverlap_OnHitCallback::NormalImpulse' has a wrong offset!");
static_assert(offsetof(DCAT_WaitforOverlap_OnHitCallback, Hit) == 0x000030, "Member 'DCAT_WaitforOverlap_OnHitCallback::Hit' has a wrong offset!");

}

