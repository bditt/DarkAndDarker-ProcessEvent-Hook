#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DragonIKPlugin

#include "Basic.hpp"

#include "DragonIKPlugin_classes.hpp"
#include "DragonIKPlugin_parameters.hpp"


namespace SDK
{

// Function DragonIKPlugin.DragonIKFootStepsComponent.CallFootSteps
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// class FName                             bone_name                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Foot_transform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height_difference                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit_info                                               (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDragonIKFootStepsComponent::CallFootSteps(class FName bone_name, const struct FTransform& Foot_transform, float Height_difference, const struct FHitResult& Hit_info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKFootStepsComponent", "CallFootSteps");

	Params::DragonIKFootStepsComponent_CallFootSteps Parms{};

	Parms.bone_name = bone_name;
	Parms.Foot_transform = std::move(Foot_transform);
	Parms.Height_difference = Height_difference;
	Parms.Hit_info = std::move(Hit_info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.CacheSimulationStates
// (Final, Native, Public, BlueprintCallable)

void UDragonIKPhysicsComponent::CacheSimulationStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "CacheSimulationStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Control_Bone_Handle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             bone_name                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Override_transform                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Control_Bone_Handle(class FName bone_name, const struct FTransform& Override_transform, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Control_Bone_Handle");

	Params::DragonIKPhysicsComponent_Control_Bone_Handle Parms{};

	Parms.bone_name = bone_name;
	Parms.Override_transform = std::move(Override_transform);
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.FirstTimeInitialization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::FirstTimeInitialization(class USkeletalMeshComponent* Skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "FirstTimeInitialization");

	Params::DragonIKPhysicsComponent_FirstTimeInitialization Parms{};

	Parms.Skeleton_input = Skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Modify_Reset_Bone_Info
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     bone_list                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Modify_Reset_Bone_Info(const TArray<class FName>& bone_list)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Modify_Reset_Bone_Info");

	Params::DragonIKPhysicsComponent_Modify_Reset_Bone_Info Parms{};

	Parms.bone_list = std::move(bone_list);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_CacheSimulationStates
// (Net, Native, Event, NetMulticast, Public, NetValidate)

void UDragonIKPhysicsComponent::Multicast_CacheSimulationStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_CacheSimulationStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_Control_Bone_Handle
// (Net, Native, Event, NetMulticast, Public, HasDefaults, NetValidate)
// Parameters:
// class FName                             bone_name                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Override_transform                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_Control_Bone_Handle(class FName bone_name, const struct FTransform& Override_transform, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_Control_Bone_Handle");

	Params::DragonIKPhysicsComponent_Multicast_Control_Bone_Handle Parms{};

	Parms.bone_name = bone_name;
	Parms.Override_transform = std::move(Override_transform);
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_DragonIKSimulatePhysics
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           Skmesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_DragonIKSimulatePhysics(class USkeletalMeshComponent* Skmesh, class FName BoneName, bool IncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_DragonIKSimulatePhysics");

	Params::DragonIKPhysicsComponent_Multicast_DragonIKSimulatePhysics Parms{};

	Parms.Skmesh = Skmesh;
	Parms.BoneName = BoneName;
	Parms.IncludeSelf = IncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_FirstTimeInitialization
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           Skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_FirstTimeInitialization(class USkeletalMeshComponent* Skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_FirstTimeInitialization");

	Params::DragonIKPhysicsComponent_Multicast_FirstTimeInitialization Parms{};

	Parms.Skeleton_input = Skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_Modify_Reset_Bone_Info
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// TArray<class FName>                     bone_list                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_Modify_Reset_Bone_Info(const TArray<class FName>& bone_list)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_Modify_Reset_Bone_Info");

	Params::DragonIKPhysicsComponent_Multicast_Modify_Reset_Bone_Info Parms{};

	Parms.bone_list = std::move(bone_list);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_OnHitCallback
// (Net, Native, Event, NetMulticast, Public, HasDefaults, NetValidate)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             Optional_Override_Hit_Bone_Name                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Hit_location                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Hit_impulse_direction                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Hit_bone_name                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_OnHitCallback(const struct FHitResult& Hit, const class FName Optional_Override_Hit_Bone_Name, const struct FVector& Hit_location, const struct FVector& Hit_impulse_direction, const class FName& Hit_bone_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_OnHitCallback");

	Params::DragonIKPhysicsComponent_Multicast_OnHitCallback Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Optional_Override_Hit_Bone_Name = Optional_Override_Hit_Bone_Name;
	Parms.Hit_location = std::move(Hit_location);
	Parms.Hit_impulse_direction = std::move(Hit_impulse_direction);
	Parms.Hit_bone_name = Hit_bone_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_PerformActiveRagdoll
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// float                                   Pelvis_mass_override                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_PerformActiveRagdoll(float Pelvis_mass_override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_PerformActiveRagdoll");

	Params::DragonIKPhysicsComponent_Multicast_PerformActiveRagdoll Parms{};

	Parms.Pelvis_mass_override = Pelvis_mass_override;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_ReGrabAllHandles
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// bool                                    Exit_ragdoll                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_ReGrabAllHandles(bool Exit_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_ReGrabAllHandles");

	Params::DragonIKPhysicsComponent_Multicast_ReGrabAllHandles Parms{};

	Parms.Exit_ragdoll = Exit_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_ReleaseAllHandles
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// bool                                    Go_ragdoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_ReleaseAllHandles(bool Go_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_ReleaseAllHandles");

	Params::DragonIKPhysicsComponent_Multicast_ReleaseAllHandles Parms{};

	Parms.Go_ragdoll = Go_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_SetInterpolation
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// int32                                   Inter_value                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_SetInterpolation(int32 Inter_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_SetInterpolation");

	Params::DragonIKPhysicsComponent_Multicast_SetInterpolation Parms{};

	Parms.Inter_value = Inter_value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Multicast_UpdatePhysanimData
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// int32                                   LinearStrength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LinearDamp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularDamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Multicast_UpdatePhysanimData(int32 LinearStrength, int32 AngularStrength, int32 LinearDamp, int32 AngularDamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Multicast_UpdatePhysanimData");

	Params::DragonIKPhysicsComponent_Multicast_UpdatePhysanimData Parms{};

	Parms.LinearStrength = LinearStrength;
	Parms.AngularStrength = AngularStrength;
	Parms.LinearDamp = LinearDamp;
	Parms.AngularDamp = AngularDamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.OnHitCallback
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             Optional_Override_Hit_Bone_Name                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Hit_location                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Hit_impulse_direction                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Hit_bone_name                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::OnHitCallback(const struct FHitResult& Hit, class FName Optional_Override_Hit_Bone_Name, struct FVector* Hit_location, struct FVector* Hit_impulse_direction, class FName* Hit_bone_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "OnHitCallback");

	Params::DragonIKPhysicsComponent_OnHitCallback Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Optional_Override_Hit_Bone_Name = Optional_Override_Hit_Bone_Name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Hit_location != nullptr)
		*Hit_location = std::move(Parms.Hit_location);

	if (Hit_impulse_direction != nullptr)
		*Hit_impulse_direction = std::move(Parms.Hit_impulse_direction);

	if (Hit_bone_name != nullptr)
		*Hit_bone_name = Parms.Hit_bone_name;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.PerformActiveRagdoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Pelvis_mass_override                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::PerformActiveRagdoll(float Pelvis_mass_override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "PerformActiveRagdoll");

	Params::DragonIKPhysicsComponent_PerformActiveRagdoll Parms{};

	Parms.Pelvis_mass_override = Pelvis_mass_override;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.ReGrabAllHandles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Exit_ragdoll                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::ReGrabAllHandles(bool Exit_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "ReGrabAllHandles");

	Params::DragonIKPhysicsComponent_ReGrabAllHandles Parms{};

	Parms.Exit_ragdoll = Exit_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.ReleaseAllHandles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Go_ragdoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::ReleaseAllHandles(bool Go_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "ReleaseAllHandles");

	Params::DragonIKPhysicsComponent_ReleaseAllHandles Parms{};

	Parms.Go_ragdoll = Go_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_CacheSimulationStates
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void UDragonIKPhysicsComponent::Server_CacheSimulationStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_CacheSimulationStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_Control_Bone_Handle
// (Net, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             bone_name                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Override_transform                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_Control_Bone_Handle(class FName bone_name, const struct FTransform& Override_transform, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_Control_Bone_Handle");

	Params::DragonIKPhysicsComponent_Server_Control_Bone_Handle Parms{};

	Parms.bone_name = bone_name;
	Parms.Override_transform = std::move(Override_transform);
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_DragonIKSimulatePhysics
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           Skmesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_DragonIKSimulatePhysics(class USkeletalMeshComponent* Skmesh, class FName BoneName, bool IncludeSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_DragonIKSimulatePhysics");

	Params::DragonIKPhysicsComponent_Server_DragonIKSimulatePhysics Parms{};

	Parms.Skmesh = Skmesh;
	Parms.BoneName = BoneName;
	Parms.IncludeSelf = IncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_FirstTimeInitialization
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           Skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_FirstTimeInitialization(class USkeletalMeshComponent* Skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_FirstTimeInitialization");

	Params::DragonIKPhysicsComponent_Server_FirstTimeInitialization Parms{};

	Parms.Skeleton_input = Skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_Modify_Reset_Bone_Info
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// TArray<class FName>                     bone_list                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_Modify_Reset_Bone_Info(const TArray<class FName>& bone_list)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_Modify_Reset_Bone_Info");

	Params::DragonIKPhysicsComponent_Server_Modify_Reset_Bone_Info Parms{};

	Parms.bone_list = std::move(bone_list);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_OnHitCallback
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             Optional_Override_Hit_Bone_Name                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Hit_location                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Hit_impulse_direction                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Hit_bone_name                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_OnHitCallback(const struct FHitResult& Hit, const class FName Optional_Override_Hit_Bone_Name, const struct FVector& Hit_location, const struct FVector& Hit_impulse_direction, const class FName& Hit_bone_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_OnHitCallback");

	Params::DragonIKPhysicsComponent_Server_OnHitCallback Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Optional_Override_Hit_Bone_Name = Optional_Override_Hit_Bone_Name;
	Parms.Hit_location = std::move(Hit_location);
	Parms.Hit_impulse_direction = std::move(Hit_impulse_direction);
	Parms.Hit_bone_name = Hit_bone_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_PerformActiveRagdoll
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// float                                   Pelvis_mass_override                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_PerformActiveRagdoll(float Pelvis_mass_override)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_PerformActiveRagdoll");

	Params::DragonIKPhysicsComponent_Server_PerformActiveRagdoll Parms{};

	Parms.Pelvis_mass_override = Pelvis_mass_override;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_ReGrabAllHandles
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    Exit_ragdoll                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_ReGrabAllHandles(bool Exit_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_ReGrabAllHandles");

	Params::DragonIKPhysicsComponent_Server_ReGrabAllHandles Parms{};

	Parms.Exit_ragdoll = Exit_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_ReleaseAllHandles
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    Go_ragdoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_ReleaseAllHandles(bool Go_ragdoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_ReleaseAllHandles");

	Params::DragonIKPhysicsComponent_Server_ReleaseAllHandles Parms{};

	Parms.Go_ragdoll = Go_ragdoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_SetInterpolation
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// int32                                   Inter_value                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_SetInterpolation(int32 Inter_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_SetInterpolation");

	Params::DragonIKPhysicsComponent_Server_SetInterpolation Parms{};

	Parms.Inter_value = Inter_value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.Server_UpdatePhysanimData
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// int32                                   LinearStrength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LinearDamp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularDamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::Server_UpdatePhysanimData(int32 LinearStrength, int32 AngularStrength, int32 LinearDamp, int32 AngularDamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "Server_UpdatePhysanimData");

	Params::DragonIKPhysicsComponent_Server_UpdatePhysanimData Parms{};

	Parms.LinearStrength = LinearStrength;
	Parms.AngularStrength = AngularStrength;
	Parms.LinearDamp = LinearDamp;
	Parms.AngularDamp = AngularDamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.SetInterpolation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Inter_value                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::SetInterpolation(int32 Inter_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "SetInterpolation");

	Params::DragonIKPhysicsComponent_SetInterpolation Parms{};

	Parms.Inter_value = Inter_value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKPhysicsComponent.UpdatePhysanimData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LinearStrength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LinearDamp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AngularDamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKPhysicsComponent::UpdatePhysanimData(int32 LinearStrength, int32 AngularStrength, int32 LinearDamp, int32 AngularDamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKPhysicsComponent", "UpdatePhysanimData");

	Params::DragonIKPhysicsComponent_UpdatePhysanimData Parms{};

	Parms.LinearStrength = LinearStrength;
	Parms.AngularStrength = AngularStrength;
	Parms.LinearDamp = LinearDamp;
	Parms.AngularDamp = AngularDamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKTraceManagerComponent.SpineSolverTraceData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FDragonIKTraceKeyValuePair>Hit_data_pair                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDragonIKTraceManagerComponent::SpineSolverTraceData(const TArray<struct FDragonIKTraceKeyValuePair>& Hit_data_pair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKTraceManagerComponent", "SpineSolverTraceData");

	Params::DragonIKTraceManagerComponent_SpineSolverTraceData Parms{};

	Parms.Hit_data_pair = std::move(Hit_data_pair);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Attach_Hand_Only
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Arm_position_recalibrate                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Attach_Hand_Only(class FName Hand_bone, bool Arm_position_recalibrate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Attach_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Attach_Hand_Only Parms{};

	Parms.Hand_bone = Hand_bone;
	Parms.Arm_position_recalibrate = Arm_position_recalibrate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Destroy_Weapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Destroy_Weapon(class AActor* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Destroy_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Destroy_Weapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.DisableWeaponsArms
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Reset_weapon_transform                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::DisableWeaponsArms(bool Reset_weapon_transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "DisableWeaponsArms");

	Params::DragonIKWeaponPhysicsComponent_DisableWeaponsArms Parms{};

	Parms.Reset_weapon_transform = Reset_weapon_transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.EnableWeaponsArms
// (Final, Native, Public, BlueprintCallable)

void UDragonIKWeaponPhysicsComponent::EnableWeaponsArms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "EnableWeaponsArms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.FirstTimeInitialization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::FirstTimeInitialization(class USkeletalMeshComponent* Skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "FirstTimeInitialization");

	Params::DragonIKWeaponPhysicsComponent_FirstTimeInitialization Parms{};

	Parms.Skeleton_input = Skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Freeze_Elbows_Function
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Freeze_Elbows_Function(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Freeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Freeze_Elbows_Function Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Grab_Weapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Grabbed_bone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Simulate_physics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Grab_Weapon(class FName Grabbed_bone, bool Simulate_physics, bool Use_gravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Grab_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Grab_Weapon Parms{};

	Parms.Grabbed_bone = Grabbed_bone;
	Parms.Simulate_physics = Simulate_physics;
	Parms.Use_gravity = Use_gravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Attach_Hand_Only
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Arm_position_recalibrate                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Attach_Hand_Only(class FName Hand_bone, bool Arm_position_recalibrate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Attach_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Attach_Hand_Only Parms{};

	Parms.Hand_bone = Hand_bone;
	Parms.Arm_position_recalibrate = Arm_position_recalibrate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Destroy_Weapon
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Destroy_Weapon(class AActor* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Destroy_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Destroy_Weapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_DisableWeaponsArms
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// bool                                    Reset_weapon_transform                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_DisableWeaponsArms(bool Reset_weapon_transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_DisableWeaponsArms");

	Params::DragonIKWeaponPhysicsComponent_Multicast_DisableWeaponsArms Parms{};

	Parms.Reset_weapon_transform = Reset_weapon_transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_EnableWeaponsArms
// (Net, Native, Event, NetMulticast, Public, NetValidate)

void UDragonIKWeaponPhysicsComponent::Multicast_EnableWeaponsArms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_EnableWeaponsArms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_FirstTimeInitialization
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           Skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_FirstTimeInitialization(class USkeletalMeshComponent* Skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_FirstTimeInitialization");

	Params::DragonIKWeaponPhysicsComponent_Multicast_FirstTimeInitialization Parms{};

	Parms.Skeleton_input = Skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Freeze_Elbows_Function
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Freeze_Elbows_Function(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Freeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Freeze_Elbows_Function Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Grab_Weapon
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FName                             Grabbed_bone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Simulate_physics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Grab_Weapon(class FName Grabbed_bone, bool Simulate_physics, bool Use_gravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Grab_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Grab_Weapon Parms{};

	Parms.Grabbed_bone = Grabbed_bone;
	Parms.Simulate_physics = Simulate_physics;
	Parms.Use_gravity = Use_gravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Release_Hand_Only
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Release_Hand_Only(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Release_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Only Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Release_Hand_Plus_Override
// (Net, Native, Event, NetMulticast, Public, HasDefaults, NetValidate)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Hand_transform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_hand_location                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_Hand_Rotation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Release_Hand_Plus_Override(class FName Hand_bone, const struct FTransform& Hand_transform, bool Override_hand_location, bool Override_Hand_Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Release_Hand_Plus_Override");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Release_Hand_Plus_Override Parms{};

	Parms.Hand_bone = Hand_bone;
	Parms.Hand_transform = std::move(Hand_transform);
	Parms.Override_hand_location = Override_hand_location;
	Parms.Override_Hand_Rotation = Override_Hand_Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Release_Weapon
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// bool                                    Should_simulatephysics                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeep_Attachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Release_Weapon(bool Should_simulatephysics, bool Use_gravity, bool bKeep_Attachment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Release_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Release_Weapon Parms{};

	Parms.Should_simulatephysics = Should_simulatephysics;
	Parms.Use_gravity = Use_gravity;
	Parms.bKeep_Attachment = bKeep_Attachment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Unfreeze_Elbows_Function
// (Net, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Unfreeze_Elbows_Function(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Unfreeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Unfreeze_Elbows_Function Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Multicast_Weapon_Transform_Override
// (Net, Native, Event, NetMulticast, Public, HasDefaults, NetValidate)
// Parameters:
// struct FTransform                       Weapon_Transform                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShould_Override_Weapon_Transform                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Multicast_Weapon_Transform_Override(const struct FTransform& Weapon_Transform, bool bShould_Override_Weapon_Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Multicast_Weapon_Transform_Override");

	Params::DragonIKWeaponPhysicsComponent_Multicast_Weapon_Transform_Override Parms{};

	Parms.Weapon_Transform = std::move(Weapon_Transform);
	Parms.bShould_Override_Weapon_Transform = bShould_Override_Weapon_Transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Hand_Only
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Release_Hand_Only(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Release_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Release_Hand_Only Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Hand_Plus_Override
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Hand_transform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_hand_location                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_Hand_Rotation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Release_Hand_Plus_Override(class FName Hand_bone, const struct FTransform& Hand_transform, bool Override_hand_location, bool Override_Hand_Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Release_Hand_Plus_Override");

	Params::DragonIKWeaponPhysicsComponent_Release_Hand_Plus_Override Parms{};

	Parms.Hand_bone = Hand_bone;
	Parms.Hand_transform = std::move(Hand_transform);
	Parms.Override_hand_location = Override_hand_location;
	Parms.Override_Hand_Rotation = Override_Hand_Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Release_Weapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Should_simulatephysics                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeep_Attachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Release_Weapon(bool Should_simulatephysics, bool Use_gravity, bool bKeep_Attachment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Release_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Release_Weapon Parms{};

	Parms.Should_simulatephysics = Should_simulatephysics;
	Parms.Use_gravity = Use_gravity;
	Parms.bKeep_Attachment = bKeep_Attachment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Attach_Hand_Only
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Arm_position_recalibrate                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Attach_Hand_Only(class FName Hand_bone, bool Arm_position_recalibrate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Attach_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Server_Attach_Hand_Only Parms{};

	Parms.Hand_bone = Hand_bone;
	Parms.Arm_position_recalibrate = Arm_position_recalibrate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Destroy_Weapon
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           Weapon                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Destroy_Weapon(class AActor* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Destroy_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Server_Destroy_Weapon Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_DisableWeaponsArms
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    Reset_weapon_transform                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_DisableWeaponsArms(bool Reset_weapon_transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_DisableWeaponsArms");

	Params::DragonIKWeaponPhysicsComponent_Server_DisableWeaponsArms Parms{};

	Parms.Reset_weapon_transform = Reset_weapon_transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_EnableWeaponsArms
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void UDragonIKWeaponPhysicsComponent::Server_EnableWeaponsArms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_EnableWeaponsArms");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_FirstTimeInitialization
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           Skeleton_input                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_FirstTimeInitialization(class USkeletalMeshComponent* Skeleton_input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_FirstTimeInitialization");

	Params::DragonIKWeaponPhysicsComponent_Server_FirstTimeInitialization Parms{};

	Parms.Skeleton_input = Skeleton_input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Freeze_Elbows_Function
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Freeze_Elbows_Function(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Freeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Server_Freeze_Elbows_Function Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Grab_Weapon
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             Grabbed_bone                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Simulate_physics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Grab_Weapon(class FName Grabbed_bone, bool Simulate_physics, bool Use_gravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Grab_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Server_Grab_Weapon Parms{};

	Parms.Grabbed_bone = Grabbed_bone;
	Parms.Simulate_physics = Simulate_physics;
	Parms.Use_gravity = Use_gravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Release_Hand_Only
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Release_Hand_Only(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Release_Hand_Only");

	Params::DragonIKWeaponPhysicsComponent_Server_Release_Hand_Only Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Release_Hand_Plus_Override
// (Net, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Hand_transform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_hand_location                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Override_Hand_Rotation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Release_Hand_Plus_Override(class FName Hand_bone, const struct FTransform& Hand_transform, bool Override_hand_location, bool Override_Hand_Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Release_Hand_Plus_Override");

	Params::DragonIKWeaponPhysicsComponent_Server_Release_Hand_Plus_Override Parms{};

	Parms.Hand_bone = Hand_bone;
	Parms.Hand_transform = std::move(Hand_transform);
	Parms.Override_hand_location = Override_hand_location;
	Parms.Override_Hand_Rotation = Override_Hand_Rotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Release_Weapon
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    Should_simulatephysics                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Use_gravity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeep_Attachment                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Release_Weapon(bool Should_simulatephysics, bool Use_gravity, bool bKeep_Attachment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Release_Weapon");

	Params::DragonIKWeaponPhysicsComponent_Server_Release_Weapon Parms{};

	Parms.Should_simulatephysics = Should_simulatephysics;
	Parms.Use_gravity = Use_gravity;
	Parms.bKeep_Attachment = bKeep_Attachment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Unfreeze_Elbows_Function
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Unfreeze_Elbows_Function(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Unfreeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Server_Unfreeze_Elbows_Function Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Server_Weapon_Transform_Override
// (Net, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// struct FTransform                       Weapon_Transform                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShould_Override_Weapon_Transform                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Server_Weapon_Transform_Override(const struct FTransform& Weapon_Transform, bool bShould_Override_Weapon_Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Server_Weapon_Transform_Override");

	Params::DragonIKWeaponPhysicsComponent_Server_Weapon_Transform_Override Parms{};

	Parms.Weapon_Transform = std::move(Weapon_Transform);
	Parms.bShould_Override_Weapon_Transform = bShould_Override_Weapon_Transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Unfreeze_Elbows_Function
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Hand_bone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Unfreeze_Elbows_Function(class FName Hand_bone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Unfreeze_Elbows_Function");

	Params::DragonIKWeaponPhysicsComponent_Unfreeze_Elbows_Function Parms{};

	Parms.Hand_bone = Hand_bone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIKWeaponPhysicsComponent.Weapon_Transform_Override
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Weapon_Transform                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShould_Override_Weapon_Transform                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonIKWeaponPhysicsComponent::Weapon_Transform_Override(const struct FTransform& Weapon_Transform, bool bShould_Override_Weapon_Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonIKWeaponPhysicsComponent", "Weapon_Transform_Override");

	Params::DragonIKWeaponPhysicsComponent_Weapon_Transform_Override Parms{};

	Parms.Weapon_Transform = std::move(Weapon_Transform);
	Parms.bShould_Override_Weapon_Transform = bShould_Override_Weapon_Transform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DragonIKPlugin.DragonIK_Library.CustomLookRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          LookAt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          UpDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDragonIK_Library::CustomLookRotation(const struct FVector& LookAt, const struct FVector& UpDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "CustomLookRotation");

	Params::DragonIK_Library_CustomLookRotation Parms{};

	Parms.LookAt = std::move(LookAt);
	Parms.UpDirection = std::move(UpDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DragonIKPlugin.DragonIK_Library.LookAtRotation_V3
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          UpVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDragonIK_Library::LookAtRotation_V3(const struct FVector& Source, const struct FVector& Target, const struct FVector& UpVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "LookAtRotation_V3");

	Params::DragonIK_Library_LookAtRotation_V3 Parms{};

	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);
	Parms.UpVector = std::move(UpVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DragonIKPlugin.DragonIK_Library.LookAtVector_V2
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Source_Location                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LookAt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          UpDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDragonIK_Library::LookAtVector_V2(const struct FVector& Source_Location, const struct FVector& LookAt, const struct FVector& UpDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "LookAtVector_V2");

	Params::DragonIK_Library_LookAtVector_V2 Parms{};

	Parms.Source_Location = std::move(Source_Location);
	Parms.LookAt = std::move(LookAt);
	Parms.UpDirection = std::move(UpDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DragonIKPlugin.DragonIK_Library.QuatLookXatLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       LookAtFromTransform                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LookAtTarget                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UDragonIK_Library::QuatLookXatLocation(const struct FTransform& LookAtFromTransform, const struct FVector& LookAtTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DragonIK_Library", "QuatLookXatLocation");

	Params::DragonIK_Library_QuatLookXatLocation Parms{};

	Parms.LookAtFromTransform = std::move(LookAtFromTransform);
	Parms.LookAtTarget = std::move(LookAtTarget);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

