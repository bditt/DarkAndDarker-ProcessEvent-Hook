#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DungeonCrawler

#include "Basic.hpp"

#include "EnhancedInput_structs.hpp"
#include "NetCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "DungeonCrawlerMessageRuntime_structs.hpp"
#include "CommonInput_structs.hpp"
#include "Engine_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "UMG_structs.hpp"


namespace SDK
{

// Enum DungeonCrawler.EGameType
// NumValues: 0x000B
enum class EGameType : uint8
{
	None                                     = 0,
	DungeonTrioNormal                        = 1,
	DungeonTrioHighRoller                    = 2,
	DungeonSoloNormal                        = 3,
	DungeonDuoNormal                         = 4,
	DungeonSoloHighRoller                    = 5,
	DungeonDuoHighRoller                     = 6,
	ArenaDuo                                 = 7,
	ArenaTrio                                = 8,
	ArenaSolo                                = 9,
	EGameType_MAX                            = 10,
};

// Enum DungeonCrawler.EFloorRulePhase
// NumValues: 0x0005
enum class EFloorRulePhase : uint8
{
	None                                     = 0,
	Display                                  = 1,
	Shrink                                   = 2,
	End                                      = 3,
	EFloorRulePhase_MAX                      = 4,
};

// Enum DungeonCrawler.EDCKarmaLevel
// NumValues: 0x0007
enum class EDCKarmaLevel : uint8
{
	None                                     = 0,
	Scoundrel                                = 1,
	Insidious                                = 2,
	Neutral                                  = 3,
	Trustworthy                              = 4,
	Paragon                                  = 5,
	EDCKarmaLevel_MAX                        = 6,
};

// Enum DungeonCrawler.EDCInventoryId
// NumValues: 0x0017
enum class EDCInventoryId : uint8
{
	None                                     = 0,
	Chest                                    = 1,
	Bag                                      = 2,
	Equipment                                = 3,
	Stash                                    = 4,
	StashPurchased_0                         = 5,
	StashPurchased_1                         = 6,
	StashPurchased_2                         = 7,
	StashPurchased_3                         = 8,
	StashPurchased_4                         = 9,
	Expressman                               = 10,
	SharedStash                              = 20,
	TradingLocal                             = 21,
	TradingRemote                            = 22,
	MerchantDummy                            = 23,
	MerchantSaleList                         = 24,
	MerchantCraftList                        = 25,
	MerchantDealTable                        = 26,
	MerchantBaseGearList                     = 27,
	MerchantBaseGearSet                      = 28,
	MerchantRecoveryItemList                 = 29,
	MerchantExpressItemList                  = 30,
	EDCInventoryId_MAX                       = 31,
};

// Enum DungeonCrawler.EDCItemOriginType
// NumValues: 0x0004
enum class EDCItemOriginType : uint8
{
	None                                     = 0,
	Found                                    = 1,
	Crafted                                  = 2,
	EDCItemOriginType_MAX                    = 3,
};

// Enum DungeonCrawler.EDCItemLootState
// NumValues: 0x0006
enum class EDCItemLootState : uint8
{
	None                                     = 0,
	Supplied                                 = 1,
	Looted                                   = 2,
	Handled                                  = 3,
	Allys                                    = 5,
	EDCItemLootState_MAX                     = 6,
};

// Enum DungeonCrawler.EDCEquipmentSlotIndex
// NumValues: 0x0018
enum class EDCEquipmentSlotIndex : uint8
{
	None                                     = 0,
	Armor_Head                               = 1,
	Armor_Chest                              = 2,
	Armor_Hands                              = 3,
	Armor_Legs                               = 4,
	Armor_Foot                               = 5,
	Belt_L                                   = 6,
	Belt_R                                   = 7,
	Utility_L1                               = 8,
	Utility_R1                               = 9,
	Weapon_L1                                = 10,
	Weapon_L2                                = 11,
	Weapon_R1                                = 12,
	Weapon_R2                                = 13,
	Utility_L2                               = 14,
	Utility_L3                               = 15,
	Utility_R2                               = 16,
	Utility_R3                               = 17,
	SoulHeart                                = 18,
	Accessory_Necklace                       = 19,
	Accessory_Ring_1                         = 20,
	Accessory_Ring_2                         = 21,
	Armor_Back                               = 22,
	EDCEquipmentSlotIndex_MAX                = 23,
};

// Enum DungeonCrawler.EDCInventoryTaskType
// NumValues: 0x0010
enum class EDCInventoryTaskType : uint8
{
	None                                     = 0,
	AddNewItem                               = 1,
	MergeNewItem                             = 2,
	MoveInventoryItem                        = 3,
	RemoveInventoryItem                      = 4,
	DropInventoryItem                        = 5,
	MergeInventoryItem                       = 6,
	SwapInventoryItem                        = 7,
	ClearItems                               = 8,
	AddItem                                  = 9,
	MergeItem                                = 10,
	DropItem                                 = 11,
	RemoveItem                               = 12,
	SplitItem                                = 13,
	SplitMergeItem                           = 14,
	EDCInventoryTaskType_MAX                 = 15,
};

// Enum DungeonCrawler.EDCEquipHoldType
// NumValues: 0x0007
enum class EDCEquipHoldType : uint8
{
	None                                     = 0,
	WeaponA                                  = 1,
	WeaponB                                  = 2,
	UtilityA                                 = 3,
	UtilityB                                 = 4,
	BareHands                                = 5,
	EDCEquipHoldType_MAX                     = 6,
};

// Enum DungeonCrawler.EDCItemSwitchEvent
// NumValues: 0x0004
enum class EDCItemSwitchEvent : uint8
{
	None                                     = 0,
	HoldInfo                                 = 1,
	UpdatedItems                             = 2,
	EDCItemSwitchEvent_MAX                   = 3,
};

// Enum DungeonCrawler.EEquipmentQuickSlotType
// NumValues: 0x0006
enum class EEquipmentQuickSlotType : uint8
{
	None                                     = 0,
	WeaponSetA                               = 1,
	WeaponSetB                               = 2,
	UtilityA                                 = 3,
	UtilityB                                 = 4,
	EEquipmentQuickSlotType_MAX              = 5,
};

// Enum DungeonCrawler.EDCShopCurrencyType
// NumValues: 0x0004
enum class EDCShopCurrencyType : uint8
{
	None                                     = 0,
	BluestoneShard                           = 1,
	RedstoneShard                            = 2,
	EDCShopCurrencyType_MAX                  = 3,
};

// Enum DungeonCrawler.EInventoryType
// NumValues: 0x000D
enum class EInventoryType : uint8
{
	None                                     = 0,
	Chest                                    = 1,
	Bag                                      = 2,
	Equipment                                = 3,
	Storage                                  = 4,
	PurchasedStorage_0                       = 5,
	PurchasedStorage_1                       = 6,
	PurchasedStorage_2                       = 7,
	StockBuy                                 = 8,
	StockSellBack                            = 9,
	StockCraft                               = 10,
	DealTable                                = 11,
	EInventoryType_MAX                       = 12,
};

// Enum DungeonCrawler.EDCActorOptimizeState
// NumValues: 0x0004
enum class EDCActorOptimizeState : uint8
{
	None                                     = 0,
	Optimize                                 = 1,
	Freeze                                   = 2,
	EDCActorOptimizeState_MAX                = 3,
};

// Enum DungeonCrawler.EAgeRatingType
// NumValues: 0x0006
enum class EAgeRatingType : uint8
{
	None                                     = 0,
	GRAC                                     = 1,
	PEGI                                     = 2,
	ESRB                                     = 3,
	CERO                                     = 4,
	EAgeRatingType_MAX                       = 5,
};

// Enum DungeonCrawler.EAoeFilterSortingType
// NumValues: 0x0003
enum class EAoeFilterSortingType : uint8
{
	Ascending                                = 0,
	Desending                                = 1,
	EAoeFilterSortingType_MAX                = 2,
};

// Enum DungeonCrawler.EDCChatChannelType
// NumValues: 0x0003
enum class EDCChatChannelType : uint8
{
	None                                     = 0,
	Recruit                                  = 1,
	EDCChatChannelType_MAX                   = 2,
};

// Enum DungeonCrawler.EDCPagingState
// NumValues: 0x0005
enum class EDCPagingState : uint8
{
	None                                     = 0,
	Begin                                    = 1,
	Progress                                 = 2,
	End                                      = 3,
	EDCPagingState_MAX                       = 4,
};

// Enum DungeonCrawler.EServerLocation
// NumValues: 0x0008
enum class EServerLocation : uint8
{
	None                                     = 0,
	Local                                    = 1,
	QA                                       = 2,
	PlayTest                                 = 3,
	NA                                       = 4,
	Dev1                                     = 5,
	Dev2                                     = 6,
	EServerLocation_MAX                      = 7,
};

// Enum DungeonCrawler.EMetaState
// NumValues: 0x0006
enum class EMetaState : uint8
{
	None                                     = 0,
	Login                                    = 1,
	CharacterSelect                          = 2,
	Lobby                                    = 3,
	InGame                                   = 4,
	EMetaState_MAX                           = 5,
};

// Enum DungeonCrawler.EServicePolicyType
// NumValues: 0x0039
enum class EServicePolicyType : uint8
{
	None                                     = 0,
	ChatMaxLength                            = 1,
	ChatResendTime                           = 2,
	ChatMaxLine                              = 3,
	TradeChannelChatResendTime               = 4,
	TradeChannelChatMaxLine                  = 5,
	HighRollerEntraceFeeGold                 = 6,
	HighRollerEntraceMinLevel                = 7,
	GoblinHighRollerEntraceFeeGold           = 8,
	GoblinHighRollerEntraceMinLevel          = 9,
	RuinsHighRollerEntraceFeeGold            = 10,
	RuinsHighRollerEntraceMinLevel           = 11,
	MatchCancelDelayTime                     = 12,
	RecruitChannelChatSendCooldownSeconds    = 13,
	RecruitChannelNumChatLogMax              = 14,
	RecruitChannelJoinMinLevel               = 15,
	ItemRarityLimitNormal                    = 16,
	ItemRarityLimitHighRoller                = 17,
	ItemRarityLimitRuins                     = 18,
	ItemRarityLimitGoblin                    = 19,
	ItemRarityLimitGoblinHighRoller          = 20,
	ItemRarityLimitRuinsHighRoller           = 21,
	LeaderboardScoreFractionalDigits         = 22,
	MarketplaceFixedListingFee               = 23,
	MarketplaceVariableListingFeeRate        = 24,
	MarketplaceListingExpiredTime            = 25,
	MarketplaceTransferExpiredTime           = 26,
	MarketplaceListingLimitCount             = 27,
	MarketplaceMaxGoldCoinPrice              = 28,
	MarketplaceClosed                        = 29,
	MerchantBulkLimitCount                   = 30,
	DeathCamUse                              = 31,
	EnableClothPhysics                       = 32,
	EnableClothPhysicsUseTaskThread          = 33,
	WaitForParallelClothTask                 = 34,
	MerchantMindwipePrice                    = 35,
	EnableShippingClientLog                  = 36,
	SetVerbosityShippingClientLog            = 37,
	OverrideAntialiasing                     = 38,
	TradeOnlyLooted                          = 39,
	EnableUpdateEngineVariables              = 40,
	EnableUpgradeAccountStatus               = 41,
	HighRollerBlockSecondsAfterUpgradeAccountStatus = 42,
	TradeBlockSecondsAfterUpgradeAccountStatus = 43,
	ReportInGameOnOff                        = 44,
	PreventCrowsHRMinGearScore               = 45,
	PreventCrowsHRPartySizeLimit             = 46,
	RandomMatchmakingOnOff                   = 47,
	ProhibitedItemCheck                      = 48,
	ReligionWeeklyResetDay                   = 49,
	ArenaEnabled                             = 50,
	EnableMultiClass                         = 51,
	NoDuplicateClassAccess                   = 52,
	ItemRarityCapInArena                     = 53,
	SquireNotAllowedInArena                  = 54,
	ArenaEntraceMinLevel                     = 55,
	EServicePolicyType_MAX                   = 56,
};

// Enum DungeonCrawler.ETradeState
// NumValues: 0x0005
enum class ETradeState : uint8
{
	None                                     = 0,
	TradeChannel                             = 1,
	Trading                                  = 2,
	TradingConfirm                           = 3,
	ETradeState_MAX                          = 4,
};

// Enum DungeonCrawler.EContextOptionType
// NumValues: 0x0010
enum class EContextOptionType : uint8
{
	None                                     = 0,
	TradeRequest                             = 1,
	Whisper                                  = 2,
	Block                                    = 3,
	Equip                                    = 4,
	Unequip                                  = 5,
	KickPartyMember                          = 6,
	InvitePartyMember                        = 7,
	Unblock                                  = 8,
	Inspect                                  = 9,
	DeleteFriend                             = 10,
	InviteFriend                             = 11,
	CancelFriend                             = 12,
	AcceptFriend                             = 13,
	DeclineFriend                            = 14,
	EContextOptionType_MAX                   = 15,
};

// Enum DungeonCrawler.EAccountLinkType
// NumValues: 0x0005
enum class EAccountLinkType : uint8
{
	Static                                   = 0,
	PlayerController                         = 1,
	PlayerPawn                               = 2,
	Dynamic                                  = 3,
	EAccountLinkType_MAX                     = 4,
};

// Enum DungeonCrawler.EAccountLinkFlag
// NumValues: 0x000A
enum class EAccountLinkFlag : uint8
{
	None                                     = 0,
	AccountSessionData                       = 1,
	Attribute                                = 2,
	GameplayTag                              = 4,
	ActorStatus                              = 8,
	Inventory                                = 16,
	Perk                                     = 32,
	Skill                                    = 64,
	PartySessionData                         = 128,
	EAccountLinkFlag_MAX                     = 129,
};

// Enum DungeonCrawler.EGameplayEffectType
// NumValues: 0x0007
enum class EGameplayEffectType : uint8
{
	MMC                                      = 0,
	MMCSimple                                = 1,
	InfiniteTagOnly                          = 2,
	DurationTagOnly                          = 3,
	Initialize                               = 4,
	Calculation                              = 5,
	EGameplayEffectType_MAX                  = 6,
};

// Enum DungeonCrawler.EGameplayEffectTargetType
// NumValues: 0x0003
enum class EGameplayEffectTargetType : uint8
{
	Owner                                    = 0,
	EventData                                = 1,
	EGameplayEffectTargetType_MAX            = 2,
};

// Enum DungeonCrawler.EItemType
// NumValues: 0x0007
enum class EItemType : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	Armor                                    = 2,
	Utility                                  = 3,
	Accessory                                = 4,
	Misc                                     = 5,
	EItemType_MAX                            = 6,
};

// Enum DungeonCrawler.EItemRequirementType
// NumValues: 0x0009
enum class EItemRequirementType : uint8
{
	Class                                    = 0,
	Strength                                 = 1,
	Agility                                  = 2,
	Will                                     = 3,
	Knowledge                                = 4,
	Resourceful                              = 5,
	Perk                                     = 6,
	CharacterSkin                            = 7,
	EItemRequirementType_MAX                 = 8,
};

// Enum DungeonCrawler.EDCCharacterClass
// NumValues: 0x000C
enum class EDCCharacterClass : uint8
{
	None                                     = 0,
	Wizard                                   = 1,
	Rogue                                    = 2,
	Ranger                                   = 3,
	Fighter                                  = 4,
	Cleric                                   = 5,
	Barbarian                                = 6,
	Bard                                     = 7,
	Warlock                                  = 8,
	Druid                                    = 9,
	GrandMaster                              = 10,
	EDCCharacterClass_MAX                    = 11,
};

// Enum DungeonCrawler.EDCGender
// NumValues: 0x0004
enum class EDCGender : uint8
{
	None                                     = 0,
	Man                                      = 1,
	Woman                                    = 2,
	EDCGender_MAX                            = 3,
};

// Enum DungeonCrawler.EDCSkillClassAbility
// NumValues: 0x0005
enum class EDCSkillClassAbility : uint8
{
	None                                     = 0,
	Music                                    = 1,
	Spell                                    = 2,
	ShapeShift                               = 3,
	EDCSkillClassAbility_MAX                 = 4,
};

// Enum DungeonCrawler.EChatSetType
// NumValues: 0x0006
enum class EChatSetType : uint8
{
	None                                     = 0,
	TradeChannel                             = 1,
	TradePrivate                             = 2,
	Party                                    = 3,
	Recruit                                  = 4,
	EChatSetType_MAX                         = 5,
};

// Enum DungeonCrawler.EChatType
// NumValues: 0x0004
enum class EChatType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Whisper                                  = 2,
	EChatType_MAX                            = 3,
};

// Enum DungeonCrawler.EChatWidgetType
// NumValues: 0x0009
enum class EChatWidgetType : uint8
{
	None                                     = 0,
	System                                   = 1,
	Normal                                   = 2,
	Mine                                     = 3,
	WhisperFrom                              = 4,
	WhisperTo                                = 5,
	Party                                    = 6,
	Announce                                 = 7,
	EChatWidgetType_MAX                      = 8,
};

// Enum DungeonCrawler.EDCMorphTarget
// NumValues: 0x001C
enum class EDCMorphTarget : uint8
{
	None                                     = 0,
	WomanFrontHair                           = 1,
	FrontHair                                = 2,
	MidHair                                  = 3,
	BackHair                                 = 4,
	Beard                                    = 5,
	UnderHair                                = 6,
	Ponytail                                 = 7,
	Ear                                      = 8,
	Hat                                      = 9,
	Cap                                      = 10,
	HalfCap                                  = 11,
	Helmet                                   = 12,
	Hood                                     = 13,
	Mask                                     = 14,
	RobeHair                                 = 15,
	HalfCapL                                 = 16,
	HalfCapR                                 = 17,
	FelidianHead                             = 18,
	GlovesEquipped                           = 19,
	ShortGlovesEquipped                      = 20,
	HelmetEquipped                           = 21,
	Cloak                                    = 22,
	BootsEquipped                            = 23,
	RobeLeg                                  = 24,
	LizardmanNeck                            = 25,
	LizardmanAnkle                           = 26,
	EDCMorphTarget_MAX                       = 27,
};

// Enum DungeonCrawler.EChatRoomCategoryType
// NumValues: 0x0004
enum class EChatRoomCategoryType : uint8
{
	None                                     = 0,
	GatheringHall                            = 1,
	Trade_All                                = 2,
	EChatRoomCategoryType_MAX                = 3,
};

// Enum DungeonCrawler.EDescriptionDataType
// NumValues: 0x000C
enum class EDescriptionDataType : uint8
{
	None                                     = 0,
	GameplayEffect                           = 1,
	Constant                                 = 2,
	MovementMod                              = 3,
	GEMod                                    = 4,
	Attribute                                = 5,
	Perk                                     = 6,
	Music                                    = 7,
	Spell                                    = 8,
	Skill                                    = 9,
	ItemConsume                              = 10,
	EDescriptionDataType_MAX                 = 11,
};

// Enum DungeonCrawler.EDescriptionValueType
// NumValues: 0x000E
enum class EDescriptionValueType : uint8
{
	None                                     = 0,
	CastingTime                              = 1,
	ChannelingDuration                       = 2,
	ChannelingInterval                       = 3,
	Duration                                 = 4,
	Range                                    = 5,
	AreaRadius                               = 6,
	Integer                                  = 7,
	Float                                    = 8,
	Add                                      = 9,
	Multiply                                 = 10,
	JumpZMultiply                            = 11,
	SetByCaller                              = 12,
	EDescriptionValueType_MAX                = 13,
};

// Enum DungeonCrawler.EDescriptionFormatType
// NumValues: 0x0008
enum class EDescriptionFormatType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Abs                                      = 2,
	AbsFromOne                               = 3,
	AbsFromZero                              = 4,
	FromOne                                  = 5,
	FromZero                                 = 6,
	EDescriptionFormatType_MAX               = 7,
};

// Enum DungeonCrawler.EDCCharacterPart
// NumValues: 0x000A
enum class EDCCharacterPart : uint8
{
	None                                     = 0,
	Head                                     = 1,
	Tongue                                   = 2,
	Hands                                    = 3,
	Chest                                    = 4,
	Legs                                     = 5,
	Foot                                     = 6,
	Back                                     = 7,
	Tail                                     = 8,
	EDCCharacterPart_MAX                     = 9,
};

// Enum DungeonCrawler.EDCMerchantServiceType
// NumValues: 0x000B
enum class EDCMerchantServiceType : uint8
{
	None                                     = 0,
	Buy                                      = 1,
	Sell                                     = 2,
	Craft                                    = 3,
	Quest                                    = 4,
	BaseGear                                 = 5,
	QuickPrepare                             = 6,
	Mindwipe                                 = 7,
	DungeonRecoveries                        = 8,
	DungeonExpress                           = 9,
	EDCMerchantServiceType_MAX               = 10,
};

// Enum DungeonCrawler.EDCRecoveryState
// NumValues: 0x0003
enum class EDCRecoveryState : uint8
{
	None                                     = 0,
	Delivered                                = 1,
	EDCRecoveryState_MAX                     = 2,
};

// Enum DungeonCrawler.EDCExpressState
// NumValues: 0x0003
enum class EDCExpressState : uint8
{
	None                                     = 0,
	Express                                  = 1,
	EDCExpressState_MAX                      = 2,
};

// Enum DungeonCrawler.EDCCurrencyType
// NumValues: 0x0005
enum class EDCCurrencyType : uint8
{
	None                                     = 0,
	Gold                                     = 1,
	BlueStone                                = 2,
	RedStone                                 = 3,
	EDCCurrencyType_MAX                      = 4,
};

// Enum DungeonCrawler.EDCAccountNameCheckState
// NumValues: 0x0004
enum class EDCAccountNameCheckState : uint8
{
	None                                     = 0,
	Failed                                   = 1,
	Succeed                                  = 2,
	EDCAccountNameCheckState_MAX             = 3,
};

// Enum DungeonCrawler.EDCPlatform
// NumValues: 0x0007
enum class EDCPlatform : uint8
{
	None                                     = 0,
	Steam                                    = 1,
	EpicGames                                = 2,
	Blacksmith                               = 3,
	ChafGames                                = 4,
	Microsoft                                = 5,
	EDCPlatform_MAX                          = 6,
};

// Enum DungeonCrawler.EDCAccountStatus
// NumValues: 0x0004
enum class EDCAccountStatus : uint8
{
	None                                     = 0,
	Squire                                   = 1,
	Legendary                                = 2,
	EDCAccountStatus_MAX                     = 3,
};

// Enum DungeonCrawler.EDCActionSkinType
// NumValues: 0x0003
enum class EDCActionSkinType : uint8
{
	None                                     = 0,
	Rest                                     = 1,
	EDCActionSkinType_MAX                    = 2,
};

// Enum DungeonCrawler.EDCArenaForceResultReason
// NumValues: 0x0003
enum class EDCArenaForceResultReason : uint8
{
	None                                     = 0,
	NoOpponent                               = 1,
	EDCArenaForceResultReason_MAX            = 2,
};

// Enum DungeonCrawler.EDCArenaTeam
// NumValues: 0x0004
enum class EDCArenaTeam : uint8
{
	None                                     = 0,
	Red                                      = 1,
	Blue                                     = 2,
	EDCArenaTeam_MAX                         = 3,
};

// Enum DungeonCrawler.EInvisibleState
// NumValues: 0x0004
enum class EInvisibleState : uint8
{
	None                                     = 0,
	InvisibleParty                           = 1,
	Invisible                                = 2,
	EInvisibleState_MAX                      = 3,
};

// Enum DungeonCrawler.ECharacterCustomMovementMode
// NumValues: 0x0003
enum class ECharacterCustomMovementMode : uint8
{
	CMOVE_None                               = 0,
	CMOVE_Ladder                             = 1,
	CMOVE_MAX                                = 2,
};

// Enum DungeonCrawler.EDCCrossPlatfromLinkPopupState
// NumValues: 0x0005
enum class EDCCrossPlatfromLinkPopupState : uint8
{
	None                                     = 0,
	CheckOtherPlatform                       = 1,
	EnterLinkCode                            = 2,
	LinkCompleted                            = 3,
	EDCCrossPlatfromLinkPopupState_MAX       = 4,
};

// Enum DungeonCrawler.EDCDamageIndicateType
// NumValues: 0x0004
enum class EDCDamageIndicateType : uint8
{
	None                                     = 0,
	Magical                                  = 1,
	Physical                                 = 2,
	EDCDamageIndicateType_MAX                = 3,
};

// Enum DungeonCrawler.EHitBoxType
// NumValues: 0x0009
enum class EHitBoxType : uint8
{
	None                                     = 0,
	Head                                     = 1,
	Body                                     = 2,
	Arm                                      = 3,
	Leg                                      = 4,
	Hand                                     = 5,
	Foot                                     = 6,
	Custom                                   = 7,
	EHitBoxType_MAX                          = 8,
};

// Enum DungeonCrawler.EHitDirection
// NumValues: 0x0006
enum class EHitDirection : uint8
{
	None                                     = 0,
	Front                                    = 1,
	Back                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	EHitDirection_MAX                        = 5,
};

// Enum DungeonCrawler.EDCProgressType
// NumValues: 0x0005
enum class EDCProgressType : uint8
{
	None                                     = 0,
	EquipStart                               = 1,
	EquipCancel                              = 2,
	EquipFinish                              = 3,
	EDCProgressType_MAX                      = 4,
};

// Enum DungeonCrawler.EDCItemTooltipStatType
// NumValues: 0x0003
enum class EDCItemTooltipStatType : uint8
{
	ConfirmedStat                            = 0,
	RangedStat                               = 1,
	EDCItemTooltipStatType_MAX               = 2,
};

// Enum DungeonCrawler.EDCItemType
// NumValues: 0x0008
enum class EDCItemType : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	Armor                                    = 2,
	Utility                                  = 3,
	Accessory                                = 4,
	Misc                                     = 5,
	Misc_Gem                                 = 6,
	EDCItemType_MAX                          = 7,
};

// Enum DungeonCrawler.EDCValidatorTargetType
// NumValues: 0x0003
enum class EDCValidatorTargetType : uint8
{
	Add                                      = 0,
	Merge                                    = 1,
	EDCValidatorTargetType_MAX               = 2,
};

// Enum DungeonCrawler.EDCInventoryValidatorType
// NumValues: 0x0008
enum class EDCInventoryValidatorType : uint8
{
	None                                     = 0,
	NotAllowed                               = 1,
	MerchantOnly                             = 2,
	SuppliedItemNotAllowed                   = 3,
	LockedItemNotAllowed                     = 4,
	MergeLootStateNotAllowed                 = 5,
	ExpressmanFilter                         = 6,
	EDCInventoryValidatorType_MAX            = 7,
};

// Enum DungeonCrawler.EDCKillLogWidgetType
// NumValues: 0x0005
enum class EDCKillLogWidgetType : uint8
{
	None                                     = 0,
	KillLog                                  = 1,
	FloorLog                                 = 2,
	OperationAnnounce                        = 3,
	EDCKillLogWidgetType_MAX                 = 4,
};

// Enum DungeonCrawler.EDCKillReason
// NumValues: 0x0006
enum class EDCKillReason : uint8
{
	None                                     = 0,
	Killed                                   = 1,
	FellOutOfWorld                           = 2,
	OutsideWorldBounds                       = 3,
	FloorRuleFinished                        = 4,
	EDCKillReason_MAX                        = 5,
};

// Enum DungeonCrawler.EDCCaptureStudioType
// NumValues: 0x0005
enum class EDCCaptureStudioType : uint8
{
	None                                     = 0,
	Inventory                                = 1,
	Customize                                = 2,
	Shop                                     = 3,
	EDCCaptureStudioType_MAX                 = 4,
};

// Enum DungeonCrawler.EDCLogEventType
// NumValues: 0x0013
enum class EDCLogEventType : uint8
{
	None                                     = 0,
	PlayerKill                               = 1,
	DungeonDown                              = 2,
	MonsterKill                              = 3,
	PropsInteraction                         = 4,
	ItemAchieve                              = 5,
	PlayerDead                               = 6,
	PlayerLocation                           = 7,
	PlayerLootNewItem                        = 8,
	SubBossKill                              = 9,
	BossKill                                 = 10,
	HighEndPropsInteraction                  = 11,
	Treasure                                 = 12,
	EntranceFee                              = 13,
	PlayerKillAssist                         = 14,
	MonsterKillAssist                        = 15,
	SubBossKillAssist                        = 16,
	BossKillAssist                           = 17,
	EDCLogEventType_MAX                      = 18,
};

// Enum DungeonCrawler.EDCLoginState
// NumValues: 0x0011
enum class EDCLoginState : uint8
{
	None                                     = 0,
	GRACCheck                                = 1,
	AbnormalDisconnection                    = 2,
	Welcome                                  = 3,
	VoipInitializeCheck                      = 4,
	PreloadCheck                             = 5,
	LinkCrossPlatform                        = 6,
	CheckAccountNickname                     = 7,
	InputIdAndPw                             = 8,
	NsLookup                                 = 9,
	Connect                                  = 10,
	Login                                    = 11,
	ConfirmToReconnect                       = 12,
	AcceptToReconnect                        = 13,
	Enter                                    = 14,
	NotifyPrevGameClosed                     = 15,
	EDCLoginState_MAX                        = 16,
};

// Enum DungeonCrawler.EDCLootTargetType
// NumValues: 0x0005
enum class EDCLootTargetType : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Monster                                  = 2,
	Prop                                     = 3,
	EDCLootTargetType_MAX                    = 4,
};

// Enum DungeonCrawler.EDCMarketplaceState
// NumValues: 0x0007
enum class EDCMarketplaceState : uint8
{
	None                                     = 0,
	ViewMarket                               = 1,
	BuyItem                                  = 2,
	ViewMyListing                            = 3,
	ListItem                                 = 4,
	TransferPayments                         = 5,
	EDCMarketplaceState_MAX                  = 6,
};

// Enum DungeonCrawler.EDCMarketplaceMyListState
// NumValues: 0x0006
enum class EDCMarketplaceMyListState : uint8
{
	None                                     = 0,
	Listing                                  = 1,
	ListingExpired                           = 2,
	Sold                                     = 3,
	TransferExpired                          = 4,
	EDCMarketplaceMyListState_MAX            = 5,
};

// Enum DungeonCrawler.EDCMarketplaceFilterType
// NumValues: 0x000A
enum class EDCMarketplaceFilterType : uint8
{
	None                                     = 0,
	Name                                     = 1,
	Rarity                                   = 2,
	Slot                                     = 3,
	Type                                     = 4,
	StaticAttribute                          = 5,
	RandomAttribute                          = 6,
	Price                                    = 7,
	ClassRequirement                         = 8,
	EDCMarketplaceFilterType_MAX             = 9,
};

// Enum DungeonCrawler.EDCMarketplaceSortMethod
// NumValues: 0x0004
enum class EDCMarketplaceSortMethod : uint8
{
	None                                     = 0,
	Ascending                                = 1,
	Descending                               = 2,
	EDCMarketplaceSortMethod_MAX             = 3,
};

// Enum DungeonCrawler.EDCMaterialType
// NumValues: 0x0005
enum class EDCMaterialType : uint8
{
	None                                     = 0,
	Coldness                                 = 1,
	Hide                                     = 2,
	Phantomize                               = 3,
	EDCMaterialType_MAX                      = 4,
};

// Enum DungeonCrawler.EDCMerchantFilterType
// NumValues: 0x0005
enum class EDCMerchantFilterType : uint8
{
	None                                     = 0,
	Name                                     = 1,
	Rarity                                   = 2,
	Slot                                     = 3,
	EDCMerchantFilterType_MAX                = 4,
};

// Enum DungeonCrawler.EMonsterSpawnerType
// NumValues: 0x0003
enum class EMonsterSpawnerType : uint8
{
	Circle                                   = 0,
	Rect                                     = 1,
	EMonsterSpawnerType_MAX                  = 2,
};

// Enum DungeonCrawler.EDCNPCType
// NumValues: 0x0003
enum class EDCNPCType : uint8
{
	None                                     = 0,
	Expressman                               = 1,
	EDCNPCType_MAX                           = 2,
};

// Enum DungeonCrawler.EDCPedestalPortalScrollNum
// NumValues: 0x0003
enum class EDCPedestalPortalScrollNum : uint8
{
	Solo                                     = 0,
	Trio                                     = 1,
	EDCPedestalPortalScrollNum_MAX           = 2,
};

// Enum DungeonCrawler.EDCExitType
// NumValues: 0x0008
enum class EDCExitType : uint8
{
	None                                     = 0,
	BackToLobby                              = 1,
	ExitClient                               = 2,
	BackToLobbyWithLoginFailure              = 3,
	BackToLobbyWithTerminatePopup            = 4,
	ExitClientWithDetectPopup                = 5,
	BackToLobbyWithInternalError             = 6,
	EDCExitType_MAX                          = 7,
};

// Enum DungeonCrawler.EDCServerTriggeredEventType
// NumValues: 0x0004
enum class EDCServerTriggeredEventType : uint8
{
	None                                     = 0,
	PostGC                                   = 1,
	IronShieldDetect                         = 2,
	EDCServerTriggeredEventType_MAX          = 3,
};

// Enum DungeonCrawler.EDCOnlineState
// NumValues: 0x0006
enum class EDCOnlineState : uint8
{
	None                                     = 0,
	Reserved                                 = 1,
	Online                                   = 2,
	Disconnected                             = 3,
	Exit                                     = 4,
	EDCOnlineState_MAX                       = 5,
};

// Enum DungeonCrawler.EDCDungeonState
// NumValues: 0x0006
enum class EDCDungeonState : uint8
{
	None                                     = 0,
	Playing                                  = 1,
	Escaped                                  = 2,
	NextFloor                                = 3,
	FloorMatchmaking                         = 4,
	EDCDungeonState_MAX                      = 5,
};

// Enum DungeonCrawler.EDCSpectatorSearchType
// NumValues: 0x0006
enum class EDCSpectatorSearchType : uint8
{
	None                                     = 0,
	Right                                    = 1,
	Left                                     = 2,
	Dead                                     = 3,
	Refresh                                  = 4,
	EDCSpectatorSearchType_MAX               = 5,
};

// Enum DungeonCrawler.EDCSpectatorAttachType
// NumValues: 0x0004
enum class EDCSpectatorAttachType : uint8
{
	None                                     = 0,
	PlayerCharacter                          = 1,
	Fly                                      = 2,
	EDCSpectatorAttachType_MAX               = 3,
};

// Enum DungeonCrawler.EDCPoolingObjectType
// NumValues: 0x0009
enum class EDCPoolingObjectType : uint8
{
	None                                     = 0,
	DCMobCharacter1                          = 1,
	DCMobCharacter2                          = 2,
	DCMobCharacter3                          = 3,
	NiagaraComponent                         = 4,
	SkeletalMeshComponent                    = 5,
	WidgetComponent                          = 6,
	DCWidget                                 = 7,
	EDCPoolingObjectType_MAX                 = 8,
};

// Enum DungeonCrawler.EDCPreLobbyMenu
// NumValues: 0x0004
enum class EDCPreLobbyMenu : uint8
{
	None                                     = 0,
	CreateCharacter                          = 1,
	SelectCharacter                          = 2,
	EDCPreLobbyMenu_MAX                      = 3,
};

// Enum DungeonCrawler.EDCQuestContentsDataType
// NumValues: 0x0009
enum class EDCQuestContentsDataType : uint8
{
	Default                                  = 0,
	DungeonType                              = 1,
	MustEscape                               = 2,
	NoDamage                                 = 3,
	ConsecutiveEscape                        = 4,
	SingleSession                            = 5,
	HealthRequirementType                    = 6,
	ItemRarityType                           = 7,
	EDCQuestContentsDataType_MAX             = 8,
};

// Enum DungeonCrawler.EDCQuestLogStatus
// NumValues: 0x0006
enum class EDCQuestLogStatus : uint8
{
	Default                                  = 0,
	NotStart                                 = 1,
	Progress                                 = 2,
	Complete                                 = 3,
	Failed                                   = 4,
	EDCQuestLogStatus_MAX                    = 5,
};

// Enum DungeonCrawler.EDCQuestHealthRequirementType
// NumValues: 0x0004
enum class EDCQuestHealthRequirementType : uint8
{
	None                                     = 0,
	Less                                     = 1,
	Greater                                  = 2,
	EDCQuestHealthRequirementType_MAX        = 3,
};

// Enum DungeonCrawler.EDCQuestContentKillType
// NumValues: 0x0004
enum class EDCQuestContentKillType : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Monster                                  = 2,
	EDCQuestContentKillType_MAX              = 3,
};

// Enum DungeonCrawler.EDCQuestState
// NumValues: 0x0007
enum class EDCQuestState : uint8
{
	None                                     = 0,
	Progress                                 = 1,
	Success                                  = 2,
	Complete                                 = 3,
	Locked                                   = 4,
	Available                                = 5,
	EDCQuestState_MAX                        = 6,
};

// Enum DungeonCrawler.EDCQuestContentType
// NumValues: 0x0008
enum class EDCQuestContentType : uint8
{
	None                                     = 0,
	Kill                                     = 1,
	Fetch                                    = 2,
	Survive                                  = 3,
	Explore                                  = 4,
	Props                                    = 5,
	UseItem                                  = 6,
	EDCQuestContentType_MAX                  = 7,
};

// Enum DungeonCrawler.EDCQuestContentPropsType
// NumValues: 0x0004
enum class EDCQuestContentPropsType : uint8
{
	None                                     = 0,
	Interact                                 = 1,
	Destroy                                  = 2,
	EDCQuestContentPropsType_MAX             = 3,
};

// Enum DungeonCrawler.EDCReportPlayerResultType
// NumValues: 0x0004
enum class EDCReportPlayerResultType : uint8
{
	None                                     = 0,
	PermanentBan                             = 1,
	TemporaryBan                             = 2,
	EDCReportPlayerResultType_MAX            = 3,
};

// Enum DungeonCrawler.EDCReportPlayerCategory
// NumValues: 0x0005
enum class EDCReportPlayerCategory : uint8
{
	None                                     = 0,
	Cheater                                  = 1,
	PreTeaming                               = 2,
	InappropriateName                        = 3,
	EDCReportPlayerCategory_MAX              = 4,
};

// Enum DungeonCrawler.EDCRewardType
// NumValues: 0x000F
enum class EDCRewardType : uint8
{
	None                                     = 0,
	CharacterSkin                            = 1,
	ItemSkin                                 = 2,
	Emote                                    = 3,
	Action                                   = 4,
	LobbyEmote                               = 5,
	ClassPackage                             = 6,
	Item                                     = 7,
	Exp                                      = 8,
	Affinity                                 = 9,
	Stash                                    = 10,
	ArmorSkin                                = 11,
	Unidentified                             = 12,
	RewardToken                              = 13,
	EDCRewardType_MAX                        = 14,
};

// Enum DungeonCrawler.EDCRopeMoveType
// NumValues: 0x0004
enum class EDCRopeMoveType : uint8
{
	None                                     = 0,
	Down                                     = 1,
	Up                                       = 2,
	EDCRopeMoveType_MAX                      = 3,
};

// Enum DungeonCrawler.EDCShopItemType
// NumValues: 0x0008
enum class EDCShopItemType : uint8
{
	None                                     = 0,
	CharacterSkin                            = 1,
	ItemSkin                                 = 2,
	Emote                                    = 3,
	ActionSkin                               = 4,
	LobbyEmote                               = 5,
	ClassPackage                             = 6,
	EDCShopItemType_MAX                      = 7,
};

// Enum DungeonCrawler.EDCShopSalesChannelType
// NumValues: 0x0004
enum class EDCShopSalesChannelType : uint8
{
	None                                     = 0,
	Shop                                     = 1,
	Exclusive                                = 2,
	EDCShopSalesChannelType_MAX              = 3,
};

// Enum DungeonCrawler.EDCShopItemState
// NumValues: 0x0005
enum class EDCShopItemState : uint8
{
	None                                     = 0,
	Owned                                    = 1,
	New                                      = 2,
	Discounted                               = 3,
	EDCShopItemState_MAX                     = 4,
};

// Enum DungeonCrawler.EDCShopState
// NumValues: 0x0005
enum class EDCShopState : uint8
{
	None                                     = 0,
	New                                      = 1,
	DiscountStart                            = 2,
	DiscountEnd                              = 3,
	EDCShopState_MAX                         = 4,
};

// Enum DungeonCrawler.EDCSortButtonState
// NumValues: 0x0004
enum class EDCSortButtonState : uint8
{
	None                                     = 0,
	Ascending                                = 1,
	Descending                               = 2,
	EDCSortButtonState_MAX                   = 3,
};

// Enum DungeonCrawler.EDCTrainingState
// NumValues: 0x0004
enum class EDCTrainingState : uint8
{
	None                                     = 0,
	RedeemLearningToken                      = 1,
	RedeemRewardToken                        = 2,
	EDCTrainingState_MAX                     = 3,
};

// Enum DungeonCrawler.EDCTrainingClassAbilityType
// NumValues: 0x0007
enum class EDCTrainingClassAbilityType : uint8
{
	None                                     = 0,
	Perk                                     = 1,
	Skill                                    = 2,
	Spell                                    = 3,
	Music                                    = 4,
	ShapeShift                               = 5,
	EDCTrainingClassAbilityType_MAX          = 6,
};

// Enum DungeonCrawler.EDCQuestRichTextFormatType
// NumValues: 0x0004
enum class EDCQuestRichTextFormatType : uint8
{
	Default                                  = 0,
	QuestChangeCount                         = 1,
	QuestHasDamage                           = 2,
	EDCQuestRichTextFormatType_MAX           = 3,
};

// Enum DungeonCrawler.EDCPortalScrollType
// NumValues: 0x0004
enum class EDCPortalScrollType : uint8
{
	None                                     = 0,
	Escape                                   = 1,
	Down                                     = 2,
	EDCPortalScrollType_MAX                  = 3,
};

// Enum DungeonCrawler.EDCFriendStatus
// NumValues: 0x0005
enum class EDCFriendStatus : uint8
{
	None                                     = 0,
	Offline                                  = 1,
	Online                                   = 2,
	Absense                                  = 3,
	EDCFriendStatus_MAX                      = 4,
};

// Enum DungeonCrawler.EDCLocationStatus
// NumValues: 0x0005
enum class EDCLocationStatus : uint8
{
	None                                     = 0,
	Lobby                                    = 1,
	Dungeon                                  = 2,
	Offline                                  = 3,
	EDCLocationStatus_MAX                    = 4,
};

// Enum DungeonCrawler.EFunctionTriggerType
// NumValues: 0x0003
enum class EFunctionTriggerType : uint8
{
	Once                                     = 0,
	Repeat                                   = 1,
	EFunctionTriggerType_MAX                 = 2,
};

// Enum DungeonCrawler.EOptionLinkType
// NumValues: 0x000A
enum class EOptionLinkType : uint8
{
	None                                     = 0,
	Home                                     = 1,
	News                                     = 2,
	Suggestion                               = 3,
	OfficialDiscord                          = 4,
	KnightLink                               = 5,
	SupportFAQ                               = 6,
	GeneralReport                            = 7,
	BugReport                                = 8,
	EOptionLinkType_MAX                      = 9,
};

// Enum DungeonCrawler.EGameStateType
// NumValues: 0x0014
enum class EGameStateType : uint8
{
	None                                     = 0,
	TavernWait                               = 1,
	TavernCountDown                          = 2,
	TavernStart                              = 3,
	FloorMatchmakingWaiting                  = 4,
	DungeonPrepareLevel                      = 5,
	DungeonPrepareNPC                        = 6,
	DungeonPreparePC                         = 7,
	DungeonWaiting                           = 8,
	DungeonPlay                              = 9,
	DungeonNextFloor                         = 10,
	DungeonResult                            = 11,
	ArenaWelcome                             = 12,
	ArenaRound                               = 13,
	ArenaRoundResult                         = 14,
	ArenaIntermission                        = 15,
	ArenaResult                              = 16,
	LobbyPrepareAccount                      = 17,
	LobbyStart                               = 18,
	EGameStateType_MAX                       = 19,
};

// Enum DungeonCrawler.EMatchMode
// NumValues: 0x0004
enum class EMatchMode : uint8
{
	None                                     = 0,
	Classic                                  = 1,
	DungeonRotation                          = 2,
	EMatchMode_MAX                           = 3,
};

// Enum DungeonCrawler.EFloorLogType
// NumValues: 0x0006
enum class EFloorLogType : uint8
{
	None                                     = 0,
	EscapePortal                             = 1,
	DownPortal                               = 2,
	Escape                                   = 3,
	Down                                     = 4,
	EFloorLogType_MAX                        = 5,
};

// Enum DungeonCrawler.EDCObjectLinkEventMethodType
// NumValues: 0x0006
enum class EDCObjectLinkEventMethodType : uint8
{
	AddGameplayTag                           = 0,
	AddLooseGameplayTag                      = 1,
	RemoveActiveEffectsWithGrantedTags       = 2,
	SendGameplayEventToActor                 = 3,
	AddGameplayCue                           = 4,
	EDCObjectLinkEventMethodType_MAX         = 5,
};

// Enum DungeonCrawler.ELeaderboardContentType
// NumValues: 0x0006
enum class ELeaderboardContentType : uint8
{
	VeteranAdventurer                        = 0,
	TreasureCollector                        = 1,
	KillerOutlaw                             = 2,
	EscapeArtist                             = 3,
	Slayer                                   = 4,
	ELeaderboardContentType_MAX              = 5,
};

// Enum DungeonCrawler.EStatisticsType
// NumValues: 0x0015
enum class EStatisticsType : uint8
{
	None                                     = 0,
	GamePlay                                 = 1,
	Escape                                   = 2,
	DownPortal                               = 3,
	PlayerKill                               = 4,
	Death                                    = 5,
	Treasure                                 = 6,
	MonsterKill                              = 7,
	SubBossKill                              = 8,
	BossKill                                 = 9,
	PropsOrnateChest                         = 10,
	PropsRoyalCoffin                         = 11,
	PropsLionsHeadChest                      = 12,
	PropsGoldenChest                         = 13,
	PropsMarvelousChest                      = 14,
	ReviveAlly                               = 15,
	PlayerKillAssist                         = 16,
	MonsterKillAssist                        = 17,
	SubBossKillAssist                        = 18,
	BossKillAssist                           = 19,
	EStatisticsType_MAX                      = 20,
};

// Enum DungeonCrawler.EDCWhisperReceiveType
// NumValues: 0x0005
enum class EDCWhisperReceiveType : uint8
{
	None                                     = 0,
	All                                      = 1,
	Friend                                   = 2,
	Block                                    = 3,
	EDCWhisperReceiveType_MAX                = 4,
};

// Enum DungeonCrawler.EAntialiasMode
// NumValues: 0x0008
enum class EAntialiasMode : uint8
{
	AntialiasMode_None                       = 0,
	AntialiasMode_FXAA                       = 1,
	AntialiasMode_TAA                        = 2,
	AntialiasMode_TSR                        = 3,
	AntialiasMode_DLSS                       = 4,
	AntialiasMode_FSR                        = 5,
	AntialiasMode_Xess                       = 6,
	AntialiasMode_Max                        = 7,
};

// Enum DungeonCrawler.EMeleeAttackStuckType
// NumValues: 0x0007
enum class EMeleeAttackStuckType : uint8
{
	None                                     = 0,
	HitBox                                   = 1,
	WeakShield                               = 2,
	MidShield                                = 3,
	HeavyShield                              = 4,
	StaticObject                             = 5,
	EMeleeAttackStuckType_MAX                = 6,
};

// Enum DungeonCrawler.ESkillCheckResult
// NumValues: 0x0005
enum class ESkillCheckResult : uint8
{
	None                                     = 0,
	PerfectSucceed                           = 1,
	Succeed                                  = 2,
	Failed                                   = 3,
	ESkillCheckResult_MAX                    = 4,
};

// Enum DungeonCrawler.EDCInteractableType
// NumValues: 0x0005
enum class EDCInteractableType : uint8
{
	None                                     = 0,
	Interactable                             = 1,
	SourceConditionNotMet                    = 2,
	TargetConditionNotMet                    = 3,
	EDCInteractableType_MAX                  = 4,
};

// Enum DungeonCrawler.ESlotSearchResult
// NumValues: 0x0004
enum class ESlotSearchResult : uint8
{
	InventoryFull                            = 0,
	NotEnoughSlots                           = 1,
	Success                                  = 2,
	ESlotSearchResult_MAX                    = 3,
};

// Enum DungeonCrawler.EItemEquipState
// NumValues: 0x0006
enum class EItemEquipState : uint8
{
	BareHands                                = 0,
	TwoHandedPrimaryItemEquipped             = 1,
	OneHandedPrimaryItemEquipped             = 2,
	SecondaryItemEquipped                    = 3,
	EachHandFull                             = 4,
	EItemEquipState_MAX                      = 5,
};

// Enum DungeonCrawler.EDCItemDropPreview
// NumValues: 0x0004
enum class EDCItemDropPreview : uint8
{
	None                                     = 0,
	Valid                                    = 1,
	Invalid                                  = 2,
	EDCItemDropPreview_MAX                   = 3,
};

// Enum DungeonCrawler.EDCItemEquipType
// NumValues: 0x000F
enum class EDCItemEquipType : uint8
{
	None                                     = 0,
	Unarmed                                  = 1,
	Primary                                  = 2,
	Secondary                                = 3,
	Utility                                  = 4,
	SoulHeart                                = 5,
	Head                                     = 6,
	Chest                                    = 7,
	Legs                                     = 8,
	Foot                                     = 9,
	Hands                                    = 10,
	Back                                     = 11,
	Necklace                                 = 12,
	Ring                                     = 13,
	EDCItemEquipType_MAX                     = 14,
};

// Enum DungeonCrawler.EDCItemActionType
// NumValues: 0x0006
enum class EDCItemActionType : uint8
{
	Default                                  = 0,
	EquipToggle                              = 1,
	StashToggle                              = 2,
	StashToggleSingle                        = 3,
	LinkToChat                               = 4,
	EDCItemActionType_MAX                    = 5,
};

// Enum DungeonCrawler.EDCItemAttachType
// NumValues: 0x0004
enum class EDCItemAttachType : uint8
{
	None                                     = 0,
	Hand                                     = 1,
	Back                                     = 2,
	EDCItemAttachType_MAX                    = 3,
};

// Enum DungeonCrawler.EItemRandomGenerateType
// NumValues: 0x0003
enum class EItemRandomGenerateType : uint8
{
	LootDrop                                 = 0,
	ItemType                                 = 1,
	EItemRandomGenerateType_MAX              = 2,
};

// Enum DungeonCrawler.EDCItemRarity
// NumValues: 0x000A
enum class EDCItemRarity : uint8
{
	None                                     = 0,
	Poor                                     = 1,
	Common                                   = 2,
	Uncommon                                 = 3,
	Rare                                     = 4,
	Epic                                     = 5,
	Legend                                   = 6,
	Unique                                   = 7,
	SetPiece                                 = 8,
	EDCItemRarity_MAX                        = 9,
};

// Enum DungeonCrawler.EDCLobbyReadyFailureReason
// NumValues: 0x0005
enum class EDCLobbyReadyFailureReason : uint8
{
	None                                     = 0,
	SameClassNotAllowed                      = 1,
	RarityOverCapItemInArena                 = 2,
	SquireNotAllowedInArena                  = 3,
	EDCLobbyReadyFailureReason_MAX           = 4,
};

// Enum DungeonCrawler.EDCMerchantPriceType
// NumValues: 0x0004
enum class EDCMerchantPriceType : uint8
{
	None                                     = 0,
	Discounted                               = 1,
	Overpaying                               = 2,
	EDCMerchantPriceType_MAX                 = 3,
};

// Enum DungeonCrawler.EDungeonMatchState
// NumValues: 0x0004
enum class EDungeonMatchState : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Succeed                                  = 2,
	EDungeonMatchState_MAX                   = 3,
};

// Enum DungeonCrawler.ELeaderboardState
// NumValues: 0x0009
enum class ELeaderboardState : uint8
{
	None                                     = 0,
	Preseason                                = 1,
	SeasonUnlimited                          = 2,
	Season                                   = 3,
	Postseason                               = 4,
	Wipeseason                               = 5,
	Rewardseason                             = 6,
	Endseason                                = 7,
	ELeaderboardState_MAX                    = 8,
};

// Enum DungeonCrawler.ELeaderboardRankRewardState
// NumValues: 0x0005
enum class ELeaderboardRankRewardState : uint8
{
	None                                     = 0,
	Active                                   = 1,
	Received                                 = 2,
	Finished                                 = 3,
	ELeaderboardRankRewardState_MAX          = 4,
};

// Enum DungeonCrawler.EMonsterCollisionProfile
// NumValues: 0x000A
enum class EMonsterCollisionProfile : uint8
{
	Normal                                   = 0,
	NormalPhysics                            = 1,
	Death                                    = 2,
	Burrow                                   = 3,
	Interactable                             = 4,
	InteractableOnly                         = 5,
	InteractableWithoutHit                   = 6,
	Fly                                      = 7,
	BeforeDeath                              = 8,
	EMonsterCollisionProfile_MAX             = 9,
};

// Enum DungeonCrawler.EMonsterFilterSortingType
// NumValues: 0x0003
enum class EMonsterFilterSortingType : uint8
{
	Ascending                                = 0,
	Desending                                = 1,
	EMonsterFilterSortingType_MAX            = 2,
};

// Enum DungeonCrawler.EWidgetMusicSlotsType
// NumValues: 0x0004
enum class EWidgetMusicSlotsType : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	EWidgetMusicSlotsType_MAX                = 3,
};

// Enum DungeonCrawler.EMusicPlayabilityType
// NumValues: 0x0006
enum class EMusicPlayabilityType : uint8
{
	None                                     = 0,
	Playable                                 = 1,
	NeedProperInstrument                     = 2,
	NotSelected                              = 3,
	CapacityOverloaded                       = 4,
	EMusicPlayabilityType_MAX                = 5,
};

// Enum DungeonCrawler.EMusicPlaySectionJudgement
// NumValues: 0x0006
enum class EMusicPlaySectionJudgement : uint8
{
	None                                     = 0,
	Miss                                     = 1,
	Bad                                      = 2,
	Good                                     = 3,
	Perfect                                  = 4,
	EMusicPlaySectionJudgement_MAX           = 5,
};

// Enum DungeonCrawler.EForceRandomMatchType
// NumValues: 0x0004
enum class EForceRandomMatchType : uint8
{
	None                                     = 0,
	ForceRandomMatch                         = 1,
	ForceNotRandomMatch                      = 2,
	EForceRandomMatchType_MAX                = 3,
};

// Enum DungeonCrawler.EReportMsgType
// NumValues: 0x0005
enum class EReportMsgType : uint8
{
	None                                     = 0,
	Info                                     = 1,
	Error                                    = 2,
	Detect                                   = 3,
	EReportMsgType_MAX                       = 4,
};

// Enum DungeonCrawler.EUpdateReason
// NumValues: 0x0008
enum class EUpdateReason : uint8
{
	NO_UPDATE_RECEIVED                       = 0,
	BACKFILL_INITIATED                       = 1,
	MATCHMAKING_DATA_UPDATED                 = 2,
	BACKFILL_FAILED                          = 3,
	BACKFILL_TIMED_OUT                       = 4,
	BACKFILL_CANCELLED                       = 5,
	BACKFILL_COMPLETED                       = 6,
	EUpdateReason_MAX                        = 7,
};

// Enum DungeonCrawler.ECheckItemUniqueIdType
// NumValues: 0x0007
enum class ECheckItemUniqueIdType : uint8
{
	None                                     = 0,
	Escape                                   = 1,
	DungeonRecovery                          = 2,
	FriendItemRecovery                       = 3,
	ExpressMan                               = 4,
	ArenaEscape                              = 5,
	ECheckItemUniqueIdType_MAX               = 6,
};

// Enum DungeonCrawler.EWidgetShapeShiftSlotsType
// NumValues: 0x0004
enum class EWidgetShapeShiftSlotsType : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	EWidgetShapeShiftSlotsType_MAX           = 3,
};

// Enum DungeonCrawler.EShapeShiftCastabilityType
// NumValues: 0x0005
enum class EShapeShiftCastabilityType : uint8
{
	None                                     = 0,
	Castable                                 = 1,
	CollisionBlocked                         = 2,
	NotSelected                              = 3,
	EShapeShiftCastabilityType_MAX           = 4,
};

// Enum DungeonCrawler.ESkillIndex
// NumValues: 0x0003
enum class ESkillIndex : uint8
{
	SKILL_INDEX_ONE                          = 0,
	SKILL_INDEX_TWO                          = 1,
	SKILL_INDEX_MAX                          = 2,
};

// Enum DungeonCrawler.ESkillActivatableType
// NumValues: 0x0008
enum class ESkillActivatableType : uint8
{
	None                                     = 0,
	Activatable                              = 1,
	OnCooldown                               = 2,
	NotEnoughCount                           = 3,
	NotEnoughSpace                           = 4,
	CannotActivateWhileMoving                = 5,
	NoTargetAimed                            = 6,
	ESkillActivatableType_MAX                = 7,
};

// Enum DungeonCrawler.EWidgetSpellSlotsType
// NumValues: 0x0004
enum class EWidgetSpellSlotsType : uint8
{
	None                                     = 0,
	Primary                                  = 1,
	Secondary                                = 2,
	EWidgetSpellSlotsType_MAX                = 3,
};

// Enum DungeonCrawler.ESpellCastabilityType
// NumValues: 0x0006
enum class ESpellCastabilityType : uint8
{
	None                                     = 0,
	Castable                                 = 1,
	NotSelected                              = 2,
	NotEnoughCount                           = 3,
	CapacityOverloaded                       = 4,
	ESpellCastabilityType_MAX                = 5,
};

// Enum DungeonCrawler.EDCBuildConfiguration
// NumValues: 0x0007
enum class EDCBuildConfiguration : uint8
{
	Unknown                                  = 0,
	Debug                                    = 1,
	DebugGame                                = 2,
	Development                              = 3,
	Shipping                                 = 4,
	Test                                     = 5,
	EDCBuildConfiguration_MAX                = 6,
};

// Enum DungeonCrawler.EVoipAkComponentState
// NumValues: 0x0005
enum class EVoipAkComponentState : uint8
{
	None                                     = 0,
	Send                                     = 1,
	Receive2d                                = 2,
	Receive3d                                = 3,
	EVoipAkComponentState_MAX                = 4,
};

// Enum DungeonCrawler.EVoipStatus
// NumValues: 0x0005
enum class EVoipStatus : uint8
{
	None                                     = 0,
	Waiting                                  = 1,
	Speaking                                 = 2,
	Muted                                    = 3,
	EVoipStatus_MAX                          = 4,
};

// Enum DungeonCrawler.EWidgetCharacterSelectGroupType
// NumValues: 0x0006
enum class EWidgetCharacterSelectGroupType : uint8
{
	None                                     = 0,
	CharacterSelectMain                      = 1,
	CharacterCreateMain                      = 2,
	Menu                                     = 3,
	MessageAnnounce                          = 4,
	EWidgetCharacterSelectGroupType_MAX      = 5,
};

// Enum DungeonCrawler.EWidgetGameGroupType
// NumValues: 0x001D
enum class EWidgetGameGroupType : uint8
{
	None                                     = 0,
	Main                                     = 1,
	Menu                                     = 2,
	Inventory                                = 3,
	Status                                   = 4,
	Interact                                 = 5,
	Alive                                    = 6,
	Spectator                                = 7,
	PartyManage                              = 8,
	ClassSelect                              = 9,
	Class                                    = 10,
	SpellSelect                              = 11,
	SpellSelectSecondary                     = 12,
	ShapeShiftSelect                         = 13,
	ShapeShiftSelectSecondary                = 14,
	EmoteSelect                              = 15,
	PlaqueText                               = 16,
	Customize                                = 17,
	ReportPlayer                             = 18,
	MusicSelect                              = 19,
	MusicSelectSecondary                     = 20,
	TestCmd                                  = 21,
	TestItemInjection                        = 22,
	DungeonResult                            = 23,
	DeathCam                                 = 24,
	QuestLog                                 = 25,
	GameSessionInfo                          = 26,
	DungeonMap                               = 27,
	EWidgetGameGroupType_MAX                 = 28,
};

// Enum DungeonCrawler.EWidgetInventoryGroupType
// NumValues: 0x0005
enum class EWidgetInventoryGroupType : uint8
{
	LinkedPlayer                             = 0,
	LootingTarget                            = 1,
	LootingTargetPlayer                      = 2,
	Storage                                  = 3,
	EWidgetInventoryGroupType_MAX            = 4,
};

// Enum DungeonCrawler.EMsgWidgetChatResult
// NumValues: 0x0003
enum class EMsgWidgetChatResult : uint8
{
	Succeed                                  = 0,
	Wait                                     = 1,
	EMsgWidgetChatResult_MAX                 = 2,
};

// Enum DungeonCrawler.EMsgWidgetWhisperChatResult
// NumValues: 0x0004
enum class EMsgWidgetWhisperChatResult : uint8
{
	Succeed                                  = 0,
	Wait                                     = 1,
	UserNotFound                             = 2,
	EMsgWidgetWhisperChatResult_MAX          = 3,
};

// Enum DungeonCrawler.EWidgetLobbyGroupType
// NumValues: 0x001B
enum class EWidgetLobbyGroupType : uint8
{
	None                                     = 0,
	Play                                     = 1,
	TopMenu                                  = 2,
	Menu                                     = 3,
	Leaderboard                              = 4,
	Status                                   = 5,
	InviteParty                              = 6,
	Loadout                                  = 7,
	MerchantList                             = 8,
	Merchant                                 = 9,
	Class                                    = 10,
	TradeChannelList                         = 11,
	TradeChannel                             = 12,
	Trading                                  = 13,
	TradeConfirm                             = 14,
	Customize                                = 15,
	Shop                                     = 16,
	Block                                    = 17,
	RecruitChannelList                       = 18,
	RecruitChannel                           = 19,
	Karma                                    = 20,
	LobbyEmoteSelect                         = 21,
	Marketplace                              = 22,
	MarketplacePurchase                      = 23,
	QuestLog                                 = 24,
	Religion                                 = 25,
	EWidgetLobbyGroupType_MAX                = 26,
};

// Enum DungeonCrawler.EWidgetClassGroupType
// NumValues: 0x0007
enum class EWidgetClassGroupType : uint8
{
	None                                     = 0,
	Level                                    = 1,
	PerkandSkill                             = 2,
	Spell                                    = 3,
	Music                                    = 4,
	ShapeShift                               = 5,
	EWidgetClassGroupType_MAX                = 6,
};

// Enum DungeonCrawler.EDCWidgetLobbyTabType
// NumValues: 0x000C
enum class EDCWidgetLobbyTabType : uint8
{
	None                                     = 0,
	Play                                     = 1,
	Leaderboard                              = 2,
	Religion                                 = 3,
	Class                                    = 4,
	Stash                                    = 5,
	Merchant                                 = 6,
	Trade                                    = 7,
	GatheringHall                            = 8,
	Customize                                = 9,
	Shop                                     = 10,
	EDCWidgetLobbyTabType_MAX                = 11,
};

// Enum DungeonCrawler.EWidgetPlayUserPartyState
// NumValues: 0x0004
enum class EWidgetPlayUserPartyState : uint8
{
	Solo                                     = 0,
	Ready                                    = 1,
	NotReady                                 = 2,
	EWidgetPlayUserPartyState_MAX            = 3,
};

// Enum DungeonCrawler.EWidgetPartyUserLocate
// NumValues: 0x0005
enum class EWidgetPartyUserLocate : uint8
{
	Mine                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	None                                     = 3,
	EWidgetPartyUserLocate_MAX               = 4,
};

// Enum DungeonCrawler.EWidgetPlayerInventoryTabType
// NumValues: 0x0004
enum class EWidgetPlayerInventoryTabType : uint8
{
	None                                     = 0,
	Inventory                                = 1,
	Storage                                  = 2,
	EWidgetPlayerInventoryTabType_MAX        = 3,
};

// Enum DungeonCrawler.EWidgetMerchantServiceCategoryType
// NumValues: 0x0005
enum class EWidgetMerchantServiceCategoryType : uint8
{
	None                                     = 0,
	Trade                                    = 1,
	Service                                  = 2,
	Quest                                    = 3,
	EWidgetMerchantServiceCategoryType_MAX   = 4,
};

// Enum DungeonCrawler.EWidgetMerchantInventoryType
// NumValues: 0x0006
enum class EWidgetMerchantInventoryType : uint8
{
	None                                     = 0,
	StockBuy                                 = 1,
	StockSellBack                            = 2,
	StockCraft                               = 3,
	DealTable                                = 4,
	EWidgetMerchantInventoryType_MAX         = 5,
};

// Enum DungeonCrawler.EWidgetCustomizeType
// NumValues: 0x0007
enum class EWidgetCustomizeType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Item                                     = 2,
	Emote                                    = 3,
	LobbyEmote                               = 4,
	Rest                                     = 5,
	EWidgetCustomizeType_MAX                 = 6,
};

// Enum DungeonCrawler.EDCMerchantMarker
// NumValues: 0x0006
enum class EDCMerchantMarker : uint8
{
	None                                     = 0,
	Quest                                    = 1,
	Success                                  = 2,
	Recovery                                 = 3,
	Express                                  = 4,
	EDCMerchantMarker_MAX                    = 5,
};

// Enum DungeonCrawler.EPopupButtonType
// NumValues: 0x000D
enum class EPopupButtonType : uint8
{
	None                                     = 0,
	NoButton                                 = 1,
	OneButton                                = 2,
	OneButton_Confirm                        = 3,
	TwoButton_InviteParty                    = 4,
	TwoButton_YesNo                          = 5,
	TwoButton_LobbySpectator                 = 6,
	TwoButton_DeleteCharacter                = 7,
	TwoButton_GetRedstoneShard               = 8,
	TwoButton_BanAppeal                      = 9,
	TwoButton_TwitchConnect                  = 10,
	TwoButton_TwitchDisconnect               = 11,
	EPopupButtonType_MAX                     = 12,
};

// Enum DungeonCrawler.EServiceConnectFailType
// NumValues: 0x000C
enum class EServiceConnectFailType : uint8
{
	None                                     = 0,
	ConnectFail                              = 1,
	SteamVersionUpdate                       = 2,
	Ban                                      = 3,
	NotSteam                                 = 4,
	DuplicatedLogin                          = 5,
	WrongPassword                            = 6,
	TooShort                                 = 7,
	TooLong                                  = 8,
	WrongIp                                  = 9,
	UnderMaintenance                         = 10,
	EServiceConnectFailType_MAX              = 11,
};

// Enum DungeonCrawler.EPopupResult
// NumValues: 0x0003
enum class EPopupResult : uint8
{
	Accept                                   = 0,
	Cancel                                   = 1,
	EPopupResult_MAX                         = 2,
};

// Enum DungeonCrawler.EItemCountSelectWidgetType
// NumValues: 0x0005
enum class EItemCountSelectWidgetType : uint8
{
	None                                     = 0,
	ItemCountSelectDrop                      = 1,
	ItemCountSelectSplit                     = 2,
	ItemCountSelectMerge                     = 3,
	EItemCountSelectWidgetType_MAX           = 4,
};

// ScriptStruct DungeonCrawler.DCKarma
// 0x0008 (0x0008 - 0x0000)
struct FDCKarma final
{
public:
	int32                                         Rating;                                            // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCKarmaLevel                                 Level;                                             // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9C[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCKarma) == 0x000004, "Wrong alignment on FDCKarma");
static_assert(sizeof(FDCKarma) == 0x000008, "Wrong size on FDCKarma");
static_assert(offsetof(FDCKarma, Rating) == 0x000000, "Member 'FDCKarma::Rating' has a wrong offset!");
static_assert(offsetof(FDCKarma, Level) == 0x000004, "Member 'FDCKarma::Level' has a wrong offset!");

// ScriptStruct DungeonCrawler.Nickname
// 0x0040 (0x0040 - 0x0000)
struct FNickname final
{
public:
	class FString                                 OriginalNickName;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StreamingModeNickName;                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCKarma                               Karma;                                             // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        LeaderboardRankId;                                 // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Fame;                                              // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9D[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNickname) == 0x000008, "Wrong alignment on FNickname");
static_assert(sizeof(FNickname) == 0x000040, "Wrong size on FNickname");
static_assert(offsetof(FNickname, OriginalNickName) == 0x000000, "Member 'FNickname::OriginalNickName' has a wrong offset!");
static_assert(offsetof(FNickname, StreamingModeNickName) == 0x000010, "Member 'FNickname::StreamingModeNickName' has a wrong offset!");
static_assert(offsetof(FNickname, Karma) == 0x000020, "Member 'FNickname::Karma' has a wrong offset!");
static_assert(offsetof(FNickname, LeaderboardRankId) == 0x000028, "Member 'FNickname::LeaderboardRankId' has a wrong offset!");
static_assert(offsetof(FNickname, Fame) == 0x000038, "Member 'FNickname::Fame' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataReplication
// 0x0090 (0x0090 - 0x0000)
struct FAccountDataReplication final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0010(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 PlayerCharacterId;                                 // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PartyId;                                           // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gender;                                            // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInit;                                             // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExit;                                             // 0x0089(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLogin;                                            // 0x008A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlive;                                            // 0x008B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEscape;                                           // 0x008C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDown;                                             // 0x008D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9E[0x2];                                     // 0x008E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAccountDataReplication) == 0x000008, "Wrong alignment on FAccountDataReplication");
static_assert(sizeof(FAccountDataReplication) == 0x000090, "Wrong size on FAccountDataReplication");
static_assert(offsetof(FAccountDataReplication, AccountId) == 0x000000, "Member 'FAccountDataReplication::AccountId' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, Nickname) == 0x000010, "Member 'FAccountDataReplication::Nickname' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, PlayerCharacterId) == 0x000050, "Member 'FAccountDataReplication::PlayerCharacterId' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, PartyId) == 0x000060, "Member 'FAccountDataReplication::PartyId' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, CharacterId) == 0x000070, "Member 'FAccountDataReplication::CharacterId' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, Gender) == 0x000080, "Member 'FAccountDataReplication::Gender' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, Level) == 0x000084, "Member 'FAccountDataReplication::Level' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, bInit) == 0x000088, "Member 'FAccountDataReplication::bInit' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, bExit) == 0x000089, "Member 'FAccountDataReplication::bExit' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, bLogin) == 0x00008A, "Member 'FAccountDataReplication::bLogin' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, bAlive) == 0x00008B, "Member 'FAccountDataReplication::bAlive' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, bEscape) == 0x00008C, "Member 'FAccountDataReplication::bEscape' has a wrong offset!");
static_assert(offsetof(FAccountDataReplication, bDown) == 0x00008D, "Member 'FAccountDataReplication::bDown' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCSpikeLogAnimationData
// 0x0014 (0x0014 - 0x0000)
struct FDCSpikeLogAnimationData final
{
public:
	float                                         AttackDistanceValue;                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRotationValue;                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackPlayRate;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchDistanceValue;                               // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchHeightValue;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCSpikeLogAnimationData) == 0x000004, "Wrong alignment on FDCSpikeLogAnimationData");
static_assert(sizeof(FDCSpikeLogAnimationData) == 0x000014, "Wrong size on FDCSpikeLogAnimationData");
static_assert(offsetof(FDCSpikeLogAnimationData, AttackDistanceValue) == 0x000000, "Member 'FDCSpikeLogAnimationData::AttackDistanceValue' has a wrong offset!");
static_assert(offsetof(FDCSpikeLogAnimationData, AttackRotationValue) == 0x000004, "Member 'FDCSpikeLogAnimationData::AttackRotationValue' has a wrong offset!");
static_assert(offsetof(FDCSpikeLogAnimationData, AttackPlayRate) == 0x000008, "Member 'FDCSpikeLogAnimationData::AttackPlayRate' has a wrong offset!");
static_assert(offsetof(FDCSpikeLogAnimationData, LaunchDistanceValue) == 0x00000C, "Member 'FDCSpikeLogAnimationData::LaunchDistanceValue' has a wrong offset!");
static_assert(offsetof(FDCSpikeLogAnimationData, LaunchHeightValue) == 0x000010, "Member 'FDCSpikeLogAnimationData::LaunchHeightValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.RequestMsg
// 0x0008 (0x0020 - 0x0018)
struct FRequestMsg : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9F[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRequestMsg) == 0x000008, "Wrong alignment on FRequestMsg");
static_assert(sizeof(FRequestMsg) == 0x000020, "Wrong size on FRequestMsg");
static_assert(offsetof(FRequestMsg, RequestCommand) == 0x000018, "Member 'FRequestMsg::RequestCommand' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgInventoryTwoHandedWeaponSwapRequest
// 0x0028 (0x0048 - 0x0020)
struct FClientMsgInventoryTwoHandedWeaponSwapRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FA0[0x28];                                    // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryTwoHandedWeaponSwapRequest) == 0x000008, "Wrong alignment on FClientMsgInventoryTwoHandedWeaponSwapRequest");
static_assert(sizeof(FClientMsgInventoryTwoHandedWeaponSwapRequest) == 0x000048, "Wrong size on FClientMsgInventoryTwoHandedWeaponSwapRequest");

// ScriptStruct DungeonCrawler.GameBlizzardData
// 0x0040 (0x0040 - 0x0000)
struct FGameBlizzardData final
{
public:
	int32                                         BlizzardFloorRuleIndex;                            // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlizzardPhaseServerWorldTime;                      // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlizzardPhaseDuration;                             // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BlizzardAbilityTag;                                // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA1[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0018(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameBlizzardData) == 0x000008, "Wrong alignment on FGameBlizzardData");
static_assert(sizeof(FGameBlizzardData) == 0x000040, "Wrong size on FGameBlizzardData");
static_assert(offsetof(FGameBlizzardData, BlizzardFloorRuleIndex) == 0x000000, "Member 'FGameBlizzardData::BlizzardFloorRuleIndex' has a wrong offset!");
static_assert(offsetof(FGameBlizzardData, BlizzardPhaseServerWorldTime) == 0x000004, "Member 'FGameBlizzardData::BlizzardPhaseServerWorldTime' has a wrong offset!");
static_assert(offsetof(FGameBlizzardData, BlizzardPhaseDuration) == 0x000008, "Member 'FGameBlizzardData::BlizzardPhaseDuration' has a wrong offset!");
static_assert(offsetof(FGameBlizzardData, BlizzardAbilityTag) == 0x00000C, "Member 'FGameBlizzardData::BlizzardAbilityTag' has a wrong offset!");
static_assert(offsetof(FGameBlizzardData, SoundData) == 0x000018, "Member 'FGameBlizzardData::SoundData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgShopLegendUpgradeRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgShopLegendUpgradeRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FA2[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopLegendUpgradeRequest) == 0x000008, "Wrong alignment on FClientMsgShopLegendUpgradeRequest");
static_assert(sizeof(FClientMsgShopLegendUpgradeRequest) == 0x000028, "Wrong size on FClientMsgShopLegendUpgradeRequest");

// ScriptStruct DungeonCrawler.DungeonLoadingImageMatchInfo
// 0x000C (0x000C - 0x0000)
struct FDungeonLoadingImageMatchInfo final
{
public:
	struct FGameplayTag                           DungeonIdTag;                                      // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FloorIdx;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDungeonLoadingImageMatchInfo) == 0x000004, "Wrong alignment on FDungeonLoadingImageMatchInfo");
static_assert(sizeof(FDungeonLoadingImageMatchInfo) == 0x00000C, "Wrong size on FDungeonLoadingImageMatchInfo");
static_assert(offsetof(FDungeonLoadingImageMatchInfo, DungeonIdTag) == 0x000000, "Member 'FDungeonLoadingImageMatchInfo::DungeonIdTag' has a wrong offset!");
static_assert(offsetof(FDungeonLoadingImageMatchInfo, FloorIdx) == 0x000008, "Member 'FDungeonLoadingImageMatchInfo::FloorIdx' has a wrong offset!");

// ScriptStruct DungeonCrawler.DungeonLoadingImageInfo
// 0x0018 (0x0018 - 0x0000)
struct FDungeonLoadingImageInfo final
{
public:
	TArray<struct FDungeonLoadingImageMatchInfo>  DungeonLoadingImageMatchInfoArray;                 // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             LoadingImage;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDungeonLoadingImageInfo) == 0x000008, "Wrong alignment on FDungeonLoadingImageInfo");
static_assert(sizeof(FDungeonLoadingImageInfo) == 0x000018, "Wrong size on FDungeonLoadingImageInfo");
static_assert(offsetof(FDungeonLoadingImageInfo, DungeonLoadingImageMatchInfoArray) == 0x000000, "Member 'FDungeonLoadingImageInfo::DungeonLoadingImageMatchInfoArray' has a wrong offset!");
static_assert(offsetof(FDungeonLoadingImageInfo, LoadingImage) == 0x000010, "Member 'FDungeonLoadingImageInfo::LoadingImage' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgCharacterPerspectiveSet
// 0x0008 (0x0020 - 0x0018)
struct FMsgCharacterPerspectiveSet final : public FMsgBase
{
public:
	bool                                          bIsFirstPersonPerspective;                         // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA3[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgCharacterPerspectiveSet) == 0x000008, "Wrong alignment on FMsgCharacterPerspectiveSet");
static_assert(sizeof(FMsgCharacterPerspectiveSet) == 0x000020, "Wrong size on FMsgCharacterPerspectiveSet");
static_assert(offsetof(FMsgCharacterPerspectiveSet, bIsFirstPersonPerspective) == 0x000018, "Member 'FMsgCharacterPerspectiveSet::bIsFirstPersonPerspective' has a wrong offset!");

// ScriptStruct DungeonCrawler.GameDeathSwarmData
// 0x0080 (0x0080 - 0x0000)
struct FGameDeathSwarmData final
{
public:
	class ADeathSwarmBase*                        DeathSwarm;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeathSwarmFloorRuleIndex;                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFloorRulePhase                               DeathSwarmPhase;                                   // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA4[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathSwarmPhaseServerWorldTime;                    // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathSwarmPhaseDuration;                           // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrevDeathSwarmSize;                                // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA5[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PrevDeathSwarmPos;                                 // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeathSwarmSize;                                    // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA6[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DeathSwarmPos;                                     // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DeathSwarmAbilityTag;                              // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0050(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaused;                                           // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA7[0x7];                                     // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameDeathSwarmData) == 0x000008, "Wrong alignment on FGameDeathSwarmData");
static_assert(sizeof(FGameDeathSwarmData) == 0x000080, "Wrong size on FGameDeathSwarmData");
static_assert(offsetof(FGameDeathSwarmData, DeathSwarm) == 0x000000, "Member 'FGameDeathSwarmData::DeathSwarm' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, DeathSwarmFloorRuleIndex) == 0x000008, "Member 'FGameDeathSwarmData::DeathSwarmFloorRuleIndex' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, DeathSwarmPhase) == 0x00000C, "Member 'FGameDeathSwarmData::DeathSwarmPhase' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, DeathSwarmPhaseServerWorldTime) == 0x000010, "Member 'FGameDeathSwarmData::DeathSwarmPhaseServerWorldTime' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, DeathSwarmPhaseDuration) == 0x000014, "Member 'FGameDeathSwarmData::DeathSwarmPhaseDuration' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, PrevDeathSwarmSize) == 0x000018, "Member 'FGameDeathSwarmData::PrevDeathSwarmSize' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, PrevDeathSwarmPos) == 0x000020, "Member 'FGameDeathSwarmData::PrevDeathSwarmPos' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, DeathSwarmSize) == 0x000030, "Member 'FGameDeathSwarmData::DeathSwarmSize' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, DeathSwarmPos) == 0x000038, "Member 'FGameDeathSwarmData::DeathSwarmPos' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, DeathSwarmAbilityTag) == 0x000048, "Member 'FGameDeathSwarmData::DeathSwarmAbilityTag' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, SoundData) == 0x000050, "Member 'FGameDeathSwarmData::SoundData' has a wrong offset!");
static_assert(offsetof(FGameDeathSwarmData, bPaused) == 0x000078, "Member 'FGameDeathSwarmData::bPaused' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgCurrentEquippedItemActorsResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgCurrentEquippedItemActorsResponse final : public FMsgBase
{
public:
	TArray<class AItemActor*>                     EquippedItemActors;                                // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgCurrentEquippedItemActorsResponse) == 0x000008, "Wrong alignment on FMsgCurrentEquippedItemActorsResponse");
static_assert(sizeof(FMsgCurrentEquippedItemActorsResponse) == 0x000028, "Wrong size on FMsgCurrentEquippedItemActorsResponse");
static_assert(offsetof(FMsgCurrentEquippedItemActorsResponse, EquippedItemActors) == 0x000018, "Member 'FMsgCurrentEquippedItemActorsResponse::EquippedItemActors' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgOpenLobbyMapRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgOpenLobbyMapRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FA8[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgOpenLobbyMapRequest) == 0x000008, "Wrong alignment on FClientMsgOpenLobbyMapRequest");
static_assert(sizeof(FClientMsgOpenLobbyMapRequest) == 0x000028, "Wrong size on FClientMsgOpenLobbyMapRequest");

// ScriptStruct DungeonCrawler.DCItemOriginInfo
// 0x0048 (0x0048 - 0x0000)
struct FDCItemOriginInfo final
{
public:
	EDCItemOriginType                             ItemOriginType;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FA9[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNickname                              OriginNickname;                                    // 0x0008(0x0040)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCItemOriginInfo) == 0x000008, "Wrong alignment on FDCItemOriginInfo");
static_assert(sizeof(FDCItemOriginInfo) == 0x000048, "Wrong size on FDCItemOriginInfo");
static_assert(offsetof(FDCItemOriginInfo, ItemOriginType) == 0x000000, "Member 'FDCItemOriginInfo::ItemOriginType' has a wrong offset!");
static_assert(offsetof(FDCItemOriginInfo, OriginNickname) == 0x000008, "Member 'FDCItemOriginInfo::OriginNickname' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCGameInfo
// 0x0040 (0x0040 - 0x0000)
struct FDCGameInfo final
{
public:
	int64                                         GameId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxGameUser;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaitGameTimeSec;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DungeonIdTag;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     GameType;                                          // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAA[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDCDungeonDataAsset*>            DungeonDraws;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDCDungeonDataAsset*                    CurrentDungeonData;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFloorMatchmaking;                                 // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAB[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MatchmakingType;                                   // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCGameInfo) == 0x000008, "Wrong alignment on FDCGameInfo");
static_assert(sizeof(FDCGameInfo) == 0x000040, "Wrong size on FDCGameInfo");
static_assert(offsetof(FDCGameInfo, GameId) == 0x000000, "Member 'FDCGameInfo::GameId' has a wrong offset!");
static_assert(offsetof(FDCGameInfo, MaxGameUser) == 0x000008, "Member 'FDCGameInfo::MaxGameUser' has a wrong offset!");
static_assert(offsetof(FDCGameInfo, WaitGameTimeSec) == 0x00000C, "Member 'FDCGameInfo::WaitGameTimeSec' has a wrong offset!");
static_assert(offsetof(FDCGameInfo, DungeonIdTag) == 0x000010, "Member 'FDCGameInfo::DungeonIdTag' has a wrong offset!");
static_assert(offsetof(FDCGameInfo, GameType) == 0x000018, "Member 'FDCGameInfo::GameType' has a wrong offset!");
static_assert(offsetof(FDCGameInfo, DungeonDraws) == 0x000020, "Member 'FDCGameInfo::DungeonDraws' has a wrong offset!");
static_assert(offsetof(FDCGameInfo, CurrentDungeonData) == 0x000030, "Member 'FDCGameInfo::CurrentDungeonData' has a wrong offset!");
static_assert(offsetof(FDCGameInfo, bFloorMatchmaking) == 0x000038, "Member 'FDCGameInfo::bFloorMatchmaking' has a wrong offset!");
static_assert(offsetof(FDCGameInfo, MatchmakingType) == 0x00003C, "Member 'FDCGameInfo::MatchmakingType' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendListResponse
// 0x0020 (0x0038 - 0x0018)
struct FClientMsgFriendListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FAC[0x20];                                    // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendListResponse) == 0x000008, "Wrong alignment on FClientMsgFriendListResponse");
static_assert(sizeof(FClientMsgFriendListResponse) == 0x000038, "Wrong size on FClientMsgFriendListResponse");

// ScriptStruct DungeonCrawler.ObjectLinkGlobalEvent
// 0x0010 (0x0010 - 0x0000)
struct FObjectLinkGlobalEvent final
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectLinkGlobalEvent) == 0x000004, "Wrong alignment on FObjectLinkGlobalEvent");
static_assert(sizeof(FObjectLinkGlobalEvent) == 0x000010, "Wrong size on FObjectLinkGlobalEvent");
static_assert(offsetof(FObjectLinkGlobalEvent, IdTag) == 0x000000, "Member 'FObjectLinkGlobalEvent::IdTag' has a wrong offset!");
static_assert(offsetof(FObjectLinkGlobalEvent, EventTag) == 0x000008, "Member 'FObjectLinkGlobalEvent::EventTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemDataMeta
// 0x0068 (0x0068 - 0x0000)
struct FItemDataMeta final
{
public:
	class FString                                 SoulHeart_AccountId;                               // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoulHeart_PartyId;                                 // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              SoulHeart_NickName;                                // 0x0020(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         AvailableValue;                                    // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAD[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemDataMeta) == 0x000008, "Wrong alignment on FItemDataMeta");
static_assert(sizeof(FItemDataMeta) == 0x000068, "Wrong size on FItemDataMeta");
static_assert(offsetof(FItemDataMeta, SoulHeart_AccountId) == 0x000000, "Member 'FItemDataMeta::SoulHeart_AccountId' has a wrong offset!");
static_assert(offsetof(FItemDataMeta, SoulHeart_PartyId) == 0x000010, "Member 'FItemDataMeta::SoulHeart_PartyId' has a wrong offset!");
static_assert(offsetof(FItemDataMeta, SoulHeart_NickName) == 0x000020, "Member 'FItemDataMeta::SoulHeart_NickName' has a wrong offset!");
static_assert(offsetof(FItemDataMeta, AvailableValue) == 0x000060, "Member 'FItemDataMeta::AvailableValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemDataProperty
// 0x0014 (0x0014 - 0x0000)
struct FItemDataProperty final
{
public:
	struct FPrimaryAssetId                        PropertyTypeId;                                    // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PropertyValue;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDataProperty) == 0x000004, "Wrong alignment on FItemDataProperty");
static_assert(sizeof(FItemDataProperty) == 0x000014, "Wrong size on FItemDataProperty");
static_assert(offsetof(FItemDataProperty, PropertyTypeId) == 0x000000, "Member 'FItemDataProperty::PropertyTypeId' has a wrong offset!");
static_assert(offsetof(FItemDataProperty, PropertyValue) == 0x000010, "Member 'FItemDataProperty::PropertyValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemData
// 0x0100 (0x0100 - 0x0000)
struct FItemData final
{
public:
	int64                                         ItemUniqueId;                                      // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ItemId;                                            // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotId;                                            // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemAmmoCount;                                     // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemContentsCount;                                 // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x002C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCItemLootState                              LootState;                                         // 0x002D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAE[0x2];                                     // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemDataMeta                          MetaData;                                          // 0x0030(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FItemDataProperty>              ItemDataPrimaryPropertyArray;                      // 0x0098(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FItemDataProperty>              ItemDataSecondaryPropertyArray;                    // 0x00A8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EDCItemOriginType                             ItemOriginType;                                    // 0x00B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAF[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNickname                              OriginNickname;                                    // 0x00C0(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemData) == 0x000008, "Wrong alignment on FItemData");
static_assert(sizeof(FItemData) == 0x000100, "Wrong size on FItemData");
static_assert(offsetof(FItemData, ItemUniqueId) == 0x000000, "Member 'FItemData::ItemUniqueId' has a wrong offset!");
static_assert(offsetof(FItemData, ItemId) == 0x000008, "Member 'FItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FItemData, InventoryId) == 0x000018, "Member 'FItemData::InventoryId' has a wrong offset!");
static_assert(offsetof(FItemData, SlotId) == 0x00001C, "Member 'FItemData::SlotId' has a wrong offset!");
static_assert(offsetof(FItemData, ItemCount) == 0x000020, "Member 'FItemData::ItemCount' has a wrong offset!");
static_assert(offsetof(FItemData, ItemAmmoCount) == 0x000024, "Member 'FItemData::ItemAmmoCount' has a wrong offset!");
static_assert(offsetof(FItemData, ItemContentsCount) == 0x000028, "Member 'FItemData::ItemContentsCount' has a wrong offset!");
static_assert(offsetof(FItemData, bEquipped) == 0x00002C, "Member 'FItemData::bEquipped' has a wrong offset!");
static_assert(offsetof(FItemData, LootState) == 0x00002D, "Member 'FItemData::LootState' has a wrong offset!");
static_assert(offsetof(FItemData, MetaData) == 0x000030, "Member 'FItemData::MetaData' has a wrong offset!");
static_assert(offsetof(FItemData, ItemDataPrimaryPropertyArray) == 0x000098, "Member 'FItemData::ItemDataPrimaryPropertyArray' has a wrong offset!");
static_assert(offsetof(FItemData, ItemDataSecondaryPropertyArray) == 0x0000A8, "Member 'FItemData::ItemDataSecondaryPropertyArray' has a wrong offset!");
static_assert(offsetof(FItemData, ItemOriginType) == 0x0000B8, "Member 'FItemData::ItemOriginType' has a wrong offset!");
static_assert(offsetof(FItemData, OriginNickname) == 0x0000C0, "Member 'FItemData::OriginNickname' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyInviteAnswerResultNotify
// 0x0048 (0x0060 - 0x0018)
struct FClientMsgPartyInviteAnswerResultNotify final : public FMsgBase
{
public:
	uint8                                         Pad_1FB0[0x48];                                    // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyInviteAnswerResultNotify) == 0x000008, "Wrong alignment on FClientMsgPartyInviteAnswerResultNotify");
static_assert(sizeof(FClientMsgPartyInviteAnswerResultNotify) == 0x000060, "Wrong size on FClientMsgPartyInviteAnswerResultNotify");

// ScriptStruct DungeonCrawler.MsgAccountLinkAccountSessionDataRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgAccountLinkAccountSessionDataRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgAccountLinkAccountSessionDataRequest) == 0x000008, "Wrong alignment on FMsgAccountLinkAccountSessionDataRequest");
static_assert(sizeof(FMsgAccountLinkAccountSessionDataRequest) == 0x000018, "Wrong size on FMsgAccountLinkAccountSessionDataRequest");

// ScriptStruct DungeonCrawler.DCReligionKillDataInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCReligionKillDataInfo final
{
public:
	class FString                                 TargetReligionId;                                  // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         KillCount;                                         // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCReligionKillDataInfo) == 0x000008, "Wrong alignment on FDCReligionKillDataInfo");
static_assert(sizeof(FDCReligionKillDataInfo) == 0x000018, "Wrong size on FDCReligionKillDataInfo");
static_assert(offsetof(FDCReligionKillDataInfo, TargetReligionId) == 0x000000, "Member 'FDCReligionKillDataInfo::TargetReligionId' has a wrong offset!");
static_assert(offsetof(FDCReligionKillDataInfo, KillCount) == 0x000010, "Member 'FDCReligionKillDataInfo::KillCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCReligionKillnfo
// 0x0020 (0x0020 - 0x0000)
struct FDCReligionKillnfo final
{
public:
	class FString                                 ReligionId;                                        // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCReligionKillDataInfo>        ReligionKillInfo;                                  // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCReligionKillnfo) == 0x000008, "Wrong alignment on FDCReligionKillnfo");
static_assert(sizeof(FDCReligionKillnfo) == 0x000020, "Wrong size on FDCReligionKillnfo");
static_assert(offsetof(FDCReligionKillnfo, ReligionId) == 0x000000, "Member 'FDCReligionKillnfo::ReligionId' has a wrong offset!");
static_assert(offsetof(FDCReligionKillnfo, ReligionKillInfo) == 0x000010, "Member 'FDCReligionKillnfo::ReligionKillInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataGameplayEffectValue
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataGameplayEffectValue final
{
public:
	class FString                                 EffectTag;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectValue;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB1[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAccountDataGameplayEffectValue) == 0x000008, "Wrong alignment on FAccountDataGameplayEffectValue");
static_assert(sizeof(FAccountDataGameplayEffectValue) == 0x000018, "Wrong size on FAccountDataGameplayEffectValue");
static_assert(offsetof(FAccountDataGameplayEffectValue, EffectTag) == 0x000000, "Member 'FAccountDataGameplayEffectValue::EffectTag' has a wrong offset!");
static_assert(offsetof(FAccountDataGameplayEffectValue, EffectValue) == 0x000010, "Member 'FAccountDataGameplayEffectValue::EffectValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantStockBuyResponse
// 0x0048 (0x0060 - 0x0018)
struct FClientMsgMerchantStockBuyResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FB2[0x48];                                    // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantStockBuyResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantStockBuyResponse");
static_assert(sizeof(FClientMsgMerchantStockBuyResponse) == 0x000060, "Wrong size on FClientMsgMerchantStockBuyResponse");

// ScriptStruct DungeonCrawler.DesignDataPerk
// 0x0098 (0x0098 - 0x0000)
struct FDesignDataPerk final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DescData;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUse;                                            // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB3[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                Classes;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        AllowIdTagGroup;                                   // 0x0044(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        NotAllowIdTagGroup;                                // 0x0054(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0064(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB4[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataPerk) == 0x000008, "Wrong alignment on FDesignDataPerk");
static_assert(sizeof(FDesignDataPerk) == 0x000098, "Wrong size on FDesignDataPerk");
static_assert(offsetof(FDesignDataPerk, Name) == 0x000000, "Member 'FDesignDataPerk::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataPerk, DescData) == 0x000018, "Member 'FDesignDataPerk::DescData' has a wrong offset!");
static_assert(offsetof(FDesignDataPerk, CanUse) == 0x000028, "Member 'FDesignDataPerk::CanUse' has a wrong offset!");
static_assert(offsetof(FDesignDataPerk, Classes) == 0x000030, "Member 'FDesignDataPerk::Classes' has a wrong offset!");
static_assert(offsetof(FDesignDataPerk, Radius) == 0x000040, "Member 'FDesignDataPerk::Radius' has a wrong offset!");
static_assert(offsetof(FDesignDataPerk, AllowIdTagGroup) == 0x000044, "Member 'FDesignDataPerk::AllowIdTagGroup' has a wrong offset!");
static_assert(offsetof(FDesignDataPerk, NotAllowIdTagGroup) == 0x000054, "Member 'FDesignDataPerk::NotAllowIdTagGroup' has a wrong offset!");
static_assert(offsetof(FDesignDataPerk, ArtData) == 0x000064, "Member 'FDesignDataPerk::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataPerk, Abilities) == 0x000078, "Member 'FDesignDataPerk::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataPerk, Effects) == 0x000088, "Member 'FDesignDataPerk::Effects' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCPropertyEffectData
// 0x001C (0x001C - 0x0000)
struct FDCPropertyEffectData final
{
public:
	struct FGameplayTag                           PropertyType;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PropertyId;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PropertyValue;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCPropertyEffectData) == 0x000004, "Wrong alignment on FDCPropertyEffectData");
static_assert(sizeof(FDCPropertyEffectData) == 0x00001C, "Wrong size on FDCPropertyEffectData");
static_assert(offsetof(FDCPropertyEffectData, PropertyType) == 0x000000, "Member 'FDCPropertyEffectData::PropertyType' has a wrong offset!");
static_assert(offsetof(FDCPropertyEffectData, PropertyId) == 0x000008, "Member 'FDCPropertyEffectData::PropertyId' has a wrong offset!");
static_assert(offsetof(FDCPropertyEffectData, PropertyValue) == 0x000018, "Member 'FDCPropertyEffectData::PropertyValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountLinkLootingTargetPlayerInventoryNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgAccountLinkLootingTargetPlayerInventoryNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryComponent*                    OldTargetInventory;                                // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryComponent*                    NewTargetInventory;                                // 0x0028(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkLootingTargetPlayerInventoryNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkLootingTargetPlayerInventoryNotify");
static_assert(sizeof(FMsgAccountLinkLootingTargetPlayerInventoryNotify) == 0x000030, "Wrong size on FMsgAccountLinkLootingTargetPlayerInventoryNotify");
static_assert(offsetof(FMsgAccountLinkLootingTargetPlayerInventoryNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkLootingTargetPlayerInventoryNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkLootingTargetPlayerInventoryNotify, OldTargetInventory) == 0x000020, "Member 'FMsgAccountLinkLootingTargetPlayerInventoryNotify::OldTargetInventory' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkLootingTargetPlayerInventoryNotify, NewTargetInventory) == 0x000028, "Member 'FMsgAccountLinkLootingTargetPlayerInventoryNotify::NewTargetInventory' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSpellChannelingEnd
// 0x0000 (0x0018 - 0x0018)
struct FMsgSpellChannelingEnd final : public FMsgBase
{
};
static_assert(alignof(FMsgSpellChannelingEnd) == 0x000008, "Wrong alignment on FMsgSpellChannelingEnd");
static_assert(sizeof(FMsgSpellChannelingEnd) == 0x000018, "Wrong size on FMsgSpellChannelingEnd");

// ScriptStruct DungeonCrawler.DCPropsSkinInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCPropsSkinInfo final
{
public:
	struct FPrimaryAssetId                        SoundData;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCPropsSkinInfo) == 0x000004, "Wrong alignment on FDCPropsSkinInfo");
static_assert(sizeof(FDCPropsSkinInfo) == 0x000010, "Wrong size on FDCPropsSkinInfo");
static_assert(offsetof(FDCPropsSkinInfo, SoundData) == 0x000000, "Member 'FDCPropsSkinInfo::SoundData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInt64IdBase
// 0x0008 (0x0008 - 0x0000)
struct FDCInt64IdBase
{
public:
	int64                                         _;                                                 // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCInt64IdBase) == 0x000008, "Wrong alignment on FDCInt64IdBase");
static_assert(sizeof(FDCInt64IdBase) == 0x000008, "Wrong size on FDCInt64IdBase");
static_assert(offsetof(FDCInt64IdBase, _) == 0x000000, "Member 'FDCInt64IdBase::_' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgRankingInfoResponse
// 0x0030 (0x0048 - 0x0018)
struct FClientMsgRankingInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FB5[0x30];                                    // 0x0018(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingInfoResponse) == 0x000008, "Wrong alignment on FClientMsgRankingInfoResponse");
static_assert(sizeof(FClientMsgRankingInfoResponse) == 0x000048, "Wrong size on FClientMsgRankingInfoResponse");

// ScriptStruct DungeonCrawler.DCInventoryKey
// 0x0010 (0x0010 - 0x0000)
struct FDCInventoryKey final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCInventoryId                                ID;                                                // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB6[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCInventoryKey) == 0x000008, "Wrong alignment on FDCInventoryKey");
static_assert(sizeof(FDCInventoryKey) == 0x000010, "Wrong size on FDCInventoryKey");
static_assert(offsetof(FDCInventoryKey, Owner) == 0x000000, "Member 'FDCInventoryKey::Owner' has a wrong offset!");
static_assert(offsetof(FDCInventoryKey, ID) == 0x000008, "Member 'FDCInventoryKey::ID' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendItemRecoveredNotCheckRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgFriendItemRecoveredNotCheckRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FB7[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendItemRecoveredNotCheckRequest) == 0x000008, "Wrong alignment on FClientMsgFriendItemRecoveredNotCheckRequest");
static_assert(sizeof(FClientMsgFriendItemRecoveredNotCheckRequest) == 0x000028, "Wrong size on FClientMsgFriendItemRecoveredNotCheckRequest");

// ScriptStruct DungeonCrawler.MsgWidgetClassEquipableSkillEmptySlotsMarkNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify final : public FMsgBase
{
public:
	bool                                          bMark;                                             // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB8[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify");
static_assert(sizeof(FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify) == 0x000020, "Wrong size on FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify");
static_assert(offsetof(FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify, bMark) == 0x000018, "Member 'FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify::bMark' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantBaseGearListRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgMerchantBaseGearListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FB9[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantBaseGearListRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantBaseGearListRequest");
static_assert(sizeof(FClientMsgMerchantBaseGearListRequest) == 0x000030, "Wrong size on FClientMsgMerchantBaseGearListRequest");

// ScriptStruct DungeonCrawler.GameFloorPortalData
// 0x0018 (0x0018 - 0x0000)
struct FGameFloorPortalData final
{
public:
	struct FGameplayTag                           PortalType;                                        // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalScrollNum;                                   // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FBA[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AFloorPortalBase*                       FloorPortal;                                       // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameFloorPortalData) == 0x000008, "Wrong alignment on FGameFloorPortalData");
static_assert(sizeof(FGameFloorPortalData) == 0x000018, "Wrong size on FGameFloorPortalData");
static_assert(offsetof(FGameFloorPortalData, PortalType) == 0x000000, "Member 'FGameFloorPortalData::PortalType' has a wrong offset!");
static_assert(offsetof(FGameFloorPortalData, PortalScrollNum) == 0x000008, "Member 'FGameFloorPortalData::PortalScrollNum' has a wrong offset!");
static_assert(offsetof(FGameFloorPortalData, FloorPortal) == 0x000010, "Member 'FGameFloorPortalData::FloorPortal' has a wrong offset!");

// ScriptStruct DungeonCrawler.GameFloorRuleData
// 0x0040 (0x0040 - 0x0000)
struct FGameFloorRuleData final
{
public:
	class FText                                   FloorRuleName;                                     // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FloorRuleIdTag;                                    // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameTimeSec;                                       // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameTimeSecServerWorldTime;                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideTimer;                                        // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FBB[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameFloorPortalData>           ActiveFloorPortalDataArray;                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameFloorRuleData) == 0x000008, "Wrong alignment on FGameFloorRuleData");
static_assert(sizeof(FGameFloorRuleData) == 0x000040, "Wrong size on FGameFloorRuleData");
static_assert(offsetof(FGameFloorRuleData, FloorRuleName) == 0x000000, "Member 'FGameFloorRuleData::FloorRuleName' has a wrong offset!");
static_assert(offsetof(FGameFloorRuleData, FloorRuleIdTag) == 0x000018, "Member 'FGameFloorRuleData::FloorRuleIdTag' has a wrong offset!");
static_assert(offsetof(FGameFloorRuleData, GameTimeSec) == 0x000020, "Member 'FGameFloorRuleData::GameTimeSec' has a wrong offset!");
static_assert(offsetof(FGameFloorRuleData, GameTimeSecServerWorldTime) == 0x000024, "Member 'FGameFloorRuleData::GameTimeSecServerWorldTime' has a wrong offset!");
static_assert(offsetof(FGameFloorRuleData, bHideTimer) == 0x000028, "Member 'FGameFloorRuleData::bHideTimer' has a wrong offset!");
static_assert(offsetof(FGameFloorRuleData, ActiveFloorPortalDataArray) == 0x000030, "Member 'FGameFloorRuleData::ActiveFloorPortalDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgGmPartyAllRandomRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgGmPartyAllRandomRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FBC[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGmPartyAllRandomRequest) == 0x000008, "Wrong alignment on FClientMsgGmPartyAllRandomRequest");
static_assert(sizeof(FClientMsgGmPartyAllRandomRequest) == 0x000028, "Wrong size on FClientMsgGmPartyAllRandomRequest");

// ScriptStruct DungeonCrawler.ClientMsgTrainingRedeemRewardTokenRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTrainingRedeemRewardTokenRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FBD[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTrainingRedeemRewardTokenRequest) == 0x000008, "Wrong alignment on FClientMsgTrainingRedeemRewardTokenRequest");
static_assert(sizeof(FClientMsgTrainingRedeemRewardTokenRequest) == 0x000028, "Wrong size on FClientMsgTrainingRedeemRewardTokenRequest");

// ScriptStruct DungeonCrawler.MsgWidgetShopBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetShopBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetShopBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetShopBeginNotify");
static_assert(sizeof(FMsgWidgetShopBeginNotify) == 0x000018, "Wrong size on FMsgWidgetShopBeginNotify");

// ScriptStruct DungeonCrawler.AccountDataGameMusic
// 0x0010 (0x0010 - 0x0000)
struct FAccountDataGameMusic final
{
public:
	struct FPrimaryAssetId                        MusicId;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataGameMusic) == 0x000004, "Wrong alignment on FAccountDataGameMusic");
static_assert(sizeof(FAccountDataGameMusic) == 0x000010, "Wrong size on FAccountDataGameMusic");
static_assert(offsetof(FAccountDataGameMusic, MusicId) == 0x000000, "Member 'FAccountDataGameMusic::MusicId' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLootDropGroupItem
// 0x0024 (0x0024 - 0x0000)
struct FDesignDataLootDropGroupItem final
{
public:
	struct FPrimaryAssetId                        LootDropId;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        LootDropRateId;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LootDropCount;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLootDropGroupItem) == 0x000004, "Wrong alignment on FDesignDataLootDropGroupItem");
static_assert(sizeof(FDesignDataLootDropGroupItem) == 0x000024, "Wrong size on FDesignDataLootDropGroupItem");
static_assert(offsetof(FDesignDataLootDropGroupItem, LootDropId) == 0x000000, "Member 'FDesignDataLootDropGroupItem::LootDropId' has a wrong offset!");
static_assert(offsetof(FDesignDataLootDropGroupItem, LootDropRateId) == 0x000010, "Member 'FDesignDataLootDropGroupItem::LootDropRateId' has a wrong offset!");
static_assert(offsetof(FDesignDataLootDropGroupItem, LootDropCount) == 0x000020, "Member 'FDesignDataLootDropGroupItem::LootDropCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLootDropGroup
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataLootDropGroup final
{
public:
	TArray<struct FDesignDataLootDropGroupItem>   LootDropGroupItemArray;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLootDropGroup) == 0x000008, "Wrong alignment on FDesignDataLootDropGroup");
static_assert(sizeof(FDesignDataLootDropGroup) == 0x000010, "Wrong size on FDesignDataLootDropGroup");
static_assert(offsetof(FDesignDataLootDropGroup, LootDropGroupItemArray) == 0x000000, "Member 'FDesignDataLootDropGroup::LootDropGroupItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCGameplayEffectSetByCallerData
// 0x000C (0x000C - 0x0000)
struct FDCGameplayEffectSetByCallerData final
{
public:
	struct FGameplayTag                           SetByCallerTag;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SetByCallerValue;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCGameplayEffectSetByCallerData) == 0x000004, "Wrong alignment on FDCGameplayEffectSetByCallerData");
static_assert(sizeof(FDCGameplayEffectSetByCallerData) == 0x00000C, "Wrong size on FDCGameplayEffectSetByCallerData");
static_assert(offsetof(FDCGameplayEffectSetByCallerData, SetByCallerTag) == 0x000000, "Member 'FDCGameplayEffectSetByCallerData::SetByCallerTag' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectSetByCallerData, SetByCallerValue) == 0x000008, "Member 'FDCGameplayEffectSetByCallerData::SetByCallerValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCGameplayEffectData
// 0x0068 (0x0068 - 0x0000)
struct FDCGameplayEffectData final
{
public:
	struct FPrimaryAssetId                        EffectId;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectSetByCallerData> SetByCallerArray;                                  // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DynamicGrantedTagContainer;                        // 0x0028(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  DynamicAssetTagContainer;                          // 0x0048(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCGameplayEffectData) == 0x000008, "Wrong alignment on FDCGameplayEffectData");
static_assert(sizeof(FDCGameplayEffectData) == 0x000068, "Wrong size on FDCGameplayEffectData");
static_assert(offsetof(FDCGameplayEffectData, EffectId) == 0x000000, "Member 'FDCGameplayEffectData::EffectId' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectData, GameplayEffectClass) == 0x000010, "Member 'FDCGameplayEffectData::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectData, SetByCallerArray) == 0x000018, "Member 'FDCGameplayEffectData::SetByCallerArray' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectData, DynamicGrantedTagContainer) == 0x000028, "Member 'FDCGameplayEffectData::DynamicGrantedTagContainer' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectData, DynamicAssetTagContainer) == 0x000048, "Member 'FDCGameplayEffectData::DynamicAssetTagContainer' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemActionTargetInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCItemActionTargetInfo final
{
public:
	class UDCInventoryBase*                       Target;                                            // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSwap;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FBE[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCItemActionTargetInfo) == 0x000008, "Wrong alignment on FDCItemActionTargetInfo");
static_assert(sizeof(FDCItemActionTargetInfo) == 0x000010, "Wrong size on FDCItemActionTargetInfo");
static_assert(offsetof(FDCItemActionTargetInfo, Target) == 0x000000, "Member 'FDCItemActionTargetInfo::Target' has a wrong offset!");
static_assert(offsetof(FDCItemActionTargetInfo, bAllowSwap) == 0x000008, "Member 'FDCItemActionTargetInfo::bAllowSwap' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemId
// 0x0000 (0x0008 - 0x0008)
struct FDCItemId final : public FDCInt64IdBase
{
};
static_assert(alignof(FDCItemId) == 0x000008, "Wrong alignment on FDCItemId");
static_assert(sizeof(FDCItemId) == 0x000008, "Wrong size on FDCItemId");

// ScriptStruct DungeonCrawler.DCFriendSentInvitationInfo
// 0x0090 (0x0090 - 0x0000)
struct FDCFriendSentInvitationInfo final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountNickname;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0030(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gender;                                            // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Status;                                            // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FBF[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCFriendSentInvitationInfo) == 0x000008, "Wrong alignment on FDCFriendSentInvitationInfo");
static_assert(sizeof(FDCFriendSentInvitationInfo) == 0x000090, "Wrong size on FDCFriendSentInvitationInfo");
static_assert(offsetof(FDCFriendSentInvitationInfo, AccountId) == 0x000000, "Member 'FDCFriendSentInvitationInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCFriendSentInvitationInfo, AccountNickname) == 0x000010, "Member 'FDCFriendSentInvitationInfo::AccountNickname' has a wrong offset!");
static_assert(offsetof(FDCFriendSentInvitationInfo, CharacterId) == 0x000020, "Member 'FDCFriendSentInvitationInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FDCFriendSentInvitationInfo, Nickname) == 0x000030, "Member 'FDCFriendSentInvitationInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FDCFriendSentInvitationInfo, CharacterClass) == 0x000070, "Member 'FDCFriendSentInvitationInfo::CharacterClass' has a wrong offset!");
static_assert(offsetof(FDCFriendSentInvitationInfo, Gender) == 0x000080, "Member 'FDCFriendSentInvitationInfo::Gender' has a wrong offset!");
static_assert(offsetof(FDCFriendSentInvitationInfo, Level) == 0x000084, "Member 'FDCFriendSentInvitationInfo::Level' has a wrong offset!");
static_assert(offsetof(FDCFriendSentInvitationInfo, Status) == 0x000088, "Member 'FDCFriendSentInvitationInfo::Status' has a wrong offset!");

// ScriptStruct DungeonCrawler.SentInvitationSlotData
// 0x0010 (0x0010 - 0x0000)
struct FSentInvitationSlotData final
{
public:
	TArray<struct FDCFriendSentInvitationInfo>    DCFriendSentInvitationInfoArray;                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSentInvitationSlotData) == 0x000008, "Wrong alignment on FSentInvitationSlotData");
static_assert(sizeof(FSentInvitationSlotData) == 0x000010, "Wrong size on FSentInvitationSlotData");
static_assert(offsetof(FSentInvitationSlotData, DCFriendSentInvitationInfoArray) == 0x000000, "Member 'FSentInvitationSlotData::DCFriendSentInvitationInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInt32IdBase
// 0x0004 (0x0004 - 0x0000)
struct FDCInt32IdBase
{
public:
	int32                                         _;                                                 // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCInt32IdBase) == 0x000004, "Wrong alignment on FDCInt32IdBase");
static_assert(sizeof(FDCInt32IdBase) == 0x000004, "Wrong size on FDCInt32IdBase");
static_assert(offsetof(FDCInt32IdBase, _) == 0x000000, "Member 'FDCInt32IdBase::_' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCRecruitChannelIndex
// 0x0000 (0x0004 - 0x0004)
struct FDCRecruitChannelIndex final : public FDCInt32IdBase
{
};
static_assert(alignof(FDCRecruitChannelIndex) == 0x000004, "Wrong alignment on FDCRecruitChannelIndex");
static_assert(sizeof(FDCRecruitChannelIndex) == 0x000004, "Wrong size on FDCRecruitChannelIndex");

// ScriptStruct DungeonCrawler.DCRecruitChannelInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCRecruitChannelInfo final
{
public:
	struct FDCRecruitChannelIndex                 Index;                                             // 0x0000(0x0004)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FC0[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCChatRoomDataAsset*                   Data;                                              // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GroupIndex;                                        // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        NumMembers;                                        // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCRecruitChannelInfo) == 0x000008, "Wrong alignment on FDCRecruitChannelInfo");
static_assert(sizeof(FDCRecruitChannelInfo) == 0x000018, "Wrong size on FDCRecruitChannelInfo");
static_assert(offsetof(FDCRecruitChannelInfo, Index) == 0x000000, "Member 'FDCRecruitChannelInfo::Index' has a wrong offset!");
static_assert(offsetof(FDCRecruitChannelInfo, Data) == 0x000008, "Member 'FDCRecruitChannelInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCRecruitChannelInfo, GroupIndex) == 0x000010, "Member 'FDCRecruitChannelInfo::GroupIndex' has a wrong offset!");
static_assert(offsetof(FDCRecruitChannelInfo, NumMembers) == 0x000014, "Member 'FDCRecruitChannelInfo::NumMembers' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryTaskTargetInfo
// 0x0020 (0x0020 - 0x0000)
struct FDCInventoryTaskTargetInfo final
{
public:
	struct FDCInventoryKey                        InventoryKey;                                      // 0x0000(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Stack;                                             // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSplit;                                            // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInnerStack;                                       // 0x0019(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC1[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCInventoryTaskTargetInfo) == 0x000008, "Wrong alignment on FDCInventoryTaskTargetInfo");
static_assert(sizeof(FDCInventoryTaskTargetInfo) == 0x000020, "Wrong size on FDCInventoryTaskTargetInfo");
static_assert(offsetof(FDCInventoryTaskTargetInfo, InventoryKey) == 0x000000, "Member 'FDCInventoryTaskTargetInfo::InventoryKey' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskTargetInfo, Index) == 0x000010, "Member 'FDCInventoryTaskTargetInfo::Index' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskTargetInfo, Stack) == 0x000014, "Member 'FDCInventoryTaskTargetInfo::Stack' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskTargetInfo, bSplit) == 0x000018, "Member 'FDCInventoryTaskTargetInfo::bSplit' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskTargetInfo, bInnerStack) == 0x000019, "Member 'FDCInventoryTaskTargetInfo::bInnerStack' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInputAction
// 0x0010 (0x0010 - 0x0000)
struct FDCInputAction final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCInputAction) == 0x000008, "Wrong alignment on FDCInputAction");
static_assert(sizeof(FDCInputAction) == 0x000010, "Wrong size on FDCInputAction");
static_assert(offsetof(FDCInputAction, InputAction) == 0x000000, "Member 'FDCInputAction::InputAction' has a wrong offset!");
static_assert(offsetof(FDCInputAction, InputTag) == 0x000008, "Member 'FDCInputAction::InputTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataMusic
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataMusic final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SequenceIndex;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MusicId;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataMusic) == 0x000008, "Wrong alignment on FAccountDataMusic");
static_assert(sizeof(FAccountDataMusic) == 0x000018, "Wrong size on FAccountDataMusic");
static_assert(offsetof(FAccountDataMusic, SlotIndex) == 0x000000, "Member 'FAccountDataMusic::SlotIndex' has a wrong offset!");
static_assert(offsetof(FAccountDataMusic, SequenceIndex) == 0x000004, "Member 'FAccountDataMusic::SequenceIndex' has a wrong offset!");
static_assert(offsetof(FAccountDataMusic, MusicId) == 0x000008, "Member 'FAccountDataMusic::MusicId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassMusicListResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgGameTestClassMusicListResponse final : public FMsgBase
{
public:
	TArray<struct FAccountDataMusic>              Musics;                                            // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassMusicListResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassMusicListResponse");
static_assert(sizeof(FMsgGameTestClassMusicListResponse) == 0x000028, "Wrong size on FMsgGameTestClassMusicListResponse");
static_assert(offsetof(FMsgGameTestClassMusicListResponse, Musics) == 0x000018, "Member 'FMsgGameTestClassMusicListResponse::Musics' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCEquipArmorInfo
// 0x0020 (0x0020 - 0x0000)
struct FDCEquipArmorInfo final
{
public:
	TArray<EDCEquipmentSlotIndex>                 Keys;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDCItemId>                      Values;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCEquipArmorInfo) == 0x000008, "Wrong alignment on FDCEquipArmorInfo");
static_assert(sizeof(FDCEquipArmorInfo) == 0x000020, "Wrong size on FDCEquipArmorInfo");
static_assert(offsetof(FDCEquipArmorInfo, Keys) == 0x000000, "Member 'FDCEquipArmorInfo::Keys' has a wrong offset!");
static_assert(offsetof(FDCEquipArmorInfo, Values) == 0x000010, "Member 'FDCEquipArmorInfo::Values' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCTargetExpressmanData
// 0x0010 (0x0010 - 0x0000)
struct FDCTargetExpressmanData final
{
public:
	class ADCNPCExpressman*                       TargetExpressman;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCBoxInventory*                        ExpressInventory;                                  // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCTargetExpressmanData) == 0x000008, "Wrong alignment on FDCTargetExpressmanData");
static_assert(sizeof(FDCTargetExpressmanData) == 0x000010, "Wrong size on FDCTargetExpressmanData");
static_assert(offsetof(FDCTargetExpressmanData, TargetExpressman) == 0x000000, "Member 'FDCTargetExpressmanData::TargetExpressman' has a wrong offset!");
static_assert(offsetof(FDCTargetExpressmanData, ExpressInventory) == 0x000008, "Member 'FDCTargetExpressmanData::ExpressInventory' has a wrong offset!");

// ScriptStruct DungeonCrawler.EmptySlotInfo
// 0x0008 (0x0008 - 0x0000)
struct FEmptySlotInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountOfConnectedEmptySlots;                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmptySlotInfo) == 0x000004, "Wrong alignment on FEmptySlotInfo");
static_assert(sizeof(FEmptySlotInfo) == 0x000008, "Wrong size on FEmptySlotInfo");
static_assert(offsetof(FEmptySlotInfo, Index) == 0x000000, "Member 'FEmptySlotInfo::Index' has a wrong offset!");
static_assert(offsetof(FEmptySlotInfo, CountOfConnectedEmptySlots) == 0x000004, "Member 'FEmptySlotInfo::CountOfConnectedEmptySlots' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyArmorSkinListNotify
// 0x0030 (0x0048 - 0x0018)
struct FClientMsgPartyArmorSkinListNotify final : public FMsgBase
{
public:
	uint8                                         Pad_1FC2[0x30];                                    // 0x0018(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyArmorSkinListNotify) == 0x000008, "Wrong alignment on FClientMsgPartyArmorSkinListNotify");
static_assert(sizeof(FClientMsgPartyArmorSkinListNotify) == 0x000048, "Wrong size on FClientMsgPartyArmorSkinListNotify");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceMyItemListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMarketplaceMyItemListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FC3[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceMyItemListRequest) == 0x000008, "Wrong alignment on FClientMsgMarketplaceMyItemListRequest");
static_assert(sizeof(FClientMsgMarketplaceMyItemListRequest) == 0x000028, "Wrong size on FClientMsgMarketplaceMyItemListRequest");

// ScriptStruct DungeonCrawler.EffectCauserData
// 0x0018 (0x0018 - 0x0000)
struct FEffectCauserData final
{
public:
	class FText                                   EffectCauserName;                                  // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectCauserData) == 0x000008, "Wrong alignment on FEffectCauserData");
static_assert(sizeof(FEffectCauserData) == 0x000018, "Wrong size on FEffectCauserData");
static_assert(offsetof(FEffectCauserData, EffectCauserName) == 0x000000, "Member 'FEffectCauserData::EffectCauserName' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantStockSellBackItemListRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgMerchantStockSellBackItemListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FC4[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantStockSellBackItemListRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantStockSellBackItemListRequest");
static_assert(sizeof(FClientMsgMerchantStockSellBackItemListRequest) == 0x000030, "Wrong size on FClientMsgMerchantStockSellBackItemListRequest");

// ScriptStruct DungeonCrawler.ClientMsgMatchPoolRegisteredNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMatchPoolRegisteredNotify final : public FMsgBase
{
public:
	uint8                                         Pad_1FC5[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMatchPoolRegisteredNotify) == 0x000008, "Wrong alignment on FClientMsgMatchPoolRegisteredNotify");
static_assert(sizeof(FClientMsgMatchPoolRegisteredNotify) == 0x000020, "Wrong size on FClientMsgMatchPoolRegisteredNotify");

// ScriptStruct DungeonCrawler.MsgWidgetKarmaBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetKarmaBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetKarmaBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetKarmaBeginNotify");
static_assert(sizeof(FMsgWidgetKarmaBeginNotify) == 0x000018, "Wrong size on FMsgWidgetKarmaBeginNotify");

// ScriptStruct DungeonCrawler.DCReligionRankEntryInfo
// 0x0048 (0x0048 - 0x0000)
struct FDCReligionRankEntryInfo final
{
public:
	class FString                                 ReligionId;                                        // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         RankNo;                                            // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Nickname;                                          // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         OfferingCount;                                     // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMine;                                           // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC6[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCReligionRankEntryInfo) == 0x000008, "Wrong alignment on FDCReligionRankEntryInfo");
static_assert(sizeof(FDCReligionRankEntryInfo) == 0x000048, "Wrong size on FDCReligionRankEntryInfo");
static_assert(offsetof(FDCReligionRankEntryInfo, ReligionId) == 0x000000, "Member 'FDCReligionRankEntryInfo::ReligionId' has a wrong offset!");
static_assert(offsetof(FDCReligionRankEntryInfo, RankNo) == 0x000010, "Member 'FDCReligionRankEntryInfo::RankNo' has a wrong offset!");
static_assert(offsetof(FDCReligionRankEntryInfo, Nickname) == 0x000018, "Member 'FDCReligionRankEntryInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FDCReligionRankEntryInfo, CharacterClass) == 0x000028, "Member 'FDCReligionRankEntryInfo::CharacterClass' has a wrong offset!");
static_assert(offsetof(FDCReligionRankEntryInfo, OfferingCount) == 0x000038, "Member 'FDCReligionRankEntryInfo::OfferingCount' has a wrong offset!");
static_assert(offsetof(FDCReligionRankEntryInfo, bIsMine) == 0x000040, "Member 'FDCReligionRankEntryInfo::bIsMine' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyExitResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyExitResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FC7[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyExitResponse) == 0x000008, "Wrong alignment on FClientMsgPartyExitResponse");
static_assert(sizeof(FClientMsgPartyExitResponse) == 0x000020, "Wrong size on FClientMsgPartyExitResponse");

// ScriptStruct DungeonCrawler.DesignDataSkill
// 0x00E0 (0x00E0 - 0x0000)
struct FDesignDataSkill final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DescData;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUse;                                            // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC8[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                Classes;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EDCSkillClassAbility                          SkillClassAbility;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC9[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SkillType;                                         // 0x0044(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillTier;                                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanRecharge;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStackable;                                       // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCA[0x2];                                     // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCount;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastingTime;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingDuration;                                // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingInterval;                                // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range;                                             // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMoving;                                         // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedAimTarget;                                     // 0x0069(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCB[0x2];                                     // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SkillTag;                                          // 0x006C(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkillCooldownTag;                                  // 0x0074(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkillCooldownEffect;                               // 0x007C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkillStackCooldownEffect;                          // 0x008C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x009C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x00AC(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCC[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataSkill) == 0x000008, "Wrong alignment on FDesignDataSkill");
static_assert(sizeof(FDesignDataSkill) == 0x0000E0, "Wrong size on FDesignDataSkill");
static_assert(offsetof(FDesignDataSkill, Name) == 0x000000, "Member 'FDesignDataSkill::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, DescData) == 0x000018, "Member 'FDesignDataSkill::DescData' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, CanUse) == 0x000028, "Member 'FDesignDataSkill::CanUse' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, Classes) == 0x000030, "Member 'FDesignDataSkill::Classes' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, SkillClassAbility) == 0x000040, "Member 'FDesignDataSkill::SkillClassAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, SkillType) == 0x000044, "Member 'FDesignDataSkill::SkillType' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, SkillTier) == 0x00004C, "Member 'FDesignDataSkill::SkillTier' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, CanRecharge) == 0x000050, "Member 'FDesignDataSkill::CanRecharge' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, IsStackable) == 0x000051, "Member 'FDesignDataSkill::IsStackable' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, MaxCount) == 0x000054, "Member 'FDesignDataSkill::MaxCount' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, CastingTime) == 0x000058, "Member 'FDesignDataSkill::CastingTime' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, ChannelingDuration) == 0x00005C, "Member 'FDesignDataSkill::ChannelingDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, ChannelingInterval) == 0x000060, "Member 'FDesignDataSkill::ChannelingInterval' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, Range) == 0x000064, "Member 'FDesignDataSkill::Range' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, UseMoving) == 0x000068, "Member 'FDesignDataSkill::UseMoving' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, NeedAimTarget) == 0x000069, "Member 'FDesignDataSkill::NeedAimTarget' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, SkillTag) == 0x00006C, "Member 'FDesignDataSkill::SkillTag' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, SkillCooldownTag) == 0x000074, "Member 'FDesignDataSkill::SkillCooldownTag' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, SkillCooldownEffect) == 0x00007C, "Member 'FDesignDataSkill::SkillCooldownEffect' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, SkillStackCooldownEffect) == 0x00008C, "Member 'FDesignDataSkill::SkillStackCooldownEffect' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, ArtData) == 0x00009C, "Member 'FDesignDataSkill::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, SoundData) == 0x0000AC, "Member 'FDesignDataSkill::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, Abilities) == 0x0000C0, "Member 'FDesignDataSkill::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataSkill, Effects) == 0x0000D0, "Member 'FDesignDataSkill::Effects' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemSwitchEventData
// 0x0038 (0x0038 - 0x0000)
struct FDCItemSwitchEventData final
{
public:
	EDCItemSwitchEvent                            EventType;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCEquipHoldType                              HoldType;                                          // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCD[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InnerIndex;                                        // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AItemActor*>                     UnequipItemActors;                                 // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AItemActor*>                     EquipItemActors;                                   // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bEquip;                                            // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCE[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CharacterMontage;                                  // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCItemSwitchEventData) == 0x000008, "Wrong alignment on FDCItemSwitchEventData");
static_assert(sizeof(FDCItemSwitchEventData) == 0x000038, "Wrong size on FDCItemSwitchEventData");
static_assert(offsetof(FDCItemSwitchEventData, EventType) == 0x000000, "Member 'FDCItemSwitchEventData::EventType' has a wrong offset!");
static_assert(offsetof(FDCItemSwitchEventData, HoldType) == 0x000001, "Member 'FDCItemSwitchEventData::HoldType' has a wrong offset!");
static_assert(offsetof(FDCItemSwitchEventData, InnerIndex) == 0x000004, "Member 'FDCItemSwitchEventData::InnerIndex' has a wrong offset!");
static_assert(offsetof(FDCItemSwitchEventData, UnequipItemActors) == 0x000008, "Member 'FDCItemSwitchEventData::UnequipItemActors' has a wrong offset!");
static_assert(offsetof(FDCItemSwitchEventData, EquipItemActors) == 0x000018, "Member 'FDCItemSwitchEventData::EquipItemActors' has a wrong offset!");
static_assert(offsetof(FDCItemSwitchEventData, bEquip) == 0x000028, "Member 'FDCItemSwitchEventData::bEquip' has a wrong offset!");
static_assert(offsetof(FDCItemSwitchEventData, CharacterMontage) == 0x000030, "Member 'FDCItemSwitchEventData::CharacterMontage' has a wrong offset!");

// ScriptStruct DungeonCrawler.InstigatorData
// 0x0068 (0x0068 - 0x0000)
struct FInstigatorData final
{
public:
	class FString                                 InstigatorAccountId;                               // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              InstigatorNickName;                                // 0x0010(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   InstigatorName;                                    // 0x0050(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInstigatorData) == 0x000008, "Wrong alignment on FInstigatorData");
static_assert(sizeof(FInstigatorData) == 0x000068, "Wrong size on FInstigatorData");
static_assert(offsetof(FInstigatorData, InstigatorAccountId) == 0x000000, "Member 'FInstigatorData::InstigatorAccountId' has a wrong offset!");
static_assert(offsetof(FInstigatorData, InstigatorNickName) == 0x000010, "Member 'FInstigatorData::InstigatorNickName' has a wrong offset!");
static_assert(offsetof(FInstigatorData, InstigatorName) == 0x000050, "Member 'FInstigatorData::InstigatorName' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemAvailableInfo
// 0x0004 (0x0004 - 0x0000)
struct FDCItemAvailableInfo final
{
public:
	int32                                         Count;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCItemAvailableInfo) == 0x000004, "Wrong alignment on FDCItemAvailableInfo");
static_assert(sizeof(FDCItemAvailableInfo) == 0x000004, "Wrong size on FDCItemAvailableInfo");
static_assert(offsetof(FDCItemAvailableInfo, Count) == 0x000000, "Member 'FDCItemAvailableInfo::Count' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCGameplayEffectContainer
// 0x0078 (0x0078 - 0x0000)
struct FDCGameplayEffectContainer final
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDCTargetType>              TargetType;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectData                  GameplayEffectData;                                // 0x0010(0x0068)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCGameplayEffectContainer) == 0x000008, "Wrong alignment on FDCGameplayEffectContainer");
static_assert(sizeof(FDCGameplayEffectContainer) == 0x000078, "Wrong size on FDCGameplayEffectContainer");
static_assert(offsetof(FDCGameplayEffectContainer, EventTag) == 0x000000, "Member 'FDCGameplayEffectContainer::EventTag' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContainer, TargetType) == 0x000008, "Member 'FDCGameplayEffectContainer::TargetType' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContainer, GameplayEffectData) == 0x000010, "Member 'FDCGameplayEffectContainer::GameplayEffectData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCGameplayAbilityData
// 0x0028 (0x0028 - 0x0000)
struct FDCGameplayAbilityData final
{
public:
	struct FPrimaryAssetId                        AbilityId;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayAbility>           GameplayAbilityClass;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectContainer>     GameplayEffectContainerArray;                      // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCGameplayAbilityData) == 0x000008, "Wrong alignment on FDCGameplayAbilityData");
static_assert(sizeof(FDCGameplayAbilityData) == 0x000028, "Wrong size on FDCGameplayAbilityData");
static_assert(offsetof(FDCGameplayAbilityData, AbilityId) == 0x000000, "Member 'FDCGameplayAbilityData::AbilityId' has a wrong offset!");
static_assert(offsetof(FDCGameplayAbilityData, GameplayAbilityClass) == 0x000010, "Member 'FDCGameplayAbilityData::GameplayAbilityClass' has a wrong offset!");
static_assert(offsetof(FDCGameplayAbilityData, GameplayEffectContainerArray) == 0x000018, "Member 'FDCGameplayAbilityData::GameplayEffectContainerArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCStringIdBase
// 0x0010 (0x0010 - 0x0000)
struct FDCStringIdBase
{
public:
	class FString                                 _;                                                 // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCStringIdBase) == 0x000008, "Wrong alignment on FDCStringIdBase");
static_assert(sizeof(FDCStringIdBase) == 0x000010, "Wrong size on FDCStringIdBase");
static_assert(offsetof(FDCStringIdBase, _) == 0x000000, "Member 'FDCStringIdBase::_' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCAccountId
// 0x0000 (0x0010 - 0x0010)
struct FDCAccountId final : public FDCStringIdBase
{
};
static_assert(alignof(FDCAccountId) == 0x000008, "Wrong alignment on FDCAccountId");
static_assert(sizeof(FDCAccountId) == 0x000010, "Wrong size on FDCAccountId");

// ScriptStruct DungeonCrawler.DCPartyId
// 0x0000 (0x0010 - 0x0010)
struct FDCPartyId final : public FDCStringIdBase
{
};
static_assert(alignof(FDCPartyId) == 0x000008, "Wrong alignment on FDCPartyId");
static_assert(sizeof(FDCPartyId) == 0x000010, "Wrong size on FDCPartyId");

// ScriptStruct DungeonCrawler.DCItemSoulHeartInfo
// 0x0060 (0x0060 - 0x0000)
struct FDCItemSoulHeartInfo final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCPartyId                             PartyId;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0020(0x0040)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCItemSoulHeartInfo) == 0x000008, "Wrong alignment on FDCItemSoulHeartInfo");
static_assert(sizeof(FDCItemSoulHeartInfo) == 0x000060, "Wrong size on FDCItemSoulHeartInfo");
static_assert(offsetof(FDCItemSoulHeartInfo, AccountId) == 0x000000, "Member 'FDCItemSoulHeartInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCItemSoulHeartInfo, PartyId) == 0x000010, "Member 'FDCItemSoulHeartInfo::PartyId' has a wrong offset!");
static_assert(offsetof(FDCItemSoulHeartInfo, Nickname) == 0x000020, "Member 'FDCItemSoulHeartInfo::Nickname' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemTempData
// 0x000C (0x000C - 0x0000)
struct FDCItemTempData final
{
public:
	EDCInventoryId                                InventoryType;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FCF[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD0[0x3];                                     // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCItemTempData) == 0x000004, "Wrong alignment on FDCItemTempData");
static_assert(sizeof(FDCItemTempData) == 0x00000C, "Wrong size on FDCItemTempData");
static_assert(offsetof(FDCItemTempData, InventoryType) == 0x000000, "Member 'FDCItemTempData::InventoryType' has a wrong offset!");
static_assert(offsetof(FDCItemTempData, SlotIndex) == 0x000004, "Member 'FDCItemTempData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FDCItemTempData, bEquipped) == 0x000008, "Member 'FDCItemTempData::bEquipped' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemInfo
// 0x0168 (0x0168 - 0x0000)
struct FDCItemInfo final
{
public:
	struct FDCItemId                              ID;                                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCItemDataAsset*                       DataAsset;                                         // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCItemSkinDataAsset*                   ItemSkinDataAsset;                                 // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCArmorSkinDataAsset*                  ArmorSkinDataAsset;                                // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Stack;                                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         InnerStack;                                        // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AmmoCount;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCItemLootState                              LootState;                                         // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FD1[0x3];                                     // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCGameplayAbilityData>         SelfAbilities;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCGameplayEffectData>          SelfEffects;                                       // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCGameplayAbilityData>         OwnerAbilities;                                    // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCGameplayEffectData>          OwnerEffects;                                      // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  OwnerItemTagContainer;                             // 0x0070(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCPropertyEffectData>          PrimaryProperties;                                 // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCPropertyEffectData>          SecondaryProperties;                               // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FDCItemOriginInfo                      ItemOriginInfo;                                    // 0x00B0(0x0048)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)
	struct FDCItemSoulHeartInfo                   SoulHeartInfo;                                     // 0x00F8(0x0060)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)
	struct FDCItemAvailableInfo                   AvailableInfo;                                     // 0x0158(0x0004)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FDCItemTempData                        TempData;                                          // 0x015C(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCItemInfo) == 0x000008, "Wrong alignment on FDCItemInfo");
static_assert(sizeof(FDCItemInfo) == 0x000168, "Wrong size on FDCItemInfo");
static_assert(offsetof(FDCItemInfo, ID) == 0x000000, "Member 'FDCItemInfo::ID' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, DataAsset) == 0x000008, "Member 'FDCItemInfo::DataAsset' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, ItemSkinDataAsset) == 0x000010, "Member 'FDCItemInfo::ItemSkinDataAsset' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, ArmorSkinDataAsset) == 0x000018, "Member 'FDCItemInfo::ArmorSkinDataAsset' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, Stack) == 0x000020, "Member 'FDCItemInfo::Stack' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, InnerStack) == 0x000024, "Member 'FDCItemInfo::InnerStack' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, AmmoCount) == 0x000028, "Member 'FDCItemInfo::AmmoCount' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, LootState) == 0x00002C, "Member 'FDCItemInfo::LootState' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, SelfAbilities) == 0x000030, "Member 'FDCItemInfo::SelfAbilities' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, SelfEffects) == 0x000040, "Member 'FDCItemInfo::SelfEffects' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, OwnerAbilities) == 0x000050, "Member 'FDCItemInfo::OwnerAbilities' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, OwnerEffects) == 0x000060, "Member 'FDCItemInfo::OwnerEffects' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, OwnerItemTagContainer) == 0x000070, "Member 'FDCItemInfo::OwnerItemTagContainer' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, PrimaryProperties) == 0x000090, "Member 'FDCItemInfo::PrimaryProperties' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, SecondaryProperties) == 0x0000A0, "Member 'FDCItemInfo::SecondaryProperties' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, ItemOriginInfo) == 0x0000B0, "Member 'FDCItemInfo::ItemOriginInfo' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, SoulHeartInfo) == 0x0000F8, "Member 'FDCItemInfo::SoulHeartInfo' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, AvailableInfo) == 0x000158, "Member 'FDCItemInfo::AvailableInfo' has a wrong offset!");
static_assert(offsetof(FDCItemInfo, TempData) == 0x00015C, "Member 'FDCItemInfo::TempData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryTaskSourceInfo
// 0x02E8 (0x02E8 - 0x0000)
struct FDCInventoryTaskSourceInfo final
{
public:
	struct FDCInventoryKey                        InventoryKey;                                      // 0x0000(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD2[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCItemInfo                            Key;                                               // 0x0018(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCItemInfo                            Value;                                             // 0x0180(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCInventoryTaskSourceInfo) == 0x000008, "Wrong alignment on FDCInventoryTaskSourceInfo");
static_assert(sizeof(FDCInventoryTaskSourceInfo) == 0x0002E8, "Wrong size on FDCInventoryTaskSourceInfo");
static_assert(offsetof(FDCInventoryTaskSourceInfo, InventoryKey) == 0x000000, "Member 'FDCInventoryTaskSourceInfo::InventoryKey' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskSourceInfo, Index) == 0x000010, "Member 'FDCInventoryTaskSourceInfo::Index' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskSourceInfo, Key) == 0x000018, "Member 'FDCInventoryTaskSourceInfo::Key' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskSourceInfo, Value) == 0x000180, "Member 'FDCInventoryTaskSourceInfo::Value' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryTaskAuxInfo
// 0x01B0 (0x01B0 - 0x0000)
struct FDCInventoryTaskAuxInfo final
{
public:
	struct FDCItemId                              MergeKey;                                          // 0x0000(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCItemInfo                            ResultValue;                                       // 0x0008(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCItemId>                      SwapKeys;                                          // 0x0170(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 SwapIndexes;                                       // 0x0180(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FDCInventoryKey>                SwapToInventories;                                 // 0x0190(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 SwapToIndexes;                                     // 0x01A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCInventoryTaskAuxInfo) == 0x000008, "Wrong alignment on FDCInventoryTaskAuxInfo");
static_assert(sizeof(FDCInventoryTaskAuxInfo) == 0x0001B0, "Wrong size on FDCInventoryTaskAuxInfo");
static_assert(offsetof(FDCInventoryTaskAuxInfo, MergeKey) == 0x000000, "Member 'FDCInventoryTaskAuxInfo::MergeKey' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskAuxInfo, ResultValue) == 0x000008, "Member 'FDCInventoryTaskAuxInfo::ResultValue' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskAuxInfo, SwapKeys) == 0x000170, "Member 'FDCInventoryTaskAuxInfo::SwapKeys' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskAuxInfo, SwapIndexes) == 0x000180, "Member 'FDCInventoryTaskAuxInfo::SwapIndexes' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskAuxInfo, SwapToInventories) == 0x000190, "Member 'FDCInventoryTaskAuxInfo::SwapToInventories' has a wrong offset!");
static_assert(offsetof(FDCInventoryTaskAuxInfo, SwapToIndexes) == 0x0001A0, "Member 'FDCInventoryTaskAuxInfo::SwapToIndexes' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryTask
// 0x04C0 (0x04C0 - 0x0000)
struct FDCInventoryTask final
{
public:
	EDCInventoryTaskType                          TaskType;                                          // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD3[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCInventoryTaskSourceInfo             Source;                                            // 0x0008(0x02E8)(Transient, NativeAccessSpecifierPublic)
	struct FDCInventoryTaskTargetInfo             Target;                                            // 0x02F0(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FDCInventoryTaskAuxInfo                TargetAux;                                         // 0x0310(0x01B0)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCInventoryTask) == 0x000008, "Wrong alignment on FDCInventoryTask");
static_assert(sizeof(FDCInventoryTask) == 0x0004C0, "Wrong size on FDCInventoryTask");
static_assert(offsetof(FDCInventoryTask, TaskType) == 0x000000, "Member 'FDCInventoryTask::TaskType' has a wrong offset!");
static_assert(offsetof(FDCInventoryTask, Source) == 0x000008, "Member 'FDCInventoryTask::Source' has a wrong offset!");
static_assert(offsetof(FDCInventoryTask, Target) == 0x0002F0, "Member 'FDCInventoryTask::Target' has a wrong offset!");
static_assert(offsetof(FDCInventoryTask, TargetAux) == 0x000310, "Member 'FDCInventoryTask::TargetAux' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryEquipData
// 0x0170 (0x0170 - 0x0000)
struct FDCInventoryEquipData final
{
public:
	float                                         DurationSeconds;                                   // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCEquipmentSlotIndex                         Index;                                             // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD4[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCItemInfo                            ItemInfo;                                          // 0x0008(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCInventoryEquipData) == 0x000008, "Wrong alignment on FDCInventoryEquipData");
static_assert(sizeof(FDCInventoryEquipData) == 0x000170, "Wrong size on FDCInventoryEquipData");
static_assert(offsetof(FDCInventoryEquipData, DurationSeconds) == 0x000000, "Member 'FDCInventoryEquipData::DurationSeconds' has a wrong offset!");
static_assert(offsetof(FDCInventoryEquipData, Index) == 0x000004, "Member 'FDCInventoryEquipData::Index' has a wrong offset!");
static_assert(offsetof(FDCInventoryEquipData, ItemInfo) == 0x000008, "Member 'FDCInventoryEquipData::ItemInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryEventData
// 0x0188 (0x0188 - 0x0000)
struct FDCInventoryEventData final
{
public:
	TArray<struct FDCInventoryTask>               Tasks;                                             // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bEquipData;                                        // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD5[0x7];                                     // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCInventoryEquipData                  EquipData;                                         // 0x0018(0x0170)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCInventoryEventData) == 0x000008, "Wrong alignment on FDCInventoryEventData");
static_assert(sizeof(FDCInventoryEventData) == 0x000188, "Wrong size on FDCInventoryEventData");
static_assert(offsetof(FDCInventoryEventData, Tasks) == 0x000000, "Member 'FDCInventoryEventData::Tasks' has a wrong offset!");
static_assert(offsetof(FDCInventoryEventData, bEquipData) == 0x000010, "Member 'FDCInventoryEventData::bEquipData' has a wrong offset!");
static_assert(offsetof(FDCInventoryEventData, EquipData) == 0x000018, "Member 'FDCInventoryEventData::EquipData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCGameplayEffectContext
// 0x03A0 (0x0420 - 0x0080)
struct FDCGameplayEffectContext final : public FGameplayEffectContext
{
public:
	struct FPrimaryAssetId                        EffectId;                                          // 0x0080(0x0010)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEquipmentQuickSlotType                       EquipmentQuickSlotType;                            // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FD6[0x7];                                     // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemData                              ItemData;                                          // 0x0098(0x0100)(Protected, NativeAccessSpecifierProtected)
	struct FInstigatorData                        InstigatorData;                                    // 0x0198(0x0068)(Protected, NativeAccessSpecifierProtected)
	struct FEffectCauserData                      EffectCauserData;                                  // 0x0200(0x0018)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FDCGameplayEffectData>          OverrideGameplayEffectDataArray;                   // 0x0218(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FPrimaryAssetId                        SoundDataPrimaryAssetId;                           // 0x0228(0x0010)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FItemData>                      ItemDatas;                                         // 0x0238(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bActivatedQuickSlotEvent;                          // 0x0248(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoFillUtilitySlot;                              // 0x0249(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bItemSwitchEvent;                                  // 0x024A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FD7[0x1];                                     // 0x024B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnequipItemActorsNum;                              // 0x024C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCItemSwitchEventData                 ItemSwitchEventData;                               // 0x0250(0x0038)(NativeAccessSpecifierPrivate)
	bool                                          bInventoryEventData;                               // 0x0288(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FD8[0x7];                                     // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCInventoryEventData                  InventoryEventData;                                // 0x0290(0x0188)(NativeAccessSpecifierPrivate)
	bool                                          bQuickSlotReserved;                                // 0x0418(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FD9[0x3];                                     // 0x0419(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EmoteRandomNumber;                                 // 0x041C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCGameplayEffectContext) == 0x000008, "Wrong alignment on FDCGameplayEffectContext");
static_assert(sizeof(FDCGameplayEffectContext) == 0x000420, "Wrong size on FDCGameplayEffectContext");
static_assert(offsetof(FDCGameplayEffectContext, EffectId) == 0x000080, "Member 'FDCGameplayEffectContext::EffectId' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, EquipmentQuickSlotType) == 0x000090, "Member 'FDCGameplayEffectContext::EquipmentQuickSlotType' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, ItemData) == 0x000098, "Member 'FDCGameplayEffectContext::ItemData' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, InstigatorData) == 0x000198, "Member 'FDCGameplayEffectContext::InstigatorData' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, EffectCauserData) == 0x000200, "Member 'FDCGameplayEffectContext::EffectCauserData' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, OverrideGameplayEffectDataArray) == 0x000218, "Member 'FDCGameplayEffectContext::OverrideGameplayEffectDataArray' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, SoundDataPrimaryAssetId) == 0x000228, "Member 'FDCGameplayEffectContext::SoundDataPrimaryAssetId' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, ItemDatas) == 0x000238, "Member 'FDCGameplayEffectContext::ItemDatas' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, bActivatedQuickSlotEvent) == 0x000248, "Member 'FDCGameplayEffectContext::bActivatedQuickSlotEvent' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, bAutoFillUtilitySlot) == 0x000249, "Member 'FDCGameplayEffectContext::bAutoFillUtilitySlot' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, bItemSwitchEvent) == 0x00024A, "Member 'FDCGameplayEffectContext::bItemSwitchEvent' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, UnequipItemActorsNum) == 0x00024C, "Member 'FDCGameplayEffectContext::UnequipItemActorsNum' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, ItemSwitchEventData) == 0x000250, "Member 'FDCGameplayEffectContext::ItemSwitchEventData' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, bInventoryEventData) == 0x000288, "Member 'FDCGameplayEffectContext::bInventoryEventData' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, InventoryEventData) == 0x000290, "Member 'FDCGameplayEffectContext::InventoryEventData' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, bQuickSlotReserved) == 0x000418, "Member 'FDCGameplayEffectContext::bQuickSlotReserved' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContext, EmoteRandomNumber) == 0x00041C, "Member 'FDCGameplayEffectContext::EmoteRandomNumber' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgReligionRegisterResponse
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgReligionRegisterResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FDA[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionRegisterResponse) == 0x000008, "Wrong alignment on FClientMsgReligionRegisterResponse");
static_assert(sizeof(FClientMsgReligionRegisterResponse) == 0x000040, "Wrong size on FClientMsgReligionRegisterResponse");

// ScriptStruct DungeonCrawler.MsgSample
// 0x0000 (0x0018 - 0x0018)
struct FMsgSample final : public FMsgBase
{
};
static_assert(alignof(FMsgSample) == 0x000008, "Wrong alignment on FMsgSample");
static_assert(sizeof(FMsgSample) == 0x000018, "Wrong size on FMsgSample");

// ScriptStruct DungeonCrawler.ClientMsgClassSpellListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgClassSpellListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FDB[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassSpellListRequest) == 0x000008, "Wrong alignment on FClientMsgClassSpellListRequest");
static_assert(sizeof(FClientMsgClassSpellListRequest) == 0x000028, "Wrong size on FClientMsgClassSpellListRequest");

// ScriptStruct DungeonCrawler.MsgContainingItemDataRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgContainingItemDataRequest final : public FMsgBase
{
public:
	int64                                         ItemUniqueId;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgContainingItemDataRequest) == 0x000008, "Wrong alignment on FMsgContainingItemDataRequest");
static_assert(sizeof(FMsgContainingItemDataRequest) == 0x000020, "Wrong size on FMsgContainingItemDataRequest");
static_assert(offsetof(FMsgContainingItemDataRequest, ItemUniqueId) == 0x000018, "Member 'FMsgContainingItemDataRequest::ItemUniqueId' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataGameSpell
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataGameSpell final
{
public:
	struct FPrimaryAssetId                        SpellId;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeAmount;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataGameSpell) == 0x000004, "Wrong alignment on FAccountDataGameSpell");
static_assert(sizeof(FAccountDataGameSpell) == 0x000018, "Wrong size on FAccountDataGameSpell");
static_assert(offsetof(FAccountDataGameSpell, SpellId) == 0x000000, "Member 'FAccountDataGameSpell::SpellId' has a wrong offset!");
static_assert(offsetof(FAccountDataGameSpell, Count) == 0x000010, "Member 'FAccountDataGameSpell::Count' has a wrong offset!");
static_assert(offsetof(FAccountDataGameSpell, ChargeAmount) == 0x000014, "Member 'FAccountDataGameSpell::ChargeAmount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMovementModifier
// 0x0018 (0x0018 - 0x0000)
struct FDesignDataMovementModifier final
{
public:
	struct FGameplayTag                           ExactEventTag;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Add;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiply;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpZMultiply;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScaleMultiply;                              // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMovementModifier) == 0x000004, "Wrong alignment on FDesignDataMovementModifier");
static_assert(sizeof(FDesignDataMovementModifier) == 0x000018, "Wrong size on FDesignDataMovementModifier");
static_assert(offsetof(FDesignDataMovementModifier, ExactEventTag) == 0x000000, "Member 'FDesignDataMovementModifier::ExactEventTag' has a wrong offset!");
static_assert(offsetof(FDesignDataMovementModifier, Add) == 0x000008, "Member 'FDesignDataMovementModifier::Add' has a wrong offset!");
static_assert(offsetof(FDesignDataMovementModifier, Multiply) == 0x00000C, "Member 'FDesignDataMovementModifier::Multiply' has a wrong offset!");
static_assert(offsetof(FDesignDataMovementModifier, JumpZMultiply) == 0x000010, "Member 'FDesignDataMovementModifier::JumpZMultiply' has a wrong offset!");
static_assert(offsetof(FDesignDataMovementModifier, GravityScaleMultiply) == 0x000014, "Member 'FDesignDataMovementModifier::GravityScaleMultiply' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMovementModifierTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataMovementModifierTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataMovementModifier> MovementModifier;                                  // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMovementModifierTableRow) == 0x000008, "Wrong alignment on FDesignDataMovementModifierTableRow");
static_assert(sizeof(FDesignDataMovementModifierTableRow) == 0x000058, "Wrong size on FDesignDataMovementModifierTableRow");
static_assert(offsetof(FDesignDataMovementModifierTableRow, MovementModifier) == 0x000008, "Member 'FDesignDataMovementModifierTableRow::MovementModifier' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantServiceMindwipeResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMerchantServiceMindwipeResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FDC[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantServiceMindwipeResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantServiceMindwipeResponse");
static_assert(sizeof(FClientMsgMerchantServiceMindwipeResponse) == 0x000020, "Wrong size on FClientMsgMerchantServiceMindwipeResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopRedStoneShardBuyCheckRequest
// 0x0028 (0x0048 - 0x0020)
struct FClientMsgShopRedStoneShardBuyCheckRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FDD[0x28];                                    // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopRedStoneShardBuyCheckRequest) == 0x000008, "Wrong alignment on FClientMsgShopRedStoneShardBuyCheckRequest");
static_assert(sizeof(FClientMsgShopRedStoneShardBuyCheckRequest) == 0x000048, "Wrong size on FClientMsgShopRedStoneShardBuyCheckRequest");

// ScriptStruct DungeonCrawler.ClientMsgKarmaReportActionRequest
// 0x0030 (0x0050 - 0x0020)
struct FClientMsgKarmaReportActionRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FDE[0x30];                                    // 0x0020(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgKarmaReportActionRequest) == 0x000008, "Wrong alignment on FClientMsgKarmaReportActionRequest");
static_assert(sizeof(FClientMsgKarmaReportActionRequest) == 0x000050, "Wrong size on FClientMsgKarmaReportActionRequest");

// ScriptStruct DungeonCrawler.ClientMsgMerchantRecoveryBuyResponse
// 0x0048 (0x0060 - 0x0018)
struct FClientMsgMerchantRecoveryBuyResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FDF[0x48];                                    // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantRecoveryBuyResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantRecoveryBuyResponse");
static_assert(sizeof(FClientMsgMerchantRecoveryBuyResponse) == 0x000060, "Wrong size on FClientMsgMerchantRecoveryBuyResponse");

// ScriptStruct DungeonCrawler.AccountDataItemMeta
// 0x0068 (0x0068 - 0x0000)
struct FAccountDataItemMeta final
{
public:
	class FString                                 SoulHeart_AccountId;                               // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SoulHeart_PartyId;                                 // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              SoulHeart_NickName;                                // 0x0020(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         AvailableValue;                                    // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE0[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAccountDataItemMeta) == 0x000008, "Wrong alignment on FAccountDataItemMeta");
static_assert(sizeof(FAccountDataItemMeta) == 0x000068, "Wrong size on FAccountDataItemMeta");
static_assert(offsetof(FAccountDataItemMeta, SoulHeart_AccountId) == 0x000000, "Member 'FAccountDataItemMeta::SoulHeart_AccountId' has a wrong offset!");
static_assert(offsetof(FAccountDataItemMeta, SoulHeart_PartyId) == 0x000010, "Member 'FAccountDataItemMeta::SoulHeart_PartyId' has a wrong offset!");
static_assert(offsetof(FAccountDataItemMeta, SoulHeart_NickName) == 0x000020, "Member 'FAccountDataItemMeta::SoulHeart_NickName' has a wrong offset!");
static_assert(offsetof(FAccountDataItemMeta, AvailableValue) == 0x000060, "Member 'FAccountDataItemMeta::AvailableValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataItemProperty
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataItemProperty final
{
public:
	class FString                                 PropertyTypeId;                                    // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PropertyValue;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE1[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAccountDataItemProperty) == 0x000008, "Wrong alignment on FAccountDataItemProperty");
static_assert(sizeof(FAccountDataItemProperty) == 0x000018, "Wrong size on FAccountDataItemProperty");
static_assert(offsetof(FAccountDataItemProperty, PropertyTypeId) == 0x000000, "Member 'FAccountDataItemProperty::PropertyTypeId' has a wrong offset!");
static_assert(offsetof(FAccountDataItemProperty, PropertyValue) == 0x000010, "Member 'FAccountDataItemProperty::PropertyValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataItem
// 0x00E0 (0x00E0 - 0x0000)
struct FAccountDataItem final
{
public:
	int64                                         ItemUniqueId;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemId;                                            // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotId;                                            // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemAmmoCount;                                     // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemContentsCount;                                 // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCItemLootState                              LootState;                                         // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE2[0x3];                                     // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAccountDataItemMeta                   MetaData;                                          // 0x0030(0x0068)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataItemProperty>       PrimaryPropertyArray;                              // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataItemProperty>       SecondaryPropertyArray;                            // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EDCItemOriginType                             ItemOriginType;                                    // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE3[0x7];                                     // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OriginNickname;                                    // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OriginStreamingNickname;                           // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataItem) == 0x000008, "Wrong alignment on FAccountDataItem");
static_assert(sizeof(FAccountDataItem) == 0x0000E0, "Wrong size on FAccountDataItem");
static_assert(offsetof(FAccountDataItem, ItemUniqueId) == 0x000000, "Member 'FAccountDataItem::ItemUniqueId' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, ItemId) == 0x000008, "Member 'FAccountDataItem::ItemId' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, InventoryId) == 0x000018, "Member 'FAccountDataItem::InventoryId' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, SlotId) == 0x00001C, "Member 'FAccountDataItem::SlotId' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, ItemCount) == 0x000020, "Member 'FAccountDataItem::ItemCount' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, ItemAmmoCount) == 0x000024, "Member 'FAccountDataItem::ItemAmmoCount' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, ItemContentsCount) == 0x000028, "Member 'FAccountDataItem::ItemContentsCount' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, LootState) == 0x00002C, "Member 'FAccountDataItem::LootState' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, MetaData) == 0x000030, "Member 'FAccountDataItem::MetaData' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, PrimaryPropertyArray) == 0x000098, "Member 'FAccountDataItem::PrimaryPropertyArray' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, SecondaryPropertyArray) == 0x0000A8, "Member 'FAccountDataItem::SecondaryPropertyArray' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, ItemOriginType) == 0x0000B8, "Member 'FAccountDataItem::ItemOriginType' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, OriginNickname) == 0x0000C0, "Member 'FAccountDataItem::OriginNickname' has a wrong offset!");
static_assert(offsetof(FAccountDataItem, OriginStreamingNickname) == 0x0000D0, "Member 'FAccountDataItem::OriginStreamingNickname' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataPerk
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataPerk final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE4[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PerkId;                                            // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataPerk) == 0x000008, "Wrong alignment on FAccountDataPerk");
static_assert(sizeof(FAccountDataPerk) == 0x000018, "Wrong size on FAccountDataPerk");
static_assert(offsetof(FAccountDataPerk, Index) == 0x000000, "Member 'FAccountDataPerk::Index' has a wrong offset!");
static_assert(offsetof(FAccountDataPerk, PerkId) == 0x000008, "Member 'FAccountDataPerk::PerkId' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataSkill
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataSkill final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE5[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SkillId;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataSkill) == 0x000008, "Wrong alignment on FAccountDataSkill");
static_assert(sizeof(FAccountDataSkill) == 0x000018, "Wrong size on FAccountDataSkill");
static_assert(offsetof(FAccountDataSkill, Index) == 0x000000, "Member 'FAccountDataSkill::Index' has a wrong offset!");
static_assert(offsetof(FAccountDataSkill, SkillId) == 0x000008, "Member 'FAccountDataSkill::SkillId' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataSpell
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataSpell final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SequenceIndex;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SpellId;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataSpell) == 0x000008, "Wrong alignment on FAccountDataSpell");
static_assert(sizeof(FAccountDataSpell) == 0x000018, "Wrong size on FAccountDataSpell");
static_assert(offsetof(FAccountDataSpell, SlotIndex) == 0x000000, "Member 'FAccountDataSpell::SlotIndex' has a wrong offset!");
static_assert(offsetof(FAccountDataSpell, SequenceIndex) == 0x000004, "Member 'FAccountDataSpell::SequenceIndex' has a wrong offset!");
static_assert(offsetof(FAccountDataSpell, SpellId) == 0x000008, "Member 'FAccountDataSpell::SpellId' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataShapeShift
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataShapeShift final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SequenceIndex;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShapeShiftId;                                      // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataShapeShift) == 0x000008, "Wrong alignment on FAccountDataShapeShift");
static_assert(sizeof(FAccountDataShapeShift) == 0x000018, "Wrong size on FAccountDataShapeShift");
static_assert(offsetof(FAccountDataShapeShift, SlotIndex) == 0x000000, "Member 'FAccountDataShapeShift::SlotIndex' has a wrong offset!");
static_assert(offsetof(FAccountDataShapeShift, SequenceIndex) == 0x000004, "Member 'FAccountDataShapeShift::SequenceIndex' has a wrong offset!");
static_assert(offsetof(FAccountDataShapeShift, ShapeShiftId) == 0x000008, "Member 'FAccountDataShapeShift::ShapeShiftId' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountData
// 0x0108 (0x0108 - 0x0000)
struct FAccountData final
{
public:
	struct FAccountDataReplication                AccountDataReplication;                            // 0x0000(0x0090)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataItem>               AccountDataItemArray;                              // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataPerk>               AccountDataPerkArray;                              // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataSkill>              AccountDataSkillArray;                             // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataSpell>              AccountDataSpellArray;                             // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataMusic>              AccountDataMusicArray;                             // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataShapeShift>         AccountDataShapeShiftArray;                        // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ExitReason;                                        // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedBlock;                                        // 0x0100(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedHWBlock;                                      // 0x0101(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE6[0x2];                                     // 0x0102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlockTimeMin;                                      // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountData) == 0x000008, "Wrong alignment on FAccountData");
static_assert(sizeof(FAccountData) == 0x000108, "Wrong size on FAccountData");
static_assert(offsetof(FAccountData, AccountDataReplication) == 0x000000, "Member 'FAccountData::AccountDataReplication' has a wrong offset!");
static_assert(offsetof(FAccountData, AccountDataItemArray) == 0x000090, "Member 'FAccountData::AccountDataItemArray' has a wrong offset!");
static_assert(offsetof(FAccountData, AccountDataPerkArray) == 0x0000A0, "Member 'FAccountData::AccountDataPerkArray' has a wrong offset!");
static_assert(offsetof(FAccountData, AccountDataSkillArray) == 0x0000B0, "Member 'FAccountData::AccountDataSkillArray' has a wrong offset!");
static_assert(offsetof(FAccountData, AccountDataSpellArray) == 0x0000C0, "Member 'FAccountData::AccountDataSpellArray' has a wrong offset!");
static_assert(offsetof(FAccountData, AccountDataMusicArray) == 0x0000D0, "Member 'FAccountData::AccountDataMusicArray' has a wrong offset!");
static_assert(offsetof(FAccountData, AccountDataShapeShiftArray) == 0x0000E0, "Member 'FAccountData::AccountDataShapeShiftArray' has a wrong offset!");
static_assert(offsetof(FAccountData, ExitReason) == 0x0000F0, "Member 'FAccountData::ExitReason' has a wrong offset!");
static_assert(offsetof(FAccountData, bNeedBlock) == 0x000100, "Member 'FAccountData::bNeedBlock' has a wrong offset!");
static_assert(offsetof(FAccountData, bNeedHWBlock) == 0x000101, "Member 'FAccountData::bNeedHWBlock' has a wrong offset!");
static_assert(offsetof(FAccountData, BlockTimeMin) == 0x000104, "Member 'FAccountData::BlockTimeMin' has a wrong offset!");

// ScriptStruct DungeonCrawler.PartyMemberData
// 0x0010 (0x0010 - 0x0000)
struct FPartyMemberData final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartyMemberData) == 0x000008, "Wrong alignment on FPartyMemberData");
static_assert(sizeof(FPartyMemberData) == 0x000010, "Wrong size on FPartyMemberData");
static_assert(offsetof(FPartyMemberData, AccountId) == 0x000000, "Member 'FPartyMemberData::AccountId' has a wrong offset!");

// ScriptStruct DungeonCrawler.PartyData
// 0x0020 (0x0020 - 0x0000)
struct FPartyData final
{
public:
	class FString                                 PartyId;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPartyMemberData>               PartyMemberDataArray;                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartyData) == 0x000008, "Wrong alignment on FPartyData");
static_assert(sizeof(FPartyData) == 0x000020, "Wrong size on FPartyData");
static_assert(offsetof(FPartyData, PartyId) == 0x000000, "Member 'FPartyData::PartyId' has a wrong offset!");
static_assert(offsetof(FPartyData, PartyMemberDataArray) == 0x000010, "Member 'FPartyData::PartyMemberDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.PartySessionData
// 0x0020 (0x0020 - 0x0000)
struct FPartySessionData final
{
public:
	struct FPartyData                             PartyData;                                         // 0x0000(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartySessionData) == 0x000008, "Wrong alignment on FPartySessionData");
static_assert(sizeof(FPartySessionData) == 0x000020, "Wrong size on FPartySessionData");
static_assert(offsetof(FPartySessionData, PartyData) == 0x000000, "Member 'FPartySessionData::PartyData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountLinkBegin
// 0x0138 (0x0150 - 0x0018)
struct FMsgAccountLinkBegin final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAccountData                           AccountData;                                       // 0x0020(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UDCAttributeSet*                        AttributeSet;                                      // 0x0128(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPartySessionData                      PartySessionData;                                  // 0x0130(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkBegin) == 0x000008, "Wrong alignment on FMsgAccountLinkBegin");
static_assert(sizeof(FMsgAccountLinkBegin) == 0x000150, "Wrong size on FMsgAccountLinkBegin");
static_assert(offsetof(FMsgAccountLinkBegin, AccountLink) == 0x000018, "Member 'FMsgAccountLinkBegin::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkBegin, AccountData) == 0x000020, "Member 'FMsgAccountLinkBegin::AccountData' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkBegin, AttributeSet) == 0x000128, "Member 'FMsgAccountLinkBegin::AttributeSet' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkBegin, PartySessionData) == 0x000130, "Member 'FMsgAccountLinkBegin::PartySessionData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataBaseGearItem
// 0x0030 (0x0030 - 0x0000)
struct FDesignDataBaseGearItem final
{
public:
	int64                                         UniqueID;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ItemId;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        MerchantId;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAffinity;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FE7[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataBaseGearItem) == 0x000008, "Wrong alignment on FDesignDataBaseGearItem");
static_assert(sizeof(FDesignDataBaseGearItem) == 0x000030, "Wrong size on FDesignDataBaseGearItem");
static_assert(offsetof(FDesignDataBaseGearItem, UniqueID) == 0x000000, "Member 'FDesignDataBaseGearItem::UniqueID' has a wrong offset!");
static_assert(offsetof(FDesignDataBaseGearItem, ItemId) == 0x000008, "Member 'FDesignDataBaseGearItem::ItemId' has a wrong offset!");
static_assert(offsetof(FDesignDataBaseGearItem, MerchantId) == 0x000018, "Member 'FDesignDataBaseGearItem::MerchantId' has a wrong offset!");
static_assert(offsetof(FDesignDataBaseGearItem, RequiredAffinity) == 0x000028, "Member 'FDesignDataBaseGearItem::RequiredAffinity' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassMusicSequenceChangeRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgClassMusicSequenceChangeRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FE8[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassMusicSequenceChangeRequest) == 0x000008, "Wrong alignment on FClientMsgClassMusicSequenceChangeRequest");
static_assert(sizeof(FClientMsgClassMusicSequenceChangeRequest) == 0x000038, "Wrong size on FClientMsgClassMusicSequenceChangeRequest");

// ScriptStruct DungeonCrawler.MsgWidgetChangeCrossHairWhenThrowingNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetChangeCrossHairWhenThrowingNotify final : public FMsgBase
{
public:
	uint8                                         Pad_1FE9[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetChangeCrossHairWhenThrowingNotify) == 0x000008, "Wrong alignment on FMsgWidgetChangeCrossHairWhenThrowingNotify");
static_assert(sizeof(FMsgWidgetChangeCrossHairWhenThrowingNotify) == 0x000030, "Wrong size on FMsgWidgetChangeCrossHairWhenThrowingNotify");

// ScriptStruct DungeonCrawler.MsgEnableSwapItemResponse
// 0x0018 (0x0030 - 0x0018)
struct FMsgEnableSwapItemResponse final : public FMsgBase
{
public:
	bool                                          bCanSwap;                                          // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FEA[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      SwapItemDataArray;                                 // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgEnableSwapItemResponse) == 0x000008, "Wrong alignment on FMsgEnableSwapItemResponse");
static_assert(sizeof(FMsgEnableSwapItemResponse) == 0x000030, "Wrong size on FMsgEnableSwapItemResponse");
static_assert(offsetof(FMsgEnableSwapItemResponse, bCanSwap) == 0x000018, "Member 'FMsgEnableSwapItemResponse::bCanSwap' has a wrong offset!");
static_assert(offsetof(FMsgEnableSwapItemResponse, SwapItemDataArray) == 0x000020, "Member 'FMsgEnableSwapItemResponse::SwapItemDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgInventorySplitSwapResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgInventorySplitSwapResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FEB[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventorySplitSwapResponse) == 0x000008, "Wrong alignment on FClientMsgInventorySplitSwapResponse");
static_assert(sizeof(FClientMsgInventorySplitSwapResponse) == 0x000028, "Wrong size on FClientMsgInventorySplitSwapResponse");

// ScriptStruct DungeonCrawler.SkillData
// 0x0030 (0x0030 - 0x0000)
struct FSkillData final
{
public:
	struct FPrimaryAssetId                        SkillId;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkillTag;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkillCooldownTag;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredChargeAmount;                              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeAmount;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillData) == 0x000004, "Wrong alignment on FSkillData");
static_assert(sizeof(FSkillData) == 0x000030, "Wrong size on FSkillData");
static_assert(offsetof(FSkillData, SkillId) == 0x000000, "Member 'FSkillData::SkillId' has a wrong offset!");
static_assert(offsetof(FSkillData, SkillTag) == 0x000010, "Member 'FSkillData::SkillTag' has a wrong offset!");
static_assert(offsetof(FSkillData, SkillCooldownTag) == 0x000018, "Member 'FSkillData::SkillCooldownTag' has a wrong offset!");
static_assert(offsetof(FSkillData, Count) == 0x000020, "Member 'FSkillData::Count' has a wrong offset!");
static_assert(offsetof(FSkillData, RequiredChargeAmount) == 0x000024, "Member 'FSkillData::RequiredChargeAmount' has a wrong offset!");
static_assert(offsetof(FSkillData, ChargeAmount) == 0x000028, "Member 'FSkillData::ChargeAmount' has a wrong offset!");
static_assert(offsetof(FSkillData, SlotIndex) == 0x00002C, "Member 'FSkillData::SlotIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgCustomizeUnmountResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgCustomizeUnmountResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FEC[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCustomizeUnmountResponse) == 0x000008, "Wrong alignment on FClientMsgCustomizeUnmountResponse");
static_assert(sizeof(FClientMsgCustomizeUnmountResponse) == 0x000030, "Wrong size on FClientMsgCustomizeUnmountResponse");

// ScriptStruct DungeonCrawler.MsgWidgetPlayShootCrossHairNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetPlayShootCrossHairNotify final : public FMsgBase
{
public:
	uint8                                         Pad_1FED[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetPlayShootCrossHairNotify) == 0x000008, "Wrong alignment on FMsgWidgetPlayShootCrossHairNotify");
static_assert(sizeof(FMsgWidgetPlayShootCrossHairNotify) == 0x000020, "Wrong size on FMsgWidgetPlayShootCrossHairNotify");

// ScriptStruct DungeonCrawler.ItemBoneModifyData
// 0x0048 (0x0048 - 0x0000)
struct FItemBoneModifyData final
{
public:
	struct FVector                                Scale;                                             // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemBoneModifyData) == 0x000008, "Wrong alignment on FItemBoneModifyData");
static_assert(sizeof(FItemBoneModifyData) == 0x000048, "Wrong size on FItemBoneModifyData");
static_assert(offsetof(FItemBoneModifyData, Scale) == 0x000000, "Member 'FItemBoneModifyData::Scale' has a wrong offset!");
static_assert(offsetof(FItemBoneModifyData, Rotation) == 0x000018, "Member 'FItemBoneModifyData::Rotation' has a wrong offset!");
static_assert(offsetof(FItemBoneModifyData, Translation) == 0x000030, "Member 'FItemBoneModifyData::Translation' has a wrong offset!");

// ScriptStruct DungeonCrawler.ChatDataPieceItemProperty
// 0x0018 (0x0018 - 0x0000)
struct FChatDataPieceItemProperty final
{
public:
	class FString                                 Pid;                                               // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Pv;                                                // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FEE[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChatDataPieceItemProperty) == 0x000008, "Wrong alignment on FChatDataPieceItemProperty");
static_assert(sizeof(FChatDataPieceItemProperty) == 0x000018, "Wrong size on FChatDataPieceItemProperty");
static_assert(offsetof(FChatDataPieceItemProperty, Pid) == 0x000000, "Member 'FChatDataPieceItemProperty::Pid' has a wrong offset!");
static_assert(offsetof(FChatDataPieceItemProperty, Pv) == 0x000010, "Member 'FChatDataPieceItemProperty::Pv' has a wrong offset!");

// ScriptStruct DungeonCrawler.ChatDataPieceItem
// 0x0038 (0x0038 - 0x0000)
struct FChatDataPieceItem final
{
public:
	TArray<struct FChatDataPieceItemProperty>     Pp;                                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FChatDataPieceItemProperty>     Sp;                                                // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int64                                         Uid;                                               // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Iid;                                               // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChatDataPieceItem) == 0x000008, "Wrong alignment on FChatDataPieceItem");
static_assert(sizeof(FChatDataPieceItem) == 0x000038, "Wrong size on FChatDataPieceItem");
static_assert(offsetof(FChatDataPieceItem, Pp) == 0x000000, "Member 'FChatDataPieceItem::Pp' has a wrong offset!");
static_assert(offsetof(FChatDataPieceItem, Sp) == 0x000010, "Member 'FChatDataPieceItem::Sp' has a wrong offset!");
static_assert(offsetof(FChatDataPieceItem, Uid) == 0x000020, "Member 'FChatDataPieceItem::Uid' has a wrong offset!");
static_assert(offsetof(FChatDataPieceItem, Iid) == 0x000028, "Member 'FChatDataPieceItem::Iid' has a wrong offset!");

// ScriptStruct DungeonCrawler.ChatDataPiece
// 0x0048 (0x0048 - 0x0000)
struct FChatDataPiece final
{
public:
	class FString                                 ChatStr;                                           // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChatDataPieceItem                     ChatDataPieceItem;                                 // 0x0010(0x0038)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChatDataPiece) == 0x000008, "Wrong alignment on FChatDataPiece");
static_assert(sizeof(FChatDataPiece) == 0x000048, "Wrong size on FChatDataPiece");
static_assert(offsetof(FChatDataPiece, ChatStr) == 0x000000, "Member 'FChatDataPiece::ChatStr' has a wrong offset!");
static_assert(offsetof(FChatDataPiece, ChatDataPieceItem) == 0x000010, "Member 'FChatDataPiece::ChatDataPieceItem' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetGameCancelTipVisibilityRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetGameCancelTipVisibilityRequest final : public FMsgBase
{
public:
	ESlateVisibility                              NewVisibility;                                     // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FEF[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetGameCancelTipVisibilityRequest) == 0x000008, "Wrong alignment on FMsgWidgetGameCancelTipVisibilityRequest");
static_assert(sizeof(FMsgWidgetGameCancelTipVisibilityRequest) == 0x000020, "Wrong size on FMsgWidgetGameCancelTipVisibilityRequest");
static_assert(offsetof(FMsgWidgetGameCancelTipVisibilityRequest, NewVisibility) == 0x000018, "Member 'FMsgWidgetGameCancelTipVisibilityRequest::NewVisibility' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelUserListResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgTradeChannelUserListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FF0[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelUserListResponse) == 0x000008, "Wrong alignment on FClientMsgTradeChannelUserListResponse");
static_assert(sizeof(FClientMsgTradeChannelUserListResponse) == 0x000030, "Wrong size on FClientMsgTradeChannelUserListResponse");

// ScriptStruct DungeonCrawler.MsgGameTestClassSpellSlotMoveResponse
// 0x0018 (0x0030 - 0x0018)
struct FMsgGameTestClassSpellSlotMoveResponse final : public FMsgBase
{
public:
	int32                                         Result;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF1[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAccountDataSpell>              EquipSpellList;                                    // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassSpellSlotMoveResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassSpellSlotMoveResponse");
static_assert(sizeof(FMsgGameTestClassSpellSlotMoveResponse) == 0x000030, "Wrong size on FMsgGameTestClassSpellSlotMoveResponse");
static_assert(offsetof(FMsgGameTestClassSpellSlotMoveResponse, Result) == 0x000018, "Member 'FMsgGameTestClassSpellSlotMoveResponse::Result' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassSpellSlotMoveResponse, EquipSpellList) == 0x000020, "Member 'FMsgGameTestClassSpellSlotMoveResponse::EquipSpellList' has a wrong offset!");

// ScriptStruct DungeonCrawler.SkillDataInfo
// 0x0024 (0x0024 - 0x0000)
struct FSkillDataInfo final
{
public:
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkillTag;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CooldownTag;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainDuration;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillDataInfo) == 0x000004, "Wrong alignment on FSkillDataInfo");
static_assert(sizeof(FSkillDataInfo) == 0x000024, "Wrong size on FSkillDataInfo");
static_assert(offsetof(FSkillDataInfo, EffectHandle) == 0x000000, "Member 'FSkillDataInfo::EffectHandle' has a wrong offset!");
static_assert(offsetof(FSkillDataInfo, SkillTag) == 0x000008, "Member 'FSkillDataInfo::SkillTag' has a wrong offset!");
static_assert(offsetof(FSkillDataInfo, CooldownTag) == 0x000010, "Member 'FSkillDataInfo::CooldownTag' has a wrong offset!");
static_assert(offsetof(FSkillDataInfo, RemainDuration) == 0x000018, "Member 'FSkillDataInfo::RemainDuration' has a wrong offset!");
static_assert(offsetof(FSkillDataInfo, MaxDuration) == 0x00001C, "Member 'FSkillDataInfo::MaxDuration' has a wrong offset!");
static_assert(offsetof(FSkillDataInfo, StartTime) == 0x000020, "Member 'FSkillDataInfo::StartTime' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendSetPrivacyRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgFriendSetPrivacyRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FF2[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendSetPrivacyRequest) == 0x000008, "Wrong alignment on FClientMsgFriendSetPrivacyRequest");
static_assert(sizeof(FClientMsgFriendSetPrivacyRequest) == 0x000028, "Wrong size on FClientMsgFriendSetPrivacyRequest");

// ScriptStruct DungeonCrawler.SpellData
// 0x0040 (0x0040 - 0x0000)
struct FSpellData final
{
public:
	struct FPrimaryAssetId                        SpellId;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SpellTag;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CostType;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostAmount;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredChargeAmount;                              // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeAmount;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SequenceIndex;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCapacityOverloaded;                             // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF3[0x3];                                     // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpellData) == 0x000004, "Wrong alignment on FSpellData");
static_assert(sizeof(FSpellData) == 0x000040, "Wrong size on FSpellData");
static_assert(offsetof(FSpellData, SpellId) == 0x000000, "Member 'FSpellData::SpellId' has a wrong offset!");
static_assert(offsetof(FSpellData, SpellTag) == 0x000010, "Member 'FSpellData::SpellTag' has a wrong offset!");
static_assert(offsetof(FSpellData, CostType) == 0x000018, "Member 'FSpellData::CostType' has a wrong offset!");
static_assert(offsetof(FSpellData, CostAmount) == 0x000020, "Member 'FSpellData::CostAmount' has a wrong offset!");
static_assert(offsetof(FSpellData, Count) == 0x000024, "Member 'FSpellData::Count' has a wrong offset!");
static_assert(offsetof(FSpellData, MaxCount) == 0x000028, "Member 'FSpellData::MaxCount' has a wrong offset!");
static_assert(offsetof(FSpellData, RequiredChargeAmount) == 0x00002C, "Member 'FSpellData::RequiredChargeAmount' has a wrong offset!");
static_assert(offsetof(FSpellData, ChargeAmount) == 0x000030, "Member 'FSpellData::ChargeAmount' has a wrong offset!");
static_assert(offsetof(FSpellData, SlotIndex) == 0x000034, "Member 'FSpellData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FSpellData, SequenceIndex) == 0x000038, "Member 'FSpellData::SequenceIndex' has a wrong offset!");
static_assert(offsetof(FSpellData, bIsCapacityOverloaded) == 0x00003C, "Member 'FSpellData::bIsCapacityOverloaded' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassSpellEquippedListNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassSpellEquippedListNotify final : public FMsgBase
{
public:
	TArray<struct FSpellData>                     SpellArray;                                        // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassSpellEquippedListNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSpellEquippedListNotify");
static_assert(sizeof(FMsgWidgetClassSpellEquippedListNotify) == 0x000028, "Wrong size on FMsgWidgetClassSpellEquippedListNotify");
static_assert(offsetof(FMsgWidgetClassSpellEquippedListNotify, SpellArray) == 0x000018, "Member 'FMsgWidgetClassSpellEquippedListNotify::SpellArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.StorageInfo
// 0x0018 (0x0018 - 0x0000)
struct FStorageInfo final
{
public:
	int32                                         InventoryId;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF4[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAccountDataItem>               CharacterStorageItemList;                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStorageInfo) == 0x000008, "Wrong alignment on FStorageInfo");
static_assert(sizeof(FStorageInfo) == 0x000018, "Wrong size on FStorageInfo");
static_assert(offsetof(FStorageInfo, InventoryId) == 0x000000, "Member 'FStorageInfo::InventoryId' has a wrong offset!");
static_assert(offsetof(FStorageInfo, CharacterStorageItemList) == 0x000008, "Member 'FStorageInfo::CharacterStorageItemList' has a wrong offset!");

// ScriptStruct DungeonCrawler.LobbyCharacterInfo
// 0x00C8 (0x00C8 - 0x0000)
struct FLobbyCharacterInfo final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountNickname;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0020(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gender;                                            // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServiceGrpc;                                       // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataItem>               CharacterItemList;                                 // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataItem>               CharacterStorageItemList;                          // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FStorageInfo>                   CharacterStorageInfos;                             // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyCharacterInfo) == 0x000008, "Wrong alignment on FLobbyCharacterInfo");
static_assert(sizeof(FLobbyCharacterInfo) == 0x0000C8, "Wrong size on FLobbyCharacterInfo");
static_assert(offsetof(FLobbyCharacterInfo, AccountId) == 0x000000, "Member 'FLobbyCharacterInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FLobbyCharacterInfo, AccountNickname) == 0x000010, "Member 'FLobbyCharacterInfo::AccountNickname' has a wrong offset!");
static_assert(offsetof(FLobbyCharacterInfo, Nickname) == 0x000020, "Member 'FLobbyCharacterInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FLobbyCharacterInfo, CharacterClass) == 0x000060, "Member 'FLobbyCharacterInfo::CharacterClass' has a wrong offset!");
static_assert(offsetof(FLobbyCharacterInfo, CharacterId) == 0x000070, "Member 'FLobbyCharacterInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FLobbyCharacterInfo, Gender) == 0x000080, "Member 'FLobbyCharacterInfo::Gender' has a wrong offset!");
static_assert(offsetof(FLobbyCharacterInfo, Level) == 0x000084, "Member 'FLobbyCharacterInfo::Level' has a wrong offset!");
static_assert(offsetof(FLobbyCharacterInfo, ServiceGrpc) == 0x000088, "Member 'FLobbyCharacterInfo::ServiceGrpc' has a wrong offset!");
static_assert(offsetof(FLobbyCharacterInfo, CharacterItemList) == 0x000098, "Member 'FLobbyCharacterInfo::CharacterItemList' has a wrong offset!");
static_assert(offsetof(FLobbyCharacterInfo, CharacterStorageItemList) == 0x0000A8, "Member 'FLobbyCharacterInfo::CharacterStorageItemList' has a wrong offset!");
static_assert(offsetof(FLobbyCharacterInfo, CharacterStorageInfos) == 0x0000B8, "Member 'FLobbyCharacterInfo::CharacterStorageInfos' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceItemRegisterResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMarketplaceItemRegisterResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FF5[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceItemRegisterResponse) == 0x000008, "Wrong alignment on FClientMsgMarketplaceItemRegisterResponse");
static_assert(sizeof(FClientMsgMarketplaceItemRegisterResponse) == 0x000020, "Wrong size on FClientMsgMarketplaceItemRegisterResponse");

// ScriptStruct DungeonCrawler.MsgInteractSucceed
// 0x0100 (0x0118 - 0x0018)
struct FMsgInteractSucceed final : public FMsgBase
{
public:
	class AActor*                                 Interacter;                                        // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StateTag;                                          // 0x0020(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TriggerTag;                                        // 0x0028(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0030(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgInteractSucceed) == 0x000008, "Wrong alignment on FMsgInteractSucceed");
static_assert(sizeof(FMsgInteractSucceed) == 0x000118, "Wrong size on FMsgInteractSucceed");
static_assert(offsetof(FMsgInteractSucceed, Interacter) == 0x000018, "Member 'FMsgInteractSucceed::Interacter' has a wrong offset!");
static_assert(offsetof(FMsgInteractSucceed, StateTag) == 0x000020, "Member 'FMsgInteractSucceed::StateTag' has a wrong offset!");
static_assert(offsetof(FMsgInteractSucceed, TriggerTag) == 0x000028, "Member 'FMsgInteractSucceed::TriggerTag' has a wrong offset!");
static_assert(offsetof(FMsgInteractSucceed, HitResult) == 0x000030, "Member 'FMsgInteractSucceed::HitResult' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassSkillListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgClassSkillListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FF6[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassSkillListRequest) == 0x000008, "Wrong alignment on FClientMsgClassSkillListRequest");
static_assert(sizeof(FClientMsgClassSkillListRequest) == 0x000028, "Wrong size on FClientMsgClassSkillListRequest");

// ScriptStruct DungeonCrawler.MsgWidgetExitCreateCharacterPageNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetExitCreateCharacterPageNotify final : public FMsgBase
{
public:
	uint8                                         Pad_1FF7[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetExitCreateCharacterPageNotify) == 0x000008, "Wrong alignment on FMsgWidgetExitCreateCharacterPageNotify");
static_assert(sizeof(FMsgWidgetExitCreateCharacterPageNotify) == 0x000020, "Wrong size on FMsgWidgetExitCreateCharacterPageNotify");

// ScriptStruct DungeonCrawler.ClientMsgClassLevelInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgClassLevelInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FF8[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassLevelInfoRequest) == 0x000008, "Wrong alignment on FClientMsgClassLevelInfoRequest");
static_assert(sizeof(FClientMsgClassLevelInfoRequest) == 0x000028, "Wrong size on FClientMsgClassLevelInfoRequest");

// ScriptStruct DungeonCrawler.MsgSlotItemDataRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgSlotItemDataRequest final : public FMsgBase
{
public:
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotId;                                            // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSlotItemDataRequest) == 0x000008, "Wrong alignment on FMsgSlotItemDataRequest");
static_assert(sizeof(FMsgSlotItemDataRequest) == 0x000020, "Wrong size on FMsgSlotItemDataRequest");
static_assert(offsetof(FMsgSlotItemDataRequest, InventoryId) == 0x000018, "Member 'FMsgSlotItemDataRequest::InventoryId' has a wrong offset!");
static_assert(offsetof(FMsgSlotItemDataRequest, SlotId) == 0x00001C, "Member 'FMsgSlotItemDataRequest::SlotId' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataGameplayAbility
// 0x0068 (0x0068 - 0x0000)
struct FDesignDataGameplayAbility final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AttackType;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayAbility>           Class;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Desc;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                MovementModifiers;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                GEModifiers;                                       // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataGameplayAbility) == 0x000008, "Wrong alignment on FDesignDataGameplayAbility");
static_assert(sizeof(FDesignDataGameplayAbility) == 0x000068, "Wrong size on FDesignDataGameplayAbility");
static_assert(offsetof(FDesignDataGameplayAbility, Name) == 0x000000, "Member 'FDesignDataGameplayAbility::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayAbility, AttackType) == 0x000018, "Member 'FDesignDataGameplayAbility::AttackType' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayAbility, Class) == 0x000020, "Member 'FDesignDataGameplayAbility::Class' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayAbility, Effects) == 0x000028, "Member 'FDesignDataGameplayAbility::Effects' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayAbility, Desc) == 0x000038, "Member 'FDesignDataGameplayAbility::Desc' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayAbility, MovementModifiers) == 0x000048, "Member 'FDesignDataGameplayAbility::MovementModifiers' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayAbility, GEModifiers) == 0x000058, "Member 'FDesignDataGameplayAbility::GEModifiers' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataProjectile
// 0x0068 (0x0068 - 0x0000)
struct FDesignDataProjectile final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SourceType;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AProjectileActor>           ActorClass;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataProjectile) == 0x000008, "Wrong alignment on FDesignDataProjectile");
static_assert(sizeof(FDesignDataProjectile) == 0x000068, "Wrong size on FDesignDataProjectile");
static_assert(offsetof(FDesignDataProjectile, Name) == 0x000000, "Member 'FDesignDataProjectile::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataProjectile, SourceType) == 0x000018, "Member 'FDesignDataProjectile::SourceType' has a wrong offset!");
static_assert(offsetof(FDesignDataProjectile, ArtData) == 0x000020, "Member 'FDesignDataProjectile::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataProjectile, SoundData) == 0x000030, "Member 'FDesignDataProjectile::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataProjectile, ActorClass) == 0x000040, "Member 'FDesignDataProjectile::ActorClass' has a wrong offset!");
static_assert(offsetof(FDesignDataProjectile, Abilities) == 0x000048, "Member 'FDesignDataProjectile::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataProjectile, Effects) == 0x000058, "Member 'FDesignDataProjectile::Effects' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataGameplayEffect
// 0x02A0 (0x02A0 - 0x0000)
struct FDesignDataGameplayEffect final
{
public:
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameplayEffectTargetType                     TargetType;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF9[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Duration;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StrengthBase;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StrengthMod;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VigorBase;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VigorMod;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgilityBase;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgilityMod;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DexterityBase;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DexterityMod;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WillBase;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WillMod;                                           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KnowledgeBase;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KnowledgeMod;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcefulnessBase;                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcefulnessMod;                                // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecDamageWeaponRatio;                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDamageWeapon;                              // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDamageBase;                                // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecPhysicalDamageBase;                            // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalPower;                                     // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDamageMod;                                 // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDamageAdd;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalDamageTrue;                                // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecPhysicalDamageTrue;                            // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalBackstabPower;                             // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalHeadshotPower;                             // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalHeadshotPenetration;                       // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmorPenetration;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecArmorPenetration;                              // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArmorRating;                                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemArmorRatingMod;                                // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalReduction;                                 // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalReductionMod;                              // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalAbsoluteReduction;                         // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDamageWeapon;                               // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDamageBase;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecMagicalDamageBase;                             // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalPower;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDamageMod;                                  // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDamageAdd;                                  // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDamageTrue;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecMagicalDamageTrue;                             // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicPenetration;                                  // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecMagicPenetration;                              // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalFireDamageBase;                             // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalFireDamageMod;                              // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalFireDamageAdd;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalIceDamageBase;                              // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalIceDamageMod;                               // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalIceDamageAdd;                               // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalArcaneDamageBase;                           // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalArcaneDamageMod;                            // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalArcaneDamageAdd;                            // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDarkDamageBase;                             // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDarkDamageMod;                              // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDarkDamageAdd;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDivineDamageBase;                           // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDivineDamageMod;                            // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalDivineDamageAdd;                            // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalSpiritDamageBase;                           // 0x0100(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalSpiritDamageMod;                            // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalSpiritDamageAdd;                            // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UndeadDamageMod;                                   // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicResistance;                                   // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalReduction;                                  // 0x0114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalReductionMod;                               // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalAbsoluteReduction;                          // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireMagicResistance;                               // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireMagicalReduction;                              // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireMagicalReductionMod;                           // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IceMagicResistance;                                // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IceMagicalReduction;                               // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IceMagicalReductionMod;                            // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightningMagicResistance;                          // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightningMagicalReduction;                         // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightningMagicalReductionMod;                      // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EarthMagicResistance;                              // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EarthMagicalReduction;                             // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EarthMagicalReductionMod;                          // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMagicResistance;                              // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMagicalReduction;                             // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMagicalReductionMod;                          // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DarkMagicResistance;                               // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DarkMagicalReduction;                              // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DarkMagicalReductionMod;                           // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArcaneMagicResistance;                             // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArcaneMagicalReduction;                            // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArcaneMagicalReductionMod;                         // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivineMagicResistance;                             // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivineMagicalReduction;                            // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DivineMagicalReductionMod;                         // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvilMagicResistance;                               // 0x0180(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvilMagicalReduction;                              // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EvilMagicalReductionMod;                           // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirMagicResistance;                                // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirMagicalReduction;                               // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirMagicalReductionMod;                            // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpiritMagicResistance;                             // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpiritMagicalReduction;                            // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpiritMagicalReductionMod;                         // 0x01A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeadshotReductionMod;                              // 0x01A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileReductionMod;                            // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UndeadReductionMod;                                // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DemonReductionMod;                                 // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImpactPower;                                       // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecImpactPower;                                   // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecImpactEnduranceRestore;                        // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ImpactResistance;                                  // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxImpactEndurance;                                // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecAddHealthByCurHealthRatio;                     // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecAddHealthByMaxHealthRatio;                     // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecAddRecoverableHealth;                          // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalHealBase;                                  // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecPhysicalHealBase;                              // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalHealMod;                                   // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhysicalHealingReceiveMod;                         // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalHealBase;                                   // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecMagicalHealBase;                               // 0x01E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalHealMod;                                    // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalHealingReceiveMod;                          // 0x01F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecRecoveryHealBase;                              // 0x01F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHealthMod;                                      // 0x01F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHealthAdd;                                      // 0x01FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddtionalAggroMod;                                 // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPhysicalShield;                                 // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMagicalShield;                                  // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTotalShield;                                    // 0x020C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemoryCapacityMod;                                 // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemoryCapacityAdd;                                 // 0x0214(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpellCountMod;                                  // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveSpeedBase;                                     // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveSpeedMod;                                      // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveSpeedAdd;                                      // 0x0224(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoveSpeedArmorPenaltyMod;                          // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActionSpeed;                                       // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpellCastingSpeed;                                 // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemEquipSpeed;                                    // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RegularInteractionSpeed;                           // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagicalInteractionSpeed;                           // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffDurationMod;                                   // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebuffDurationMod;                                 // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CooldownReductionMod;                              // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UtilityEffectivenessMod;                           // 0x024C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UtilityEffectivenessAdd;                           // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeightLimitMod;                                    // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeightLimitAdd;                                    // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Luck;                                              // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ManualDexterity;                                   // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Persuasiveness;                                    // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PersuasivenessBonusRatio;                          // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecAttributeBonusRatio;                           // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecHealthCost;                                    // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecColdness;                                      // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecPrimitiveCalcAdd;                              // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExecPrimitiveCalcMultiply;                         // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   GrantedTags;                                       // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   AssetTags;                                         // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataGameplayEffect) == 0x000008, "Wrong alignment on FDesignDataGameplayEffect");
static_assert(sizeof(FDesignDataGameplayEffect) == 0x0002A0, "Wrong size on FDesignDataGameplayEffect");
static_assert(offsetof(FDesignDataGameplayEffect, EffectClass) == 0x000000, "Member 'FDesignDataGameplayEffect::EffectClass' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, EventTag) == 0x000008, "Member 'FDesignDataGameplayEffect::EventTag' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, TargetType) == 0x000010, "Member 'FDesignDataGameplayEffect::TargetType' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, Duration) == 0x000014, "Member 'FDesignDataGameplayEffect::Duration' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, StrengthBase) == 0x000018, "Member 'FDesignDataGameplayEffect::StrengthBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, StrengthMod) == 0x00001C, "Member 'FDesignDataGameplayEffect::StrengthMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, VigorBase) == 0x000020, "Member 'FDesignDataGameplayEffect::VigorBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, VigorMod) == 0x000024, "Member 'FDesignDataGameplayEffect::VigorMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, AgilityBase) == 0x000028, "Member 'FDesignDataGameplayEffect::AgilityBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, AgilityMod) == 0x00002C, "Member 'FDesignDataGameplayEffect::AgilityMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, DexterityBase) == 0x000030, "Member 'FDesignDataGameplayEffect::DexterityBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, DexterityMod) == 0x000034, "Member 'FDesignDataGameplayEffect::DexterityMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, WillBase) == 0x000038, "Member 'FDesignDataGameplayEffect::WillBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, WillMod) == 0x00003C, "Member 'FDesignDataGameplayEffect::WillMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, KnowledgeBase) == 0x000040, "Member 'FDesignDataGameplayEffect::KnowledgeBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, KnowledgeMod) == 0x000044, "Member 'FDesignDataGameplayEffect::KnowledgeMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ResourcefulnessBase) == 0x000048, "Member 'FDesignDataGameplayEffect::ResourcefulnessBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ResourcefulnessMod) == 0x00004C, "Member 'FDesignDataGameplayEffect::ResourcefulnessMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecDamageWeaponRatio) == 0x000050, "Member 'FDesignDataGameplayEffect::ExecDamageWeaponRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalDamageWeapon) == 0x000054, "Member 'FDesignDataGameplayEffect::PhysicalDamageWeapon' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalDamageBase) == 0x000058, "Member 'FDesignDataGameplayEffect::PhysicalDamageBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecPhysicalDamageBase) == 0x00005C, "Member 'FDesignDataGameplayEffect::ExecPhysicalDamageBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalPower) == 0x000060, "Member 'FDesignDataGameplayEffect::PhysicalPower' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalDamageMod) == 0x000064, "Member 'FDesignDataGameplayEffect::PhysicalDamageMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalDamageAdd) == 0x000068, "Member 'FDesignDataGameplayEffect::PhysicalDamageAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalDamageTrue) == 0x00006C, "Member 'FDesignDataGameplayEffect::PhysicalDamageTrue' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecPhysicalDamageTrue) == 0x000070, "Member 'FDesignDataGameplayEffect::ExecPhysicalDamageTrue' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalBackstabPower) == 0x000074, "Member 'FDesignDataGameplayEffect::PhysicalBackstabPower' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalHeadshotPower) == 0x000078, "Member 'FDesignDataGameplayEffect::PhysicalHeadshotPower' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalHeadshotPenetration) == 0x00007C, "Member 'FDesignDataGameplayEffect::PhysicalHeadshotPenetration' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ArmorPenetration) == 0x000080, "Member 'FDesignDataGameplayEffect::ArmorPenetration' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecArmorPenetration) == 0x000084, "Member 'FDesignDataGameplayEffect::ExecArmorPenetration' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ArmorRating) == 0x000088, "Member 'FDesignDataGameplayEffect::ArmorRating' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ItemArmorRatingMod) == 0x00008C, "Member 'FDesignDataGameplayEffect::ItemArmorRatingMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalReduction) == 0x000090, "Member 'FDesignDataGameplayEffect::PhysicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalReductionMod) == 0x000094, "Member 'FDesignDataGameplayEffect::PhysicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalAbsoluteReduction) == 0x000098, "Member 'FDesignDataGameplayEffect::PhysicalAbsoluteReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDamageWeapon) == 0x00009C, "Member 'FDesignDataGameplayEffect::MagicalDamageWeapon' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDamageBase) == 0x0000A0, "Member 'FDesignDataGameplayEffect::MagicalDamageBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecMagicalDamageBase) == 0x0000A4, "Member 'FDesignDataGameplayEffect::ExecMagicalDamageBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalPower) == 0x0000A8, "Member 'FDesignDataGameplayEffect::MagicalPower' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDamageMod) == 0x0000AC, "Member 'FDesignDataGameplayEffect::MagicalDamageMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDamageAdd) == 0x0000B0, "Member 'FDesignDataGameplayEffect::MagicalDamageAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDamageTrue) == 0x0000B4, "Member 'FDesignDataGameplayEffect::MagicalDamageTrue' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecMagicalDamageTrue) == 0x0000B8, "Member 'FDesignDataGameplayEffect::ExecMagicalDamageTrue' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicPenetration) == 0x0000BC, "Member 'FDesignDataGameplayEffect::MagicPenetration' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecMagicPenetration) == 0x0000C0, "Member 'FDesignDataGameplayEffect::ExecMagicPenetration' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalFireDamageBase) == 0x0000C4, "Member 'FDesignDataGameplayEffect::MagicalFireDamageBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalFireDamageMod) == 0x0000C8, "Member 'FDesignDataGameplayEffect::MagicalFireDamageMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalFireDamageAdd) == 0x0000CC, "Member 'FDesignDataGameplayEffect::MagicalFireDamageAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalIceDamageBase) == 0x0000D0, "Member 'FDesignDataGameplayEffect::MagicalIceDamageBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalIceDamageMod) == 0x0000D4, "Member 'FDesignDataGameplayEffect::MagicalIceDamageMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalIceDamageAdd) == 0x0000D8, "Member 'FDesignDataGameplayEffect::MagicalIceDamageAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalArcaneDamageBase) == 0x0000DC, "Member 'FDesignDataGameplayEffect::MagicalArcaneDamageBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalArcaneDamageMod) == 0x0000E0, "Member 'FDesignDataGameplayEffect::MagicalArcaneDamageMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalArcaneDamageAdd) == 0x0000E4, "Member 'FDesignDataGameplayEffect::MagicalArcaneDamageAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDarkDamageBase) == 0x0000E8, "Member 'FDesignDataGameplayEffect::MagicalDarkDamageBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDarkDamageMod) == 0x0000EC, "Member 'FDesignDataGameplayEffect::MagicalDarkDamageMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDarkDamageAdd) == 0x0000F0, "Member 'FDesignDataGameplayEffect::MagicalDarkDamageAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDivineDamageBase) == 0x0000F4, "Member 'FDesignDataGameplayEffect::MagicalDivineDamageBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDivineDamageMod) == 0x0000F8, "Member 'FDesignDataGameplayEffect::MagicalDivineDamageMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalDivineDamageAdd) == 0x0000FC, "Member 'FDesignDataGameplayEffect::MagicalDivineDamageAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalSpiritDamageBase) == 0x000100, "Member 'FDesignDataGameplayEffect::MagicalSpiritDamageBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalSpiritDamageMod) == 0x000104, "Member 'FDesignDataGameplayEffect::MagicalSpiritDamageMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalSpiritDamageAdd) == 0x000108, "Member 'FDesignDataGameplayEffect::MagicalSpiritDamageAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, UndeadDamageMod) == 0x00010C, "Member 'FDesignDataGameplayEffect::UndeadDamageMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicResistance) == 0x000110, "Member 'FDesignDataGameplayEffect::MagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalReduction) == 0x000114, "Member 'FDesignDataGameplayEffect::MagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalReductionMod) == 0x000118, "Member 'FDesignDataGameplayEffect::MagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalAbsoluteReduction) == 0x00011C, "Member 'FDesignDataGameplayEffect::MagicalAbsoluteReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, FireMagicResistance) == 0x000120, "Member 'FDesignDataGameplayEffect::FireMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, FireMagicalReduction) == 0x000124, "Member 'FDesignDataGameplayEffect::FireMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, FireMagicalReductionMod) == 0x000128, "Member 'FDesignDataGameplayEffect::FireMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, IceMagicResistance) == 0x00012C, "Member 'FDesignDataGameplayEffect::IceMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, IceMagicalReduction) == 0x000130, "Member 'FDesignDataGameplayEffect::IceMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, IceMagicalReductionMod) == 0x000134, "Member 'FDesignDataGameplayEffect::IceMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, LightningMagicResistance) == 0x000138, "Member 'FDesignDataGameplayEffect::LightningMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, LightningMagicalReduction) == 0x00013C, "Member 'FDesignDataGameplayEffect::LightningMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, LightningMagicalReductionMod) == 0x000140, "Member 'FDesignDataGameplayEffect::LightningMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, EarthMagicResistance) == 0x000144, "Member 'FDesignDataGameplayEffect::EarthMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, EarthMagicalReduction) == 0x000148, "Member 'FDesignDataGameplayEffect::EarthMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, EarthMagicalReductionMod) == 0x00014C, "Member 'FDesignDataGameplayEffect::EarthMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, LightMagicResistance) == 0x000150, "Member 'FDesignDataGameplayEffect::LightMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, LightMagicalReduction) == 0x000154, "Member 'FDesignDataGameplayEffect::LightMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, LightMagicalReductionMod) == 0x000158, "Member 'FDesignDataGameplayEffect::LightMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, DarkMagicResistance) == 0x00015C, "Member 'FDesignDataGameplayEffect::DarkMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, DarkMagicalReduction) == 0x000160, "Member 'FDesignDataGameplayEffect::DarkMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, DarkMagicalReductionMod) == 0x000164, "Member 'FDesignDataGameplayEffect::DarkMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ArcaneMagicResistance) == 0x000168, "Member 'FDesignDataGameplayEffect::ArcaneMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ArcaneMagicalReduction) == 0x00016C, "Member 'FDesignDataGameplayEffect::ArcaneMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ArcaneMagicalReductionMod) == 0x000170, "Member 'FDesignDataGameplayEffect::ArcaneMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, DivineMagicResistance) == 0x000174, "Member 'FDesignDataGameplayEffect::DivineMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, DivineMagicalReduction) == 0x000178, "Member 'FDesignDataGameplayEffect::DivineMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, DivineMagicalReductionMod) == 0x00017C, "Member 'FDesignDataGameplayEffect::DivineMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, EvilMagicResistance) == 0x000180, "Member 'FDesignDataGameplayEffect::EvilMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, EvilMagicalReduction) == 0x000184, "Member 'FDesignDataGameplayEffect::EvilMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, EvilMagicalReductionMod) == 0x000188, "Member 'FDesignDataGameplayEffect::EvilMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, AirMagicResistance) == 0x00018C, "Member 'FDesignDataGameplayEffect::AirMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, AirMagicalReduction) == 0x000190, "Member 'FDesignDataGameplayEffect::AirMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, AirMagicalReductionMod) == 0x000194, "Member 'FDesignDataGameplayEffect::AirMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, SpiritMagicResistance) == 0x000198, "Member 'FDesignDataGameplayEffect::SpiritMagicResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, SpiritMagicalReduction) == 0x00019C, "Member 'FDesignDataGameplayEffect::SpiritMagicalReduction' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, SpiritMagicalReductionMod) == 0x0001A0, "Member 'FDesignDataGameplayEffect::SpiritMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, HeadshotReductionMod) == 0x0001A4, "Member 'FDesignDataGameplayEffect::HeadshotReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ProjectileReductionMod) == 0x0001A8, "Member 'FDesignDataGameplayEffect::ProjectileReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, UndeadReductionMod) == 0x0001AC, "Member 'FDesignDataGameplayEffect::UndeadReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, DemonReductionMod) == 0x0001B0, "Member 'FDesignDataGameplayEffect::DemonReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ImpactPower) == 0x0001B4, "Member 'FDesignDataGameplayEffect::ImpactPower' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecImpactPower) == 0x0001B8, "Member 'FDesignDataGameplayEffect::ExecImpactPower' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecImpactEnduranceRestore) == 0x0001BC, "Member 'FDesignDataGameplayEffect::ExecImpactEnduranceRestore' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ImpactResistance) == 0x0001C0, "Member 'FDesignDataGameplayEffect::ImpactResistance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MaxImpactEndurance) == 0x0001C4, "Member 'FDesignDataGameplayEffect::MaxImpactEndurance' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecAddHealthByCurHealthRatio) == 0x0001C8, "Member 'FDesignDataGameplayEffect::ExecAddHealthByCurHealthRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecAddHealthByMaxHealthRatio) == 0x0001CC, "Member 'FDesignDataGameplayEffect::ExecAddHealthByMaxHealthRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecAddRecoverableHealth) == 0x0001D0, "Member 'FDesignDataGameplayEffect::ExecAddRecoverableHealth' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalHealBase) == 0x0001D4, "Member 'FDesignDataGameplayEffect::PhysicalHealBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecPhysicalHealBase) == 0x0001D8, "Member 'FDesignDataGameplayEffect::ExecPhysicalHealBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalHealMod) == 0x0001DC, "Member 'FDesignDataGameplayEffect::PhysicalHealMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PhysicalHealingReceiveMod) == 0x0001E0, "Member 'FDesignDataGameplayEffect::PhysicalHealingReceiveMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalHealBase) == 0x0001E4, "Member 'FDesignDataGameplayEffect::MagicalHealBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecMagicalHealBase) == 0x0001E8, "Member 'FDesignDataGameplayEffect::ExecMagicalHealBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalHealMod) == 0x0001EC, "Member 'FDesignDataGameplayEffect::MagicalHealMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalHealingReceiveMod) == 0x0001F0, "Member 'FDesignDataGameplayEffect::MagicalHealingReceiveMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecRecoveryHealBase) == 0x0001F4, "Member 'FDesignDataGameplayEffect::ExecRecoveryHealBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MaxHealthMod) == 0x0001F8, "Member 'FDesignDataGameplayEffect::MaxHealthMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MaxHealthAdd) == 0x0001FC, "Member 'FDesignDataGameplayEffect::MaxHealthAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, AddtionalAggroMod) == 0x000200, "Member 'FDesignDataGameplayEffect::AddtionalAggroMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MaxPhysicalShield) == 0x000204, "Member 'FDesignDataGameplayEffect::MaxPhysicalShield' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MaxMagicalShield) == 0x000208, "Member 'FDesignDataGameplayEffect::MaxMagicalShield' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MaxTotalShield) == 0x00020C, "Member 'FDesignDataGameplayEffect::MaxTotalShield' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MemoryCapacityMod) == 0x000210, "Member 'FDesignDataGameplayEffect::MemoryCapacityMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MemoryCapacityAdd) == 0x000214, "Member 'FDesignDataGameplayEffect::MemoryCapacityAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MaxSpellCountMod) == 0x000218, "Member 'FDesignDataGameplayEffect::MaxSpellCountMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MoveSpeedBase) == 0x00021C, "Member 'FDesignDataGameplayEffect::MoveSpeedBase' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MoveSpeedMod) == 0x000220, "Member 'FDesignDataGameplayEffect::MoveSpeedMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MoveSpeedAdd) == 0x000224, "Member 'FDesignDataGameplayEffect::MoveSpeedAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MoveSpeedArmorPenaltyMod) == 0x000228, "Member 'FDesignDataGameplayEffect::MoveSpeedArmorPenaltyMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ActionSpeed) == 0x00022C, "Member 'FDesignDataGameplayEffect::ActionSpeed' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, SpellCastingSpeed) == 0x000230, "Member 'FDesignDataGameplayEffect::SpellCastingSpeed' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ItemEquipSpeed) == 0x000234, "Member 'FDesignDataGameplayEffect::ItemEquipSpeed' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, RegularInteractionSpeed) == 0x000238, "Member 'FDesignDataGameplayEffect::RegularInteractionSpeed' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, MagicalInteractionSpeed) == 0x00023C, "Member 'FDesignDataGameplayEffect::MagicalInteractionSpeed' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, BuffDurationMod) == 0x000240, "Member 'FDesignDataGameplayEffect::BuffDurationMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, DebuffDurationMod) == 0x000244, "Member 'FDesignDataGameplayEffect::DebuffDurationMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, CooldownReductionMod) == 0x000248, "Member 'FDesignDataGameplayEffect::CooldownReductionMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, UtilityEffectivenessMod) == 0x00024C, "Member 'FDesignDataGameplayEffect::UtilityEffectivenessMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, UtilityEffectivenessAdd) == 0x000250, "Member 'FDesignDataGameplayEffect::UtilityEffectivenessAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, WeightLimitMod) == 0x000254, "Member 'FDesignDataGameplayEffect::WeightLimitMod' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, WeightLimitAdd) == 0x000258, "Member 'FDesignDataGameplayEffect::WeightLimitAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, Luck) == 0x00025C, "Member 'FDesignDataGameplayEffect::Luck' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ManualDexterity) == 0x000260, "Member 'FDesignDataGameplayEffect::ManualDexterity' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, Persuasiveness) == 0x000264, "Member 'FDesignDataGameplayEffect::Persuasiveness' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, PersuasivenessBonusRatio) == 0x000268, "Member 'FDesignDataGameplayEffect::PersuasivenessBonusRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecAttributeBonusRatio) == 0x00026C, "Member 'FDesignDataGameplayEffect::ExecAttributeBonusRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecHealthCost) == 0x000270, "Member 'FDesignDataGameplayEffect::ExecHealthCost' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecColdness) == 0x000274, "Member 'FDesignDataGameplayEffect::ExecColdness' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecPrimitiveCalcAdd) == 0x000278, "Member 'FDesignDataGameplayEffect::ExecPrimitiveCalcAdd' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, ExecPrimitiveCalcMultiply) == 0x00027C, "Member 'FDesignDataGameplayEffect::ExecPrimitiveCalcMultiply' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, GrantedTags) == 0x000280, "Member 'FDesignDataGameplayEffect::GrantedTags' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayEffect, AssetTags) == 0x000290, "Member 'FDesignDataGameplayEffect::AssetTags' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataProjectileTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataProjectileTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataProjectile> Projectile;                                        // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> ProjectileAbility;                                 // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> ProjectileEffect;                                  // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataProjectileTableRow) == 0x000008, "Wrong alignment on FDesignDataProjectileTableRow");
static_assert(sizeof(FDesignDataProjectileTableRow) == 0x0000F8, "Wrong size on FDesignDataProjectileTableRow");
static_assert(offsetof(FDesignDataProjectileTableRow, Projectile) == 0x000008, "Member 'FDesignDataProjectileTableRow::Projectile' has a wrong offset!");
static_assert(offsetof(FDesignDataProjectileTableRow, ProjectileAbility) == 0x000058, "Member 'FDesignDataProjectileTableRow::ProjectileAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataProjectileTableRow, ProjectileEffect) == 0x0000A8, "Member 'FDesignDataProjectileTableRow::ProjectileEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataBaseItemItem
// 0x0018 (0x0018 - 0x0000)
struct FDesignDataBaseItemItem final
{
public:
	struct FPrimaryAssetId                        BaseItemId;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseItemCount;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCEquipmentSlotIndex                         BaseItemSlot;                                      // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FFA[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataBaseItemItem) == 0x000004, "Wrong alignment on FDesignDataBaseItemItem");
static_assert(sizeof(FDesignDataBaseItemItem) == 0x000018, "Wrong size on FDesignDataBaseItemItem");
static_assert(offsetof(FDesignDataBaseItemItem, BaseItemId) == 0x000000, "Member 'FDesignDataBaseItemItem::BaseItemId' has a wrong offset!");
static_assert(offsetof(FDesignDataBaseItemItem, BaseItemCount) == 0x000010, "Member 'FDesignDataBaseItemItem::BaseItemCount' has a wrong offset!");
static_assert(offsetof(FDesignDataBaseItemItem, BaseItemSlot) == 0x000014, "Member 'FDesignDataBaseItemItem::BaseItemSlot' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataBaseItem
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataBaseItem final
{
public:
	TArray<struct FDesignDataBaseItemItem>        BaseItemItemArray;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataBaseItem) == 0x000008, "Wrong alignment on FDesignDataBaseItem");
static_assert(sizeof(FDesignDataBaseItem) == 0x000010, "Wrong size on FDesignDataBaseItem");
static_assert(offsetof(FDesignDataBaseItem, BaseItemItemArray) == 0x000000, "Member 'FDesignDataBaseItem::BaseItemItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMerchantSaleItemId
// 0x0000 (0x0008 - 0x0008)
struct FDCMerchantSaleItemId final : public FDCInt64IdBase
{
};
static_assert(alignof(FDCMerchantSaleItemId) == 0x000008, "Wrong alignment on FDCMerchantSaleItemId");
static_assert(sizeof(FDCMerchantSaleItemId) == 0x000008, "Wrong size on FDCMerchantSaleItemId");

// ScriptStruct DungeonCrawler.DCMerchantWishItemId
// 0x0000 (0x0008 - 0x0008)
struct FDCMerchantWishItemId final : public FDCInt64IdBase
{
};
static_assert(alignof(FDCMerchantWishItemId) == 0x000008, "Wrong alignment on FDCMerchantWishItemId");
static_assert(sizeof(FDCMerchantWishItemId) == 0x000008, "Wrong size on FDCMerchantWishItemId");

// ScriptStruct DungeonCrawler.DCMerchantCraftItemId
// 0x0000 (0x0008 - 0x0008)
struct FDCMerchantCraftItemId final : public FDCInt64IdBase
{
};
static_assert(alignof(FDCMerchantCraftItemId) == 0x000008, "Wrong alignment on FDCMerchantCraftItemId");
static_assert(sizeof(FDCMerchantCraftItemId) == 0x000008, "Wrong size on FDCMerchantCraftItemId");

// ScriptStruct DungeonCrawler.DCMerchantBaseGearItemId
// 0x0000 (0x0008 - 0x0008)
struct FDCMerchantBaseGearItemId final : public FDCInt64IdBase
{
};
static_assert(alignof(FDCMerchantBaseGearItemId) == 0x000008, "Wrong alignment on FDCMerchantBaseGearItemId");
static_assert(sizeof(FDCMerchantBaseGearItemId) == 0x000008, "Wrong size on FDCMerchantBaseGearItemId");

// ScriptStruct DungeonCrawler.DCMerchantAssetManager
// 0x01E0 (0x01E0 - 0x0000)
struct FDCMerchantAssetManager final
{
public:
	TMap<struct FDCMerchantSaleItemId, class UDCStockBuyDataAsset*> SaleDataAssets;                                    // 0x0000(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCMerchantWishItemId, class UDCStockSellBackDataAsset*> WishDataAssets;                                    // 0x0050(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCMerchantCraftItemId, class UDCStockCraftDataAsset*> CraftDataAssets;                                   // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FDCMerchantBaseGearItemId, class UDCBaseGearDataAsset*> BaseGearDataAssets;                                // 0x00F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCMerchantWishItemId> WishListItemDataAssetIds;                          // 0x0140(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCMerchantBaseGearItemId> BaseGearListItemDataAssetIds;                      // 0x0190(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCMerchantAssetManager) == 0x000008, "Wrong alignment on FDCMerchantAssetManager");
static_assert(sizeof(FDCMerchantAssetManager) == 0x0001E0, "Wrong size on FDCMerchantAssetManager");
static_assert(offsetof(FDCMerchantAssetManager, SaleDataAssets) == 0x000000, "Member 'FDCMerchantAssetManager::SaleDataAssets' has a wrong offset!");
static_assert(offsetof(FDCMerchantAssetManager, WishDataAssets) == 0x000050, "Member 'FDCMerchantAssetManager::WishDataAssets' has a wrong offset!");
static_assert(offsetof(FDCMerchantAssetManager, CraftDataAssets) == 0x0000A0, "Member 'FDCMerchantAssetManager::CraftDataAssets' has a wrong offset!");
static_assert(offsetof(FDCMerchantAssetManager, BaseGearDataAssets) == 0x0000F0, "Member 'FDCMerchantAssetManager::BaseGearDataAssets' has a wrong offset!");
static_assert(offsetof(FDCMerchantAssetManager, WishListItemDataAssetIds) == 0x000140, "Member 'FDCMerchantAssetManager::WishListItemDataAssetIds' has a wrong offset!");
static_assert(offsetof(FDCMerchantAssetManager, BaseGearListItemDataAssetIds) == 0x000190, "Member 'FDCMerchantAssetManager::BaseGearListItemDataAssetIds' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyEquipItemChangeNotify
// 0x0040 (0x0058 - 0x0018)
struct FClientMsgPartyEquipItemChangeNotify final : public FMsgBase
{
public:
	uint8                                         Pad_1FFB[0x40];                                    // 0x0018(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyEquipItemChangeNotify) == 0x000008, "Wrong alignment on FClientMsgPartyEquipItemChangeNotify");
static_assert(sizeof(FClientMsgPartyEquipItemChangeNotify) == 0x000058, "Wrong size on FClientMsgPartyEquipItemChangeNotify");

// ScriptStruct DungeonCrawler.ObjectLinkMetaData
// 0x0058 (0x0058 - 0x0000)
struct FObjectLinkMetaData final
{
public:
	struct FGameplayTagQuery                      MetaDataTagQuery;                                  // 0x0000(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class AActor*                                 MetaDataActor;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetaDataFloat;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FFC[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectLinkMetaData) == 0x000008, "Wrong alignment on FObjectLinkMetaData");
static_assert(sizeof(FObjectLinkMetaData) == 0x000058, "Wrong size on FObjectLinkMetaData");
static_assert(offsetof(FObjectLinkMetaData, MetaDataTagQuery) == 0x000000, "Member 'FObjectLinkMetaData::MetaDataTagQuery' has a wrong offset!");
static_assert(offsetof(FObjectLinkMetaData, MetaDataActor) == 0x000048, "Member 'FObjectLinkMetaData::MetaDataActor' has a wrong offset!");
static_assert(offsetof(FObjectLinkMetaData, MetaDataFloat) == 0x000050, "Member 'FObjectLinkMetaData::MetaDataFloat' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataGEModifier
// 0x0028 (0x0028 - 0x0000)
struct FDesignDataGEModifier final
{
public:
	struct FGameplayTag                           TargetGameplayEffectTag;                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetRequiredStateTag;                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetType;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EffectType;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Add;                                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiply;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataGEModifier) == 0x000004, "Wrong alignment on FDesignDataGEModifier");
static_assert(sizeof(FDesignDataGEModifier) == 0x000028, "Wrong size on FDesignDataGEModifier");
static_assert(offsetof(FDesignDataGEModifier, TargetGameplayEffectTag) == 0x000000, "Member 'FDesignDataGEModifier::TargetGameplayEffectTag' has a wrong offset!");
static_assert(offsetof(FDesignDataGEModifier, TargetRequiredStateTag) == 0x000008, "Member 'FDesignDataGEModifier::TargetRequiredStateTag' has a wrong offset!");
static_assert(offsetof(FDesignDataGEModifier, TargetType) == 0x000010, "Member 'FDesignDataGEModifier::TargetType' has a wrong offset!");
static_assert(offsetof(FDesignDataGEModifier, EffectType) == 0x000018, "Member 'FDesignDataGEModifier::EffectType' has a wrong offset!");
static_assert(offsetof(FDesignDataGEModifier, Add) == 0x000020, "Member 'FDesignDataGEModifier::Add' has a wrong offset!");
static_assert(offsetof(FDesignDataGEModifier, Multiply) == 0x000024, "Member 'FDesignDataGEModifier::Multiply' has a wrong offset!");

// ScriptStruct DungeonCrawler.EmptySlotInfoArray
// 0x0010 (0x0010 - 0x0000)
struct FEmptySlotInfoArray final
{
public:
	TArray<struct FEmptySlotInfo>                 Values;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmptySlotInfoArray) == 0x000008, "Wrong alignment on FEmptySlotInfoArray");
static_assert(sizeof(FEmptySlotInfoArray) == 0x000010, "Wrong size on FEmptySlotInfoArray");
static_assert(offsetof(FEmptySlotInfoArray, Values) == 0x000000, "Member 'FEmptySlotInfoArray::Values' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgRefreshRedStoneShardResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgRefreshRedStoneShardResponse final : public FMsgBase
{
public:
	uint8                                         Pad_1FFD[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRefreshRedStoneShardResponse) == 0x000008, "Wrong alignment on FClientMsgRefreshRedStoneShardResponse");
static_assert(sizeof(FClientMsgRefreshRedStoneShardResponse) == 0x000020, "Wrong size on FClientMsgRefreshRedStoneShardResponse");

// ScriptStruct DungeonCrawler.SlotInfo
// 0x0010 (0x0010 - 0x0000)
struct FSlotInfo final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Row;                                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ItemUniqueId;                                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlotInfo) == 0x000008, "Wrong alignment on FSlotInfo");
static_assert(sizeof(FSlotInfo) == 0x000010, "Wrong size on FSlotInfo");
static_assert(offsetof(FSlotInfo, Index) == 0x000000, "Member 'FSlotInfo::Index' has a wrong offset!");
static_assert(offsetof(FSlotInfo, Row) == 0x000004, "Member 'FSlotInfo::Row' has a wrong offset!");
static_assert(offsetof(FSlotInfo, ItemUniqueId) == 0x000008, "Member 'FSlotInfo::ItemUniqueId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ComboTriggerStep
// 0x0010 (0x0010 - 0x0000)
struct FComboTriggerStep final
{
public:
	class UInputAction*                           DependentAction;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationThreshold;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FFE[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FComboTriggerStep) == 0x000008, "Wrong alignment on FComboTriggerStep");
static_assert(sizeof(FComboTriggerStep) == 0x000010, "Wrong size on FComboTriggerStep");
static_assert(offsetof(FComboTriggerStep, DependentAction) == 0x000000, "Member 'FComboTriggerStep::DependentAction' has a wrong offset!");
static_assert(offsetof(FComboTriggerStep, ActivationThreshold) == 0x000008, "Member 'FComboTriggerStep::ActivationThreshold' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgLobbyGameTypeSelectRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgLobbyGameTypeSelectRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_1FFF[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyGameTypeSelectRequest) == 0x000008, "Wrong alignment on FClientMsgLobbyGameTypeSelectRequest");
static_assert(sizeof(FClientMsgLobbyGameTypeSelectRequest) == 0x000028, "Wrong size on FClientMsgLobbyGameTypeSelectRequest");

// ScriptStruct DungeonCrawler.MsgLobbyCharacterInfoNotify
// 0x00D0 (0x00E8 - 0x0018)
struct FMsgLobbyCharacterInfoNotify final : public FMsgBase
{
public:
	EWidgetPartyUserLocate                        WidgetPartyUserLocate;                             // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2000[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLobbyCharacterInfo                    LobbyCharacterData;                                // 0x0020(0x00C8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgLobbyCharacterInfoNotify) == 0x000008, "Wrong alignment on FMsgLobbyCharacterInfoNotify");
static_assert(sizeof(FMsgLobbyCharacterInfoNotify) == 0x0000E8, "Wrong size on FMsgLobbyCharacterInfoNotify");
static_assert(offsetof(FMsgLobbyCharacterInfoNotify, WidgetPartyUserLocate) == 0x000018, "Member 'FMsgLobbyCharacterInfoNotify::WidgetPartyUserLocate' has a wrong offset!");
static_assert(offsetof(FMsgLobbyCharacterInfoNotify, LobbyCharacterData) == 0x000020, "Member 'FMsgLobbyCharacterInfoNotify::LobbyCharacterData' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataGameplayEffect
// 0x0020 (0x0020 - 0x0000)
struct FAccountDataGameplayEffect final
{
public:
	class FString                                 EffectId;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataGameplayEffectValue> SelfEffectValueArray;                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataGameplayEffect) == 0x000008, "Wrong alignment on FAccountDataGameplayEffect");
static_assert(sizeof(FAccountDataGameplayEffect) == 0x000020, "Wrong size on FAccountDataGameplayEffect");
static_assert(offsetof(FAccountDataGameplayEffect, EffectId) == 0x000000, "Member 'FAccountDataGameplayEffect::EffectId' has a wrong offset!");
static_assert(offsetof(FAccountDataGameplayEffect, SelfEffectValueArray) == 0x000010, "Member 'FAccountDataGameplayEffect::SelfEffectValueArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantRecoveryCheckResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMerchantRecoveryCheckResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2001[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantRecoveryCheckResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantRecoveryCheckResponse");
static_assert(sizeof(FClientMsgMerchantRecoveryCheckResponse) == 0x000020, "Wrong size on FClientMsgMerchantRecoveryCheckResponse");

// ScriptStruct DungeonCrawler.ClientMsgWhisperChatRequest
// 0x0090 (0x00B0 - 0x0020)
struct FClientMsgWhisperChatRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2002[0x90];                                    // 0x0020(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgWhisperChatRequest) == 0x000008, "Wrong alignment on FClientMsgWhisperChatRequest");
static_assert(sizeof(FClientMsgWhisperChatRequest) == 0x0000B0, "Wrong size on FClientMsgWhisperChatRequest");

// ScriptStruct DungeonCrawler.ObjectLinkRequestEvent
// 0x00D0 (0x00D0 - 0x0000)
struct FObjectLinkRequestEvent final
{
public:
	struct FGameplayTagContainer                  StateTagContainer;                                 // 0x0000(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SrcTypeTag;                                        // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      DstTypeTagQuery;                                   // 0x0030(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FObjectLinkMetaData                    MetaData;                                          // 0x0078(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectLinkRequestEvent) == 0x000008, "Wrong alignment on FObjectLinkRequestEvent");
static_assert(sizeof(FObjectLinkRequestEvent) == 0x0000D0, "Wrong size on FObjectLinkRequestEvent");
static_assert(offsetof(FObjectLinkRequestEvent, StateTagContainer) == 0x000000, "Member 'FObjectLinkRequestEvent::StateTagContainer' has a wrong offset!");
static_assert(offsetof(FObjectLinkRequestEvent, SrcTypeTag) == 0x000020, "Member 'FObjectLinkRequestEvent::SrcTypeTag' has a wrong offset!");
static_assert(offsetof(FObjectLinkRequestEvent, EventTag) == 0x000028, "Member 'FObjectLinkRequestEvent::EventTag' has a wrong offset!");
static_assert(offsetof(FObjectLinkRequestEvent, DstTypeTagQuery) == 0x000030, "Member 'FObjectLinkRequestEvent::DstTypeTagQuery' has a wrong offset!");
static_assert(offsetof(FObjectLinkRequestEvent, MetaData) == 0x000078, "Member 'FObjectLinkRequestEvent::MetaData' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataGameplayAbility
// 0x0020 (0x0020 - 0x0000)
struct FAccountDataGameplayAbility final
{
public:
	class FString                                 AbilityId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataGameplayEffect>     SelfEffectArray;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataGameplayAbility) == 0x000008, "Wrong alignment on FAccountDataGameplayAbility");
static_assert(sizeof(FAccountDataGameplayAbility) == 0x000020, "Wrong size on FAccountDataGameplayAbility");
static_assert(offsetof(FAccountDataGameplayAbility, AbilityId) == 0x000000, "Member 'FAccountDataGameplayAbility::AbilityId' has a wrong offset!");
static_assert(offsetof(FAccountDataGameplayAbility, SelfEffectArray) == 0x000010, "Member 'FAccountDataGameplayAbility::SelfEffectArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMarketplaceSortInfo
// 0x0002 (0x0002 - 0x0000)
struct FDCMarketplaceSortInfo final
{
public:
	EDCMarketplaceFilterType                      Target;                                            // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCMarketplaceSortMethod                      Method;                                            // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCMarketplaceSortInfo) == 0x000001, "Wrong alignment on FDCMarketplaceSortInfo");
static_assert(sizeof(FDCMarketplaceSortInfo) == 0x000002, "Wrong size on FDCMarketplaceSortInfo");
static_assert(offsetof(FDCMarketplaceSortInfo, Target) == 0x000000, "Member 'FDCMarketplaceSortInfo::Target' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceSortInfo, Method) == 0x000001, "Member 'FDCMarketplaceSortInfo::Method' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgLobbyCharacterResetEquipItemNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgLobbyCharacterResetEquipItemNotify final : public FMsgBase
{
public:
	EWidgetPartyUserLocate                        WidgetPartyUserLocate;                             // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2003[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      ItemData;                                          // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAccountDataPerk>               Perks;                                             // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgLobbyCharacterResetEquipItemNotify) == 0x000008, "Wrong alignment on FMsgLobbyCharacterResetEquipItemNotify");
static_assert(sizeof(FMsgLobbyCharacterResetEquipItemNotify) == 0x000040, "Wrong size on FMsgLobbyCharacterResetEquipItemNotify");
static_assert(offsetof(FMsgLobbyCharacterResetEquipItemNotify, WidgetPartyUserLocate) == 0x000018, "Member 'FMsgLobbyCharacterResetEquipItemNotify::WidgetPartyUserLocate' has a wrong offset!");
static_assert(offsetof(FMsgLobbyCharacterResetEquipItemNotify, ItemData) == 0x000020, "Member 'FMsgLobbyCharacterResetEquipItemNotify::ItemData' has a wrong offset!");
static_assert(offsetof(FMsgLobbyCharacterResetEquipItemNotify, Perks) == 0x000030, "Member 'FMsgLobbyCharacterResetEquipItemNotify::Perks' has a wrong offset!");

// ScriptStruct DungeonCrawler.PerkData
// 0x0010 (0x0010 - 0x0000)
struct FPerkData final
{
public:
	struct FPrimaryAssetId                        PerkId;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkData) == 0x000004, "Wrong alignment on FPerkData");
static_assert(sizeof(FPerkData) == 0x000010, "Wrong size on FPerkData");
static_assert(offsetof(FPerkData, PerkId) == 0x000000, "Member 'FPerkData::PerkId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTrainingReceiveRewardRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgTrainingReceiveRewardRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2004[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTrainingReceiveRewardRequest) == 0x000008, "Wrong alignment on FClientMsgTrainingReceiveRewardRequest");
static_assert(sizeof(FClientMsgTrainingReceiveRewardRequest) == 0x000038, "Wrong size on FClientMsgTrainingReceiveRewardRequest");

// ScriptStruct DungeonCrawler.MsgWidgetReligionListBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetReligionListBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetReligionListBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetReligionListBeginNotify");
static_assert(sizeof(FMsgWidgetReligionListBeginNotify) == 0x000018, "Wrong size on FMsgWidgetReligionListBeginNotify");

// ScriptStruct DungeonCrawler.DataSkill
// 0x0010 (0x0010 - 0x0000)
struct FDataSkill final
{
public:
	struct FPrimaryAssetId                        SkillId;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataSkill) == 0x000004, "Wrong alignment on FDataSkill");
static_assert(sizeof(FDataSkill) == 0x000010, "Wrong size on FDataSkill");
static_assert(offsetof(FDataSkill, SkillId) == 0x000000, "Member 'FDataSkill::SkillId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassEquipInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgClassEquipInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2005[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassEquipInfoRequest) == 0x000008, "Wrong alignment on FClientMsgClassEquipInfoRequest");
static_assert(sizeof(FClientMsgClassEquipInfoRequest) == 0x000028, "Wrong size on FClientMsgClassEquipInfoRequest");

// ScriptStruct DungeonCrawler.DesignDataQuestContentFetch
// 0x0020 (0x0020 - 0x0000)
struct FDesignDataQuestContentFetch final
{
public:
	int32                                         ContentCount;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemIdTag;                                         // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TypeTag;                                           // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RarityType;                                        // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCItemLootState                              ItemLootState;                                     // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2006[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataQuestContentFetch) == 0x000004, "Wrong alignment on FDesignDataQuestContentFetch");
static_assert(sizeof(FDesignDataQuestContentFetch) == 0x000020, "Wrong size on FDesignDataQuestContentFetch");
static_assert(offsetof(FDesignDataQuestContentFetch, ContentCount) == 0x000000, "Member 'FDesignDataQuestContentFetch::ContentCount' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentFetch, ItemIdTag) == 0x000004, "Member 'FDesignDataQuestContentFetch::ItemIdTag' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentFetch, TypeTag) == 0x00000C, "Member 'FDesignDataQuestContentFetch::TypeTag' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentFetch, RarityType) == 0x000014, "Member 'FDesignDataQuestContentFetch::RarityType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentFetch, ItemLootState) == 0x00001C, "Member 'FDesignDataQuestContentFetch::ItemLootState' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgReduceContainingItemResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgReduceContainingItemResponse final : public FMsgBase
{
public:
	bool                                          bSucceed;                                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2007[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgReduceContainingItemResponse) == 0x000008, "Wrong alignment on FMsgReduceContainingItemResponse");
static_assert(sizeof(FMsgReduceContainingItemResponse) == 0x000020, "Wrong size on FMsgReduceContainingItemResponse");
static_assert(offsetof(FMsgReduceContainingItemResponse, bSucceed) == 0x000018, "Member 'FMsgReduceContainingItemResponse::bSucceed' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataGameSkill
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataGameSkill final
{
public:
	struct FPrimaryAssetId                        SkillId;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChargeAmount;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataGameSkill) == 0x000004, "Wrong alignment on FAccountDataGameSkill");
static_assert(sizeof(FAccountDataGameSkill) == 0x000018, "Wrong size on FAccountDataGameSkill");
static_assert(offsetof(FAccountDataGameSkill, SkillId) == 0x000000, "Member 'FAccountDataGameSkill::SkillId' has a wrong offset!");
static_assert(offsetof(FAccountDataGameSkill, Count) == 0x000010, "Member 'FAccountDataGameSkill::Count' has a wrong offset!");
static_assert(offsetof(FAccountDataGameSkill, ChargeAmount) == 0x000014, "Member 'FAccountDataGameSkill::ChargeAmount' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataGameShapeShift
// 0x0010 (0x0010 - 0x0000)
struct FAccountDataGameShapeShift final
{
public:
	struct FPrimaryAssetId                        ShapeShiftId;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataGameShapeShift) == 0x000004, "Wrong alignment on FAccountDataGameShapeShift");
static_assert(sizeof(FAccountDataGameShapeShift) == 0x000010, "Wrong size on FAccountDataGameShapeShift");
static_assert(offsetof(FAccountDataGameShapeShift, ShapeShiftId) == 0x000000, "Member 'FAccountDataGameShapeShift::ShapeShiftId' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountSessionData
// 0x0118 (0x0118 - 0x0000)
struct FAccountSessionData final
{
public:
	struct FAccountData                           AccountData;                                       // 0x0000(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APlayerController>       PlayerController;                                  // 0x0108(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class APawn>                   PlayerPawn;                                        // 0x0110(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountSessionData) == 0x000008, "Wrong alignment on FAccountSessionData");
static_assert(sizeof(FAccountSessionData) == 0x000118, "Wrong size on FAccountSessionData");
static_assert(offsetof(FAccountSessionData, AccountData) == 0x000000, "Member 'FAccountSessionData::AccountData' has a wrong offset!");
static_assert(offsetof(FAccountSessionData, PlayerController) == 0x000108, "Member 'FAccountSessionData::PlayerController' has a wrong offset!");
static_assert(offsetof(FAccountSessionData, PlayerPawn) == 0x000110, "Member 'FAccountSessionData::PlayerPawn' has a wrong offset!");

// ScriptStruct DungeonCrawler.EquipmentQuickSlotInfo
// 0x0020 (0x0020 - 0x0000)
struct FEquipmentQuickSlotInfo final
{
public:
	EEquipmentQuickSlotType                       QuickSlotType;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2008[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDCEquipmentSlot*>               SlotArray;                                         // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         LastSlotIndex;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2009[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEquipmentQuickSlotInfo) == 0x000008, "Wrong alignment on FEquipmentQuickSlotInfo");
static_assert(sizeof(FEquipmentQuickSlotInfo) == 0x000020, "Wrong size on FEquipmentQuickSlotInfo");
static_assert(offsetof(FEquipmentQuickSlotInfo, QuickSlotType) == 0x000000, "Member 'FEquipmentQuickSlotInfo::QuickSlotType' has a wrong offset!");
static_assert(offsetof(FEquipmentQuickSlotInfo, SlotArray) == 0x000008, "Member 'FEquipmentQuickSlotInfo::SlotArray' has a wrong offset!");
static_assert(offsetof(FEquipmentQuickSlotInfo, LastSlotIndex) == 0x000018, "Member 'FEquipmentQuickSlotInfo::LastSlotIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCDungeonExpressPriceInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCDungeonExpressPriceInfo final
{
public:
	class UDCItemDataAsset*                       PriceItemData;                                     // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginPrice;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FinalPrice;                                        // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCDungeonExpressPriceInfo) == 0x000008, "Wrong alignment on FDCDungeonExpressPriceInfo");
static_assert(sizeof(FDCDungeonExpressPriceInfo) == 0x000010, "Wrong size on FDCDungeonExpressPriceInfo");
static_assert(offsetof(FDCDungeonExpressPriceInfo, PriceItemData) == 0x000000, "Member 'FDCDungeonExpressPriceInfo::PriceItemData' has a wrong offset!");
static_assert(offsetof(FDCDungeonExpressPriceInfo, OriginPrice) == 0x000008, "Member 'FDCDungeonExpressPriceInfo::OriginPrice' has a wrong offset!");
static_assert(offsetof(FDCDungeonExpressPriceInfo, FinalPrice) == 0x00000C, "Member 'FDCDungeonExpressPriceInfo::FinalPrice' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCDungeonExpressItemInfo
// 0x0188 (0x0188 - 0x0000)
struct FDCDungeonExpressItemInfo final
{
public:
	int64                                         UniqueID;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCItemInfo                            ItemInfo;                                          // 0x0008(0x0168)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCDungeonExpressPriceInfo>     PriceInfoArray;                                    // 0x0170(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpiredDateTime;                                   // 0x0180(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCDungeonExpressItemInfo) == 0x000008, "Wrong alignment on FDCDungeonExpressItemInfo");
static_assert(sizeof(FDCDungeonExpressItemInfo) == 0x000188, "Wrong size on FDCDungeonExpressItemInfo");
static_assert(offsetof(FDCDungeonExpressItemInfo, UniqueID) == 0x000000, "Member 'FDCDungeonExpressItemInfo::UniqueID' has a wrong offset!");
static_assert(offsetof(FDCDungeonExpressItemInfo, ItemInfo) == 0x000008, "Member 'FDCDungeonExpressItemInfo::ItemInfo' has a wrong offset!");
static_assert(offsetof(FDCDungeonExpressItemInfo, PriceInfoArray) == 0x000170, "Member 'FDCDungeonExpressItemInfo::PriceInfoArray' has a wrong offset!");
static_assert(offsetof(FDCDungeonExpressItemInfo, ExpiredDateTime) == 0x000180, "Member 'FDCDungeonExpressItemInfo::ExpiredDateTime' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassSpellSequenceChangeRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgClassSpellSequenceChangeRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_200A[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassSpellSequenceChangeRequest) == 0x000008, "Wrong alignment on FClientMsgClassSpellSequenceChangeRequest");
static_assert(sizeof(FClientMsgClassSpellSequenceChangeRequest) == 0x000038, "Wrong size on FClientMsgClassSpellSequenceChangeRequest");

// ScriptStruct DungeonCrawler.ClientMsgClassMusicListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgClassMusicListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_200B[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassMusicListRequest) == 0x000008, "Wrong alignment on FClientMsgClassMusicListRequest");
static_assert(sizeof(FClientMsgClassMusicListRequest) == 0x000028, "Wrong size on FClientMsgClassMusicListRequest");

// ScriptStruct DungeonCrawler.DesignDataReligionSeason
// 0x0038 (0x0040 - 0x0008)
struct FDesignDataReligionSeason final : public FTableRowBase
{
public:
	class FText                                   SeasonName;                                        // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                ReligionIds;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DefaultReligionId;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataReligionSeason) == 0x000008, "Wrong alignment on FDesignDataReligionSeason");
static_assert(sizeof(FDesignDataReligionSeason) == 0x000040, "Wrong size on FDesignDataReligionSeason");
static_assert(offsetof(FDesignDataReligionSeason, SeasonName) == 0x000008, "Member 'FDesignDataReligionSeason::SeasonName' has a wrong offset!");
static_assert(offsetof(FDesignDataReligionSeason, ReligionIds) == 0x000020, "Member 'FDesignDataReligionSeason::ReligionIds' has a wrong offset!");
static_assert(offsetof(FDesignDataReligionSeason, DefaultReligionId) == 0x000030, "Member 'FDesignDataReligionSeason::DefaultReligionId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAddEquippedItemActor
// 0x0008 (0x0020 - 0x0018)
struct FMsgAddEquippedItemActor final : public FMsgBase
{
public:
	class AItemActor*                             EquippedItemActor;                                 // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAddEquippedItemActor) == 0x000008, "Wrong alignment on FMsgAddEquippedItemActor");
static_assert(sizeof(FMsgAddEquippedItemActor) == 0x000020, "Wrong size on FMsgAddEquippedItemActor");
static_assert(offsetof(FMsgAddEquippedItemActor, EquippedItemActor) == 0x000018, "Member 'FMsgAddEquippedItemActor::EquippedItemActor' has a wrong offset!");

// ScriptStruct DungeonCrawler.RankRecord
// 0x0070 (0x0070 - 0x0000)
struct FRankRecord final
{
public:
	int32                                         PageIndex;                                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percentage;                                        // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountId;                                         // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0020(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankRecord) == 0x000008, "Wrong alignment on FRankRecord");
static_assert(sizeof(FRankRecord) == 0x000070, "Wrong size on FRankRecord");
static_assert(offsetof(FRankRecord, PageIndex) == 0x000000, "Member 'FRankRecord::PageIndex' has a wrong offset!");
static_assert(offsetof(FRankRecord, Rank) == 0x000004, "Member 'FRankRecord::Rank' has a wrong offset!");
static_assert(offsetof(FRankRecord, Score) == 0x000008, "Member 'FRankRecord::Score' has a wrong offset!");
static_assert(offsetof(FRankRecord, Percentage) == 0x00000C, "Member 'FRankRecord::Percentage' has a wrong offset!");
static_assert(offsetof(FRankRecord, AccountId) == 0x000010, "Member 'FRankRecord::AccountId' has a wrong offset!");
static_assert(offsetof(FRankRecord, Nickname) == 0x000020, "Member 'FRankRecord::Nickname' has a wrong offset!");
static_assert(offsetof(FRankRecord, CharacterClass) == 0x000060, "Member 'FRankRecord::CharacterClass' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassPerkListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgClassPerkListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_200C[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassPerkListRequest) == 0x000008, "Wrong alignment on FClientMsgClassPerkListRequest");
static_assert(sizeof(FClientMsgClassPerkListRequest) == 0x000028, "Wrong size on FClientMsgClassPerkListRequest");

// ScriptStruct DungeonCrawler.MsgWidgetCharacterSelectGroupToggleNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetCharacterSelectGroupToggleNotify final : public FMsgBase
{
public:
	EWidgetCharacterSelectGroupType               WidgetCharacterSelectGroupType;                    // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              NewVisibility;                                     // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200D[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetCharacterSelectGroupToggleNotify) == 0x000008, "Wrong alignment on FMsgWidgetCharacterSelectGroupToggleNotify");
static_assert(sizeof(FMsgWidgetCharacterSelectGroupToggleNotify) == 0x000020, "Wrong size on FMsgWidgetCharacterSelectGroupToggleNotify");
static_assert(offsetof(FMsgWidgetCharacterSelectGroupToggleNotify, WidgetCharacterSelectGroupType) == 0x000018, "Member 'FMsgWidgetCharacterSelectGroupToggleNotify::WidgetCharacterSelectGroupType' has a wrong offset!");
static_assert(offsetof(FMsgWidgetCharacterSelectGroupToggleNotify, NewVisibility) == 0x000019, "Member 'FMsgWidgetCharacterSelectGroupToggleNotify::NewVisibility' has a wrong offset!");

// ScriptStruct DungeonCrawler.CharacterSlot
// 0x00C0 (0x00C0 - 0x0000)
struct FCharacterSlot final
{
public:
	class FString                                 CharacterId;                                       // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0010(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         CreateAt;                                          // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCGender                                     Gender;                                            // 0x0068(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200E[0x3];                                     // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x006C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         LastLoginDate;                                     // 0x0070(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x0078(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200F[0x7];                                     // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAccountDataItem>               EquipItemList;                                     // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        EquipCharacterSkin;                                // 0x0090(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                EquipItemSkinList;                                 // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                EquipArmorSkinList;                                // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSlot) == 0x000008, "Wrong alignment on FCharacterSlot");
static_assert(sizeof(FCharacterSlot) == 0x0000C0, "Wrong size on FCharacterSlot");
static_assert(offsetof(FCharacterSlot, CharacterId) == 0x000000, "Member 'FCharacterSlot::CharacterId' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, Nickname) == 0x000010, "Member 'FCharacterSlot::Nickname' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, CharacterClass) == 0x000050, "Member 'FCharacterSlot::CharacterClass' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, CreateAt) == 0x000060, "Member 'FCharacterSlot::CreateAt' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, Gender) == 0x000068, "Member 'FCharacterSlot::Gender' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, Level) == 0x00006C, "Member 'FCharacterSlot::Level' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, LastLoginDate) == 0x000070, "Member 'FCharacterSlot::LastLoginDate' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, bSelected) == 0x000078, "Member 'FCharacterSlot::bSelected' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, EquipItemList) == 0x000080, "Member 'FCharacterSlot::EquipItemList' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, EquipCharacterSkin) == 0x000090, "Member 'FCharacterSlot::EquipCharacterSkin' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, EquipItemSkinList) == 0x0000A0, "Member 'FCharacterSlot::EquipItemSkinList' has a wrong offset!");
static_assert(offsetof(FCharacterSlot, EquipArmorSkinList) == 0x0000B0, "Member 'FCharacterSlot::EquipArmorSkinList' has a wrong offset!");

// ScriptStruct DungeonCrawler.CharacterSlotData
// 0x0010 (0x0010 - 0x0000)
struct FCharacterSlotData final
{
public:
	TArray<struct FCharacterSlot>                 CharacterSlotArray;                                // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSlotData) == 0x000008, "Wrong alignment on FCharacterSlotData");
static_assert(sizeof(FCharacterSlotData) == 0x000010, "Wrong size on FCharacterSlotData");
static_assert(offsetof(FCharacterSlotData, CharacterSlotArray) == 0x000000, "Member 'FCharacterSlotData::CharacterSlotArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassSpellSlotMoveRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgClassSpellSlotMoveRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2010[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassSpellSlotMoveRequest) == 0x000008, "Wrong alignment on FClientMsgClassSpellSlotMoveRequest");
static_assert(sizeof(FClientMsgClassSpellSlotMoveRequest) == 0x000038, "Wrong size on FClientMsgClassSpellSlotMoveRequest");

// ScriptStruct DungeonCrawler.MsgWidgetGameGroupToggleNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetGameGroupToggleNotify final : public FMsgBase
{
public:
	EWidgetGameGroupType                          WidgetGameGroupType;                               // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              NewVisibility;                                     // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2011[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetGameGroupToggleNotify) == 0x000008, "Wrong alignment on FMsgWidgetGameGroupToggleNotify");
static_assert(sizeof(FMsgWidgetGameGroupToggleNotify) == 0x000020, "Wrong size on FMsgWidgetGameGroupToggleNotify");
static_assert(offsetof(FMsgWidgetGameGroupToggleNotify, WidgetGameGroupType) == 0x000018, "Member 'FMsgWidgetGameGroupToggleNotify::WidgetGameGroupType' has a wrong offset!");
static_assert(offsetof(FMsgWidgetGameGroupToggleNotify, NewVisibility) == 0x000019, "Member 'FMsgWidgetGameGroupToggleNotify::NewVisibility' has a wrong offset!");

// ScriptStruct DungeonCrawler.InvitePartyUserSlot
// 0x0098 (0x0098 - 0x0000)
struct FInvitePartyUserSlot final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountNickname;                                   // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0020(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gender;                                            // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0084(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationStatus;                                    // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyMemeberCount;                                 // 0x008C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyMaxMemeberCount;                              // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2012[0x4];                                     // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInvitePartyUserSlot) == 0x000008, "Wrong alignment on FInvitePartyUserSlot");
static_assert(sizeof(FInvitePartyUserSlot) == 0x000098, "Wrong size on FInvitePartyUserSlot");
static_assert(offsetof(FInvitePartyUserSlot, AccountId) == 0x000000, "Member 'FInvitePartyUserSlot::AccountId' has a wrong offset!");
static_assert(offsetof(FInvitePartyUserSlot, AccountNickname) == 0x000010, "Member 'FInvitePartyUserSlot::AccountNickname' has a wrong offset!");
static_assert(offsetof(FInvitePartyUserSlot, Nickname) == 0x000020, "Member 'FInvitePartyUserSlot::Nickname' has a wrong offset!");
static_assert(offsetof(FInvitePartyUserSlot, CharacterClass) == 0x000060, "Member 'FInvitePartyUserSlot::CharacterClass' has a wrong offset!");
static_assert(offsetof(FInvitePartyUserSlot, CharacterId) == 0x000070, "Member 'FInvitePartyUserSlot::CharacterId' has a wrong offset!");
static_assert(offsetof(FInvitePartyUserSlot, Gender) == 0x000080, "Member 'FInvitePartyUserSlot::Gender' has a wrong offset!");
static_assert(offsetof(FInvitePartyUserSlot, Level) == 0x000084, "Member 'FInvitePartyUserSlot::Level' has a wrong offset!");
static_assert(offsetof(FInvitePartyUserSlot, LocationStatus) == 0x000088, "Member 'FInvitePartyUserSlot::LocationStatus' has a wrong offset!");
static_assert(offsetof(FInvitePartyUserSlot, PartyMemeberCount) == 0x00008C, "Member 'FInvitePartyUserSlot::PartyMemeberCount' has a wrong offset!");
static_assert(offsetof(FInvitePartyUserSlot, PartyMaxMemeberCount) == 0x000090, "Member 'FInvitePartyUserSlot::PartyMaxMemeberCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.InvitePartyUserSlotData
// 0x0010 (0x0010 - 0x0000)
struct FInvitePartyUserSlotData final
{
public:
	TArray<struct FInvitePartyUserSlot>           InvitePartyUserSlotArray;                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvitePartyUserSlotData) == 0x000008, "Wrong alignment on FInvitePartyUserSlotData");
static_assert(sizeof(FInvitePartyUserSlotData) == 0x000010, "Wrong size on FInvitePartyUserSlotData");
static_assert(offsetof(FInvitePartyUserSlotData, InvitePartyUserSlotArray) == 0x000000, "Member 'FInvitePartyUserSlotData::InvitePartyUserSlotArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.LineCollisionMarkerSocket
// 0x0048 (0x0048 - 0x0000)
struct FLineCollisionMarkerSocket final
{
public:
	class USkeletalMeshSocket*                    Socket;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SocketName;                                        // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrevSocketLocation;                                // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EffectTag;                                         // 0x0030(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ChannelTag;                                        // 0x0038(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannel;                                  // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2013[0x7];                                     // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLineCollisionMarkerSocket) == 0x000008, "Wrong alignment on FLineCollisionMarkerSocket");
static_assert(sizeof(FLineCollisionMarkerSocket) == 0x000048, "Wrong size on FLineCollisionMarkerSocket");
static_assert(offsetof(FLineCollisionMarkerSocket, Socket) == 0x000000, "Member 'FLineCollisionMarkerSocket::Socket' has a wrong offset!");
static_assert(offsetof(FLineCollisionMarkerSocket, SocketName) == 0x000008, "Member 'FLineCollisionMarkerSocket::SocketName' has a wrong offset!");
static_assert(offsetof(FLineCollisionMarkerSocket, PrevSocketLocation) == 0x000018, "Member 'FLineCollisionMarkerSocket::PrevSocketLocation' has a wrong offset!");
static_assert(offsetof(FLineCollisionMarkerSocket, EffectTag) == 0x000030, "Member 'FLineCollisionMarkerSocket::EffectTag' has a wrong offset!");
static_assert(offsetof(FLineCollisionMarkerSocket, ChannelTag) == 0x000038, "Member 'FLineCollisionMarkerSocket::ChannelTag' has a wrong offset!");
static_assert(offsetof(FLineCollisionMarkerSocket, CollisionChannel) == 0x000040, "Member 'FLineCollisionMarkerSocket::CollisionChannel' has a wrong offset!");

// ScriptStruct DungeonCrawler.MetaBindAccountUserData
// 0x0008 (0x0008 - 0x0000)
struct FMetaBindAccountUserData final
{
public:
	class AActor*                                 DummyActor;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMetaBindAccountUserData) == 0x000008, "Wrong alignment on FMetaBindAccountUserData");
static_assert(sizeof(FMetaBindAccountUserData) == 0x000008, "Wrong size on FMetaBindAccountUserData");
static_assert(offsetof(FMetaBindAccountUserData, DummyActor) == 0x000000, "Member 'FMetaBindAccountUserData::DummyActor' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassShapeShiftSlotMoveRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgClassShapeShiftSlotMoveRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2014[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassShapeShiftSlotMoveRequest) == 0x000008, "Wrong alignment on FClientMsgClassShapeShiftSlotMoveRequest");
static_assert(sizeof(FClientMsgClassShapeShiftSlotMoveRequest) == 0x000038, "Wrong size on FClientMsgClassShapeShiftSlotMoveRequest");

// ScriptStruct DungeonCrawler.DCFriendInfo
// 0x0098 (0x0098 - 0x0000)
struct FDCFriendInfo final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountNickname;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0030(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gender;                                            // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Status;                                            // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LocationStatus;                                    // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyMemeberCount;                                 // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyMaxMemeberCount;                              // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCFriendInfo) == 0x000008, "Wrong alignment on FDCFriendInfo");
static_assert(sizeof(FDCFriendInfo) == 0x000098, "Wrong size on FDCFriendInfo");
static_assert(offsetof(FDCFriendInfo, AccountId) == 0x000000, "Member 'FDCFriendInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCFriendInfo, AccountNickname) == 0x000010, "Member 'FDCFriendInfo::AccountNickname' has a wrong offset!");
static_assert(offsetof(FDCFriendInfo, CharacterId) == 0x000020, "Member 'FDCFriendInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FDCFriendInfo, Nickname) == 0x000030, "Member 'FDCFriendInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FDCFriendInfo, CharacterClass) == 0x000070, "Member 'FDCFriendInfo::CharacterClass' has a wrong offset!");
static_assert(offsetof(FDCFriendInfo, Gender) == 0x000080, "Member 'FDCFriendInfo::Gender' has a wrong offset!");
static_assert(offsetof(FDCFriendInfo, Level) == 0x000084, "Member 'FDCFriendInfo::Level' has a wrong offset!");
static_assert(offsetof(FDCFriendInfo, Status) == 0x000088, "Member 'FDCFriendInfo::Status' has a wrong offset!");
static_assert(offsetof(FDCFriendInfo, LocationStatus) == 0x00008C, "Member 'FDCFriendInfo::LocationStatus' has a wrong offset!");
static_assert(offsetof(FDCFriendInfo, PartyMemeberCount) == 0x000090, "Member 'FDCFriendInfo::PartyMemeberCount' has a wrong offset!");
static_assert(offsetof(FDCFriendInfo, PartyMaxMemeberCount) == 0x000094, "Member 'FDCFriendInfo::PartyMaxMemeberCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.FriendSlotData
// 0x0010 (0x0010 - 0x0000)
struct FFriendSlotData final
{
public:
	TArray<struct FDCFriendInfo>                  DCFriendInfoArray;                                 // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFriendSlotData) == 0x000008, "Wrong alignment on FFriendSlotData");
static_assert(sizeof(FFriendSlotData) == 0x000010, "Wrong size on FFriendSlotData");
static_assert(offsetof(FFriendSlotData, DCFriendInfoArray) == 0x000000, "Member 'FFriendSlotData::DCFriendInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.StockBuyTradeItemInfo
// 0x0010 (0x0010 - 0x0000)
struct FStockBuyTradeItemInfo final
{
public:
	int64                                         ItemUniqueId;                                      // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemContentsCount;                                 // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStockBuyTradeItemInfo) == 0x000008, "Wrong alignment on FStockBuyTradeItemInfo");
static_assert(sizeof(FStockBuyTradeItemInfo) == 0x000010, "Wrong size on FStockBuyTradeItemInfo");
static_assert(offsetof(FStockBuyTradeItemInfo, ItemUniqueId) == 0x000000, "Member 'FStockBuyTradeItemInfo::ItemUniqueId' has a wrong offset!");
static_assert(offsetof(FStockBuyTradeItemInfo, ItemCount) == 0x000008, "Member 'FStockBuyTradeItemInfo::ItemCount' has a wrong offset!");
static_assert(offsetof(FStockBuyTradeItemInfo, ItemContentsCount) == 0x00000C, "Member 'FStockBuyTradeItemInfo::ItemContentsCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassItemMoveRequest
// 0x0040 (0x0060 - 0x0020)
struct FClientMsgClassItemMoveRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2015[0x40];                                    // 0x0020(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassItemMoveRequest) == 0x000008, "Wrong alignment on FClientMsgClassItemMoveRequest");
static_assert(sizeof(FClientMsgClassItemMoveRequest) == 0x000060, "Wrong size on FClientMsgClassItemMoveRequest");

// ScriptStruct DungeonCrawler.DesignDataLootDropItem
// 0x0018 (0x0018 - 0x0000)
struct FDesignDataLootDropItem final
{
public:
	struct FPrimaryAssetId                        ItemId;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LuckGrade;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLootDropItem) == 0x000004, "Wrong alignment on FDesignDataLootDropItem");
static_assert(sizeof(FDesignDataLootDropItem) == 0x000018, "Wrong size on FDesignDataLootDropItem");
static_assert(offsetof(FDesignDataLootDropItem, ItemId) == 0x000000, "Member 'FDesignDataLootDropItem::ItemId' has a wrong offset!");
static_assert(offsetof(FDesignDataLootDropItem, ItemCount) == 0x000010, "Member 'FDesignDataLootDropItem::ItemCount' has a wrong offset!");
static_assert(offsetof(FDesignDataLootDropItem, LuckGrade) == 0x000014, "Member 'FDesignDataLootDropItem::LuckGrade' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLootDrop
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataLootDrop final
{
public:
	TArray<struct FDesignDataLootDropItem>        LootDropItemArray;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLootDrop) == 0x000008, "Wrong alignment on FDesignDataLootDrop");
static_assert(sizeof(FDesignDataLootDrop) == 0x000010, "Wrong size on FDesignDataLootDrop");
static_assert(offsetof(FDesignDataLootDrop, LootDropItemArray) == 0x000000, "Member 'FDesignDataLootDrop::LootDropItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLootDropRateItem
// 0x0008 (0x0008 - 0x0000)
struct FDesignDataLootDropRateItem final
{
public:
	int32                                         LuckGrade;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropRate;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLootDropRateItem) == 0x000004, "Wrong alignment on FDesignDataLootDropRateItem");
static_assert(sizeof(FDesignDataLootDropRateItem) == 0x000008, "Wrong size on FDesignDataLootDropRateItem");
static_assert(offsetof(FDesignDataLootDropRateItem, LuckGrade) == 0x000000, "Member 'FDesignDataLootDropRateItem::LuckGrade' has a wrong offset!");
static_assert(offsetof(FDesignDataLootDropRateItem, DropRate) == 0x000004, "Member 'FDesignDataLootDropRateItem::DropRate' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLootDropRate
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataLootDropRate final
{
public:
	TArray<struct FDesignDataLootDropRateItem>    LootDropRateItemArray;                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLootDropRate) == 0x000008, "Wrong alignment on FDesignDataLootDropRate");
static_assert(sizeof(FDesignDataLootDropRate) == 0x000010, "Wrong size on FDesignDataLootDropRate");
static_assert(offsetof(FDesignDataLootDropRate, LootDropRateItemArray) == 0x000000, "Member 'FDesignDataLootDropRate::LootDropRateItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLootDropTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataLootDropTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataLootDrop> LootDrop;                                          // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataLootDropRate> LootDropRate;                                      // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataLootDropGroup> LootDropGroup;                                     // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLootDropTableRow) == 0x000008, "Wrong alignment on FDesignDataLootDropTableRow");
static_assert(sizeof(FDesignDataLootDropTableRow) == 0x0000F8, "Wrong size on FDesignDataLootDropTableRow");
static_assert(offsetof(FDesignDataLootDropTableRow, LootDrop) == 0x000008, "Member 'FDesignDataLootDropTableRow::LootDrop' has a wrong offset!");
static_assert(offsetof(FDesignDataLootDropTableRow, LootDropRate) == 0x000058, "Member 'FDesignDataLootDropTableRow::LootDropRate' has a wrong offset!");
static_assert(offsetof(FDesignDataLootDropTableRow, LootDropGroup) == 0x0000A8, "Member 'FDesignDataLootDropTableRow::LootDropGroup' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCCharacterId
// 0x0000 (0x0010 - 0x0010)
struct FDCCharacterId final : public FDCStringIdBase
{
};
static_assert(alignof(FDCCharacterId) == 0x000008, "Wrong alignment on FDCCharacterId");
static_assert(sizeof(FDCCharacterId) == 0x000010, "Wrong size on FDCCharacterId");

// ScriptStruct DungeonCrawler.DCCommunityCharacterInfo
// 0x0078 (0x0078 - 0x0000)
struct FDCCommunityCharacterInfo final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountNickname;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCCharacterId                         CharacterId;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0030(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EDCCharacterClass                             CharacterClass;                                    // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCGender                                     Gender;                                            // 0x0071(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2016[0x6];                                     // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCCommunityCharacterInfo) == 0x000008, "Wrong alignment on FDCCommunityCharacterInfo");
static_assert(sizeof(FDCCommunityCharacterInfo) == 0x000078, "Wrong size on FDCCommunityCharacterInfo");
static_assert(offsetof(FDCCommunityCharacterInfo, AccountId) == 0x000000, "Member 'FDCCommunityCharacterInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCCommunityCharacterInfo, AccountNickname) == 0x000010, "Member 'FDCCommunityCharacterInfo::AccountNickname' has a wrong offset!");
static_assert(offsetof(FDCCommunityCharacterInfo, CharacterId) == 0x000020, "Member 'FDCCommunityCharacterInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FDCCommunityCharacterInfo, Nickname) == 0x000030, "Member 'FDCCommunityCharacterInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FDCCommunityCharacterInfo, CharacterClass) == 0x000070, "Member 'FDCCommunityCharacterInfo::CharacterClass' has a wrong offset!");
static_assert(offsetof(FDCCommunityCharacterInfo, Gender) == 0x000071, "Member 'FDCCommunityCharacterInfo::Gender' has a wrong offset!");

// ScriptStruct DungeonCrawler.BlockUserSlotData
// 0x0010 (0x0010 - 0x0000)
struct FBlockUserSlotData final
{
public:
	TArray<struct FDCCommunityCharacterInfo>      DCCommunityCharacterInfoArray;                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlockUserSlotData) == 0x000008, "Wrong alignment on FBlockUserSlotData");
static_assert(sizeof(FBlockUserSlotData) == 0x000010, "Wrong size on FBlockUserSlotData");
static_assert(offsetof(FBlockUserSlotData, DCCommunityCharacterInfoArray) == 0x000000, "Member 'FBlockUserSlotData::DCCommunityCharacterInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.RankInfo
// 0x0010 (0x0010 - 0x0000)
struct FRankInfo final
{
public:
	class UDCLeaderboardRankDataAsset*            LeaderboardRankData;                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentRankAdvPoint;                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentNeedAdvPoint;                               // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankInfo) == 0x000008, "Wrong alignment on FRankInfo");
static_assert(sizeof(FRankInfo) == 0x000010, "Wrong size on FRankInfo");
static_assert(offsetof(FRankInfo, LeaderboardRankData) == 0x000000, "Member 'FRankInfo::LeaderboardRankData' has a wrong offset!");
static_assert(offsetof(FRankInfo, CurrentRankAdvPoint) == 0x000008, "Member 'FRankInfo::CurrentRankAdvPoint' has a wrong offset!");
static_assert(offsetof(FRankInfo, CurrentNeedAdvPoint) == 0x00000C, "Member 'FRankInfo::CurrentNeedAdvPoint' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassShapeShiftListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgClassShapeShiftListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2017[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassShapeShiftListRequest) == 0x000008, "Wrong alignment on FClientMsgClassShapeShiftListRequest");
static_assert(sizeof(FClientMsgClassShapeShiftListRequest) == 0x000028, "Wrong size on FClientMsgClassShapeShiftListRequest");

// ScriptStruct DungeonCrawler.MsgWidgetGameGroupHideUIbyNonCoexistWidgetResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetGameGroupHideUIbyNonCoexistWidgetResponse final : public FMsgBase
{
public:
	EWidgetGameGroupType                          WidgetGameGroupType;                               // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2018[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetGameGroupHideUIbyNonCoexistWidgetResponse) == 0x000008, "Wrong alignment on FMsgWidgetGameGroupHideUIbyNonCoexistWidgetResponse");
static_assert(sizeof(FMsgWidgetGameGroupHideUIbyNonCoexistWidgetResponse) == 0x000020, "Wrong size on FMsgWidgetGameGroupHideUIbyNonCoexistWidgetResponse");
static_assert(offsetof(FMsgWidgetGameGroupHideUIbyNonCoexistWidgetResponse, WidgetGameGroupType) == 0x000018, "Member 'FMsgWidgetGameGroupHideUIbyNonCoexistWidgetResponse::WidgetGameGroupType' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestLogListResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgMerchantQuestLogListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2019[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestLogListResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestLogListResponse");
static_assert(sizeof(FClientMsgMerchantQuestLogListResponse) == 0x000030, "Wrong size on FClientMsgMerchantQuestLogListResponse");

// ScriptStruct DungeonCrawler.DCFriendReceivedInvitationInfo
// 0x0090 (0x0090 - 0x0000)
struct FDCFriendReceivedInvitationInfo final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountNickname;                                   // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0030(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gender;                                            // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Status;                                            // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201A[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCFriendReceivedInvitationInfo) == 0x000008, "Wrong alignment on FDCFriendReceivedInvitationInfo");
static_assert(sizeof(FDCFriendReceivedInvitationInfo) == 0x000090, "Wrong size on FDCFriendReceivedInvitationInfo");
static_assert(offsetof(FDCFriendReceivedInvitationInfo, AccountId) == 0x000000, "Member 'FDCFriendReceivedInvitationInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCFriendReceivedInvitationInfo, AccountNickname) == 0x000010, "Member 'FDCFriendReceivedInvitationInfo::AccountNickname' has a wrong offset!");
static_assert(offsetof(FDCFriendReceivedInvitationInfo, CharacterId) == 0x000020, "Member 'FDCFriendReceivedInvitationInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FDCFriendReceivedInvitationInfo, Nickname) == 0x000030, "Member 'FDCFriendReceivedInvitationInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FDCFriendReceivedInvitationInfo, CharacterClass) == 0x000070, "Member 'FDCFriendReceivedInvitationInfo::CharacterClass' has a wrong offset!");
static_assert(offsetof(FDCFriendReceivedInvitationInfo, Gender) == 0x000080, "Member 'FDCFriendReceivedInvitationInfo::Gender' has a wrong offset!");
static_assert(offsetof(FDCFriendReceivedInvitationInfo, Level) == 0x000084, "Member 'FDCFriendReceivedInvitationInfo::Level' has a wrong offset!");
static_assert(offsetof(FDCFriendReceivedInvitationInfo, Status) == 0x000088, "Member 'FDCFriendReceivedInvitationInfo::Status' has a wrong offset!");

// ScriptStruct DungeonCrawler.ReceivedInvitationSlotData
// 0x0010 (0x0010 - 0x0000)
struct FReceivedInvitationSlotData final
{
public:
	TArray<struct FDCFriendReceivedInvitationInfo> DCFriendReceivedInvitationInfoArray;               // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReceivedInvitationSlotData) == 0x000008, "Wrong alignment on FReceivedInvitationSlotData");
static_assert(sizeof(FReceivedInvitationSlotData) == 0x000010, "Wrong size on FReceivedInvitationSlotData");
static_assert(offsetof(FReceivedInvitationSlotData, DCFriendReceivedInvitationInfoArray) == 0x000000, "Member 'FReceivedInvitationSlotData::DCFriendReceivedInvitationInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendCreateAccountnicknameRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgFriendCreateAccountnicknameRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_201B[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendCreateAccountnicknameRequest) == 0x000008, "Wrong alignment on FClientMsgFriendCreateAccountnicknameRequest");
static_assert(sizeof(FClientMsgFriendCreateAccountnicknameRequest) == 0x000030, "Wrong size on FClientMsgFriendCreateAccountnicknameRequest");

// ScriptStruct DungeonCrawler.MsgWidgetTradingCanMoveItemStateNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetTradingCanMoveItemStateNotify final : public FMsgBase
{
public:
	bool                                          bCanMove;                                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMine;                                           // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201C[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetTradingCanMoveItemStateNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradingCanMoveItemStateNotify");
static_assert(sizeof(FMsgWidgetTradingCanMoveItemStateNotify) == 0x000020, "Wrong size on FMsgWidgetTradingCanMoveItemStateNotify");
static_assert(offsetof(FMsgWidgetTradingCanMoveItemStateNotify, bCanMove) == 0x000018, "Member 'FMsgWidgetTradingCanMoveItemStateNotify::bCanMove' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradingCanMoveItemStateNotify, bIsMine) == 0x000019, "Member 'FMsgWidgetTradingCanMoveItemStateNotify::bIsMine' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSpellMemoryCapacityChangedNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgSpellMemoryCapacityChangedNotify final : public FMsgBase
{
public:
	float                                         SpellCurrentCapacity;                              // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpellMaxCapacity;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSpellMemoryCapacityChangedNotify) == 0x000008, "Wrong alignment on FMsgSpellMemoryCapacityChangedNotify");
static_assert(sizeof(FMsgSpellMemoryCapacityChangedNotify) == 0x000020, "Wrong size on FMsgSpellMemoryCapacityChangedNotify");
static_assert(offsetof(FMsgSpellMemoryCapacityChangedNotify, SpellCurrentCapacity) == 0x000018, "Member 'FMsgSpellMemoryCapacityChangedNotify::SpellCurrentCapacity' has a wrong offset!");
static_assert(offsetof(FMsgSpellMemoryCapacityChangedNotify, SpellMaxCapacity) == 0x00001C, "Member 'FMsgSpellMemoryCapacityChangedNotify::SpellMaxCapacity' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgUnblockCharacterRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgUnblockCharacterRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_201D[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgUnblockCharacterRequest) == 0x000008, "Wrong alignment on FClientMsgUnblockCharacterRequest");
static_assert(sizeof(FClientMsgUnblockCharacterRequest) == 0x000040, "Wrong size on FClientMsgUnblockCharacterRequest");

// ScriptStruct DungeonCrawler.DeathSwarmCircle
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FDeathSwarmCircle final
{
public:
	uint8                                         Pad_201E[0x28];                                    // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeathSwarmCircle) == 0x000008, "Wrong alignment on FDeathSwarmCircle");
static_assert(sizeof(FDeathSwarmCircle) == 0x000028, "Wrong size on FDeathSwarmCircle");

// ScriptStruct DungeonCrawler.AccountDataCustomizeCharacter
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataCustomizeCharacter final
{
public:
	class FString                                 CustomizeCharacterId;                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsEquip;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsNew;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataCustomizeCharacter) == 0x000008, "Wrong alignment on FAccountDataCustomizeCharacter");
static_assert(sizeof(FAccountDataCustomizeCharacter) == 0x000018, "Wrong size on FAccountDataCustomizeCharacter");
static_assert(offsetof(FAccountDataCustomizeCharacter, CustomizeCharacterId) == 0x000000, "Member 'FAccountDataCustomizeCharacter::CustomizeCharacterId' has a wrong offset!");
static_assert(offsetof(FAccountDataCustomizeCharacter, IsEquip) == 0x000010, "Member 'FAccountDataCustomizeCharacter::IsEquip' has a wrong offset!");
static_assert(offsetof(FAccountDataCustomizeCharacter, IsNew) == 0x000014, "Member 'FAccountDataCustomizeCharacter::IsNew' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradeEndNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetTradeEndNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetTradeEndNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeEndNotify");
static_assert(sizeof(FMsgWidgetTradeEndNotify) == 0x000018, "Wrong size on FMsgWidgetTradeEndNotify");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestLogListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMerchantQuestLogListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_201F[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestLogListRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestLogListRequest");
static_assert(sizeof(FClientMsgMerchantQuestLogListRequest) == 0x000028, "Wrong size on FClientMsgMerchantQuestLogListRequest");

// ScriptStruct DungeonCrawler.AccountDataCustomizeItem
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataCustomizeItem final
{
public:
	class FString                                 CustomizeItemId;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsEquip;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsNew;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataCustomizeItem) == 0x000008, "Wrong alignment on FAccountDataCustomizeItem");
static_assert(sizeof(FAccountDataCustomizeItem) == 0x000018, "Wrong size on FAccountDataCustomizeItem");
static_assert(offsetof(FAccountDataCustomizeItem, CustomizeItemId) == 0x000000, "Member 'FAccountDataCustomizeItem::CustomizeItemId' has a wrong offset!");
static_assert(offsetof(FAccountDataCustomizeItem, IsEquip) == 0x000010, "Member 'FAccountDataCustomizeItem::IsEquip' has a wrong offset!");
static_assert(offsetof(FAccountDataCustomizeItem, IsNew) == 0x000014, "Member 'FAccountDataCustomizeItem::IsNew' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendCheckAccountnicknameRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgFriendCheckAccountnicknameRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2020[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendCheckAccountnicknameRequest) == 0x000008, "Wrong alignment on FClientMsgFriendCheckAccountnicknameRequest");
static_assert(sizeof(FClientMsgFriendCheckAccountnicknameRequest) == 0x000030, "Wrong size on FClientMsgFriendCheckAccountnicknameRequest");

// ScriptStruct DungeonCrawler.ClientMsgMerchantExpressBuyRequest
// 0x0028 (0x0048 - 0x0020)
struct FClientMsgMerchantExpressBuyRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2021[0x28];                                    // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantExpressBuyRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantExpressBuyRequest");
static_assert(sizeof(FClientMsgMerchantExpressBuyRequest) == 0x000048, "Wrong size on FClientMsgMerchantExpressBuyRequest");

// ScriptStruct DungeonCrawler.AccountDataEmote
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataEmote final
{
public:
	class FString                                 EmoteId;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipSlotIndex;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsNew;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataEmote) == 0x000008, "Wrong alignment on FAccountDataEmote");
static_assert(sizeof(FAccountDataEmote) == 0x000018, "Wrong size on FAccountDataEmote");
static_assert(offsetof(FAccountDataEmote, EmoteId) == 0x000000, "Member 'FAccountDataEmote::EmoteId' has a wrong offset!");
static_assert(offsetof(FAccountDataEmote, EquipSlotIndex) == 0x000010, "Member 'FAccountDataEmote::EquipSlotIndex' has a wrong offset!");
static_assert(offsetof(FAccountDataEmote, IsNew) == 0x000014, "Member 'FAccountDataEmote::IsNew' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgBlockCharacterRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgBlockCharacterRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2022[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgBlockCharacterRequest) == 0x000008, "Wrong alignment on FClientMsgBlockCharacterRequest");
static_assert(sizeof(FClientMsgBlockCharacterRequest) == 0x000040, "Wrong size on FClientMsgBlockCharacterRequest");

// ScriptStruct DungeonCrawler.MsgWidgetClassPerkListNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassPerkListNotify final : public FMsgBase
{
public:
	TArray<struct FPerkData>                      PerkIdArray;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassPerkListNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassPerkListNotify");
static_assert(sizeof(FMsgWidgetClassPerkListNotify) == 0x000028, "Wrong size on FMsgWidgetClassPerkListNotify");
static_assert(offsetof(FMsgWidgetClassPerkListNotify, PerkIdArray) == 0x000018, "Member 'FMsgWidgetClassPerkListNotify::PerkIdArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataCustomizeAction
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataCustomizeAction final
{
public:
	class FString                                 CustomizeActionId;                                 // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsEquip;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsNew;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataCustomizeAction) == 0x000008, "Wrong alignment on FAccountDataCustomizeAction");
static_assert(sizeof(FAccountDataCustomizeAction) == 0x000018, "Wrong size on FAccountDataCustomizeAction");
static_assert(offsetof(FAccountDataCustomizeAction, CustomizeActionId) == 0x000000, "Member 'FAccountDataCustomizeAction::CustomizeActionId' has a wrong offset!");
static_assert(offsetof(FAccountDataCustomizeAction, IsEquip) == 0x000010, "Member 'FAccountDataCustomizeAction::IsEquip' has a wrong offset!");
static_assert(offsetof(FAccountDataCustomizeAction, IsNew) == 0x000014, "Member 'FAccountDataCustomizeAction::IsNew' has a wrong offset!");

// ScriptStruct DungeonCrawler.AccountDataLobbyEmote
// 0x0018 (0x0018 - 0x0000)
struct FAccountDataLobbyEmote final
{
public:
	class FString                                 LobbyEmoteId;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipSlotIndex;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsNew;                                             // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccountDataLobbyEmote) == 0x000008, "Wrong alignment on FAccountDataLobbyEmote");
static_assert(sizeof(FAccountDataLobbyEmote) == 0x000018, "Wrong size on FAccountDataLobbyEmote");
static_assert(offsetof(FAccountDataLobbyEmote, LobbyEmoteId) == 0x000000, "Member 'FAccountDataLobbyEmote::LobbyEmoteId' has a wrong offset!");
static_assert(offsetof(FAccountDataLobbyEmote, EquipSlotIndex) == 0x000010, "Member 'FAccountDataLobbyEmote::EquipSlotIndex' has a wrong offset!");
static_assert(offsetof(FAccountDataLobbyEmote, IsNew) == 0x000014, "Member 'FAccountDataLobbyEmote::IsNew' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCReligionSeasonInfo
// 0x0028 (0x0028 - 0x0000)
struct FDCReligionSeasonInfo final
{
public:
	class FString                                 SeasonId;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SeasonName;                                        // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCReligionSeasonInfo) == 0x000008, "Wrong alignment on FDCReligionSeasonInfo");
static_assert(sizeof(FDCReligionSeasonInfo) == 0x000028, "Wrong size on FDCReligionSeasonInfo");
static_assert(offsetof(FDCReligionSeasonInfo, SeasonId) == 0x000000, "Member 'FDCReligionSeasonInfo::SeasonId' has a wrong offset!");
static_assert(offsetof(FDCReligionSeasonInfo, SeasonName) == 0x000010, "Member 'FDCReligionSeasonInfo::SeasonName' has a wrong offset!");

// ScriptStruct DungeonCrawler.VoipUserData
// 0x0008 (0x0008 - 0x0000)
struct FVoipUserData final
{
public:
	uint8                                         Pad_2023[0x4];                                     // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReceiveVolume;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoipUserData) == 0x000004, "Wrong alignment on FVoipUserData");
static_assert(sizeof(FVoipUserData) == 0x000008, "Wrong size on FVoipUserData");
static_assert(offsetof(FVoipUserData, ReceiveVolume) == 0x000004, "Member 'FVoipUserData::ReceiveVolume' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgReLoginRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgReLoginRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2024[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReLoginRequest) == 0x000008, "Wrong alignment on FClientMsgReLoginRequest");
static_assert(sizeof(FClientMsgReLoginRequest) == 0x000028, "Wrong size on FClientMsgReLoginRequest");

// ScriptStruct DungeonCrawler.MsgAccountDataNotify
// 0x0108 (0x0120 - 0x0018)
struct FMsgAccountDataNotify final : public FMsgBase
{
public:
	struct FAccountData                           AccountData;                                       // 0x0018(0x0108)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountDataNotify) == 0x000008, "Wrong alignment on FMsgAccountDataNotify");
static_assert(sizeof(FMsgAccountDataNotify) == 0x000120, "Wrong size on FMsgAccountDataNotify");
static_assert(offsetof(FMsgAccountDataNotify, AccountData) == 0x000018, "Member 'FMsgAccountDataNotify::AccountData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountDataItemChangeRequest
// 0x00F0 (0x0108 - 0x0018)
struct FMsgAccountDataItemChangeRequest final : public FMsgBase
{
public:
	class FString                                 AccountId;                                         // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAccountDataItem                       AccountDataItem;                                   // 0x0028(0x00E0)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountDataItemChangeRequest) == 0x000008, "Wrong alignment on FMsgAccountDataItemChangeRequest");
static_assert(sizeof(FMsgAccountDataItemChangeRequest) == 0x000108, "Wrong size on FMsgAccountDataItemChangeRequest");
static_assert(offsetof(FMsgAccountDataItemChangeRequest, AccountId) == 0x000018, "Member 'FMsgAccountDataItemChangeRequest::AccountId' has a wrong offset!");
static_assert(offsetof(FMsgAccountDataItemChangeRequest, AccountDataItem) == 0x000028, "Member 'FMsgAccountDataItemChangeRequest::AccountDataItem' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgUpdateSoundDataEvent
// 0x0008 (0x0020 - 0x0018)
struct FMsgUpdateSoundDataEvent final : public FMsgBase
{
public:
	class USoundData*                             Data;                                              // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgUpdateSoundDataEvent) == 0x000008, "Wrong alignment on FMsgUpdateSoundDataEvent");
static_assert(sizeof(FMsgUpdateSoundDataEvent) == 0x000020, "Wrong size on FMsgUpdateSoundDataEvent");
static_assert(offsetof(FMsgUpdateSoundDataEvent, Data) == 0x000018, "Member 'FMsgUpdateSoundDataEvent::Data' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgBlockCharacterListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgBlockCharacterListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2025[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgBlockCharacterListRequest) == 0x000008, "Wrong alignment on FClientMsgBlockCharacterListRequest");
static_assert(sizeof(FClientMsgBlockCharacterListRequest) == 0x000028, "Wrong size on FClientMsgBlockCharacterListRequest");

// ScriptStruct DungeonCrawler.MsgAccountLinkResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgAccountLinkResponse final : public FMsgBase
{
public:
	class UAccountSession*                        AccountSession;                                    // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkResponse) == 0x000008, "Wrong alignment on FMsgAccountLinkResponse");
static_assert(sizeof(FMsgAccountLinkResponse) == 0x000020, "Wrong size on FMsgAccountLinkResponse");
static_assert(offsetof(FMsgAccountLinkResponse, AccountSession) == 0x000018, "Member 'FMsgAccountLinkResponse::AccountSession' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataPropsSkillCheck
// 0x0030 (0x0030 - 0x0000)
struct FDesignDataPropsSkillCheck final
{
public:
	struct FGameplayTag                           SkillCheckType;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDuration;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSkillCheckInterval;                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSkillCheckInterval;                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSucceedSectionStartTime;                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SucceedSectionSizeSeconds;                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SucceedBonusTimeRatio;                             // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectSucceedSectionSizeSeconds;                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectSucceedBonusTimeRatio;                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FailedBonusTimeRatio;                              // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataPropsSkillCheck) == 0x000004, "Wrong alignment on FDesignDataPropsSkillCheck");
static_assert(sizeof(FDesignDataPropsSkillCheck) == 0x000030, "Wrong size on FDesignDataPropsSkillCheck");
static_assert(offsetof(FDesignDataPropsSkillCheck, SkillCheckType) == 0x000000, "Member 'FDesignDataPropsSkillCheck::SkillCheckType' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsSkillCheck, MinDuration) == 0x000008, "Member 'FDesignDataPropsSkillCheck::MinDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsSkillCheck, MaxDuration) == 0x00000C, "Member 'FDesignDataPropsSkillCheck::MaxDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsSkillCheck, MinSkillCheckInterval) == 0x000010, "Member 'FDesignDataPropsSkillCheck::MinSkillCheckInterval' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsSkillCheck, MaxSkillCheckInterval) == 0x000014, "Member 'FDesignDataPropsSkillCheck::MaxSkillCheckInterval' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsSkillCheck, MinSucceedSectionStartTime) == 0x000018, "Member 'FDesignDataPropsSkillCheck::MinSucceedSectionStartTime' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsSkillCheck, SucceedSectionSizeSeconds) == 0x00001C, "Member 'FDesignDataPropsSkillCheck::SucceedSectionSizeSeconds' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsSkillCheck, SucceedBonusTimeRatio) == 0x000020, "Member 'FDesignDataPropsSkillCheck::SucceedBonusTimeRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsSkillCheck, PerfectSucceedSectionSizeSeconds) == 0x000024, "Member 'FDesignDataPropsSkillCheck::PerfectSucceedSectionSizeSeconds' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsSkillCheck, PerfectSucceedBonusTimeRatio) == 0x000028, "Member 'FDesignDataPropsSkillCheck::PerfectSucceedBonusTimeRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsSkillCheck, FailedBonusTimeRatio) == 0x00002C, "Member 'FDesignDataPropsSkillCheck::FailedBonusTimeRatio' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountSessionDataNotify
// 0x0118 (0x0130 - 0x0018)
struct FMsgAccountSessionDataNotify final : public FMsgBase
{
public:
	struct FAccountSessionData                    AccountSessionData;                                // 0x0018(0x0118)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountSessionDataNotify) == 0x000008, "Wrong alignment on FMsgAccountSessionDataNotify");
static_assert(sizeof(FMsgAccountSessionDataNotify) == 0x000130, "Wrong size on FMsgAccountSessionDataNotify");
static_assert(offsetof(FMsgAccountSessionDataNotify, AccountSessionData) == 0x000018, "Member 'FMsgAccountSessionDataNotify::AccountSessionData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassEquipInfoBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassEquipInfoBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassEquipInfoBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassEquipInfoBeginNotify");
static_assert(sizeof(FMsgWidgetClassEquipInfoBeginNotify) == 0x000018, "Wrong size on FMsgWidgetClassEquipInfoBeginNotify");

// ScriptStruct DungeonCrawler.ClientMsgMerchantExpressListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgMerchantExpressListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2026[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantExpressListResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantExpressListResponse");
static_assert(sizeof(FClientMsgMerchantExpressListResponse) == 0x000028, "Wrong size on FClientMsgMerchantExpressListResponse");

// ScriptStruct DungeonCrawler.MsgAccountSessionNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgAccountSessionNotify final : public FMsgBase
{
public:
	class UAccountSession*                        AccountSession;                                    // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountSessionNotify) == 0x000008, "Wrong alignment on FMsgAccountSessionNotify");
static_assert(sizeof(FMsgAccountSessionNotify) == 0x000020, "Wrong size on FMsgAccountSessionNotify");
static_assert(offsetof(FMsgAccountSessionNotify, AccountSession) == 0x000018, "Member 'FMsgAccountSessionNotify::AccountSession' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMetaLocationRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMetaLocationRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2027[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMetaLocationRequest) == 0x000008, "Wrong alignment on FClientMsgMetaLocationRequest");
static_assert(sizeof(FClientMsgMetaLocationRequest) == 0x000028, "Wrong size on FClientMsgMetaLocationRequest");

// ScriptStruct DungeonCrawler.ClientMsgOperateAnnounceNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgOperateAnnounceNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2028[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgOperateAnnounceNotify) == 0x000008, "Wrong alignment on FClientMsgOperateAnnounceNotify");
static_assert(sizeof(FClientMsgOperateAnnounceNotify) == 0x000028, "Wrong size on FClientMsgOperateAnnounceNotify");

// ScriptStruct DungeonCrawler.MsgWidgetContextMenuCloseNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetContextMenuCloseNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetContextMenuCloseNotify) == 0x000008, "Wrong alignment on FMsgWidgetContextMenuCloseNotify");
static_assert(sizeof(FMsgWidgetContextMenuCloseNotify) == 0x000018, "Wrong size on FMsgWidgetContextMenuCloseNotify");

// ScriptStruct DungeonCrawler.MsgAccountLinkAccountSessionDataResponse
// 0x0120 (0x0138 - 0x0018)
struct FMsgAccountLinkAccountSessionDataResponse final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAccountSessionData                    AccountSessionData;                                // 0x0020(0x0118)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkAccountSessionDataResponse) == 0x000008, "Wrong alignment on FMsgAccountLinkAccountSessionDataResponse");
static_assert(sizeof(FMsgAccountLinkAccountSessionDataResponse) == 0x000138, "Wrong size on FMsgAccountLinkAccountSessionDataResponse");
static_assert(offsetof(FMsgAccountLinkAccountSessionDataResponse, AccountLink) == 0x000018, "Member 'FMsgAccountLinkAccountSessionDataResponse::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkAccountSessionDataResponse, AccountSessionData) == 0x000020, "Member 'FMsgAccountLinkAccountSessionDataResponse::AccountSessionData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPartySessionDataNotify
// 0x0020 (0x0038 - 0x0018)
struct FMsgPartySessionDataNotify final : public FMsgBase
{
public:
	struct FPartySessionData                      PartySessionData;                                  // 0x0018(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPartySessionDataNotify) == 0x000008, "Wrong alignment on FMsgPartySessionDataNotify");
static_assert(sizeof(FMsgPartySessionDataNotify) == 0x000038, "Wrong size on FMsgPartySessionDataNotify");
static_assert(offsetof(FMsgPartySessionDataNotify, PartySessionData) == 0x000018, "Member 'FMsgPartySessionDataNotify::PartySessionData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgLatencyCheckNotify
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgLatencyCheckNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2029[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLatencyCheckNotify) == 0x000008, "Wrong alignment on FClientMsgLatencyCheckNotify");
static_assert(sizeof(FClientMsgLatencyCheckNotify) == 0x000030, "Wrong size on FClientMsgLatencyCheckNotify");

// ScriptStruct DungeonCrawler.MsgAccountLinkAccountDataReplicationNotify
// 0x0098 (0x00B0 - 0x0018)
struct FMsgAccountLinkAccountDataReplicationNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAccountDataReplication                AccountDataReplication;                            // 0x0020(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkAccountDataReplicationNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkAccountDataReplicationNotify");
static_assert(sizeof(FMsgAccountLinkAccountDataReplicationNotify) == 0x0000B0, "Wrong size on FMsgAccountLinkAccountDataReplicationNotify");
static_assert(offsetof(FMsgAccountLinkAccountDataReplicationNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkAccountDataReplicationNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkAccountDataReplicationNotify, AccountDataReplication) == 0x000020, "Member 'FMsgAccountLinkAccountDataReplicationNotify::AccountDataReplication' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountLinkPlayerControllerNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgAccountLinkPlayerControllerNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkPlayerControllerNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkPlayerControllerNotify");
static_assert(sizeof(FMsgAccountLinkPlayerControllerNotify) == 0x000028, "Wrong size on FMsgAccountLinkPlayerControllerNotify");
static_assert(offsetof(FMsgAccountLinkPlayerControllerNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkPlayerControllerNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkPlayerControllerNotify, PlayerController) == 0x000020, "Member 'FMsgAccountLinkPlayerControllerNotify::PlayerController' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSpellCastSucceed
// 0x0000 (0x0018 - 0x0018)
struct FMsgSpellCastSucceed final : public FMsgBase
{
};
static_assert(alignof(FMsgSpellCastSucceed) == 0x000008, "Wrong alignment on FMsgSpellCastSucceed");
static_assert(sizeof(FMsgSpellCastSucceed) == 0x000018, "Wrong size on FMsgSpellCastSucceed");

// ScriptStruct DungeonCrawler.ClientMsgClosedGameNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgClosedGameNotify final : public FMsgBase
{
public:
	uint8                                         Pad_202A[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClosedGameNotify) == 0x000008, "Wrong alignment on FClientMsgClosedGameNotify");
static_assert(sizeof(FClientMsgClosedGameNotify) == 0x000020, "Wrong size on FClientMsgClosedGameNotify");

// ScriptStruct DungeonCrawler.MsgAccountLinkPlayerPawnNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgAccountLinkPlayerPawnNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  PlayerPawn;                                        // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkPlayerPawnNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkPlayerPawnNotify");
static_assert(sizeof(FMsgAccountLinkPlayerPawnNotify) == 0x000028, "Wrong size on FMsgAccountLinkPlayerPawnNotify");
static_assert(offsetof(FMsgAccountLinkPlayerPawnNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkPlayerPawnNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkPlayerPawnNotify, PlayerPawn) == 0x000020, "Member 'FMsgAccountLinkPlayerPawnNotify::PlayerPawn' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataItemBundleInfoItem
// 0x0018 (0x0018 - 0x0000)
struct FDesignDataItemBundleInfoItem final
{
public:
	struct FPrimaryAssetId                        BundleArtData;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BundleGrade;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemMinCount;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemBundleInfoItem) == 0x000004, "Wrong alignment on FDesignDataItemBundleInfoItem");
static_assert(sizeof(FDesignDataItemBundleInfoItem) == 0x000018, "Wrong size on FDesignDataItemBundleInfoItem");
static_assert(offsetof(FDesignDataItemBundleInfoItem, BundleArtData) == 0x000000, "Member 'FDesignDataItemBundleInfoItem::BundleArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataItemBundleInfoItem, BundleGrade) == 0x000010, "Member 'FDesignDataItemBundleInfoItem::BundleGrade' has a wrong offset!");
static_assert(offsetof(FDesignDataItemBundleInfoItem, ItemMinCount) == 0x000014, "Member 'FDesignDataItemBundleInfoItem::ItemMinCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataItemBundleInfo
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataItemBundleInfo final
{
public:
	TArray<struct FDesignDataItemBundleInfoItem>  ItemBundleInfoItemArray;                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemBundleInfo) == 0x000008, "Wrong alignment on FDesignDataItemBundleInfo");
static_assert(sizeof(FDesignDataItemBundleInfo) == 0x000010, "Wrong size on FDesignDataItemBundleInfo");
static_assert(offsetof(FDesignDataItemBundleInfo, ItemBundleInfoItemArray) == 0x000000, "Member 'FDesignDataItemBundleInfo::ItemBundleInfoItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountLinkAttributeSetNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgAccountLinkAttributeSetNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAttributeSet*                        AttributeSet;                                      // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkAttributeSetNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkAttributeSetNotify");
static_assert(sizeof(FMsgAccountLinkAttributeSetNotify) == 0x000028, "Wrong size on FMsgAccountLinkAttributeSetNotify");
static_assert(offsetof(FMsgAccountLinkAttributeSetNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkAttributeSetNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkAttributeSetNotify, AttributeSet) == 0x000020, "Member 'FMsgAccountLinkAttributeSetNotify::AttributeSet' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetCommemorativePlaqueTextNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgWidgetCommemorativePlaqueTextNotify final : public FMsgBase
{
public:
	struct FPrimaryAssetId                        ScriptId;                                          // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0028(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetCommemorativePlaqueTextNotify) == 0x000008, "Wrong alignment on FMsgWidgetCommemorativePlaqueTextNotify");
static_assert(sizeof(FMsgWidgetCommemorativePlaqueTextNotify) == 0x000040, "Wrong size on FMsgWidgetCommemorativePlaqueTextNotify");
static_assert(offsetof(FMsgWidgetCommemorativePlaqueTextNotify, ScriptId) == 0x000018, "Member 'FMsgWidgetCommemorativePlaqueTextNotify::ScriptId' has a wrong offset!");
static_assert(offsetof(FMsgWidgetCommemorativePlaqueTextNotify, Location) == 0x000028, "Member 'FMsgWidgetCommemorativePlaqueTextNotify::Location' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyInviteAnswerResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyInviteAnswerResponse final : public FMsgBase
{
public:
	uint8                                         Pad_202B[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyInviteAnswerResponse) == 0x000008, "Wrong alignment on FClientMsgPartyInviteAnswerResponse");
static_assert(sizeof(FClientMsgPartyInviteAnswerResponse) == 0x000020, "Wrong size on FClientMsgPartyInviteAnswerResponse");

// ScriptStruct DungeonCrawler.MsgAccountLinkAttributeNotify
// 0x0478 (0x0490 - 0x0018)
struct FMsgAccountLinkAttributeNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCAttributeSet*                        AttributeSet;                                      // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0028(0x0038)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldValue;                                          // 0x0064(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0070(0x0420)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkAttributeNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkAttributeNotify");
static_assert(sizeof(FMsgAccountLinkAttributeNotify) == 0x000490, "Wrong size on FMsgAccountLinkAttributeNotify");
static_assert(offsetof(FMsgAccountLinkAttributeNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkAttributeNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkAttributeNotify, AttributeSet) == 0x000020, "Member 'FMsgAccountLinkAttributeNotify::AttributeSet' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkAttributeNotify, Attribute) == 0x000028, "Member 'FMsgAccountLinkAttributeNotify::Attribute' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkAttributeNotify, NewValue) == 0x000060, "Member 'FMsgAccountLinkAttributeNotify::NewValue' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkAttributeNotify, OldValue) == 0x000064, "Member 'FMsgAccountLinkAttributeNotify::OldValue' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkAttributeNotify, GameplayEffectClass) == 0x000068, "Member 'FMsgAccountLinkAttributeNotify::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkAttributeNotify, EffectContext) == 0x000070, "Member 'FMsgAccountLinkAttributeNotify::EffectContext' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgHackLogRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgHackLogRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_202C[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgHackLogRequest) == 0x000008, "Wrong alignment on FClientMsgHackLogRequest");
static_assert(sizeof(FClientMsgHackLogRequest) == 0x000030, "Wrong size on FClientMsgHackLogRequest");

// ScriptStruct DungeonCrawler.ClientMsgPartyLocationUpdateNotify
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgPartyLocationUpdateNotify final : public FMsgBase
{
public:
	uint8                                         Pad_202D[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyLocationUpdateNotify) == 0x000008, "Wrong alignment on FClientMsgPartyLocationUpdateNotify");
static_assert(sizeof(FClientMsgPartyLocationUpdateNotify) == 0x000040, "Wrong size on FClientMsgPartyLocationUpdateNotify");

// ScriptStruct DungeonCrawler.MsgAccountLinkGameplayTagContainerNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgAccountLinkGameplayTagContainerNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayTagContainer;                              // 0x0020(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkGameplayTagContainerNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkGameplayTagContainerNotify");
static_assert(sizeof(FMsgAccountLinkGameplayTagContainerNotify) == 0x000040, "Wrong size on FMsgAccountLinkGameplayTagContainerNotify");
static_assert(offsetof(FMsgAccountLinkGameplayTagContainerNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkGameplayTagContainerNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkGameplayTagContainerNotify, GameplayTagContainer) == 0x000020, "Member 'FMsgAccountLinkGameplayTagContainerNotify::GameplayTagContainer' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantRecoveryBuyRequest
// 0x0028 (0x0048 - 0x0020)
struct FClientMsgMerchantRecoveryBuyRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_202E[0x28];                                    // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantRecoveryBuyRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantRecoveryBuyRequest");
static_assert(sizeof(FClientMsgMerchantRecoveryBuyRequest) == 0x000048, "Wrong size on FClientMsgMerchantRecoveryBuyRequest");

// ScriptStruct DungeonCrawler.ClientMsgGmEnterGameSpectatorResponse
// 0x0040 (0x0058 - 0x0018)
struct FClientMsgGmEnterGameSpectatorResponse final : public FMsgBase
{
public:
	uint8                                         Pad_202F[0x40];                                    // 0x0018(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGmEnterGameSpectatorResponse) == 0x000008, "Wrong alignment on FClientMsgGmEnterGameSpectatorResponse");
static_assert(sizeof(FClientMsgGmEnterGameSpectatorResponse) == 0x000058, "Wrong size on FClientMsgGmEnterGameSpectatorResponse");

// ScriptStruct DungeonCrawler.MsgAccountLinkGameplayTagNotify
// 0x0038 (0x0050 - 0x0018)
struct FMsgAccountLinkGameplayTagNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayTagContainer;                              // 0x0020(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0040(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2030[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgAccountLinkGameplayTagNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkGameplayTagNotify");
static_assert(sizeof(FMsgAccountLinkGameplayTagNotify) == 0x000050, "Wrong size on FMsgAccountLinkGameplayTagNotify");
static_assert(offsetof(FMsgAccountLinkGameplayTagNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkGameplayTagNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkGameplayTagNotify, GameplayTagContainer) == 0x000020, "Member 'FMsgAccountLinkGameplayTagNotify::GameplayTagContainer' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkGameplayTagNotify, GameplayTag) == 0x000040, "Member 'FMsgAccountLinkGameplayTagNotify::GameplayTag' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkGameplayTagNotify, Count) == 0x000048, "Member 'FMsgAccountLinkGameplayTagNotify::Count' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantExpressListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMerchantExpressListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2031[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantExpressListRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantExpressListRequest");
static_assert(sizeof(FClientMsgMerchantExpressListRequest) == 0x000028, "Wrong size on FClientMsgMerchantExpressListRequest");

// ScriptStruct DungeonCrawler.ActorStatusData
// 0x0020 (0x0020 - 0x0000)
struct FActorStatusData final
{
public:
	struct FActiveGameplayEffectHandle            EffectHandle;                                      // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartServerWorldTime;                              // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2032[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorStatusData) == 0x000008, "Wrong alignment on FActorStatusData");
static_assert(sizeof(FActorStatusData) == 0x000020, "Wrong size on FActorStatusData");
static_assert(offsetof(FActorStatusData, EffectHandle) == 0x000000, "Member 'FActorStatusData::EffectHandle' has a wrong offset!");
static_assert(offsetof(FActorStatusData, GameplayEffectClass) == 0x000008, "Member 'FActorStatusData::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FActorStatusData, StackCount) == 0x000010, "Member 'FActorStatusData::StackCount' has a wrong offset!");
static_assert(offsetof(FActorStatusData, StartServerWorldTime) == 0x000014, "Member 'FActorStatusData::StartServerWorldTime' has a wrong offset!");
static_assert(offsetof(FActorStatusData, MaxDuration) == 0x000018, "Member 'FActorStatusData::MaxDuration' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountLinkActorStatusNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgAccountLinkActorStatusNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActorStatusData>               ActorStatusDatas;                                  // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkActorStatusNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkActorStatusNotify");
static_assert(sizeof(FMsgAccountLinkActorStatusNotify) == 0x000030, "Wrong size on FMsgAccountLinkActorStatusNotify");
static_assert(offsetof(FMsgAccountLinkActorStatusNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkActorStatusNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkActorStatusNotify, ActorStatusDatas) == 0x000020, "Member 'FMsgAccountLinkActorStatusNotify::ActorStatusDatas' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataAbilityRelationshipTagGroupItem
// 0x0058 (0x0058 - 0x0000)
struct FDesignDataAbilityRelationshipTagGroupItem final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   AbilityTagsToBlock;                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   AbilityTagsToCancel;                               // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ActivationRequiredTags;                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ActivationBlockedTags;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ActivationCancelingTags;                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataAbilityRelationshipTagGroupItem) == 0x000008, "Wrong alignment on FDesignDataAbilityRelationshipTagGroupItem");
static_assert(sizeof(FDesignDataAbilityRelationshipTagGroupItem) == 0x000058, "Wrong size on FDesignDataAbilityRelationshipTagGroupItem");
static_assert(offsetof(FDesignDataAbilityRelationshipTagGroupItem, AbilityTag) == 0x000000, "Member 'FDesignDataAbilityRelationshipTagGroupItem::AbilityTag' has a wrong offset!");
static_assert(offsetof(FDesignDataAbilityRelationshipTagGroupItem, AbilityTagsToBlock) == 0x000008, "Member 'FDesignDataAbilityRelationshipTagGroupItem::AbilityTagsToBlock' has a wrong offset!");
static_assert(offsetof(FDesignDataAbilityRelationshipTagGroupItem, AbilityTagsToCancel) == 0x000018, "Member 'FDesignDataAbilityRelationshipTagGroupItem::AbilityTagsToCancel' has a wrong offset!");
static_assert(offsetof(FDesignDataAbilityRelationshipTagGroupItem, ActivationRequiredTags) == 0x000028, "Member 'FDesignDataAbilityRelationshipTagGroupItem::ActivationRequiredTags' has a wrong offset!");
static_assert(offsetof(FDesignDataAbilityRelationshipTagGroupItem, ActivationBlockedTags) == 0x000038, "Member 'FDesignDataAbilityRelationshipTagGroupItem::ActivationBlockedTags' has a wrong offset!");
static_assert(offsetof(FDesignDataAbilityRelationshipTagGroupItem, ActivationCancelingTags) == 0x000048, "Member 'FDesignDataAbilityRelationshipTagGroupItem::ActivationCancelingTags' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPlayerTargetNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgPlayerTargetNotify final : public FMsgBase
{
public:
	class FString                                 AccountId;                                         // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPlayerTargetNotify) == 0x000008, "Wrong alignment on FMsgPlayerTargetNotify");
static_assert(sizeof(FMsgPlayerTargetNotify) == 0x000028, "Wrong size on FMsgPlayerTargetNotify");
static_assert(offsetof(FMsgPlayerTargetNotify, AccountId) == 0x000018, "Member 'FMsgPlayerTargetNotify::AccountId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgWhisperChatNotify
// 0x0088 (0x00A0 - 0x0018)
struct FClientMsgWhisperChatNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2033[0x88];                                    // 0x0018(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgWhisperChatNotify) == 0x000008, "Wrong alignment on FClientMsgWhisperChatNotify");
static_assert(sizeof(FClientMsgWhisperChatNotify) == 0x0000A0, "Wrong size on FClientMsgWhisperChatNotify");

// ScriptStruct DungeonCrawler.MsgAccountLinkEquipmentInventoryNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgAccountLinkEquipmentInventoryNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEquipmentInventoryComponent*           EquipmentInventory;                                // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkEquipmentInventoryNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkEquipmentInventoryNotify");
static_assert(sizeof(FMsgAccountLinkEquipmentInventoryNotify) == 0x000028, "Wrong size on FMsgAccountLinkEquipmentInventoryNotify");
static_assert(offsetof(FMsgAccountLinkEquipmentInventoryNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkEquipmentInventoryNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkEquipmentInventoryNotify, EquipmentInventory) == 0x000020, "Member 'FMsgAccountLinkEquipmentInventoryNotify::EquipmentInventory' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCSteamAuthTicket
// 0x0018 (0x0018 - 0x0000)
struct FDCSteamAuthTicket final
{
public:
	class FString                                 SessionTicket;                                     // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSteamSystem;                                   // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2034[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LocalSteamBuildId;                                 // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCSteamAuthTicket) == 0x000008, "Wrong alignment on FDCSteamAuthTicket");
static_assert(sizeof(FDCSteamAuthTicket) == 0x000018, "Wrong size on FDCSteamAuthTicket");
static_assert(offsetof(FDCSteamAuthTicket, SessionTicket) == 0x000000, "Member 'FDCSteamAuthTicket::SessionTicket' has a wrong offset!");
static_assert(offsetof(FDCSteamAuthTicket, bUseSteamSystem) == 0x000010, "Member 'FDCSteamAuthTicket::bUseSteamSystem' has a wrong offset!");
static_assert(offsetof(FDCSteamAuthTicket, LocalSteamBuildId) == 0x000014, "Member 'FDCSteamAuthTicket::LocalSteamBuildId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgChatHackReportRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgChatHackReportRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2035[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgChatHackReportRequest) == 0x000008, "Wrong alignment on FClientMsgChatHackReportRequest");
static_assert(sizeof(FClientMsgChatHackReportRequest) == 0x000038, "Wrong size on FClientMsgChatHackReportRequest");

// ScriptStruct DungeonCrawler.MsgAccountLinkContainerInventoryNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgAccountLinkContainerInventoryNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryComponent*                    OldInventory;                                      // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryComponent*                    NewInventory;                                      // 0x0028(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkContainerInventoryNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkContainerInventoryNotify");
static_assert(sizeof(FMsgAccountLinkContainerInventoryNotify) == 0x000030, "Wrong size on FMsgAccountLinkContainerInventoryNotify");
static_assert(offsetof(FMsgAccountLinkContainerInventoryNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkContainerInventoryNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkContainerInventoryNotify, OldInventory) == 0x000020, "Member 'FMsgAccountLinkContainerInventoryNotify::OldInventory' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkContainerInventoryNotify, NewInventory) == 0x000028, "Member 'FMsgAccountLinkContainerInventoryNotify::NewInventory' has a wrong offset!");

// ScriptStruct DungeonCrawler.AggroInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAggroInfo final
{
public:
	uint8                                         Pad_2036[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAggroInfo) == 0x000008, "Wrong alignment on FAggroInfo");
static_assert(sizeof(FAggroInfo) == 0x000010, "Wrong size on FAggroInfo");

// ScriptStruct DungeonCrawler.MsgAccountLinkLootComponentNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgAccountLinkLootComponentNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULootComponent*                         OldLootComponent;                                  // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULootComponent*                         NewLootComponent;                                  // 0x0028(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkLootComponentNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkLootComponentNotify");
static_assert(sizeof(FMsgAccountLinkLootComponentNotify) == 0x000030, "Wrong size on FMsgAccountLinkLootComponentNotify");
static_assert(offsetof(FMsgAccountLinkLootComponentNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkLootComponentNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkLootComponentNotify, OldLootComponent) == 0x000020, "Member 'FMsgAccountLinkLootComponentNotify::OldLootComponent' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkLootComponentNotify, NewLootComponent) == 0x000028, "Member 'FMsgAccountLinkLootComponentNotify::NewLootComponent' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyRegionChangeNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyRegionChangeNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2037[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyRegionChangeNotify) == 0x000008, "Wrong alignment on FClientMsgPartyRegionChangeNotify");
static_assert(sizeof(FClientMsgPartyRegionChangeNotify) == 0x000020, "Wrong size on FClientMsgPartyRegionChangeNotify");

// ScriptStruct DungeonCrawler.MsgAccountLinkLootingTargetPlayerEquipmentInventoryNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgAccountLinkLootingTargetPlayerEquipmentInventoryNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEquipmentInventoryComponent*           EquipmentInventory;                                // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkLootingTargetPlayerEquipmentInventoryNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkLootingTargetPlayerEquipmentInventoryNotify");
static_assert(sizeof(FMsgAccountLinkLootingTargetPlayerEquipmentInventoryNotify) == 0x000028, "Wrong size on FMsgAccountLinkLootingTargetPlayerEquipmentInventoryNotify");
static_assert(offsetof(FMsgAccountLinkLootingTargetPlayerEquipmentInventoryNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkLootingTargetPlayerEquipmentInventoryNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkLootingTargetPlayerEquipmentInventoryNotify, EquipmentInventory) == 0x000020, "Member 'FMsgAccountLinkLootingTargetPlayerEquipmentInventoryNotify::EquipmentInventory' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgUserCharacterInfoResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgUserCharacterInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2038[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgUserCharacterInfoResponse) == 0x000008, "Wrong alignment on FClientMsgUserCharacterInfoResponse");
static_assert(sizeof(FClientMsgUserCharacterInfoResponse) == 0x000020, "Wrong size on FClientMsgUserCharacterInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgTrainingInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTrainingInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2039[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTrainingInfoRequest) == 0x000008, "Wrong alignment on FClientMsgTrainingInfoRequest");
static_assert(sizeof(FClientMsgTrainingInfoRequest) == 0x000028, "Wrong size on FClientMsgTrainingInfoRequest");

// ScriptStruct DungeonCrawler.MsgWidgetClassRemoveEquipSkillNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassRemoveEquipSkillNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkillId;                                           // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_203A[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassRemoveEquipSkillNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassRemoveEquipSkillNotify");
static_assert(sizeof(FMsgWidgetClassRemoveEquipSkillNotify) == 0x000030, "Wrong size on FMsgWidgetClassRemoveEquipSkillNotify");
static_assert(offsetof(FMsgWidgetClassRemoveEquipSkillNotify, Index) == 0x000018, "Member 'FMsgWidgetClassRemoveEquipSkillNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassRemoveEquipSkillNotify, SkillId) == 0x00001C, "Member 'FMsgWidgetClassRemoveEquipSkillNotify::SkillId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountLinkPerkIdArrayNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgAccountLinkPerkIdArrayNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                OldPerkIdArray;                                    // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                NewPerkIdArray;                                    // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkPerkIdArrayNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkPerkIdArrayNotify");
static_assert(sizeof(FMsgAccountLinkPerkIdArrayNotify) == 0x000040, "Wrong size on FMsgAccountLinkPerkIdArrayNotify");
static_assert(offsetof(FMsgAccountLinkPerkIdArrayNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkPerkIdArrayNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkPerkIdArrayNotify, OldPerkIdArray) == 0x000020, "Member 'FMsgAccountLinkPerkIdArrayNotify::OldPerkIdArray' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkPerkIdArrayNotify, NewPerkIdArray) == 0x000030, "Member 'FMsgAccountLinkPerkIdArrayNotify::NewPerkIdArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountLinkSkillIdArrayNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgAccountLinkSkillIdArrayNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                OldSkillIdArray;                                   // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                NewSkillIdArray;                                   // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkSkillIdArrayNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkSkillIdArrayNotify");
static_assert(sizeof(FMsgAccountLinkSkillIdArrayNotify) == 0x000040, "Wrong size on FMsgAccountLinkSkillIdArrayNotify");
static_assert(offsetof(FMsgAccountLinkSkillIdArrayNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkSkillIdArrayNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkSkillIdArrayNotify, OldSkillIdArray) == 0x000020, "Member 'FMsgAccountLinkSkillIdArrayNotify::OldSkillIdArray' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkSkillIdArrayNotify, NewSkillIdArray) == 0x000030, "Member 'FMsgAccountLinkSkillIdArrayNotify::NewSkillIdArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMonster
// 0x00C0 (0x00C0 - 0x0000)
struct FDesignDataMonster final
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ClassType;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GradeType;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   CharacterTypes;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        LootDropGroup;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADCMonsterBase>             ActorClass;                                        // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                HitTagQueryData;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                BeHitTagQueryData;                                 // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AdvPoint;                                          // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpPoint;                                          // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMonster) == 0x000008, "Wrong alignment on FDesignDataMonster");
static_assert(sizeof(FDesignDataMonster) == 0x0000C0, "Wrong size on FDesignDataMonster");
static_assert(offsetof(FDesignDataMonster, IdTag) == 0x000000, "Member 'FDesignDataMonster::IdTag' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, ClassType) == 0x000008, "Member 'FDesignDataMonster::ClassType' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, GradeType) == 0x000010, "Member 'FDesignDataMonster::GradeType' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, CharacterTypes) == 0x000018, "Member 'FDesignDataMonster::CharacterTypes' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, Name) == 0x000028, "Member 'FDesignDataMonster::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, LootDropGroup) == 0x000040, "Member 'FDesignDataMonster::LootDropGroup' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, ArtData) == 0x000050, "Member 'FDesignDataMonster::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, SoundData) == 0x000060, "Member 'FDesignDataMonster::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, ActorClass) == 0x000070, "Member 'FDesignDataMonster::ActorClass' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, HitTagQueryData) == 0x000078, "Member 'FDesignDataMonster::HitTagQueryData' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, BeHitTagQueryData) == 0x000088, "Member 'FDesignDataMonster::BeHitTagQueryData' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, Abilities) == 0x000098, "Member 'FDesignDataMonster::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, Effects) == 0x0000A8, "Member 'FDesignDataMonster::Effects' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, AdvPoint) == 0x0000B8, "Member 'FDesignDataMonster::AdvPoint' has a wrong offset!");
static_assert(offsetof(FDesignDataMonster, ExpPoint) == 0x0000BC, "Member 'FDesignDataMonster::ExpPoint' has a wrong offset!");

// ScriptStruct DungeonCrawler.LoginWidgetHandleData
// 0x0001 (0x0001 - 0x0000)
struct FLoginWidgetHandleData final
{
public:
	EAgeRatingType                                AgeRatingType;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoginWidgetHandleData) == 0x000001, "Wrong alignment on FLoginWidgetHandleData");
static_assert(sizeof(FLoginWidgetHandleData) == 0x000001, "Wrong size on FLoginWidgetHandleData");
static_assert(offsetof(FLoginWidgetHandleData, AgeRatingType) == 0x000000, "Member 'FLoginWidgetHandleData::AgeRatingType' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPlatformLinkFaqUrlRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgPlatformLinkFaqUrlRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_203B[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPlatformLinkFaqUrlRequest) == 0x000008, "Wrong alignment on FClientMsgPlatformLinkFaqUrlRequest");
static_assert(sizeof(FClientMsgPlatformLinkFaqUrlRequest) == 0x000028, "Wrong size on FClientMsgPlatformLinkFaqUrlRequest");

// ScriptStruct DungeonCrawler.MsgAccountLinkSpellIdArrayNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgAccountLinkSpellIdArrayNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                OldSpellIdArray;                                   // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                NewSpellIdArray;                                   // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkSpellIdArrayNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkSpellIdArrayNotify");
static_assert(sizeof(FMsgAccountLinkSpellIdArrayNotify) == 0x000040, "Wrong size on FMsgAccountLinkSpellIdArrayNotify");
static_assert(offsetof(FMsgAccountLinkSpellIdArrayNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkSpellIdArrayNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkSpellIdArrayNotify, OldSpellIdArray) == 0x000020, "Member 'FMsgAccountLinkSpellIdArrayNotify::OldSpellIdArray' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkSpellIdArrayNotify, NewSpellIdArray) == 0x000030, "Member 'FMsgAccountLinkSpellIdArrayNotify::NewSpellIdArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountLinkPartySessionDataNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgAccountLinkPartySessionDataNotify final : public FMsgBase
{
public:
	class UAccountLink*                           AccountLink;                                       // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPartySessionData                      PartySessionData;                                  // 0x0020(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkPartySessionDataNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkPartySessionDataNotify");
static_assert(sizeof(FMsgAccountLinkPartySessionDataNotify) == 0x000040, "Wrong size on FMsgAccountLinkPartySessionDataNotify");
static_assert(offsetof(FMsgAccountLinkPartySessionDataNotify, AccountLink) == 0x000018, "Member 'FMsgAccountLinkPartySessionDataNotify::AccountLink' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkPartySessionDataNotify, PartySessionData) == 0x000020, "Member 'FMsgAccountLinkPartySessionDataNotify::PartySessionData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemDataGameplayEffectValue
// 0x000C (0x000C - 0x0000)
struct FItemDataGameplayEffectValue final
{
public:
	struct FGameplayTag                           EffectTag;                                         // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectValue;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDataGameplayEffectValue) == 0x000004, "Wrong alignment on FItemDataGameplayEffectValue");
static_assert(sizeof(FItemDataGameplayEffectValue) == 0x00000C, "Wrong size on FItemDataGameplayEffectValue");
static_assert(offsetof(FItemDataGameplayEffectValue, EffectTag) == 0x000000, "Member 'FItemDataGameplayEffectValue::EffectTag' has a wrong offset!");
static_assert(offsetof(FItemDataGameplayEffectValue, EffectValue) == 0x000008, "Member 'FItemDataGameplayEffectValue::EffectValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemDataGameplayEffect
// 0x0020 (0x0020 - 0x0000)
struct FItemDataGameplayEffect final
{
public:
	struct FPrimaryAssetId                        EffectId;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemDataGameplayEffectValue>   ItemDataGameplayEffectValueArray;                  // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDataGameplayEffect) == 0x000008, "Wrong alignment on FItemDataGameplayEffect");
static_assert(sizeof(FItemDataGameplayEffect) == 0x000020, "Wrong size on FItemDataGameplayEffect");
static_assert(offsetof(FItemDataGameplayEffect, EffectId) == 0x000000, "Member 'FItemDataGameplayEffect::EffectId' has a wrong offset!");
static_assert(offsetof(FItemDataGameplayEffect, ItemDataGameplayEffectValueArray) == 0x000010, "Member 'FItemDataGameplayEffect::ItemDataGameplayEffectValueArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemDataGameplayAbility
// 0x0020 (0x0020 - 0x0000)
struct FItemDataGameplayAbility final
{
public:
	struct FPrimaryAssetId                        AbilityId;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemDataGameplayEffect>        ItemDataGameplayEffectArray;                       // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDataGameplayAbility) == 0x000008, "Wrong alignment on FItemDataGameplayAbility");
static_assert(sizeof(FItemDataGameplayAbility) == 0x000020, "Wrong size on FItemDataGameplayAbility");
static_assert(offsetof(FItemDataGameplayAbility, AbilityId) == 0x000000, "Member 'FItemDataGameplayAbility::AbilityId' has a wrong offset!");
static_assert(offsetof(FItemDataGameplayAbility, ItemDataGameplayEffectArray) == 0x000010, "Member 'FItemDataGameplayAbility::ItemDataGameplayEffectArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTrainingReceiveClassAbilityRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgTrainingReceiveClassAbilityRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_203C[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTrainingReceiveClassAbilityRequest) == 0x000008, "Wrong alignment on FClientMsgTrainingReceiveClassAbilityRequest");
static_assert(sizeof(FClientMsgTrainingReceiveClassAbilityRequest) == 0x000030, "Wrong size on FClientMsgTrainingReceiveClassAbilityRequest");

// ScriptStruct DungeonCrawler.MsgAccountLinkAllAccountDataReplicationNotify
// 0x0120 (0x0138 - 0x0018)
struct FMsgAccountLinkAllAccountDataReplicationNotify final : public FMsgBase
{
public:
	struct FAccountDataReplication                AccountDataReplication;                            // 0x0018(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAccountDataReplication                OldAccountDataReplication;                         // 0x00A8(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountLinkAllAccountDataReplicationNotify) == 0x000008, "Wrong alignment on FMsgAccountLinkAllAccountDataReplicationNotify");
static_assert(sizeof(FMsgAccountLinkAllAccountDataReplicationNotify) == 0x000138, "Wrong size on FMsgAccountLinkAllAccountDataReplicationNotify");
static_assert(offsetof(FMsgAccountLinkAllAccountDataReplicationNotify, AccountDataReplication) == 0x000018, "Member 'FMsgAccountLinkAllAccountDataReplicationNotify::AccountDataReplication' has a wrong offset!");
static_assert(offsetof(FMsgAccountLinkAllAccountDataReplicationNotify, OldAccountDataReplication) == 0x0000A8, "Member 'FMsgAccountLinkAllAccountDataReplicationNotify::OldAccountDataReplication' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCReportedInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCReportedInfo final
{
public:
	struct FDCAccountId                           TargetAccountId;                                   // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCReportPlayerCategory                       ReportCategory;                                    // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_203D[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReportCount;                                       // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCReportedInfo) == 0x000008, "Wrong alignment on FDCReportedInfo");
static_assert(sizeof(FDCReportedInfo) == 0x000018, "Wrong size on FDCReportedInfo");
static_assert(offsetof(FDCReportedInfo, TargetAccountId) == 0x000000, "Member 'FDCReportedInfo::TargetAccountId' has a wrong offset!");
static_assert(offsetof(FDCReportedInfo, ReportCategory) == 0x000010, "Member 'FDCReportedInfo::ReportCategory' has a wrong offset!");
static_assert(offsetof(FDCReportedInfo, ReportCount) == 0x000014, "Member 'FDCReportedInfo::ReportCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCQuestContentInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCQuestContentInfo final
{
public:
	class UDCQuestContentDataAsset*               QuestContentData;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuestContentCount;                                 // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuestContentStartingCount;                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsQuestCountChange;                               // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_203E[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCQuestContentInfo) == 0x000008, "Wrong alignment on FDCQuestContentInfo");
static_assert(sizeof(FDCQuestContentInfo) == 0x000018, "Wrong size on FDCQuestContentInfo");
static_assert(offsetof(FDCQuestContentInfo, QuestContentData) == 0x000000, "Member 'FDCQuestContentInfo::QuestContentData' has a wrong offset!");
static_assert(offsetof(FDCQuestContentInfo, QuestContentCount) == 0x000008, "Member 'FDCQuestContentInfo::QuestContentCount' has a wrong offset!");
static_assert(offsetof(FDCQuestContentInfo, QuestContentStartingCount) == 0x00000C, "Member 'FDCQuestContentInfo::QuestContentStartingCount' has a wrong offset!");
static_assert(offsetof(FDCQuestContentInfo, bIsQuestCountChange) == 0x000010, "Member 'FDCQuestContentInfo::bIsQuestCountChange' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCQuestInfo
// 0x0050 (0x0050 - 0x0000)
struct FDCQuestInfo final
{
public:
	class UDCQuestDataAsset*                      QuestData;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCQuestState                                 State;                                             // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_203F[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QuestChapterId;                                    // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MerchantId;                                        // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2040[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCQuestContentInfo>            QuestContentInfoArray;                             // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          AlreadyGetAffinity;                                // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2041[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCQuestInfo) == 0x000008, "Wrong alignment on FDCQuestInfo");
static_assert(sizeof(FDCQuestInfo) == 0x000050, "Wrong size on FDCQuestInfo");
static_assert(offsetof(FDCQuestInfo, QuestData) == 0x000000, "Member 'FDCQuestInfo::QuestData' has a wrong offset!");
static_assert(offsetof(FDCQuestInfo, State) == 0x000008, "Member 'FDCQuestInfo::State' has a wrong offset!");
static_assert(offsetof(FDCQuestInfo, QuestChapterId) == 0x000010, "Member 'FDCQuestInfo::QuestChapterId' has a wrong offset!");
static_assert(offsetof(FDCQuestInfo, MerchantId) == 0x000020, "Member 'FDCQuestInfo::MerchantId' has a wrong offset!");
static_assert(offsetof(FDCQuestInfo, Order) == 0x000030, "Member 'FDCQuestInfo::Order' has a wrong offset!");
static_assert(offsetof(FDCQuestInfo, QuestContentInfoArray) == 0x000038, "Member 'FDCQuestInfo::QuestContentInfoArray' has a wrong offset!");
static_assert(offsetof(FDCQuestInfo, AlreadyGetAffinity) == 0x000048, "Member 'FDCQuestInfo::AlreadyGetAffinity' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCIngameUser
// 0x0368 (0x0368 - 0x0000)
struct FDCIngameUser final
{
public:
	uint8                                         Pad_2042[0xF0];                                    // 0x0000(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCCharacterSkinDataAsset*              CharacterSkin;                                     // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDCItemSkinDataAsset*>           ItemSkins;                                         // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UDCArmorSkinDataAsset*>          ArmorSkins;                                        // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<int32, class UDCEmoteDataAsset*>         Emotes;                                            // 0x0118(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UDCActionSkinDataAsset*>         ActionSkins;                                       // 0x0168(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCReportedInfo>                ReportedInfoArray;                                 // 0x0178(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2043[0xD0];                                    // 0x0188(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCDungeonModuleDataAsset*              DungeonModuleData;                                 // 0x0258(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDCQuestInfo>                   Quests;                                            // 0x0260(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCQuestInfo>                   LastQuests;                                        // 0x0270(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2044[0xE8];                                    // 0x0280(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCIngameUser) == 0x000008, "Wrong alignment on FDCIngameUser");
static_assert(sizeof(FDCIngameUser) == 0x000368, "Wrong size on FDCIngameUser");
static_assert(offsetof(FDCIngameUser, CharacterSkin) == 0x0000F0, "Member 'FDCIngameUser::CharacterSkin' has a wrong offset!");
static_assert(offsetof(FDCIngameUser, ItemSkins) == 0x0000F8, "Member 'FDCIngameUser::ItemSkins' has a wrong offset!");
static_assert(offsetof(FDCIngameUser, ArmorSkins) == 0x000108, "Member 'FDCIngameUser::ArmorSkins' has a wrong offset!");
static_assert(offsetof(FDCIngameUser, Emotes) == 0x000118, "Member 'FDCIngameUser::Emotes' has a wrong offset!");
static_assert(offsetof(FDCIngameUser, ActionSkins) == 0x000168, "Member 'FDCIngameUser::ActionSkins' has a wrong offset!");
static_assert(offsetof(FDCIngameUser, ReportedInfoArray) == 0x000178, "Member 'FDCIngameUser::ReportedInfoArray' has a wrong offset!");
static_assert(offsetof(FDCIngameUser, DungeonModuleData) == 0x000258, "Member 'FDCIngameUser::DungeonModuleData' has a wrong offset!");
static_assert(offsetof(FDCIngameUser, Quests) == 0x000260, "Member 'FDCIngameUser::Quests' has a wrong offset!");
static_assert(offsetof(FDCIngameUser, LastQuests) == 0x000270, "Member 'FDCIngameUser::LastQuests' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAccountExitReasonRequest
// 0x0028 (0x0040 - 0x0018)
struct FMsgAccountExitReasonRequest final : public FMsgBase
{
public:
	class FString                                 AccountId;                                         // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedBlock;                                        // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedHWBlock;                                      // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2045[0x2];                                     // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BlockTimeMin;                                      // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAccountExitReasonRequest) == 0x000008, "Wrong alignment on FMsgAccountExitReasonRequest");
static_assert(sizeof(FMsgAccountExitReasonRequest) == 0x000040, "Wrong size on FMsgAccountExitReasonRequest");
static_assert(offsetof(FMsgAccountExitReasonRequest, AccountId) == 0x000018, "Member 'FMsgAccountExitReasonRequest::AccountId' has a wrong offset!");
static_assert(offsetof(FMsgAccountExitReasonRequest, Reason) == 0x000028, "Member 'FMsgAccountExitReasonRequest::Reason' has a wrong offset!");
static_assert(offsetof(FMsgAccountExitReasonRequest, bNeedBlock) == 0x000038, "Member 'FMsgAccountExitReasonRequest::bNeedBlock' has a wrong offset!");
static_assert(offsetof(FMsgAccountExitReasonRequest, bNeedHWBlock) == 0x000039, "Member 'FMsgAccountExitReasonRequest::bNeedHWBlock' has a wrong offset!");
static_assert(offsetof(FMsgAccountExitReasonRequest, BlockTimeMin) == 0x00003C, "Member 'FMsgAccountExitReasonRequest::BlockTimeMin' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgUserHwInfoRequest
// 0x0080 (0x00A0 - 0x0020)
struct FClientMsgUserHwInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2046[0x80];                                    // 0x0020(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgUserHwInfoRequest) == 0x000008, "Wrong alignment on FClientMsgUserHwInfoRequest");
static_assert(sizeof(FClientMsgUserHwInfoRequest) == 0x0000A0, "Wrong size on FClientMsgUserHwInfoRequest");

// ScriptStruct DungeonCrawler.MsgWidgetClassAddEquipSkillNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassAddEquipSkillNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkillId;                                           // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2047[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassAddEquipSkillNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassAddEquipSkillNotify");
static_assert(sizeof(FMsgWidgetClassAddEquipSkillNotify) == 0x000030, "Wrong size on FMsgWidgetClassAddEquipSkillNotify");
static_assert(offsetof(FMsgWidgetClassAddEquipSkillNotify, Index) == 0x000018, "Member 'FMsgWidgetClassAddEquipSkillNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassAddEquipSkillNotify, SkillId) == 0x00001C, "Member 'FMsgWidgetClassAddEquipSkillNotify::SkillId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgActorAttachmentChangedNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgActorAttachmentChangedNotify final : public FMsgBase
{
public:
	class USceneComponent*                        AttachParentComponent;                             // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgActorAttachmentChangedNotify) == 0x000008, "Wrong alignment on FMsgActorAttachmentChangedNotify");
static_assert(sizeof(FMsgActorAttachmentChangedNotify) == 0x000020, "Wrong size on FMsgActorAttachmentChangedNotify");
static_assert(offsetof(FMsgActorAttachmentChangedNotify, AttachParentComponent) == 0x000018, "Member 'FMsgActorAttachmentChangedNotify::AttachParentComponent' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCEquipAnimData
// 0x02D0 (0x02D0 - 0x0000)
struct FDCEquipAnimData final
{
public:
	struct FDCItemInfo                            PrimaryItem;                                       // 0x0000(0x0168)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCItemInfo                            SecondaryItem;                                     // 0x0168(0x0168)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCEquipAnimData) == 0x000008, "Wrong alignment on FDCEquipAnimData");
static_assert(sizeof(FDCEquipAnimData) == 0x0002D0, "Wrong size on FDCEquipAnimData");
static_assert(offsetof(FDCEquipAnimData, PrimaryItem) == 0x000000, "Member 'FDCEquipAnimData::PrimaryItem' has a wrong offset!");
static_assert(offsetof(FDCEquipAnimData, SecondaryItem) == 0x000168, "Member 'FDCEquipAnimData::SecondaryItem' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgEquipItemAnimData
// 0x02D0 (0x02E8 - 0x0018)
struct FMsgEquipItemAnimData final : public FMsgBase
{
public:
	struct FDCEquipAnimData                       EquipAnimData;                                     // 0x0018(0x02D0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgEquipItemAnimData) == 0x000008, "Wrong alignment on FMsgEquipItemAnimData");
static_assert(sizeof(FMsgEquipItemAnimData) == 0x0002E8, "Wrong size on FMsgEquipItemAnimData");
static_assert(offsetof(FMsgEquipItemAnimData, EquipAnimData) == 0x000018, "Member 'FMsgEquipItemAnimData::EquipAnimData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPlatformLinkInfoListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgPlatformLinkInfoListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2048[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPlatformLinkInfoListRequest) == 0x000008, "Wrong alignment on FClientMsgPlatformLinkInfoListRequest");
static_assert(sizeof(FClientMsgPlatformLinkInfoListRequest) == 0x000028, "Wrong size on FClientMsgPlatformLinkInfoListRequest");

// ScriptStruct DungeonCrawler.MsgWidgetClassMusicUnequipNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassMusicUnequipNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        MusicId;                                           // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2049[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassMusicUnequipNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassMusicUnequipNotify");
static_assert(sizeof(FMsgWidgetClassMusicUnequipNotify) == 0x000030, "Wrong size on FMsgWidgetClassMusicUnequipNotify");
static_assert(offsetof(FMsgWidgetClassMusicUnequipNotify, Index) == 0x000018, "Member 'FMsgWidgetClassMusicUnequipNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassMusicUnequipNotify, MusicId) == 0x00001C, "Member 'FMsgWidgetClassMusicUnequipNotify::MusicId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAnimationStopMontage
// 0x0000 (0x0018 - 0x0018)
struct FMsgAnimationStopMontage final : public FMsgBase
{
};
static_assert(alignof(FMsgAnimationStopMontage) == 0x000008, "Wrong alignment on FMsgAnimationStopMontage");
static_assert(sizeof(FMsgAnimationStopMontage) == 0x000018, "Wrong size on FMsgAnimationStopMontage");

// ScriptStruct DungeonCrawler.DesignDataItemPropertyItem
// 0x001C (0x001C - 0x0000)
struct FDesignDataItemPropertyItem final
{
public:
	struct FPrimaryAssetId                        PropertyTypeId;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinValue;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxValue;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PropertyRate;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemPropertyItem) == 0x000004, "Wrong alignment on FDesignDataItemPropertyItem");
static_assert(sizeof(FDesignDataItemPropertyItem) == 0x00001C, "Wrong size on FDesignDataItemPropertyItem");
static_assert(offsetof(FDesignDataItemPropertyItem, PropertyTypeId) == 0x000000, "Member 'FDesignDataItemPropertyItem::PropertyTypeId' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyItem, MinValue) == 0x000010, "Member 'FDesignDataItemPropertyItem::MinValue' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyItem, MaxValue) == 0x000014, "Member 'FDesignDataItemPropertyItem::MaxValue' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyItem, PropertyRate) == 0x000018, "Member 'FDesignDataItemPropertyItem::PropertyRate' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataItemProperty
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataItemProperty final
{
public:
	TArray<struct FDesignDataItemPropertyItem>    ItemPropertyItemArray;                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemProperty) == 0x000008, "Wrong alignment on FDesignDataItemProperty");
static_assert(sizeof(FDesignDataItemProperty) == 0x000010, "Wrong size on FDesignDataItemProperty");
static_assert(offsetof(FDesignDataItemProperty, ItemPropertyItemArray) == 0x000000, "Member 'FDesignDataItemProperty::ItemPropertyItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgRemoveAllLooters
// 0x0000 (0x0018 - 0x0018)
struct FMsgRemoveAllLooters final : public FMsgBase
{
};
static_assert(alignof(FMsgRemoveAllLooters) == 0x000008, "Wrong alignment on FMsgRemoveAllLooters");
static_assert(sizeof(FMsgRemoveAllLooters) == 0x000018, "Wrong size on FMsgRemoveAllLooters");

// ScriptStruct DungeonCrawler.ClientMsgArenaScheduleNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgArenaScheduleNotify final : public FMsgBase
{
public:
	uint8                                         Pad_204A[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgArenaScheduleNotify) == 0x000008, "Wrong alignment on FClientMsgArenaScheduleNotify");
static_assert(sizeof(FClientMsgArenaScheduleNotify) == 0x000028, "Wrong size on FClientMsgArenaScheduleNotify");

// ScriptStruct DungeonCrawler.MsgAnimationMontageJumpToSection
// 0x0008 (0x0020 - 0x0018)
struct FMsgAnimationMontageJumpToSection final : public FMsgBase
{
public:
	class FName                                   SectionName;                                       // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAnimationMontageJumpToSection) == 0x000008, "Wrong alignment on FMsgAnimationMontageJumpToSection");
static_assert(sizeof(FMsgAnimationMontageJumpToSection) == 0x000020, "Wrong size on FMsgAnimationMontageJumpToSection");
static_assert(offsetof(FMsgAnimationMontageJumpToSection, SectionName) == 0x000018, "Member 'FMsgAnimationMontageJumpToSection::SectionName' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAnimationChangeIdle
// 0x0008 (0x0020 - 0x0018)
struct FMsgAnimationChangeIdle final : public FMsgBase
{
public:
	struct FGameplayTag                           IdleAnimSequenceGameplayTag;                       // 0x0018(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAnimationChangeIdle) == 0x000008, "Wrong alignment on FMsgAnimationChangeIdle");
static_assert(sizeof(FMsgAnimationChangeIdle) == 0x000020, "Wrong size on FMsgAnimationChangeIdle");
static_assert(offsetof(FMsgAnimationChangeIdle, IdleAnimSequenceGameplayTag) == 0x000018, "Member 'FMsgAnimationChangeIdle::IdleAnimSequenceGameplayTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardSheetInfo
// 0x0018 (0x0018 - 0x0000)
struct FLeaderboardSheetInfo final
{
public:
	class UDCLeaderboardSheetDataAsset*           LeaderboardSheetData;                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRankInfo                              RankInfo;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeaderboardSheetInfo) == 0x000008, "Wrong alignment on FLeaderboardSheetInfo");
static_assert(sizeof(FLeaderboardSheetInfo) == 0x000018, "Wrong size on FLeaderboardSheetInfo");
static_assert(offsetof(FLeaderboardSheetInfo, LeaderboardSheetData) == 0x000000, "Member 'FLeaderboardSheetInfo::LeaderboardSheetData' has a wrong offset!");
static_assert(offsetof(FLeaderboardSheetInfo, RankInfo) == 0x000008, "Member 'FLeaderboardSheetInfo::RankInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardInfo
// 0x0040 (0x0040 - 0x0000)
struct FLeaderboardInfo final
{
public:
	class UDCLeaderboardDataAsset*                LeaderboardData;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              BeginDateTime;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDateTime;                                       // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              WipeDateTime;                                      // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              RewardDateTime;                                    // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              NextSeasonBeginDateTime;                           // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLeaderboardSheetInfo>          LeaderboardSheetInfoArray;                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeaderboardInfo) == 0x000008, "Wrong alignment on FLeaderboardInfo");
static_assert(sizeof(FLeaderboardInfo) == 0x000040, "Wrong size on FLeaderboardInfo");
static_assert(offsetof(FLeaderboardInfo, LeaderboardData) == 0x000000, "Member 'FLeaderboardInfo::LeaderboardData' has a wrong offset!");
static_assert(offsetof(FLeaderboardInfo, BeginDateTime) == 0x000008, "Member 'FLeaderboardInfo::BeginDateTime' has a wrong offset!");
static_assert(offsetof(FLeaderboardInfo, EndDateTime) == 0x000010, "Member 'FLeaderboardInfo::EndDateTime' has a wrong offset!");
static_assert(offsetof(FLeaderboardInfo, WipeDateTime) == 0x000018, "Member 'FLeaderboardInfo::WipeDateTime' has a wrong offset!");
static_assert(offsetof(FLeaderboardInfo, RewardDateTime) == 0x000020, "Member 'FLeaderboardInfo::RewardDateTime' has a wrong offset!");
static_assert(offsetof(FLeaderboardInfo, NextSeasonBeginDateTime) == 0x000028, "Member 'FLeaderboardInfo::NextSeasonBeginDateTime' has a wrong offset!");
static_assert(offsetof(FLeaderboardInfo, LeaderboardSheetInfoArray) == 0x000030, "Member 'FLeaderboardInfo::LeaderboardSheetInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardRankRewardInfo
// 0x0010 (0x0010 - 0x0000)
struct FLeaderboardRankRewardInfo final
{
public:
	class UDCLeaderboardRankGroupDataAsset*       LeaderboardRankGroupData;                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELeaderboardRankRewardState                   RankRewardState;                                   // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204B[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeaderboardRankRewardInfo) == 0x000008, "Wrong alignment on FLeaderboardRankRewardInfo");
static_assert(sizeof(FLeaderboardRankRewardInfo) == 0x000010, "Wrong size on FLeaderboardRankRewardInfo");
static_assert(offsetof(FLeaderboardRankRewardInfo, LeaderboardRankGroupData) == 0x000000, "Member 'FLeaderboardRankRewardInfo::LeaderboardRankGroupData' has a wrong offset!");
static_assert(offsetof(FLeaderboardRankRewardInfo, RankRewardState) == 0x000008, "Member 'FLeaderboardRankRewardInfo::RankRewardState' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardSeasonInfo
// 0x0068 (0x0068 - 0x0000)
struct FLeaderboardSeasonInfo final
{
public:
	struct FLeaderboardInfo                       LeaderboardInfo;                                   // 0x0000(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ELeaderboardState                             LeaderboardState;                                  // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204C[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SeasonDays;                                        // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeasonHours;                                       // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeasonMinutes;                                     // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeasonSeconds;                                     // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_204D[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLeaderboardRankRewardInfo>     LeaderboardRankRewardInfoArray;                    // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeaderboardSeasonInfo) == 0x000008, "Wrong alignment on FLeaderboardSeasonInfo");
static_assert(sizeof(FLeaderboardSeasonInfo) == 0x000068, "Wrong size on FLeaderboardSeasonInfo");
static_assert(offsetof(FLeaderboardSeasonInfo, LeaderboardInfo) == 0x000000, "Member 'FLeaderboardSeasonInfo::LeaderboardInfo' has a wrong offset!");
static_assert(offsetof(FLeaderboardSeasonInfo, LeaderboardState) == 0x000040, "Member 'FLeaderboardSeasonInfo::LeaderboardState' has a wrong offset!");
static_assert(offsetof(FLeaderboardSeasonInfo, SeasonDays) == 0x000044, "Member 'FLeaderboardSeasonInfo::SeasonDays' has a wrong offset!");
static_assert(offsetof(FLeaderboardSeasonInfo, SeasonHours) == 0x000048, "Member 'FLeaderboardSeasonInfo::SeasonHours' has a wrong offset!");
static_assert(offsetof(FLeaderboardSeasonInfo, SeasonMinutes) == 0x00004C, "Member 'FLeaderboardSeasonInfo::SeasonMinutes' has a wrong offset!");
static_assert(offsetof(FLeaderboardSeasonInfo, SeasonSeconds) == 0x000050, "Member 'FLeaderboardSeasonInfo::SeasonSeconds' has a wrong offset!");
static_assert(offsetof(FLeaderboardSeasonInfo, LeaderboardRankRewardInfoArray) == 0x000058, "Member 'FLeaderboardSeasonInfo::LeaderboardRankRewardInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardSheetWidgetHandleData
// 0x0088 (0x0088 - 0x0000)
struct FLeaderboardSheetWidgetHandleData final
{
public:
	class UDCLeaderboardDataAsset*                LeaderboardData;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCLeaderboardSheetDataAsset*           LeaderboardSheetData;                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLeaderboardSeasonInfo                 LeaderboardSeasonInfo;                             // 0x0010(0x0068)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FRankInfo                              RankInfo;                                          // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeaderboardSheetWidgetHandleData) == 0x000008, "Wrong alignment on FLeaderboardSheetWidgetHandleData");
static_assert(sizeof(FLeaderboardSheetWidgetHandleData) == 0x000088, "Wrong size on FLeaderboardSheetWidgetHandleData");
static_assert(offsetof(FLeaderboardSheetWidgetHandleData, LeaderboardData) == 0x000000, "Member 'FLeaderboardSheetWidgetHandleData::LeaderboardData' has a wrong offset!");
static_assert(offsetof(FLeaderboardSheetWidgetHandleData, LeaderboardSheetData) == 0x000008, "Member 'FLeaderboardSheetWidgetHandleData::LeaderboardSheetData' has a wrong offset!");
static_assert(offsetof(FLeaderboardSheetWidgetHandleData, LeaderboardSeasonInfo) == 0x000010, "Member 'FLeaderboardSheetWidgetHandleData::LeaderboardSeasonInfo' has a wrong offset!");
static_assert(offsetof(FLeaderboardSheetWidgetHandleData, RankInfo) == 0x000078, "Member 'FLeaderboardSheetWidgetHandleData::RankInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClientPopupMessageNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgClientPopupMessageNotify final : public FMsgBase
{
public:
	uint8                                         Pad_204E[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClientPopupMessageNotify) == 0x000008, "Wrong alignment on FClientMsgClientPopupMessageNotify");
static_assert(sizeof(FClientMsgClientPopupMessageNotify) == 0x000028, "Wrong size on FClientMsgClientPopupMessageNotify");

// ScriptStruct DungeonCrawler.MsgAnimationHitReaction
// 0x0018 (0x0030 - 0x0018)
struct FMsgAnimationHitReaction final : public FMsgBase
{
public:
	struct FVector                                HitDirection;                                      // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAnimationHitReaction) == 0x000008, "Wrong alignment on FMsgAnimationHitReaction");
static_assert(sizeof(FMsgAnimationHitReaction) == 0x000030, "Wrong size on FMsgAnimationHitReaction");
static_assert(offsetof(FMsgAnimationHitReaction, HitDirection) == 0x000018, "Member 'FMsgAnimationHitReaction::HitDirection' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryVersion
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FDCInventoryVersion final
{
public:
	uint8                                         Pad_204F[0x18];                                    // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        BaseSequence;                                      // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        AuthorizedSequence;                                // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        LocalSequence;                                     // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2050[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCInventoryVersion) == 0x000008, "Wrong alignment on FDCInventoryVersion");
static_assert(sizeof(FDCInventoryVersion) == 0x000028, "Wrong size on FDCInventoryVersion");
static_assert(offsetof(FDCInventoryVersion, BaseSequence) == 0x000018, "Member 'FDCInventoryVersion::BaseSequence' has a wrong offset!");
static_assert(offsetof(FDCInventoryVersion, AuthorizedSequence) == 0x00001C, "Member 'FDCInventoryVersion::AuthorizedSequence' has a wrong offset!");
static_assert(offsetof(FDCInventoryVersion, LocalSequence) == 0x000020, "Member 'FDCInventoryVersion::LocalSequence' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAoeAISet
// 0x0008 (0x0020 - 0x0018)
struct FMsgAoeAISet final : public FMsgBase
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAoeAISet) == 0x000008, "Wrong alignment on FMsgAoeAISet");
static_assert(sizeof(FMsgAoeAISet) == 0x000020, "Wrong size on FMsgAoeAISet");
static_assert(offsetof(FMsgAoeAISet, BehaviorTree) == 0x000018, "Member 'FMsgAoeAISet::BehaviorTree' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPlatformLinkCodeActiveRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgPlatformLinkCodeActiveRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2051[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPlatformLinkCodeActiveRequest) == 0x000008, "Wrong alignment on FClientMsgPlatformLinkCodeActiveRequest");
static_assert(sizeof(FClientMsgPlatformLinkCodeActiveRequest) == 0x000030, "Wrong size on FClientMsgPlatformLinkCodeActiveRequest");

// ScriptStruct DungeonCrawler.MsgWidgetClassSpellUnequipNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassSpellUnequipNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SpellId;                                           // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2052[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassSpellUnequipNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSpellUnequipNotify");
static_assert(sizeof(FMsgWidgetClassSpellUnequipNotify) == 0x000030, "Wrong size on FMsgWidgetClassSpellUnequipNotify");
static_assert(offsetof(FMsgWidgetClassSpellUnequipNotify, Index) == 0x000018, "Member 'FMsgWidgetClassSpellUnequipNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassSpellUnequipNotify, SpellId) == 0x00001C, "Member 'FMsgWidgetClassSpellUnequipNotify::SpellId' has a wrong offset!");

// ScriptStruct DungeonCrawler.AoeScaleData
// 0x0010 (0x0010 - 0x0000)
struct FAoeScaleData final
{
public:
	float                                         OldServerWorldTimeSeconds;                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldScale;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewServerWorldTimeSeconds;                         // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewScale;                                          // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAoeScaleData) == 0x000004, "Wrong alignment on FAoeScaleData");
static_assert(sizeof(FAoeScaleData) == 0x000010, "Wrong size on FAoeScaleData");
static_assert(offsetof(FAoeScaleData, OldServerWorldTimeSeconds) == 0x000000, "Member 'FAoeScaleData::OldServerWorldTimeSeconds' has a wrong offset!");
static_assert(offsetof(FAoeScaleData, OldScale) == 0x000004, "Member 'FAoeScaleData::OldScale' has a wrong offset!");
static_assert(offsetof(FAoeScaleData, NewServerWorldTimeSeconds) == 0x000008, "Member 'FAoeScaleData::NewServerWorldTimeSeconds' has a wrong offset!");
static_assert(offsetof(FAoeScaleData, NewScale) == 0x00000C, "Member 'FAoeScaleData::NewScale' has a wrong offset!");

// ScriptStruct DungeonCrawler.LocomotionAnimSet
// 0x0018 (0x0018 - 0x0000)
struct FLocomotionAnimSet final
{
public:
	class UAnimSequenceBase*                      StandIdle;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      CrouchIdle;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            RunUpperBody;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocomotionAnimSet) == 0x000008, "Wrong alignment on FLocomotionAnimSet");
static_assert(sizeof(FLocomotionAnimSet) == 0x000018, "Wrong size on FLocomotionAnimSet");
static_assert(offsetof(FLocomotionAnimSet, StandIdle) == 0x000000, "Member 'FLocomotionAnimSet::StandIdle' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimSet, CrouchIdle) == 0x000008, "Member 'FLocomotionAnimSet::CrouchIdle' has a wrong offset!");
static_assert(offsetof(FLocomotionAnimSet, RunUpperBody) == 0x000010, "Member 'FLocomotionAnimSet::RunUpperBody' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTwitchDropsLinkedNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTwitchDropsLinkedNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2053[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTwitchDropsLinkedNotify) == 0x000008, "Wrong alignment on FClientMsgTwitchDropsLinkedNotify");
static_assert(sizeof(FClientMsgTwitchDropsLinkedNotify) == 0x000020, "Wrong size on FClientMsgTwitchDropsLinkedNotify");

// ScriptStruct DungeonCrawler.ChatData
// 0x0080 (0x0080 - 0x0000)
struct FChatData final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0020(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 PartyId;                                           // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FChatDataPiece>                 ChatDataPieceArray;                                // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChatData) == 0x000008, "Wrong alignment on FChatData");
static_assert(sizeof(FChatData) == 0x000080, "Wrong size on FChatData");
static_assert(offsetof(FChatData, AccountId) == 0x000000, "Member 'FChatData::AccountId' has a wrong offset!");
static_assert(offsetof(FChatData, CharacterId) == 0x000010, "Member 'FChatData::CharacterId' has a wrong offset!");
static_assert(offsetof(FChatData, Nickname) == 0x000020, "Member 'FChatData::Nickname' has a wrong offset!");
static_assert(offsetof(FChatData, PartyId) == 0x000060, "Member 'FChatData::PartyId' has a wrong offset!");
static_assert(offsetof(FChatData, ChatDataPieceArray) == 0x000070, "Member 'FChatData::ChatDataPieceArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradingChatRequest
// 0x00A8 (0x00C0 - 0x0018)
struct FMsgWidgetTradingChatRequest final : public FMsgBase
{
public:
	EChatType                                     ChatType;                                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2054[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChatTargetAccountId;                               // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChatTargetCharacterId;                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChatData                              ChatData;                                          // 0x0040(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetTradingChatRequest) == 0x000008, "Wrong alignment on FMsgWidgetTradingChatRequest");
static_assert(sizeof(FMsgWidgetTradingChatRequest) == 0x0000C0, "Wrong size on FMsgWidgetTradingChatRequest");
static_assert(offsetof(FMsgWidgetTradingChatRequest, ChatType) == 0x000018, "Member 'FMsgWidgetTradingChatRequest::ChatType' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradingChatRequest, ChatTargetAccountId) == 0x000020, "Member 'FMsgWidgetTradingChatRequest::ChatTargetAccountId' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradingChatRequest, ChatTargetCharacterId) == 0x000030, "Member 'FMsgWidgetTradingChatRequest::ChatTargetCharacterId' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradingChatRequest, ChatData) == 0x000040, "Member 'FMsgWidgetTradingChatRequest::ChatData' has a wrong offset!");

// ScriptStruct DungeonCrawler.AnimationSet
// 0x0038 (0x0038 - 0x0000)
struct FAnimationSet final
{
public:
	class UAnimMontage*                           EquipMontage;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UnEquipMontage;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           EquipMontageItem;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UnEquipMontageItem;                                // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLocomotionAnimSet                     LocomotionAnimSet;                                 // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationSet) == 0x000008, "Wrong alignment on FAnimationSet");
static_assert(sizeof(FAnimationSet) == 0x000038, "Wrong size on FAnimationSet");
static_assert(offsetof(FAnimationSet, EquipMontage) == 0x000000, "Member 'FAnimationSet::EquipMontage' has a wrong offset!");
static_assert(offsetof(FAnimationSet, UnEquipMontage) == 0x000008, "Member 'FAnimationSet::UnEquipMontage' has a wrong offset!");
static_assert(offsetof(FAnimationSet, EquipMontageItem) == 0x000010, "Member 'FAnimationSet::EquipMontageItem' has a wrong offset!");
static_assert(offsetof(FAnimationSet, UnEquipMontageItem) == 0x000018, "Member 'FAnimationSet::UnEquipMontageItem' has a wrong offset!");
static_assert(offsetof(FAnimationSet, LocomotionAnimSet) == 0x000020, "Member 'FAnimationSet::LocomotionAnimSet' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemMaterialInfo
// 0x0010 (0x0010 - 0x0000)
struct FItemMaterialInfo final
{
public:
	class FName                                   MaterialSlotName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialInterface;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemMaterialInfo) == 0x000008, "Wrong alignment on FItemMaterialInfo");
static_assert(sizeof(FItemMaterialInfo) == 0x000010, "Wrong size on FItemMaterialInfo");
static_assert(offsetof(FItemMaterialInfo, MaterialSlotName) == 0x000000, "Member 'FItemMaterialInfo::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(FItemMaterialInfo, MaterialInterface) == 0x000008, "Member 'FItemMaterialInfo::MaterialInterface' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCStockCraftItemData
// 0x0150 (0x0150 - 0x0000)
struct FDCStockCraftItemData final
{
public:
	int64                                         UniqueID;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ConversationText;                                  // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CraftCompleteText;                                 // 0x0020(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCItemDataAsset>        ItemId;                                            // 0x0038(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCItemDataAsset>        RequiredItemId_01;                                 // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount01;                                  // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2055[0x4];                                     // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        RequiredItemId_02;                                 // 0x0090(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount02;                                  // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2056[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        RequiredItemId_03;                                 // 0x00C0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount03;                                  // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2057[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        RequiredItemId_04;                                 // 0x00F0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount04;                                  // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2058[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        RequiredItemId_05;                                 // 0x0120(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount05;                                  // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2059[0x4];                                     // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCStockCraftItemData) == 0x000008, "Wrong alignment on FDCStockCraftItemData");
static_assert(sizeof(FDCStockCraftItemData) == 0x000150, "Wrong size on FDCStockCraftItemData");
static_assert(offsetof(FDCStockCraftItemData, UniqueID) == 0x000000, "Member 'FDCStockCraftItemData::UniqueID' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, ConversationText) == 0x000008, "Member 'FDCStockCraftItemData::ConversationText' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, CraftCompleteText) == 0x000020, "Member 'FDCStockCraftItemData::CraftCompleteText' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, ItemId) == 0x000038, "Member 'FDCStockCraftItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, RequiredItemId_01) == 0x000060, "Member 'FDCStockCraftItemData::RequiredItemId_01' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, RequiredAmount01) == 0x000088, "Member 'FDCStockCraftItemData::RequiredAmount01' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, RequiredItemId_02) == 0x000090, "Member 'FDCStockCraftItemData::RequiredItemId_02' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, RequiredAmount02) == 0x0000B8, "Member 'FDCStockCraftItemData::RequiredAmount02' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, RequiredItemId_03) == 0x0000C0, "Member 'FDCStockCraftItemData::RequiredItemId_03' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, RequiredAmount03) == 0x0000E8, "Member 'FDCStockCraftItemData::RequiredAmount03' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, RequiredItemId_04) == 0x0000F0, "Member 'FDCStockCraftItemData::RequiredItemId_04' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, RequiredAmount04) == 0x000118, "Member 'FDCStockCraftItemData::RequiredAmount04' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, RequiredItemId_05) == 0x000120, "Member 'FDCStockCraftItemData::RequiredItemId_05' has a wrong offset!");
static_assert(offsetof(FDCStockCraftItemData, RequiredAmount05) == 0x000148, "Member 'FDCStockCraftItemData::RequiredAmount05' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCFloorRuleBlizzardItemData
// 0x0050 (0x0050 - 0x0000)
struct FDCFloorRuleBlizzardItemData final
{
public:
	struct FGameplayTag                           BlizzardAbilityTag;                                // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseDuration;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_205A[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UDCFloorPortalDataAsset>> PhaseFloorPortalArray;                             // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          HideBlizzardTimer;                                 // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_205B[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCFloorRuleBlizzardItemData) == 0x000008, "Wrong alignment on FDCFloorRuleBlizzardItemData");
static_assert(sizeof(FDCFloorRuleBlizzardItemData) == 0x000050, "Wrong size on FDCFloorRuleBlizzardItemData");
static_assert(offsetof(FDCFloorRuleBlizzardItemData, BlizzardAbilityTag) == 0x000000, "Member 'FDCFloorRuleBlizzardItemData::BlizzardAbilityTag' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleBlizzardItemData, PhaseDuration) == 0x000008, "Member 'FDCFloorRuleBlizzardItemData::PhaseDuration' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleBlizzardItemData, PhaseFloorPortalArray) == 0x000010, "Member 'FDCFloorRuleBlizzardItemData::PhaseFloorPortalArray' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleBlizzardItemData, HideBlizzardTimer) == 0x000020, "Member 'FDCFloorRuleBlizzardItemData::HideBlizzardTimer' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleBlizzardItemData, SoundData) == 0x000028, "Member 'FDCFloorRuleBlizzardItemData::SoundData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCFloorRuleBlizzardInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FDCFloorRuleBlizzardInfo final
{
public:
	int32                                         FloorRuleIdx;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_205C[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCFloorRuleBlizzardItemData           Data;                                              // 0x0008(0x0050)(Transient, NativeAccessSpecifierPublic)
	TMap<class AFloorPortalBase*, class UDCFloorPortalDataAsset*> PhaseFloorPortalMap;                               // 0x0058(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCFloorRuleBlizzardInfo) == 0x000008, "Wrong alignment on FDCFloorRuleBlizzardInfo");
static_assert(sizeof(FDCFloorRuleBlizzardInfo) == 0x0000A8, "Wrong size on FDCFloorRuleBlizzardInfo");
static_assert(offsetof(FDCFloorRuleBlizzardInfo, FloorRuleIdx) == 0x000000, "Member 'FDCFloorRuleBlizzardInfo::FloorRuleIdx' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleBlizzardInfo, Data) == 0x000008, "Member 'FDCFloorRuleBlizzardInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleBlizzardInfo, PhaseFloorPortalMap) == 0x000058, "Member 'FDCFloorRuleBlizzardInfo::PhaseFloorPortalMap' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgLootContainingItemsNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgLootContainingItemsNotify final : public FMsgBase
{
public:
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_205D[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      ContainingItemDataArray;                           // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSlotInfo>                      SlotInfoArray;                                     // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgLootContainingItemsNotify) == 0x000008, "Wrong alignment on FMsgLootContainingItemsNotify");
static_assert(sizeof(FMsgLootContainingItemsNotify) == 0x000040, "Wrong size on FMsgLootContainingItemsNotify");
static_assert(offsetof(FMsgLootContainingItemsNotify, InventoryId) == 0x000018, "Member 'FMsgLootContainingItemsNotify::InventoryId' has a wrong offset!");
static_assert(offsetof(FMsgLootContainingItemsNotify, ContainingItemDataArray) == 0x000020, "Member 'FMsgLootContainingItemsNotify::ContainingItemDataArray' has a wrong offset!");
static_assert(offsetof(FMsgLootContainingItemsNotify, SlotInfoArray) == 0x000030, "Member 'FMsgLootContainingItemsNotify::SlotInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgDlcInstalledCheckResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgDlcInstalledCheckResponse final : public FMsgBase
{
public:
	uint8                                         Pad_205E[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgDlcInstalledCheckResponse) == 0x000008, "Wrong alignment on FClientMsgDlcInstalledCheckResponse");
static_assert(sizeof(FClientMsgDlcInstalledCheckResponse) == 0x000020, "Wrong size on FClientMsgDlcInstalledCheckResponse");

// ScriptStruct DungeonCrawler.ClientMsgTwitchDropsConnectResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgTwitchDropsConnectResponse final : public FMsgBase
{
public:
	uint8                                         Pad_205F[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTwitchDropsConnectResponse) == 0x000008, "Wrong alignment on FClientMsgTwitchDropsConnectResponse");
static_assert(sizeof(FClientMsgTwitchDropsConnectResponse) == 0x000030, "Wrong size on FClientMsgTwitchDropsConnectResponse");

// ScriptStruct DungeonCrawler.MsgWidgetTradeChannelChatNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetTradeChannelChatNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2060[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetTradeChannelChatNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeChannelChatNotify");
static_assert(sizeof(FMsgWidgetTradeChannelChatNotify) == 0x000030, "Wrong size on FMsgWidgetTradeChannelChatNotify");

// ScriptStruct DungeonCrawler.MsgDefaultBodyPartMapRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgDefaultBodyPartMapRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgDefaultBodyPartMapRequest) == 0x000008, "Wrong alignment on FMsgDefaultBodyPartMapRequest");
static_assert(sizeof(FMsgDefaultBodyPartMapRequest) == 0x000018, "Wrong size on FMsgDefaultBodyPartMapRequest");

// ScriptStruct DungeonCrawler.MsgDefaultBodyPartMapResponse
// 0x0050 (0x0068 - 0x0018)
struct FMsgDefaultBodyPartMapResponse final : public FMsgBase
{
public:
	TMap<struct FGameplayTag, class USkeletalMesh*> DefaultBodyPartsMap;                               // 0x0018(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgDefaultBodyPartMapResponse) == 0x000008, "Wrong alignment on FMsgDefaultBodyPartMapResponse");
static_assert(sizeof(FMsgDefaultBodyPartMapResponse) == 0x000068, "Wrong size on FMsgDefaultBodyPartMapResponse");
static_assert(offsetof(FMsgDefaultBodyPartMapResponse, DefaultBodyPartsMap) == 0x000018, "Member 'FMsgDefaultBodyPartMapResponse::DefaultBodyPartsMap' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgCustomizeMountResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgCustomizeMountResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2061[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCustomizeMountResponse) == 0x000008, "Wrong alignment on FClientMsgCustomizeMountResponse");
static_assert(sizeof(FClientMsgCustomizeMountResponse) == 0x000030, "Wrong size on FClientMsgCustomizeMountResponse");

// ScriptStruct DungeonCrawler.MsgWidgetTradeChannelEndNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetTradeChannelEndNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetTradeChannelEndNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeChannelEndNotify");
static_assert(sizeof(FMsgWidgetTradeChannelEndNotify) == 0x000018, "Wrong size on FMsgWidgetTradeChannelEndNotify");

// ScriptStruct DungeonCrawler.MsgSetCheckTargetPlayerEquipment
// 0x0010 (0x0028 - 0x0018)
struct FMsgSetCheckTargetPlayerEquipment final : public FMsgBase
{
public:
	class FString                                 TargetPlayerAccountId;                             // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSetCheckTargetPlayerEquipment) == 0x000008, "Wrong alignment on FMsgSetCheckTargetPlayerEquipment");
static_assert(sizeof(FMsgSetCheckTargetPlayerEquipment) == 0x000028, "Wrong size on FMsgSetCheckTargetPlayerEquipment");
static_assert(offsetof(FMsgSetCheckTargetPlayerEquipment, TargetPlayerAccountId) == 0x000018, "Member 'FMsgSetCheckTargetPlayerEquipment::TargetPlayerAccountId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgRemoveCheckTargetPlayerEquipment
// 0x0000 (0x0018 - 0x0018)
struct FMsgRemoveCheckTargetPlayerEquipment final : public FMsgBase
{
};
static_assert(alignof(FMsgRemoveCheckTargetPlayerEquipment) == 0x000008, "Wrong alignment on FMsgRemoveCheckTargetPlayerEquipment");
static_assert(sizeof(FMsgRemoveCheckTargetPlayerEquipment) == 0x000018, "Wrong size on FMsgRemoveCheckTargetPlayerEquipment");

// ScriptStruct DungeonCrawler.DCPlayerInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FDCPlayerInfo final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AccountIdx;                                        // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LoginCount;                                        // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNickname                              Nickname;                                          // 0x0018(0x0040)(Transient, NativeAccessSpecifierPrivate)
	EDCCharacterClass                             CharacterClass;                                    // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2062[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCPartyId                             PartyId;                                           // 0x0060(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCGender                                     Gender;                                            // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCOnlineState                                OnlineState;                                       // 0x0071(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCDungeonState                               DungeonState;                                      // 0x0072(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAlive;                                            // 0x0073(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Level;                                             // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FActorStatusData>               ActorStatuses;                                     // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         HealthRate;                                        // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OverhealedHealthRate;                              // 0x008C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RecoverableHealthRate;                             // 0x0090(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ColdnessRate;                                      // 0x0094(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPrimaryAssetId                        CharacterSkin;                                     // 0x0098(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPrimaryAssetId>                EquippedArmorItems;                                // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FPrimaryAssetId                        DungeonModuleId;                                   // 0x00B8(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDCShapeShiftDataAsset*                 ShapeShiftDataAsset;                               // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDCArmorSkinDataAsset*>          ArmorSkins;                                        // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCPlayerInfo) == 0x000008, "Wrong alignment on FDCPlayerInfo");
static_assert(sizeof(FDCPlayerInfo) == 0x0000E0, "Wrong size on FDCPlayerInfo");
static_assert(offsetof(FDCPlayerInfo, AccountId) == 0x000000, "Member 'FDCPlayerInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, AccountIdx) == 0x000010, "Member 'FDCPlayerInfo::AccountIdx' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, LoginCount) == 0x000014, "Member 'FDCPlayerInfo::LoginCount' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, Nickname) == 0x000018, "Member 'FDCPlayerInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, CharacterClass) == 0x000058, "Member 'FDCPlayerInfo::CharacterClass' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, PartyId) == 0x000060, "Member 'FDCPlayerInfo::PartyId' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, Gender) == 0x000070, "Member 'FDCPlayerInfo::Gender' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, OnlineState) == 0x000071, "Member 'FDCPlayerInfo::OnlineState' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, DungeonState) == 0x000072, "Member 'FDCPlayerInfo::DungeonState' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, bAlive) == 0x000073, "Member 'FDCPlayerInfo::bAlive' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, Level) == 0x000074, "Member 'FDCPlayerInfo::Level' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, ActorStatuses) == 0x000078, "Member 'FDCPlayerInfo::ActorStatuses' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, HealthRate) == 0x000088, "Member 'FDCPlayerInfo::HealthRate' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, OverhealedHealthRate) == 0x00008C, "Member 'FDCPlayerInfo::OverhealedHealthRate' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, RecoverableHealthRate) == 0x000090, "Member 'FDCPlayerInfo::RecoverableHealthRate' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, ColdnessRate) == 0x000094, "Member 'FDCPlayerInfo::ColdnessRate' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, CharacterSkin) == 0x000098, "Member 'FDCPlayerInfo::CharacterSkin' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, EquippedArmorItems) == 0x0000A8, "Member 'FDCPlayerInfo::EquippedArmorItems' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, DungeonModuleId) == 0x0000B8, "Member 'FDCPlayerInfo::DungeonModuleId' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, ShapeShiftDataAsset) == 0x0000C8, "Member 'FDCPlayerInfo::ShapeShiftDataAsset' has a wrong offset!");
static_assert(offsetof(FDCPlayerInfo, ArmorSkins) == 0x0000D0, "Member 'FDCPlayerInfo::ArmorSkins' has a wrong offset!");

// ScriptStruct DungeonCrawler.AkAudioVolumeInfo
// 0x0040 (0x0040 - 0x0000)
struct FAkAudioVolumeInfo final
{
public:
	float                                         Priority;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2063[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkEventBeginOverlap;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AkStateValueBeginOverlap;                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkEventEndOverlap;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkStateValue*                          AkStateValueEndOverlap;                            // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRtpc*                                Rtpc;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RtpcValue;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2064[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    Volume;                                            // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAkAudioVolumeInfo) == 0x000008, "Wrong alignment on FAkAudioVolumeInfo");
static_assert(sizeof(FAkAudioVolumeInfo) == 0x000040, "Wrong size on FAkAudioVolumeInfo");
static_assert(offsetof(FAkAudioVolumeInfo, Priority) == 0x000000, "Member 'FAkAudioVolumeInfo::Priority' has a wrong offset!");
static_assert(offsetof(FAkAudioVolumeInfo, AkEventBeginOverlap) == 0x000008, "Member 'FAkAudioVolumeInfo::AkEventBeginOverlap' has a wrong offset!");
static_assert(offsetof(FAkAudioVolumeInfo, AkStateValueBeginOverlap) == 0x000010, "Member 'FAkAudioVolumeInfo::AkStateValueBeginOverlap' has a wrong offset!");
static_assert(offsetof(FAkAudioVolumeInfo, AkEventEndOverlap) == 0x000018, "Member 'FAkAudioVolumeInfo::AkEventEndOverlap' has a wrong offset!");
static_assert(offsetof(FAkAudioVolumeInfo, AkStateValueEndOverlap) == 0x000020, "Member 'FAkAudioVolumeInfo::AkStateValueEndOverlap' has a wrong offset!");
static_assert(offsetof(FAkAudioVolumeInfo, Rtpc) == 0x000028, "Member 'FAkAudioVolumeInfo::Rtpc' has a wrong offset!");
static_assert(offsetof(FAkAudioVolumeInfo, RtpcValue) == 0x000030, "Member 'FAkAudioVolumeInfo::RtpcValue' has a wrong offset!");
static_assert(offsetof(FAkAudioVolumeInfo, Volume) == 0x000038, "Member 'FAkAudioVolumeInfo::Volume' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendSetStatusRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgFriendSetStatusRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2065[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendSetStatusRequest) == 0x000008, "Wrong alignment on FClientMsgFriendSetStatusRequest");
static_assert(sizeof(FClientMsgFriendSetStatusRequest) == 0x000028, "Wrong size on FClientMsgFriendSetStatusRequest");

// ScriptStruct DungeonCrawler.DCArmorPartInfo
// 0x0188 (0x0188 - 0x0000)
struct FDCArmorPartInfo final
{
public:
	struct FDCItemInfo                            ItemInfo;                                          // 0x0000(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanEquip;                                         // 0x0168(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2066[0x7];                                     // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCArmorSkinDataAsset*                  SkinData;                                          // 0x0170(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2067[0x10];                                    // 0x0178(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCArmorPartInfo) == 0x000008, "Wrong alignment on FDCArmorPartInfo");
static_assert(sizeof(FDCArmorPartInfo) == 0x000188, "Wrong size on FDCArmorPartInfo");
static_assert(offsetof(FDCArmorPartInfo, ItemInfo) == 0x000000, "Member 'FDCArmorPartInfo::ItemInfo' has a wrong offset!");
static_assert(offsetof(FDCArmorPartInfo, bCanEquip) == 0x000168, "Member 'FDCArmorPartInfo::bCanEquip' has a wrong offset!");
static_assert(offsetof(FDCArmorPartInfo, SkinData) == 0x000170, "Member 'FDCArmorPartInfo::SkinData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCShapeShiftInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCShapeShiftInfo final
{
public:
	class UDCShapeShiftDataAsset*                 DataAsset;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2068[0x10];                                    // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCShapeShiftInfo) == 0x000008, "Wrong alignment on FDCShapeShiftInfo");
static_assert(sizeof(FDCShapeShiftInfo) == 0x000018, "Wrong size on FDCShapeShiftInfo");
static_assert(offsetof(FDCShapeShiftInfo, DataAsset) == 0x000000, "Member 'FDCShapeShiftInfo::DataAsset' has a wrong offset!");

// ScriptStruct DungeonCrawler.ServerMsgLobbyCharacterNotify
// 0x00C8 (0x00E0 - 0x0018)
struct FServerMsgLobbyCharacterNotify final : public FMsgBase
{
public:
	struct FLobbyCharacterInfo                    LobbyCharacterData;                                // 0x0018(0x00C8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerMsgLobbyCharacterNotify) == 0x000008, "Wrong alignment on FServerMsgLobbyCharacterNotify");
static_assert(sizeof(FServerMsgLobbyCharacterNotify) == 0x0000E0, "Wrong size on FServerMsgLobbyCharacterNotify");
static_assert(offsetof(FServerMsgLobbyCharacterNotify, LobbyCharacterData) == 0x000018, "Member 'FServerMsgLobbyCharacterNotify::LobbyCharacterData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgCustomizeNewItemCheckResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgCustomizeNewItemCheckResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2069[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCustomizeNewItemCheckResponse) == 0x000008, "Wrong alignment on FClientMsgCustomizeNewItemCheckResponse");
static_assert(sizeof(FClientMsgCustomizeNewItemCheckResponse) == 0x000020, "Wrong size on FClientMsgCustomizeNewItemCheckResponse");

// ScriptStruct DungeonCrawler.CharacterStatusWidgetData
// 0x01C0 (0x01C0 - 0x0000)
struct FCharacterStatusWidgetData
{
public:
	struct FGameplayAttributeData                 Strength;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Vigor;                                             // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Agility;                                           // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Dexterity;                                         // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Will;                                              // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Knowledge;                                         // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Resourcefulness;                                   // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Health;                                            // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OverhealedHealth;                                  // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealth;                                         // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealthBase;                                     // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealthMod;                                      // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealthAdd;                                      // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Weight;                                            // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WeightLimit;                                       // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WeightLimitBase;                                   // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WeightLimitMod;                                    // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WeightLimitAdd;                                    // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemorySpellPayload;                                // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryMusicPayload;                                // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryCapacity;                                    // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryCapacityBase;                                // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryCapacityMod;                                 // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryCapacityAdd;                                 // 0x0170(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UtilityEffectiveness;                              // 0x0180(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UtilityEffectivenessBase;                          // 0x0190(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UtilityEffectivenessMod;                           // 0x01A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UtilityEffectivenessAdd;                           // 0x01B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterStatusWidgetData) == 0x000008, "Wrong alignment on FCharacterStatusWidgetData");
static_assert(sizeof(FCharacterStatusWidgetData) == 0x0001C0, "Wrong size on FCharacterStatusWidgetData");
static_assert(offsetof(FCharacterStatusWidgetData, Strength) == 0x000000, "Member 'FCharacterStatusWidgetData::Strength' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, Vigor) == 0x000010, "Member 'FCharacterStatusWidgetData::Vigor' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, Agility) == 0x000020, "Member 'FCharacterStatusWidgetData::Agility' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, Dexterity) == 0x000030, "Member 'FCharacterStatusWidgetData::Dexterity' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, Will) == 0x000040, "Member 'FCharacterStatusWidgetData::Will' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, Knowledge) == 0x000050, "Member 'FCharacterStatusWidgetData::Knowledge' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, Resourcefulness) == 0x000060, "Member 'FCharacterStatusWidgetData::Resourcefulness' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, Health) == 0x000070, "Member 'FCharacterStatusWidgetData::Health' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, OverhealedHealth) == 0x000080, "Member 'FCharacterStatusWidgetData::OverhealedHealth' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, MaxHealth) == 0x000090, "Member 'FCharacterStatusWidgetData::MaxHealth' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, MaxHealthBase) == 0x0000A0, "Member 'FCharacterStatusWidgetData::MaxHealthBase' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, MaxHealthMod) == 0x0000B0, "Member 'FCharacterStatusWidgetData::MaxHealthMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, MaxHealthAdd) == 0x0000C0, "Member 'FCharacterStatusWidgetData::MaxHealthAdd' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, Weight) == 0x0000D0, "Member 'FCharacterStatusWidgetData::Weight' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, WeightLimit) == 0x0000E0, "Member 'FCharacterStatusWidgetData::WeightLimit' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, WeightLimitBase) == 0x0000F0, "Member 'FCharacterStatusWidgetData::WeightLimitBase' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, WeightLimitMod) == 0x000100, "Member 'FCharacterStatusWidgetData::WeightLimitMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, WeightLimitAdd) == 0x000110, "Member 'FCharacterStatusWidgetData::WeightLimitAdd' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, MemorySpellPayload) == 0x000120, "Member 'FCharacterStatusWidgetData::MemorySpellPayload' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, MemoryMusicPayload) == 0x000130, "Member 'FCharacterStatusWidgetData::MemoryMusicPayload' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, MemoryCapacity) == 0x000140, "Member 'FCharacterStatusWidgetData::MemoryCapacity' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, MemoryCapacityBase) == 0x000150, "Member 'FCharacterStatusWidgetData::MemoryCapacityBase' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, MemoryCapacityMod) == 0x000160, "Member 'FCharacterStatusWidgetData::MemoryCapacityMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, MemoryCapacityAdd) == 0x000170, "Member 'FCharacterStatusWidgetData::MemoryCapacityAdd' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, UtilityEffectiveness) == 0x000180, "Member 'FCharacterStatusWidgetData::UtilityEffectiveness' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, UtilityEffectivenessBase) == 0x000190, "Member 'FCharacterStatusWidgetData::UtilityEffectivenessBase' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, UtilityEffectivenessMod) == 0x0001A0, "Member 'FCharacterStatusWidgetData::UtilityEffectivenessMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusWidgetData, UtilityEffectivenessAdd) == 0x0001B0, "Member 'FCharacterStatusWidgetData::UtilityEffectivenessAdd' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCRecruitChannelId
// 0x0000 (0x0010 - 0x0010)
struct FDCRecruitChannelId final : public FDCStringIdBase
{
};
static_assert(alignof(FDCRecruitChannelId) == 0x000008, "Wrong alignment on FDCRecruitChannelId");
static_assert(sizeof(FDCRecruitChannelId) == 0x000010, "Wrong size on FDCRecruitChannelId");

// ScriptStruct DungeonCrawler.CharacterStatusDetailWidgetData
// 0x06B8 (0x0878 - 0x01C0)
struct FCharacterStatusDetailWidgetData final : public FCharacterStatusWidgetData
{
public:
	struct FGameplayAttributeData                 PhysicalDamageWeaponPrimary;                       // 0x01C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageWeaponSecondary;                     // 0x01D0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageBase;                                // 0x01E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalPower;                                     // 0x01F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageMod;                                 // 0x0200(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageModPhysicalPower;                    // 0x0210(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageModBonus;                            // 0x0220(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageAdd;                                 // 0x0230(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalDamageTrue;                                // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArmorPenetration;                                  // 0x0250(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArmorRating;                                       // 0x0260(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalReductionArmorRating;                      // 0x0270(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalReductionBonus;                            // 0x0280(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalReduction;                                 // 0x0290(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalReductionMod;                              // 0x02A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageBase;                                 // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalPower;                                      // 0x02C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageMod;                                  // 0x02D0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageModMagicalPower;                      // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageModBonus;                             // 0x02F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageAdd;                                  // 0x0300(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalDamageTrue;                                 // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicPenetration;                                  // 0x0320(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UndeadDamageMod;                                   // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicResistance;                                   // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalReductionMagicResistance;                   // 0x0350(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalReductionBonus;                             // 0x0360(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalReduction;                                  // 0x0370(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalReductionMod;                               // 0x0380(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FireMagicResistance;                               // 0x0390(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FireMagicalReductionMagicResistance;               // 0x03A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FireMagicalReduction;                              // 0x03B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FireMagicalReductionMod;                           // 0x03C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IceMagicResistance;                                // 0x03D0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IceMagicalReductionMagicResistance;                // 0x03E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IceMagicalReduction;                               // 0x03F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 IceMagicalReductionMod;                            // 0x0400(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightningMagicResistance;                          // 0x0410(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightningMagicalReductionMagicResistance;          // 0x0420(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightningMagicalReduction;                         // 0x0430(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightningMagicalReductionMod;                      // 0x0440(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EarthMagicResistance;                              // 0x0450(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EarthMagicalReductionMagicResistance;              // 0x0460(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EarthMagicalReduction;                             // 0x0470(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EarthMagicalReductionMod;                          // 0x0480(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightMagicResistance;                              // 0x0490(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightMagicalReductionMagicResistance;              // 0x04A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightMagicalReduction;                             // 0x04B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LightMagicalReductionMod;                          // 0x04C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DarkMagicResistance;                               // 0x04D0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DarkMagicalReductionMagicResistance;               // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DarkMagicalReduction;                              // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DarkMagicalReductionMod;                           // 0x0500(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArcaneMagicResistance;                             // 0x0510(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArcaneMagicalReductionMagicResistance;             // 0x0520(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArcaneMagicalReduction;                            // 0x0530(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArcaneMagicalReductionMod;                         // 0x0540(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DivineMagicResistance;                             // 0x0550(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DivineMagicalReductionMagicResistance;             // 0x0560(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DivineMagicalReduction;                            // 0x0570(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DivineMagicalReductionMod;                         // 0x0580(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EvilMagicResistance;                               // 0x0590(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EvilMagicalReductionMagicResistance;               // 0x05A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EvilMagicalReduction;                              // 0x05B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EvilMagicalReductionMod;                           // 0x05C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AirMagicResistance;                                // 0x05D0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AirMagicalReductionMagicResistance;                // 0x05E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AirMagicalReduction;                               // 0x05F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AirMagicalReductionMod;                            // 0x0600(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpiritMagicResistance;                             // 0x0610(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpiritMagicalReductionMagicResistance;             // 0x0620(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpiritMagicalReduction;                            // 0x0630(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpiritMagicalReductionMod;                         // 0x0640(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 UndeadReductionMod;                                // 0x0650(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DemonReductionMod;                                 // 0x0660(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalHealBase;                                  // 0x0670(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalHealMod;                                   // 0x0680(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalHealingReceiveMod;                         // 0x0690(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalHealBase;                                   // 0x06A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalHealMod;                                    // 0x06B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalHealingReceiveMod;                          // 0x06C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealthRecoveryMod;                                 // 0x06D0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MemoryRecoveryMod;                                 // 0x06E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxSpellCountMod;                                  // 0x06F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeed;                                         // 0x0700(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedBase;                                     // 0x0710(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedMod;                                      // 0x0720(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedAdd;                                      // 0x0730(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeedWithModifier;                             // 0x0740(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ActionSpeed;                                       // 0x0750(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SpellCastingSpeed;                                 // 0x0760(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ItemEquipSpeed;                                    // 0x0770(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RegularInteractionSpeedBase;                       // 0x0780(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RegularInteractionSpeed;                           // 0x0790(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MagicalInteractionSpeed;                           // 0x07A0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 BuffDurationMod;                                   // 0x07B0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 DebuffDurationMod;                                 // 0x07C0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CooldownReductionMod;                              // 0x07D0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HeadshotReductionMod;                              // 0x07E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ProjectileReductionMod;                            // 0x07F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PhysicalHeadshotPenetration;                       // 0x0800(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Luck;                                              // 0x0810(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ManualDexterity;                                   // 0x0820(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Persuasiveness;                                    // 0x0830(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ImpactPower;                                       // 0x0840(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         PrimaryWeaponImpactPower;                          // 0x0850(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondaryWeaponImpactPower;                        // 0x0854(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UItemTooltipStatWidgetData*>     PrimaryAbilityWidgetArray;                         // 0x0858(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UItemTooltipStatWidgetData*>     SecondaryAbilityWidgetArray;                       // 0x0868(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterStatusDetailWidgetData) == 0x000008, "Wrong alignment on FCharacterStatusDetailWidgetData");
static_assert(sizeof(FCharacterStatusDetailWidgetData) == 0x000878, "Wrong size on FCharacterStatusDetailWidgetData");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalDamageWeaponPrimary) == 0x0001C0, "Member 'FCharacterStatusDetailWidgetData::PhysicalDamageWeaponPrimary' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalDamageWeaponSecondary) == 0x0001D0, "Member 'FCharacterStatusDetailWidgetData::PhysicalDamageWeaponSecondary' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalDamageBase) == 0x0001E0, "Member 'FCharacterStatusDetailWidgetData::PhysicalDamageBase' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalPower) == 0x0001F0, "Member 'FCharacterStatusDetailWidgetData::PhysicalPower' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalDamageMod) == 0x000200, "Member 'FCharacterStatusDetailWidgetData::PhysicalDamageMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalDamageModPhysicalPower) == 0x000210, "Member 'FCharacterStatusDetailWidgetData::PhysicalDamageModPhysicalPower' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalDamageModBonus) == 0x000220, "Member 'FCharacterStatusDetailWidgetData::PhysicalDamageModBonus' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalDamageAdd) == 0x000230, "Member 'FCharacterStatusDetailWidgetData::PhysicalDamageAdd' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalDamageTrue) == 0x000240, "Member 'FCharacterStatusDetailWidgetData::PhysicalDamageTrue' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ArmorPenetration) == 0x000250, "Member 'FCharacterStatusDetailWidgetData::ArmorPenetration' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ArmorRating) == 0x000260, "Member 'FCharacterStatusDetailWidgetData::ArmorRating' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalReductionArmorRating) == 0x000270, "Member 'FCharacterStatusDetailWidgetData::PhysicalReductionArmorRating' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalReductionBonus) == 0x000280, "Member 'FCharacterStatusDetailWidgetData::PhysicalReductionBonus' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalReduction) == 0x000290, "Member 'FCharacterStatusDetailWidgetData::PhysicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalReductionMod) == 0x0002A0, "Member 'FCharacterStatusDetailWidgetData::PhysicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalDamageBase) == 0x0002B0, "Member 'FCharacterStatusDetailWidgetData::MagicalDamageBase' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalPower) == 0x0002C0, "Member 'FCharacterStatusDetailWidgetData::MagicalPower' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalDamageMod) == 0x0002D0, "Member 'FCharacterStatusDetailWidgetData::MagicalDamageMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalDamageModMagicalPower) == 0x0002E0, "Member 'FCharacterStatusDetailWidgetData::MagicalDamageModMagicalPower' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalDamageModBonus) == 0x0002F0, "Member 'FCharacterStatusDetailWidgetData::MagicalDamageModBonus' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalDamageAdd) == 0x000300, "Member 'FCharacterStatusDetailWidgetData::MagicalDamageAdd' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalDamageTrue) == 0x000310, "Member 'FCharacterStatusDetailWidgetData::MagicalDamageTrue' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicPenetration) == 0x000320, "Member 'FCharacterStatusDetailWidgetData::MagicPenetration' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, UndeadDamageMod) == 0x000330, "Member 'FCharacterStatusDetailWidgetData::UndeadDamageMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicResistance) == 0x000340, "Member 'FCharacterStatusDetailWidgetData::MagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalReductionMagicResistance) == 0x000350, "Member 'FCharacterStatusDetailWidgetData::MagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalReductionBonus) == 0x000360, "Member 'FCharacterStatusDetailWidgetData::MagicalReductionBonus' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalReduction) == 0x000370, "Member 'FCharacterStatusDetailWidgetData::MagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalReductionMod) == 0x000380, "Member 'FCharacterStatusDetailWidgetData::MagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, FireMagicResistance) == 0x000390, "Member 'FCharacterStatusDetailWidgetData::FireMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, FireMagicalReductionMagicResistance) == 0x0003A0, "Member 'FCharacterStatusDetailWidgetData::FireMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, FireMagicalReduction) == 0x0003B0, "Member 'FCharacterStatusDetailWidgetData::FireMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, FireMagicalReductionMod) == 0x0003C0, "Member 'FCharacterStatusDetailWidgetData::FireMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, IceMagicResistance) == 0x0003D0, "Member 'FCharacterStatusDetailWidgetData::IceMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, IceMagicalReductionMagicResistance) == 0x0003E0, "Member 'FCharacterStatusDetailWidgetData::IceMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, IceMagicalReduction) == 0x0003F0, "Member 'FCharacterStatusDetailWidgetData::IceMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, IceMagicalReductionMod) == 0x000400, "Member 'FCharacterStatusDetailWidgetData::IceMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, LightningMagicResistance) == 0x000410, "Member 'FCharacterStatusDetailWidgetData::LightningMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, LightningMagicalReductionMagicResistance) == 0x000420, "Member 'FCharacterStatusDetailWidgetData::LightningMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, LightningMagicalReduction) == 0x000430, "Member 'FCharacterStatusDetailWidgetData::LightningMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, LightningMagicalReductionMod) == 0x000440, "Member 'FCharacterStatusDetailWidgetData::LightningMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, EarthMagicResistance) == 0x000450, "Member 'FCharacterStatusDetailWidgetData::EarthMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, EarthMagicalReductionMagicResistance) == 0x000460, "Member 'FCharacterStatusDetailWidgetData::EarthMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, EarthMagicalReduction) == 0x000470, "Member 'FCharacterStatusDetailWidgetData::EarthMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, EarthMagicalReductionMod) == 0x000480, "Member 'FCharacterStatusDetailWidgetData::EarthMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, LightMagicResistance) == 0x000490, "Member 'FCharacterStatusDetailWidgetData::LightMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, LightMagicalReductionMagicResistance) == 0x0004A0, "Member 'FCharacterStatusDetailWidgetData::LightMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, LightMagicalReduction) == 0x0004B0, "Member 'FCharacterStatusDetailWidgetData::LightMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, LightMagicalReductionMod) == 0x0004C0, "Member 'FCharacterStatusDetailWidgetData::LightMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, DarkMagicResistance) == 0x0004D0, "Member 'FCharacterStatusDetailWidgetData::DarkMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, DarkMagicalReductionMagicResistance) == 0x0004E0, "Member 'FCharacterStatusDetailWidgetData::DarkMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, DarkMagicalReduction) == 0x0004F0, "Member 'FCharacterStatusDetailWidgetData::DarkMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, DarkMagicalReductionMod) == 0x000500, "Member 'FCharacterStatusDetailWidgetData::DarkMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ArcaneMagicResistance) == 0x000510, "Member 'FCharacterStatusDetailWidgetData::ArcaneMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ArcaneMagicalReductionMagicResistance) == 0x000520, "Member 'FCharacterStatusDetailWidgetData::ArcaneMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ArcaneMagicalReduction) == 0x000530, "Member 'FCharacterStatusDetailWidgetData::ArcaneMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ArcaneMagicalReductionMod) == 0x000540, "Member 'FCharacterStatusDetailWidgetData::ArcaneMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, DivineMagicResistance) == 0x000550, "Member 'FCharacterStatusDetailWidgetData::DivineMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, DivineMagicalReductionMagicResistance) == 0x000560, "Member 'FCharacterStatusDetailWidgetData::DivineMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, DivineMagicalReduction) == 0x000570, "Member 'FCharacterStatusDetailWidgetData::DivineMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, DivineMagicalReductionMod) == 0x000580, "Member 'FCharacterStatusDetailWidgetData::DivineMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, EvilMagicResistance) == 0x000590, "Member 'FCharacterStatusDetailWidgetData::EvilMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, EvilMagicalReductionMagicResistance) == 0x0005A0, "Member 'FCharacterStatusDetailWidgetData::EvilMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, EvilMagicalReduction) == 0x0005B0, "Member 'FCharacterStatusDetailWidgetData::EvilMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, EvilMagicalReductionMod) == 0x0005C0, "Member 'FCharacterStatusDetailWidgetData::EvilMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, AirMagicResistance) == 0x0005D0, "Member 'FCharacterStatusDetailWidgetData::AirMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, AirMagicalReductionMagicResistance) == 0x0005E0, "Member 'FCharacterStatusDetailWidgetData::AirMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, AirMagicalReduction) == 0x0005F0, "Member 'FCharacterStatusDetailWidgetData::AirMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, AirMagicalReductionMod) == 0x000600, "Member 'FCharacterStatusDetailWidgetData::AirMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, SpiritMagicResistance) == 0x000610, "Member 'FCharacterStatusDetailWidgetData::SpiritMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, SpiritMagicalReductionMagicResistance) == 0x000620, "Member 'FCharacterStatusDetailWidgetData::SpiritMagicalReductionMagicResistance' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, SpiritMagicalReduction) == 0x000630, "Member 'FCharacterStatusDetailWidgetData::SpiritMagicalReduction' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, SpiritMagicalReductionMod) == 0x000640, "Member 'FCharacterStatusDetailWidgetData::SpiritMagicalReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, UndeadReductionMod) == 0x000650, "Member 'FCharacterStatusDetailWidgetData::UndeadReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, DemonReductionMod) == 0x000660, "Member 'FCharacterStatusDetailWidgetData::DemonReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalHealBase) == 0x000670, "Member 'FCharacterStatusDetailWidgetData::PhysicalHealBase' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalHealMod) == 0x000680, "Member 'FCharacterStatusDetailWidgetData::PhysicalHealMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalHealingReceiveMod) == 0x000690, "Member 'FCharacterStatusDetailWidgetData::PhysicalHealingReceiveMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalHealBase) == 0x0006A0, "Member 'FCharacterStatusDetailWidgetData::MagicalHealBase' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalHealMod) == 0x0006B0, "Member 'FCharacterStatusDetailWidgetData::MagicalHealMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalHealingReceiveMod) == 0x0006C0, "Member 'FCharacterStatusDetailWidgetData::MagicalHealingReceiveMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, HealthRecoveryMod) == 0x0006D0, "Member 'FCharacterStatusDetailWidgetData::HealthRecoveryMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MemoryRecoveryMod) == 0x0006E0, "Member 'FCharacterStatusDetailWidgetData::MemoryRecoveryMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MaxSpellCountMod) == 0x0006F0, "Member 'FCharacterStatusDetailWidgetData::MaxSpellCountMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MoveSpeed) == 0x000700, "Member 'FCharacterStatusDetailWidgetData::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MoveSpeedBase) == 0x000710, "Member 'FCharacterStatusDetailWidgetData::MoveSpeedBase' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MoveSpeedMod) == 0x000720, "Member 'FCharacterStatusDetailWidgetData::MoveSpeedMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MoveSpeedAdd) == 0x000730, "Member 'FCharacterStatusDetailWidgetData::MoveSpeedAdd' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MoveSpeedWithModifier) == 0x000740, "Member 'FCharacterStatusDetailWidgetData::MoveSpeedWithModifier' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ActionSpeed) == 0x000750, "Member 'FCharacterStatusDetailWidgetData::ActionSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, SpellCastingSpeed) == 0x000760, "Member 'FCharacterStatusDetailWidgetData::SpellCastingSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ItemEquipSpeed) == 0x000770, "Member 'FCharacterStatusDetailWidgetData::ItemEquipSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, RegularInteractionSpeedBase) == 0x000780, "Member 'FCharacterStatusDetailWidgetData::RegularInteractionSpeedBase' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, RegularInteractionSpeed) == 0x000790, "Member 'FCharacterStatusDetailWidgetData::RegularInteractionSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, MagicalInteractionSpeed) == 0x0007A0, "Member 'FCharacterStatusDetailWidgetData::MagicalInteractionSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, BuffDurationMod) == 0x0007B0, "Member 'FCharacterStatusDetailWidgetData::BuffDurationMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, DebuffDurationMod) == 0x0007C0, "Member 'FCharacterStatusDetailWidgetData::DebuffDurationMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, CooldownReductionMod) == 0x0007D0, "Member 'FCharacterStatusDetailWidgetData::CooldownReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, HeadshotReductionMod) == 0x0007E0, "Member 'FCharacterStatusDetailWidgetData::HeadshotReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ProjectileReductionMod) == 0x0007F0, "Member 'FCharacterStatusDetailWidgetData::ProjectileReductionMod' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PhysicalHeadshotPenetration) == 0x000800, "Member 'FCharacterStatusDetailWidgetData::PhysicalHeadshotPenetration' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, Luck) == 0x000810, "Member 'FCharacterStatusDetailWidgetData::Luck' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ManualDexterity) == 0x000820, "Member 'FCharacterStatusDetailWidgetData::ManualDexterity' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, Persuasiveness) == 0x000830, "Member 'FCharacterStatusDetailWidgetData::Persuasiveness' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, ImpactPower) == 0x000840, "Member 'FCharacterStatusDetailWidgetData::ImpactPower' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PrimaryWeaponImpactPower) == 0x000850, "Member 'FCharacterStatusDetailWidgetData::PrimaryWeaponImpactPower' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, SecondaryWeaponImpactPower) == 0x000854, "Member 'FCharacterStatusDetailWidgetData::SecondaryWeaponImpactPower' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, PrimaryAbilityWidgetArray) == 0x000858, "Member 'FCharacterStatusDetailWidgetData::PrimaryAbilityWidgetArray' has a wrong offset!");
static_assert(offsetof(FCharacterStatusDetailWidgetData, SecondaryAbilityWidgetArray) == 0x000868, "Member 'FCharacterStatusDetailWidgetData::SecondaryAbilityWidgetArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgCustomizeInfoResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgCustomizeInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_206A[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCustomizeInfoResponse) == 0x000008, "Wrong alignment on FClientMsgCustomizeInfoResponse");
static_assert(sizeof(FClientMsgCustomizeInfoResponse) == 0x000030, "Wrong size on FClientMsgCustomizeInfoResponse");

// ScriptStruct DungeonCrawler.MsgWidgetTradeChannelButtonClicked
// 0x0028 (0x0040 - 0x0018)
struct FMsgWidgetTradeChannelButtonClicked final : public FMsgBase
{
public:
	uint8                                         Pad_206B[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetTradeChannelButtonClicked) == 0x000008, "Wrong alignment on FMsgWidgetTradeChannelButtonClicked");
static_assert(sizeof(FMsgWidgetTradeChannelButtonClicked) == 0x000040, "Wrong size on FMsgWidgetTradeChannelButtonClicked");

// ScriptStruct DungeonCrawler.DCChatInfo
// 0x0080 (0x0080 - 0x0000)
struct FDCChatInfo final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCCharacterId                         CharacterId;                                       // 0x0010(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0020(0x0040)(Transient, NativeAccessSpecifierPublic)
	struct FDCPartyId                             PartyId;                                           // 0x0060(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FChatDataPiece>                 Pieces;                                            // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCChatInfo) == 0x000008, "Wrong alignment on FDCChatInfo");
static_assert(sizeof(FDCChatInfo) == 0x000080, "Wrong size on FDCChatInfo");
static_assert(offsetof(FDCChatInfo, AccountId) == 0x000000, "Member 'FDCChatInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCChatInfo, CharacterId) == 0x000010, "Member 'FDCChatInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FDCChatInfo, Nickname) == 0x000020, "Member 'FDCChatInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FDCChatInfo, PartyId) == 0x000060, "Member 'FDCChatInfo::PartyId' has a wrong offset!");
static_assert(offsetof(FDCChatInfo, Pieces) == 0x000070, "Member 'FDCChatInfo::Pieces' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgAliveReverseRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgAliveReverseRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_206C[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAliveReverseRequest) == 0x000008, "Wrong alignment on FClientMsgAliveReverseRequest");
static_assert(sizeof(FClientMsgAliveReverseRequest) == 0x000028, "Wrong size on FClientMsgAliveReverseRequest");

// ScriptStruct DungeonCrawler.MsgMusicPlaySucceed
// 0x0008 (0x0020 - 0x0018)
struct FMsgMusicPlaySucceed final : public FMsgBase
{
public:
	EMusicPlaySectionJudgement                    Judge;                                             // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_206D[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgMusicPlaySucceed) == 0x000008, "Wrong alignment on FMsgMusicPlaySucceed");
static_assert(sizeof(FMsgMusicPlaySucceed) == 0x000020, "Wrong size on FMsgMusicPlaySucceed");
static_assert(offsetof(FMsgMusicPlaySucceed, Judge) == 0x000018, "Member 'FMsgMusicPlaySucceed::Judge' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCChatLog
// 0x0088 (0x0088 - 0x0000)
struct FDCChatLog final
{
public:
	int64                                         Timestamp;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCChatInfo                            ChatInfo;                                          // 0x0008(0x0080)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCChatLog) == 0x000008, "Wrong alignment on FDCChatLog");
static_assert(sizeof(FDCChatLog) == 0x000088, "Wrong size on FDCChatLog");
static_assert(offsetof(FDCChatLog, Timestamp) == 0x000000, "Member 'FDCChatLog::Timestamp' has a wrong offset!");
static_assert(offsetof(FDCChatLog, ChatInfo) == 0x000008, "Member 'FDCChatLog::ChatInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassGroupToggleRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetClassGroupToggleRequest final : public FMsgBase
{
public:
	EWidgetClassGroupType                         WidgetClassGroupType;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_206E[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassGroupToggleRequest) == 0x000008, "Wrong alignment on FMsgWidgetClassGroupToggleRequest");
static_assert(sizeof(FMsgWidgetClassGroupToggleRequest) == 0x000020, "Wrong size on FMsgWidgetClassGroupToggleRequest");
static_assert(offsetof(FMsgWidgetClassGroupToggleRequest, WidgetClassGroupType) == 0x000018, "Member 'FMsgWidgetClassGroupToggleRequest::WidgetClassGroupType' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgRankingCharacterRequest
// 0x0080 (0x00A0 - 0x0020)
struct FClientMsgRankingCharacterRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_206F[0x80];                                    // 0x0020(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingCharacterRequest) == 0x000008, "Wrong alignment on FClientMsgRankingCharacterRequest");
static_assert(sizeof(FClientMsgRankingCharacterRequest) == 0x0000A0, "Wrong size on FClientMsgRankingCharacterRequest");

// ScriptStruct DungeonCrawler.BaseChatData
// 0x0090 (0x0090 - 0x0000)
struct FBaseChatData final
{
public:
	int64                                         Time;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChatData                              ChatData;                                          // 0x0008(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EChatWidgetType                               ChatWidgetType;                                    // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2070[0x7];                                     // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseChatData) == 0x000008, "Wrong alignment on FBaseChatData");
static_assert(sizeof(FBaseChatData) == 0x000090, "Wrong size on FBaseChatData");
static_assert(offsetof(FBaseChatData, Time) == 0x000000, "Member 'FBaseChatData::Time' has a wrong offset!");
static_assert(offsetof(FBaseChatData, ChatData) == 0x000008, "Member 'FBaseChatData::ChatData' has a wrong offset!");
static_assert(offsetof(FBaseChatData, ChatWidgetType) == 0x000088, "Member 'FBaseChatData::ChatWidgetType' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgMonsterAISet
// 0x0008 (0x0020 - 0x0018)
struct FMsgMonsterAISet final : public FMsgBase
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgMonsterAISet) == 0x000008, "Wrong alignment on FMsgMonsterAISet");
static_assert(sizeof(FMsgMonsterAISet) == 0x000020, "Wrong size on FMsgMonsterAISet");
static_assert(offsetof(FMsgMonsterAISet, BehaviorTree) == 0x000018, "Member 'FMsgMonsterAISet::BehaviorTree' has a wrong offset!");

// ScriptStruct DungeonCrawler.ChatAccountData
// 0x0060 (0x0060 - 0x0000)
struct FChatAccountData final
{
public:
	class FString                                 ChatAccountId;                                     // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChatCharacterId;                                   // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              ChatNickName;                                      // 0x0020(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChatAccountData) == 0x000008, "Wrong alignment on FChatAccountData");
static_assert(sizeof(FChatAccountData) == 0x000060, "Wrong size on FChatAccountData");
static_assert(offsetof(FChatAccountData, ChatAccountId) == 0x000000, "Member 'FChatAccountData::ChatAccountId' has a wrong offset!");
static_assert(offsetof(FChatAccountData, ChatCharacterId) == 0x000010, "Member 'FChatAccountData::ChatCharacterId' has a wrong offset!");
static_assert(offsetof(FChatAccountData, ChatNickName) == 0x000020, "Member 'FChatAccountData::ChatNickName' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTradingCloseResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTradingCloseResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2071[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingCloseResponse) == 0x000008, "Wrong alignment on FClientMsgTradingCloseResponse");
static_assert(sizeof(FClientMsgTradingCloseResponse) == 0x000020, "Wrong size on FClientMsgTradingCloseResponse");

// ScriptStruct DungeonCrawler.ChatEditWidgetData
// 0x0050 (0x0050 - 0x0000)
struct FChatEditWidgetData final
{
public:
	int32                                         StartIndex;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2072[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChatDataPiece                         ChatDataPiece;                                     // 0x0008(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChatEditWidgetData) == 0x000008, "Wrong alignment on FChatEditWidgetData");
static_assert(sizeof(FChatEditWidgetData) == 0x000050, "Wrong size on FChatEditWidgetData");
static_assert(offsetof(FChatEditWidgetData, StartIndex) == 0x000000, "Member 'FChatEditWidgetData::StartIndex' has a wrong offset!");
static_assert(offsetof(FChatEditWidgetData, ChatDataPiece) == 0x000008, "Member 'FChatEditWidgetData::ChatDataPiece' has a wrong offset!");

// ScriptStruct DungeonCrawler.ChannelChatWidgetData
// 0x0068 (0x0068 - 0x0000)
struct FChannelChatWidgetData final
{
public:
	EChatType                                     ChatType;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2073[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChatAccountData                       ChatAccountData;                                   // 0x0008(0x0060)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChannelChatWidgetData) == 0x000008, "Wrong alignment on FChannelChatWidgetData");
static_assert(sizeof(FChannelChatWidgetData) == 0x000068, "Wrong size on FChannelChatWidgetData");
static_assert(offsetof(FChannelChatWidgetData, ChatType) == 0x000000, "Member 'FChannelChatWidgetData::ChatType' has a wrong offset!");
static_assert(offsetof(FChannelChatWidgetData, ChatAccountData) == 0x000008, "Member 'FChannelChatWidgetData::ChatAccountData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ChatRecord
// 0x0090 (0x0090 - 0x0000)
struct FChatRecord final
{
public:
	EChatWidgetType                               ChatWidgetType;                                    // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2074[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DateTime;                                          // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountId;                                         // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0030(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 PartyId;                                           // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChatStr;                                           // 0x0080(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChatRecord) == 0x000008, "Wrong alignment on FChatRecord");
static_assert(sizeof(FChatRecord) == 0x000090, "Wrong size on FChatRecord");
static_assert(offsetof(FChatRecord, ChatWidgetType) == 0x000000, "Member 'FChatRecord::ChatWidgetType' has a wrong offset!");
static_assert(offsetof(FChatRecord, DateTime) == 0x000008, "Member 'FChatRecord::DateTime' has a wrong offset!");
static_assert(offsetof(FChatRecord, AccountId) == 0x000010, "Member 'FChatRecord::AccountId' has a wrong offset!");
static_assert(offsetof(FChatRecord, CharacterId) == 0x000020, "Member 'FChatRecord::CharacterId' has a wrong offset!");
static_assert(offsetof(FChatRecord, Nickname) == 0x000030, "Member 'FChatRecord::Nickname' has a wrong offset!");
static_assert(offsetof(FChatRecord, PartyId) == 0x000070, "Member 'FChatRecord::PartyId' has a wrong offset!");
static_assert(offsetof(FChatRecord, ChatStr) == 0x000080, "Member 'FChatRecord::ChatStr' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgAccountLoginRequest
// 0x0070 (0x0090 - 0x0020)
struct FClientMsgAccountLoginRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2075[0x70];                                    // 0x0020(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountLoginRequest) == 0x000008, "Wrong alignment on FClientMsgAccountLoginRequest");
static_assert(sizeof(FClientMsgAccountLoginRequest) == 0x000090, "Wrong size on FClientMsgAccountLoginRequest");

// ScriptStruct DungeonCrawler.DCAbilityRelationshipTagGroupItemData
// 0x0058 (0x0058 - 0x0000)
struct FDCAbilityRelationshipTagGroupItemData final
{
public:
	struct FGameplayTag                           AbilityTag;                                        // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   AbilityTagsToBlock;                                // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   AbilityTagsToCancel;                               // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ActivationRequiredTags;                            // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ActivationBlockedTags;                             // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ActivationCancelingTags;                           // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCAbilityRelationshipTagGroupItemData) == 0x000008, "Wrong alignment on FDCAbilityRelationshipTagGroupItemData");
static_assert(sizeof(FDCAbilityRelationshipTagGroupItemData) == 0x000058, "Wrong size on FDCAbilityRelationshipTagGroupItemData");
static_assert(offsetof(FDCAbilityRelationshipTagGroupItemData, AbilityTag) == 0x000000, "Member 'FDCAbilityRelationshipTagGroupItemData::AbilityTag' has a wrong offset!");
static_assert(offsetof(FDCAbilityRelationshipTagGroupItemData, AbilityTagsToBlock) == 0x000008, "Member 'FDCAbilityRelationshipTagGroupItemData::AbilityTagsToBlock' has a wrong offset!");
static_assert(offsetof(FDCAbilityRelationshipTagGroupItemData, AbilityTagsToCancel) == 0x000018, "Member 'FDCAbilityRelationshipTagGroupItemData::AbilityTagsToCancel' has a wrong offset!");
static_assert(offsetof(FDCAbilityRelationshipTagGroupItemData, ActivationRequiredTags) == 0x000028, "Member 'FDCAbilityRelationshipTagGroupItemData::ActivationRequiredTags' has a wrong offset!");
static_assert(offsetof(FDCAbilityRelationshipTagGroupItemData, ActivationBlockedTags) == 0x000038, "Member 'FDCAbilityRelationshipTagGroupItemData::ActivationBlockedTags' has a wrong offset!");
static_assert(offsetof(FDCAbilityRelationshipTagGroupItemData, ActivationCancelingTags) == 0x000048, "Member 'FDCAbilityRelationshipTagGroupItemData::ActivationCancelingTags' has a wrong offset!");

// ScriptStruct DungeonCrawler.MusicChannelingTargetData
// 0x0018 (0x0018 - 0x0000)
struct FMusicChannelingTargetData final
{
public:
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    ActiveGameplayEffectHandleArray;                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMusicChannelingTargetData) == 0x000008, "Wrong alignment on FMusicChannelingTargetData");
static_assert(sizeof(FMusicChannelingTargetData) == 0x000018, "Wrong size on FMusicChannelingTargetData");
static_assert(offsetof(FMusicChannelingTargetData, TargetActor) == 0x000000, "Member 'FMusicChannelingTargetData::TargetActor' has a wrong offset!");
static_assert(offsetof(FMusicChannelingTargetData, ActiveGameplayEffectHandleArray) == 0x000008, "Member 'FMusicChannelingTargetData::ActiveGameplayEffectHandleArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgAccountLoginResponse
// 0x0160 (0x0178 - 0x0018)
struct FClientMsgAccountLoginResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2076[0x160];                                   // 0x0018(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountLoginResponse) == 0x000008, "Wrong alignment on FClientMsgAccountLoginResponse");
static_assert(sizeof(FClientMsgAccountLoginResponse) == 0x000178, "Wrong size on FClientMsgAccountLoginResponse");

// ScriptStruct DungeonCrawler.ClientMsgAccountCharacterCreateRequest
// 0x0028 (0x0048 - 0x0020)
struct FClientMsgAccountCharacterCreateRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2077[0x28];                                    // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountCharacterCreateRequest) == 0x000008, "Wrong alignment on FClientMsgAccountCharacterCreateRequest");
static_assert(sizeof(FClientMsgAccountCharacterCreateRequest) == 0x000048, "Wrong size on FClientMsgAccountCharacterCreateRequest");

// ScriptStruct DungeonCrawler.MsgMusicChannelingStart
// 0x0020 (0x0038 - 0x0018)
struct FMsgMusicChannelingStart final : public FMsgBase
{
public:
	EMusicPlaySectionJudgement                    Judge;                                             // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2078[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgMusicChannelingStart) == 0x000008, "Wrong alignment on FMsgMusicChannelingStart");
static_assert(sizeof(FMsgMusicChannelingStart) == 0x000038, "Wrong size on FMsgMusicChannelingStart");
static_assert(offsetof(FMsgMusicChannelingStart, Judge) == 0x000018, "Member 'FMsgMusicChannelingStart::Judge' has a wrong offset!");
static_assert(offsetof(FMsgMusicChannelingStart, Duration) == 0x00001C, "Member 'FMsgMusicChannelingStart::Duration' has a wrong offset!");
static_assert(offsetof(FMsgMusicChannelingStart, Description) == 0x000020, "Member 'FMsgMusicChannelingStart::Description' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgAccountCharacterCreateResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgAccountCharacterCreateResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2079[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountCharacterCreateResponse) == 0x000008, "Wrong alignment on FClientMsgAccountCharacterCreateResponse");
static_assert(sizeof(FClientMsgAccountCharacterCreateResponse) == 0x000020, "Wrong size on FClientMsgAccountCharacterCreateResponse");

// ScriptStruct DungeonCrawler.DCEmoteInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCEmoteInfo final
{
public:
	class UDCEmoteDataAsset*                      Data;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEquipped;                                       // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_207A[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCEmoteInfo) == 0x000008, "Wrong alignment on FDCEmoteInfo");
static_assert(sizeof(FDCEmoteInfo) == 0x000010, "Wrong size on FDCEmoteInfo");
static_assert(offsetof(FDCEmoteInfo, Data) == 0x000000, "Member 'FDCEmoteInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCEmoteInfo, bIsEquipped) == 0x000008, "Member 'FDCEmoteInfo::bIsEquipped' has a wrong offset!");
static_assert(offsetof(FDCEmoteInfo, SlotIndex) == 0x00000C, "Member 'FDCEmoteInfo::SlotIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCLobbyEmoteInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCLobbyEmoteInfo final
{
public:
	class UDCLobbyEmoteDataAsset*                 Data;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEquipped;                                       // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_207B[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCLobbyEmoteInfo) == 0x000008, "Wrong alignment on FDCLobbyEmoteInfo");
static_assert(sizeof(FDCLobbyEmoteInfo) == 0x000010, "Wrong size on FDCLobbyEmoteInfo");
static_assert(offsetof(FDCLobbyEmoteInfo, Data) == 0x000000, "Member 'FDCLobbyEmoteInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCLobbyEmoteInfo, bIsEquipped) == 0x000008, "Member 'FDCLobbyEmoteInfo::bIsEquipped' has a wrong offset!");
static_assert(offsetof(FDCLobbyEmoteInfo, SlotIndex) == 0x00000C, "Member 'FDCLobbyEmoteInfo::SlotIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCCharacterSkinInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCCharacterSkinInfo final
{
public:
	class UDCCharacterSkinDataAsset*              Data;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEquipped;                                       // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_207C[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCCharacterSkinInfo) == 0x000008, "Wrong alignment on FDCCharacterSkinInfo");
static_assert(sizeof(FDCCharacterSkinInfo) == 0x000010, "Wrong size on FDCCharacterSkinInfo");
static_assert(offsetof(FDCCharacterSkinInfo, Data) == 0x000000, "Member 'FDCCharacterSkinInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCCharacterSkinInfo, bIsEquipped) == 0x000008, "Member 'FDCCharacterSkinInfo::bIsEquipped' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemSkinInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCItemSkinInfo final
{
public:
	class UDCTableDataAsset*                      Data;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEquipped;                                       // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_207D[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCItemSkinInfo) == 0x000008, "Wrong alignment on FDCItemSkinInfo");
static_assert(sizeof(FDCItemSkinInfo) == 0x000010, "Wrong size on FDCItemSkinInfo");
static_assert(offsetof(FDCItemSkinInfo, Data) == 0x000000, "Member 'FDCItemSkinInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCItemSkinInfo, bIsEquipped) == 0x000008, "Member 'FDCItemSkinInfo::bIsEquipped' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCActionSkinInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCActionSkinInfo final
{
public:
	class UDCActionSkinDataAsset*                 Data;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEquipped;                                       // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_207E[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCActionSkinInfo) == 0x000008, "Wrong alignment on FDCActionSkinInfo");
static_assert(sizeof(FDCActionSkinInfo) == 0x000010, "Wrong size on FDCActionSkinInfo");
static_assert(offsetof(FDCActionSkinInfo, Data) == 0x000000, "Member 'FDCActionSkinInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCActionSkinInfo, bIsEquipped) == 0x000008, "Member 'FDCActionSkinInfo::bIsEquipped' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCPlayerCharacterClassInfo
// 0x0020 (0x0020 - 0x0000)
struct FDCPlayerCharacterClassInfo final
{
public:
	class UDesignDataAssetPlayerCharacter*        Data;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOwned;                                          // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_207F[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        ShopId;                                            // 0x000C(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2080[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCPlayerCharacterClassInfo) == 0x000008, "Wrong alignment on FDCPlayerCharacterClassInfo");
static_assert(sizeof(FDCPlayerCharacterClassInfo) == 0x000020, "Wrong size on FDCPlayerCharacterClassInfo");
static_assert(offsetof(FDCPlayerCharacterClassInfo, Data) == 0x000000, "Member 'FDCPlayerCharacterClassInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCPlayerCharacterClassInfo, bIsOwned) == 0x000008, "Member 'FDCPlayerCharacterClassInfo::bIsOwned' has a wrong offset!");
static_assert(offsetof(FDCPlayerCharacterClassInfo, ShopId) == 0x00000C, "Member 'FDCPlayerCharacterClassInfo::ShopId' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCClientAccountInfo
// 0x0240 (0x0240 - 0x0000)
struct FDCClientAccountInfo final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCCharacterSkinInfo> CharacterSkins;                                    // 0x0010(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCItemSkinInfo> ItemSkins;                                         // 0x0060(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCItemSkinInfo> ArmorSkins;                                        // 0x00B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCEmoteInfo> Emotes;                                            // 0x0100(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCLobbyEmoteInfo> LobbyEmotes;                                       // 0x0150(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCActionSkinInfo> ActionSkins;                                       // 0x01A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<EDCCharacterClass, struct FDCPlayerCharacterClassInfo> PlayerCharacterClasses;                            // 0x01F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCClientAccountInfo) == 0x000008, "Wrong alignment on FDCClientAccountInfo");
static_assert(sizeof(FDCClientAccountInfo) == 0x000240, "Wrong size on FDCClientAccountInfo");
static_assert(offsetof(FDCClientAccountInfo, AccountId) == 0x000000, "Member 'FDCClientAccountInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCClientAccountInfo, CharacterSkins) == 0x000010, "Member 'FDCClientAccountInfo::CharacterSkins' has a wrong offset!");
static_assert(offsetof(FDCClientAccountInfo, ItemSkins) == 0x000060, "Member 'FDCClientAccountInfo::ItemSkins' has a wrong offset!");
static_assert(offsetof(FDCClientAccountInfo, ArmorSkins) == 0x0000B0, "Member 'FDCClientAccountInfo::ArmorSkins' has a wrong offset!");
static_assert(offsetof(FDCClientAccountInfo, Emotes) == 0x000100, "Member 'FDCClientAccountInfo::Emotes' has a wrong offset!");
static_assert(offsetof(FDCClientAccountInfo, LobbyEmotes) == 0x000150, "Member 'FDCClientAccountInfo::LobbyEmotes' has a wrong offset!");
static_assert(offsetof(FDCClientAccountInfo, ActionSkins) == 0x0001A0, "Member 'FDCClientAccountInfo::ActionSkins' has a wrong offset!");
static_assert(offsetof(FDCClientAccountInfo, PlayerCharacterClasses) == 0x0001F0, "Member 'FDCClientAccountInfo::PlayerCharacterClasses' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgAccountCharacterListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgAccountCharacterListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2081[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountCharacterListRequest) == 0x000008, "Wrong alignment on FClientMsgAccountCharacterListRequest");
static_assert(sizeof(FClientMsgAccountCharacterListRequest) == 0x000028, "Wrong size on FClientMsgAccountCharacterListRequest");

// ScriptStruct DungeonCrawler.ClientMsgAccountCharacterListResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgAccountCharacterListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2082[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountCharacterListResponse) == 0x000008, "Wrong alignment on FClientMsgAccountCharacterListResponse");
static_assert(sizeof(FClientMsgAccountCharacterListResponse) == 0x000030, "Wrong size on FClientMsgAccountCharacterListResponse");

// ScriptStruct DungeonCrawler.ClientMsgAccountCharacterDeleteRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgAccountCharacterDeleteRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2083[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountCharacterDeleteRequest) == 0x000008, "Wrong alignment on FClientMsgAccountCharacterDeleteRequest");
static_assert(sizeof(FClientMsgAccountCharacterDeleteRequest) == 0x000030, "Wrong size on FClientMsgAccountCharacterDeleteRequest");

// ScriptStruct DungeonCrawler.ClientMsgAccountCharacterDeleteResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgAccountCharacterDeleteResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2084[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountCharacterDeleteResponse) == 0x000008, "Wrong alignment on FClientMsgAccountCharacterDeleteResponse");
static_assert(sizeof(FClientMsgAccountCharacterDeleteResponse) == 0x000020, "Wrong size on FClientMsgAccountCharacterDeleteResponse");

// ScriptStruct DungeonCrawler.ClientMsgLobbyEnterRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgLobbyEnterRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2085[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyEnterRequest) == 0x000008, "Wrong alignment on FClientMsgLobbyEnterRequest");
static_assert(sizeof(FClientMsgLobbyEnterRequest) == 0x000030, "Wrong size on FClientMsgLobbyEnterRequest");

// ScriptStruct DungeonCrawler.ClientMsgShopLegendDlcInstallCheckRequest
// 0x0028 (0x0048 - 0x0020)
struct FClientMsgShopLegendDlcInstallCheckRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2086[0x28];                                    // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopLegendDlcInstallCheckRequest) == 0x000008, "Wrong alignment on FClientMsgShopLegendDlcInstallCheckRequest");
static_assert(sizeof(FClientMsgShopLegendDlcInstallCheckRequest) == 0x000048, "Wrong size on FClientMsgShopLegendDlcInstallCheckRequest");

// ScriptStruct DungeonCrawler.ClientMsgLobbyEnterResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgLobbyEnterResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2087[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyEnterResponse) == 0x000008, "Wrong alignment on FClientMsgLobbyEnterResponse");
static_assert(sizeof(FClientMsgLobbyEnterResponse) == 0x000030, "Wrong size on FClientMsgLobbyEnterResponse");

// ScriptStruct DungeonCrawler.ClientMsgAccountAgreeAnswerRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgAccountAgreeAnswerRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2088[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountAgreeAnswerRequest) == 0x000008, "Wrong alignment on FClientMsgAccountAgreeAnswerRequest");
static_assert(sizeof(FClientMsgAccountAgreeAnswerRequest) == 0x000028, "Wrong size on FClientMsgAccountAgreeAnswerRequest");

// ScriptStruct DungeonCrawler.DesignDataItemConsume
// 0x0020 (0x0020 - 0x0000)
struct FDesignDataItemConsume final
{
public:
	class FText                                   ConsumeText;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         ConsumeDuration;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConsumeInteractSpeedBonusRatio;                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemConsume) == 0x000008, "Wrong alignment on FDesignDataItemConsume");
static_assert(sizeof(FDesignDataItemConsume) == 0x000020, "Wrong size on FDesignDataItemConsume");
static_assert(offsetof(FDesignDataItemConsume, ConsumeText) == 0x000000, "Member 'FDesignDataItemConsume::ConsumeText' has a wrong offset!");
static_assert(offsetof(FDesignDataItemConsume, ConsumeDuration) == 0x000018, "Member 'FDesignDataItemConsume::ConsumeDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataItemConsume, ConsumeInteractSpeedBonusRatio) == 0x00001C, "Member 'FDesignDataItemConsume::ConsumeInteractSpeedBonusRatio' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgItemConsumeDataResponse
// 0x0120 (0x0138 - 0x0018)
struct FMsgItemConsumeDataResponse final : public FMsgBase
{
public:
	struct FItemData                              ItemData;                                          // 0x0018(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDesignDataItemConsume                 ItemConsumeData;                                   // 0x0118(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgItemConsumeDataResponse) == 0x000008, "Wrong alignment on FMsgItemConsumeDataResponse");
static_assert(sizeof(FMsgItemConsumeDataResponse) == 0x000138, "Wrong size on FMsgItemConsumeDataResponse");
static_assert(offsetof(FMsgItemConsumeDataResponse, ItemData) == 0x000018, "Member 'FMsgItemConsumeDataResponse::ItemData' has a wrong offset!");
static_assert(offsetof(FMsgItemConsumeDataResponse, ItemConsumeData) == 0x000118, "Member 'FMsgItemConsumeDataResponse::ItemConsumeData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgAccountAgreeAnswerResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgAccountAgreeAnswerResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2089[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountAgreeAnswerResponse) == 0x000008, "Wrong alignment on FClientMsgAccountAgreeAnswerResponse");
static_assert(sizeof(FClientMsgAccountAgreeAnswerResponse) == 0x000020, "Wrong size on FClientMsgAccountAgreeAnswerResponse");

// ScriptStruct DungeonCrawler.DCShopItemPriceInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCShopItemPriceInfo final
{
public:
	int32                                         Price;                                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountedPrice;                                   // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CashPrice;                                         // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountedCashPrice;                               // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCShopItemPriceInfo) == 0x000004, "Wrong alignment on FDCShopItemPriceInfo");
static_assert(sizeof(FDCShopItemPriceInfo) == 0x000010, "Wrong size on FDCShopItemPriceInfo");
static_assert(offsetof(FDCShopItemPriceInfo, Price) == 0x000000, "Member 'FDCShopItemPriceInfo::Price' has a wrong offset!");
static_assert(offsetof(FDCShopItemPriceInfo, DiscountedPrice) == 0x000004, "Member 'FDCShopItemPriceInfo::DiscountedPrice' has a wrong offset!");
static_assert(offsetof(FDCShopItemPriceInfo, CashPrice) == 0x000008, "Member 'FDCShopItemPriceInfo::CashPrice' has a wrong offset!");
static_assert(offsetof(FDCShopItemPriceInfo, DiscountedCashPrice) == 0x00000C, "Member 'FDCShopItemPriceInfo::DiscountedCashPrice' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgAccountCharacterClassListNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgAccountCharacterClassListNotify final : public FMsgBase
{
public:
	uint8                                         Pad_208A[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountCharacterClassListNotify) == 0x000008, "Wrong alignment on FClientMsgAccountCharacterClassListNotify");
static_assert(sizeof(FClientMsgAccountCharacterClassListNotify) == 0x000028, "Wrong size on FClientMsgAccountCharacterClassListNotify");

// ScriptStruct DungeonCrawler.ClientMsgUserHwInfoResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgUserHwInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_208B[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgUserHwInfoResponse) == 0x000008, "Wrong alignment on FClientMsgUserHwInfoResponse");
static_assert(sizeof(FClientMsgUserHwInfoResponse) == 0x000020, "Wrong size on FClientMsgUserHwInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgTrainingInfoResponse
// 0x0050 (0x0068 - 0x0018)
struct FClientMsgTrainingInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_208C[0x50];                                    // 0x0018(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTrainingInfoResponse) == 0x000008, "Wrong alignment on FClientMsgTrainingInfoResponse");
static_assert(sizeof(FClientMsgTrainingInfoResponse) == 0x000068, "Wrong size on FClientMsgTrainingInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelExitResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTradeChannelExitResponse final : public FMsgBase
{
public:
	uint8                                         Pad_208D[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelExitResponse) == 0x000008, "Wrong alignment on FClientMsgTradeChannelExitResponse");
static_assert(sizeof(FClientMsgTradeChannelExitResponse) == 0x000020, "Wrong size on FClientMsgTradeChannelExitResponse");

// ScriptStruct DungeonCrawler.LeaderboardRankRecordData
// 0x0078 (0x0078 - 0x0000)
struct FLeaderboardRankRecordData final
{
public:
	struct FRankRecord                            RankRecord;                                        // 0x0000(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bMine;                                             // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208E[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LeaderboardScoreFractionalDigits;                  // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeaderboardRankRecordData) == 0x000008, "Wrong alignment on FLeaderboardRankRecordData");
static_assert(sizeof(FLeaderboardRankRecordData) == 0x000078, "Wrong size on FLeaderboardRankRecordData");
static_assert(offsetof(FLeaderboardRankRecordData, RankRecord) == 0x000000, "Member 'FLeaderboardRankRecordData::RankRecord' has a wrong offset!");
static_assert(offsetof(FLeaderboardRankRecordData, bMine) == 0x000070, "Member 'FLeaderboardRankRecordData::bMine' has a wrong offset!");
static_assert(offsetof(FLeaderboardRankRecordData, LeaderboardScoreFractionalDigits) == 0x000074, "Member 'FLeaderboardRankRecordData::LeaderboardScoreFractionalDigits' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTrainingRedeemLearningTokenRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgTrainingRedeemLearningTokenRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_208F[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTrainingRedeemLearningTokenRequest) == 0x000008, "Wrong alignment on FClientMsgTrainingRedeemLearningTokenRequest");
static_assert(sizeof(FClientMsgTrainingRedeemLearningTokenRequest) == 0x000040, "Wrong size on FClientMsgTrainingRedeemLearningTokenRequest");

// ScriptStruct DungeonCrawler.ClientMsgTrainingRedeemLearningTokenResponse
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgTrainingRedeemLearningTokenResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2090[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTrainingRedeemLearningTokenResponse) == 0x000008, "Wrong alignment on FClientMsgTrainingRedeemLearningTokenResponse");
static_assert(sizeof(FClientMsgTrainingRedeemLearningTokenResponse) == 0x000040, "Wrong size on FClientMsgTrainingRedeemLearningTokenResponse");

// ScriptStruct DungeonCrawler.DesignDataItemSkin
// 0x0090 (0x0090 - 0x0000)
struct FDesignDataItemSkin final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemActor>                 ItemActor;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AProjectileActor>           ProjectileActor;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APropsActorBase>            InstallActor;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemHolderActorBase>       ItemHolderActor;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Art;                                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetItem;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCItemPreviewDataAsset*                ItemPreview;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                CharacterEquipEffects;                             // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemSkin) == 0x000008, "Wrong alignment on FDesignDataItemSkin");
static_assert(sizeof(FDesignDataItemSkin) == 0x000090, "Wrong size on FDesignDataItemSkin");
static_assert(offsetof(FDesignDataItemSkin, Name) == 0x000000, "Member 'FDesignDataItemSkin::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkin, FlavorText) == 0x000018, "Member 'FDesignDataItemSkin::FlavorText' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkin, ItemActor) == 0x000030, "Member 'FDesignDataItemSkin::ItemActor' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkin, ProjectileActor) == 0x000038, "Member 'FDesignDataItemSkin::ProjectileActor' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkin, InstallActor) == 0x000040, "Member 'FDesignDataItemSkin::InstallActor' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkin, ItemHolderActor) == 0x000048, "Member 'FDesignDataItemSkin::ItemHolderActor' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkin, Art) == 0x000050, "Member 'FDesignDataItemSkin::Art' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkin, TargetItem) == 0x000060, "Member 'FDesignDataItemSkin::TargetItem' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkin, ItemPreview) == 0x000068, "Member 'FDesignDataItemSkin::ItemPreview' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkin, SoundData) == 0x000070, "Member 'FDesignDataItemSkin::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkin, CharacterEquipEffects) == 0x000080, "Member 'FDesignDataItemSkin::CharacterEquipEffects' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTrainingReceiveClassAbilityResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTrainingReceiveClassAbilityResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2091[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTrainingReceiveClassAbilityResponse) == 0x000008, "Wrong alignment on FClientMsgTrainingReceiveClassAbilityResponse");
static_assert(sizeof(FClientMsgTrainingReceiveClassAbilityResponse) == 0x000020, "Wrong size on FClientMsgTrainingReceiveClassAbilityResponse");

// ScriptStruct DungeonCrawler.ClientMsgTrainingRedeemRewardTokenResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgTrainingRedeemRewardTokenResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2092[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTrainingRedeemRewardTokenResponse) == 0x000008, "Wrong alignment on FClientMsgTrainingRedeemRewardTokenResponse");
static_assert(sizeof(FClientMsgTrainingRedeemRewardTokenResponse) == 0x000030, "Wrong size on FClientMsgTrainingRedeemRewardTokenResponse");

// ScriptStruct DungeonCrawler.ClientMsgPartyRandomMatchmakingNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyRandomMatchmakingNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2093[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyRandomMatchmakingNotify) == 0x000008, "Wrong alignment on FClientMsgPartyRandomMatchmakingNotify");
static_assert(sizeof(FClientMsgPartyRandomMatchmakingNotify) == 0x000020, "Wrong size on FClientMsgPartyRandomMatchmakingNotify");

// ScriptStruct DungeonCrawler.ClientMsgTrainingReceiveRewardResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTrainingReceiveRewardResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2094[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTrainingReceiveRewardResponse) == 0x000008, "Wrong alignment on FClientMsgTrainingReceiveRewardResponse");
static_assert(sizeof(FClientMsgTrainingReceiveRewardResponse) == 0x000020, "Wrong size on FClientMsgTrainingReceiveRewardResponse");

// ScriptStruct DungeonCrawler.ClientMsgClassLevelInfoResponse
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgClassLevelInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2095[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassLevelInfoResponse) == 0x000008, "Wrong alignment on FClientMsgClassLevelInfoResponse");
static_assert(sizeof(FClientMsgClassLevelInfoResponse) == 0x000040, "Wrong size on FClientMsgClassLevelInfoResponse");

// ScriptStruct DungeonCrawler.DesignDataReligionBlessing
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataReligionBlessing final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Religion;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DescData;                                          // 0x0034(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2096[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataReligionBlessing) == 0x000008, "Wrong alignment on FDesignDataReligionBlessing");
static_assert(sizeof(FDesignDataReligionBlessing) == 0x000058, "Wrong size on FDesignDataReligionBlessing");
static_assert(offsetof(FDesignDataReligionBlessing, Name) == 0x000008, "Member 'FDesignDataReligionBlessing::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataReligionBlessing, Religion) == 0x000020, "Member 'FDesignDataReligionBlessing::Religion' has a wrong offset!");
static_assert(offsetof(FDesignDataReligionBlessing, Level) == 0x000030, "Member 'FDesignDataReligionBlessing::Level' has a wrong offset!");
static_assert(offsetof(FDesignDataReligionBlessing, DescData) == 0x000034, "Member 'FDesignDataReligionBlessing::DescData' has a wrong offset!");
static_assert(offsetof(FDesignDataReligionBlessing, Effects) == 0x000048, "Member 'FDesignDataReligionBlessing::Effects' has a wrong offset!");

// ScriptStruct DungeonCrawler.ActorRigidData
// 0x0040 (0x0040 - 0x0000)
struct FActorRigidData final
{
public:
	bool                                          bRigid;                                            // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2097[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          RigidPoseSnapshot;                                 // 0x0008(0x0038)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorRigidData) == 0x000008, "Wrong alignment on FActorRigidData");
static_assert(sizeof(FActorRigidData) == 0x000040, "Wrong size on FActorRigidData");
static_assert(offsetof(FActorRigidData, bRigid) == 0x000000, "Member 'FActorRigidData::bRigid' has a wrong offset!");
static_assert(offsetof(FActorRigidData, RigidPoseSnapshot) == 0x000008, "Member 'FActorRigidData::RigidPoseSnapshot' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassEquipInfoResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgClassEquipInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2098[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassEquipInfoResponse) == 0x000008, "Wrong alignment on FClientMsgClassEquipInfoResponse");
static_assert(sizeof(FClientMsgClassEquipInfoResponse) == 0x000028, "Wrong size on FClientMsgClassEquipInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgClassPerkListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgClassPerkListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2099[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassPerkListResponse) == 0x000008, "Wrong alignment on FClientMsgClassPerkListResponse");
static_assert(sizeof(FClientMsgClassPerkListResponse) == 0x000028, "Wrong size on FClientMsgClassPerkListResponse");

// ScriptStruct DungeonCrawler.ClientMsgRankingRewardGetResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgRankingRewardGetResponse final : public FMsgBase
{
public:
	uint8                                         Pad_209A[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingRewardGetResponse) == 0x000008, "Wrong alignment on FClientMsgRankingRewardGetResponse");
static_assert(sizeof(FClientMsgRankingRewardGetResponse) == 0x000020, "Wrong size on FClientMsgRankingRewardGetResponse");

// ScriptStruct DungeonCrawler.ClientMsgClassSkillListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgClassSkillListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_209B[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassSkillListResponse) == 0x000008, "Wrong alignment on FClientMsgClassSkillListResponse");
static_assert(sizeof(FClientMsgClassSkillListResponse) == 0x000028, "Wrong size on FClientMsgClassSkillListResponse");

// ScriptStruct DungeonCrawler.ClientMsgPartyCharacterSkinChangeNotify
// 0x0040 (0x0058 - 0x0018)
struct FClientMsgPartyCharacterSkinChangeNotify final : public FMsgBase
{
public:
	uint8                                         Pad_209C[0x40];                                    // 0x0018(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyCharacterSkinChangeNotify) == 0x000008, "Wrong alignment on FClientMsgPartyCharacterSkinChangeNotify");
static_assert(sizeof(FClientMsgPartyCharacterSkinChangeNotify) == 0x000058, "Wrong size on FClientMsgPartyCharacterSkinChangeNotify");

// ScriptStruct DungeonCrawler.ClientMsgClassSpellListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgClassSpellListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_209D[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassSpellListResponse) == 0x000008, "Wrong alignment on FClientMsgClassSpellListResponse");
static_assert(sizeof(FClientMsgClassSpellListResponse) == 0x000028, "Wrong size on FClientMsgClassSpellListResponse");

// ScriptStruct DungeonCrawler.DesignDataItemPropertyType
// 0x0060 (0x0060 - 0x0000)
struct FDesignDataItemPropertyType final
{
public:
	int32                                         PropertyTypeGroupId;                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PropertyType;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PerkId;                                            // 0x000C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkillId;                                           // 0x001C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SpellId;                                           // 0x002C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209E[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            EffectClass;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EffectType;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueRatio;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryTooltipPriority;                            // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryTooltipPriority;                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209F[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataItemPropertyType) == 0x000008, "Wrong alignment on FDesignDataItemPropertyType");
static_assert(sizeof(FDesignDataItemPropertyType) == 0x000060, "Wrong size on FDesignDataItemPropertyType");
static_assert(offsetof(FDesignDataItemPropertyType, PropertyTypeGroupId) == 0x000000, "Member 'FDesignDataItemPropertyType::PropertyTypeGroupId' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyType, PropertyType) == 0x000004, "Member 'FDesignDataItemPropertyType::PropertyType' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyType, PerkId) == 0x00000C, "Member 'FDesignDataItemPropertyType::PerkId' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyType, SkillId) == 0x00001C, "Member 'FDesignDataItemPropertyType::SkillId' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyType, SpellId) == 0x00002C, "Member 'FDesignDataItemPropertyType::SpellId' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyType, EffectClass) == 0x000040, "Member 'FDesignDataItemPropertyType::EffectClass' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyType, EffectType) == 0x000048, "Member 'FDesignDataItemPropertyType::EffectType' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyType, ValueRatio) == 0x000050, "Member 'FDesignDataItemPropertyType::ValueRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyType, PrimaryTooltipPriority) == 0x000054, "Member 'FDesignDataItemPropertyType::PrimaryTooltipPriority' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyType, SecondaryTooltipPriority) == 0x000058, "Member 'FDesignDataItemPropertyType::SecondaryTooltipPriority' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataItemPropertyTableRow
// 0x00A0 (0x00A8 - 0x0008)
struct FDesignDataItemPropertyTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataItemProperty> ItemProperty;                                      // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataItemPropertyType> ItemPropertyType;                                  // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemPropertyTableRow) == 0x000008, "Wrong alignment on FDesignDataItemPropertyTableRow");
static_assert(sizeof(FDesignDataItemPropertyTableRow) == 0x0000A8, "Wrong size on FDesignDataItemPropertyTableRow");
static_assert(offsetof(FDesignDataItemPropertyTableRow, ItemProperty) == 0x000008, "Member 'FDesignDataItemPropertyTableRow::ItemProperty' has a wrong offset!");
static_assert(offsetof(FDesignDataItemPropertyTableRow, ItemPropertyType) == 0x000058, "Member 'FDesignDataItemPropertyTableRow::ItemPropertyType' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelListResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgTradeChannelListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20A0[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelListResponse) == 0x000008, "Wrong alignment on FClientMsgTradeChannelListResponse");
static_assert(sizeof(FClientMsgTradeChannelListResponse) == 0x000030, "Wrong size on FClientMsgTradeChannelListResponse");

// ScriptStruct DungeonCrawler.ClientMsgClassMusicListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgClassMusicListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20A1[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassMusicListResponse) == 0x000008, "Wrong alignment on FClientMsgClassMusicListResponse");
static_assert(sizeof(FClientMsgClassMusicListResponse) == 0x000028, "Wrong size on FClientMsgClassMusicListResponse");

// ScriptStruct DungeonCrawler.ClientMsgClassShapeShiftListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgClassShapeShiftListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20A2[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassShapeShiftListResponse) == 0x000008, "Wrong alignment on FClientMsgClassShapeShiftListResponse");
static_assert(sizeof(FClientMsgClassShapeShiftListResponse) == 0x000028, "Wrong size on FClientMsgClassShapeShiftListResponse");

// ScriptStruct DungeonCrawler.ClientMsgClassSpellSlotMoveResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgClassSpellSlotMoveResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20A3[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassSpellSlotMoveResponse) == 0x000008, "Wrong alignment on FClientMsgClassSpellSlotMoveResponse");
static_assert(sizeof(FClientMsgClassSpellSlotMoveResponse) == 0x000030, "Wrong size on FClientMsgClassSpellSlotMoveResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradingItemUpdateResponse
// 0x0140 (0x0158 - 0x0018)
struct FClientMsgTradingItemUpdateResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20A4[0x140];                                   // 0x0018(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingItemUpdateResponse) == 0x000008, "Wrong alignment on FClientMsgTradingItemUpdateResponse");
static_assert(sizeof(FClientMsgTradingItemUpdateResponse) == 0x000158, "Wrong size on FClientMsgTradingItemUpdateResponse");

// ScriptStruct DungeonCrawler.ClientMsgPartyChatRequest
// 0x0080 (0x00A0 - 0x0020)
struct FClientMsgPartyChatRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20A5[0x80];                                    // 0x0020(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyChatRequest) == 0x000008, "Wrong alignment on FClientMsgPartyChatRequest");
static_assert(sizeof(FClientMsgPartyChatRequest) == 0x0000A0, "Wrong size on FClientMsgPartyChatRequest");

// ScriptStruct DungeonCrawler.ClientMsgClassSpellSequenceChangeResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgClassSpellSequenceChangeResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20A6[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassSpellSequenceChangeResponse) == 0x000008, "Wrong alignment on FClientMsgClassSpellSequenceChangeResponse");
static_assert(sizeof(FClientMsgClassSpellSequenceChangeResponse) == 0x000030, "Wrong size on FClientMsgClassSpellSequenceChangeResponse");

// ScriptStruct DungeonCrawler.DesignDataPerkTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataPerkTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataPerk> Perk;                                              // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> PerkAbility;                                       // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> PerkEffect;                                        // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataPerkTableRow) == 0x000008, "Wrong alignment on FDesignDataPerkTableRow");
static_assert(sizeof(FDesignDataPerkTableRow) == 0x0000F8, "Wrong size on FDesignDataPerkTableRow");
static_assert(offsetof(FDesignDataPerkTableRow, Perk) == 0x000008, "Member 'FDesignDataPerkTableRow::Perk' has a wrong offset!");
static_assert(offsetof(FDesignDataPerkTableRow, PerkAbility) == 0x000058, "Member 'FDesignDataPerkTableRow::PerkAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataPerkTableRow, PerkEffect) == 0x0000A8, "Member 'FDesignDataPerkTableRow::PerkEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelChatRequest
// 0x00A8 (0x00C8 - 0x0020)
struct FClientMsgTradeChannelChatRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20A7[0xA8];                                    // 0x0020(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelChatRequest) == 0x000008, "Wrong alignment on FClientMsgTradeChannelChatRequest");
static_assert(sizeof(FClientMsgTradeChannelChatRequest) == 0x0000C8, "Wrong size on FClientMsgTradeChannelChatRequest");

// ScriptStruct DungeonCrawler.ClientMsgClassItemMoveResponse
// 0x0048 (0x0060 - 0x0018)
struct FClientMsgClassItemMoveResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20A8[0x48];                                    // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassItemMoveResponse) == 0x000008, "Wrong alignment on FClientMsgClassItemMoveResponse");
static_assert(sizeof(FClientMsgClassItemMoveResponse) == 0x000060, "Wrong size on FClientMsgClassItemMoveResponse");

// ScriptStruct DungeonCrawler.ClientMsgClassMusicSlotMoveRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgClassMusicSlotMoveRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20A9[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassMusicSlotMoveRequest) == 0x000008, "Wrong alignment on FClientMsgClassMusicSlotMoveRequest");
static_assert(sizeof(FClientMsgClassMusicSlotMoveRequest) == 0x000038, "Wrong size on FClientMsgClassMusicSlotMoveRequest");

// ScriptStruct DungeonCrawler.ClientMsgClassMusicSlotMoveResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgClassMusicSlotMoveResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20AA[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassMusicSlotMoveResponse) == 0x000008, "Wrong alignment on FClientMsgClassMusicSlotMoveResponse");
static_assert(sizeof(FClientMsgClassMusicSlotMoveResponse) == 0x000030, "Wrong size on FClientMsgClassMusicSlotMoveResponse");

// ScriptStruct DungeonCrawler.ClientMsgClassMusicSequenceChangeResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgClassMusicSequenceChangeResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20AB[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassMusicSequenceChangeResponse) == 0x000008, "Wrong alignment on FClientMsgClassMusicSequenceChangeResponse");
static_assert(sizeof(FClientMsgClassMusicSequenceChangeResponse) == 0x000030, "Wrong size on FClientMsgClassMusicSequenceChangeResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradingConfirmCancelRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradingConfirmCancelRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20AC[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingConfirmCancelRequest) == 0x000008, "Wrong alignment on FClientMsgTradingConfirmCancelRequest");
static_assert(sizeof(FClientMsgTradingConfirmCancelRequest) == 0x000028, "Wrong size on FClientMsgTradingConfirmCancelRequest");

// ScriptStruct DungeonCrawler.MsgWidgetLobbyGroupHideUIbyNonCoexistWidgetResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetResponse final : public FMsgBase
{
public:
	EWidgetLobbyGroupType                         WidgetLobbyGroupType;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20AD[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetResponse) == 0x000008, "Wrong alignment on FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetResponse");
static_assert(sizeof(FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetResponse) == 0x000020, "Wrong size on FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetResponse");
static_assert(offsetof(FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetResponse, WidgetLobbyGroupType) == 0x000018, "Member 'FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetResponse::WidgetLobbyGroupType' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyStartLobbyEmoteNotify
// 0x0030 (0x0048 - 0x0018)
struct FClientMsgPartyStartLobbyEmoteNotify final : public FMsgBase
{
public:
	uint8                                         Pad_20AE[0x30];                                    // 0x0018(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyStartLobbyEmoteNotify) == 0x000008, "Wrong alignment on FClientMsgPartyStartLobbyEmoteNotify");
static_assert(sizeof(FClientMsgPartyStartLobbyEmoteNotify) == 0x000048, "Wrong size on FClientMsgPartyStartLobbyEmoteNotify");

// ScriptStruct DungeonCrawler.ClientMsgClassShapeShiftSlotMoveResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgClassShapeShiftSlotMoveResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20AF[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassShapeShiftSlotMoveResponse) == 0x000008, "Wrong alignment on FClientMsgClassShapeShiftSlotMoveResponse");
static_assert(sizeof(FClientMsgClassShapeShiftSlotMoveResponse) == 0x000030, "Wrong size on FClientMsgClassShapeShiftSlotMoveResponse");

// ScriptStruct DungeonCrawler.DesignDataIdTagGroupItem
// 0x0008 (0x0008 - 0x0000)
struct FDesignDataIdTagGroupItem final
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataIdTagGroupItem) == 0x000004, "Wrong alignment on FDesignDataIdTagGroupItem");
static_assert(sizeof(FDesignDataIdTagGroupItem) == 0x000008, "Wrong size on FDesignDataIdTagGroupItem");
static_assert(offsetof(FDesignDataIdTagGroupItem, IdTag) == 0x000000, "Member 'FDesignDataIdTagGroupItem::IdTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataIdTagGroup
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataIdTagGroup final
{
public:
	TArray<struct FDesignDataIdTagGroupItem>      IdTagGroupItemArray;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataIdTagGroup) == 0x000008, "Wrong alignment on FDesignDataIdTagGroup");
static_assert(sizeof(FDesignDataIdTagGroup) == 0x000010, "Wrong size on FDesignDataIdTagGroup");
static_assert(offsetof(FDesignDataIdTagGroup, IdTagGroupItemArray) == 0x000000, "Member 'FDesignDataIdTagGroup::IdTagGroupItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataIdTagGroupTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataIdTagGroupTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataIdTagGroup> IdTagGroup;                                        // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataIdTagGroupTableRow) == 0x000008, "Wrong alignment on FDesignDataIdTagGroupTableRow");
static_assert(sizeof(FDesignDataIdTagGroupTableRow) == 0x000058, "Wrong size on FDesignDataIdTagGroupTableRow");
static_assert(offsetof(FDesignDataIdTagGroupTableRow, IdTagGroup) == 0x000008, "Member 'FDesignDataIdTagGroupTableRow::IdTagGroup' has a wrong offset!");

// ScriptStruct DungeonCrawler.DungeonRotationItemInfo
// 0x000C (0x000C - 0x0000)
struct FDungeonRotationItemInfo final
{
public:
	EGameType                                     GameType;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20B0[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DungeonIdTag;                                      // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDungeonRotationItemInfo) == 0x000004, "Wrong alignment on FDungeonRotationItemInfo");
static_assert(sizeof(FDungeonRotationItemInfo) == 0x00000C, "Wrong size on FDungeonRotationItemInfo");
static_assert(offsetof(FDungeonRotationItemInfo, GameType) == 0x000000, "Member 'FDungeonRotationItemInfo::GameType' has a wrong offset!");
static_assert(offsetof(FDungeonRotationItemInfo, DungeonIdTag) == 0x000004, "Member 'FDungeonRotationItemInfo::DungeonIdTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.DungeonRotationInfo
// 0x0020 (0x0020 - 0x0000)
struct FDungeonRotationInfo final
{
public:
	bool                                          bMatching;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20B1[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              NextRotateDateTime;                                // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDungeonRotationItemInfo>       DungeonRotationItemInfoArray;                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDungeonRotationInfo) == 0x000008, "Wrong alignment on FDungeonRotationInfo");
static_assert(sizeof(FDungeonRotationInfo) == 0x000020, "Wrong size on FDungeonRotationInfo");
static_assert(offsetof(FDungeonRotationInfo, bMatching) == 0x000000, "Member 'FDungeonRotationInfo::bMatching' has a wrong offset!");
static_assert(offsetof(FDungeonRotationInfo, NextRotateDateTime) == 0x000008, "Member 'FDungeonRotationInfo::NextRotateDateTime' has a wrong offset!");
static_assert(offsetof(FDungeonRotationInfo, DungeonRotationItemInfoArray) == 0x000010, "Member 'FDungeonRotationInfo::DungeonRotationItemInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgClassShapeShiftSequenceChangeRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgClassShapeShiftSequenceChangeRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20B2[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassShapeShiftSequenceChangeRequest) == 0x000008, "Wrong alignment on FClientMsgClassShapeShiftSequenceChangeRequest");
static_assert(sizeof(FClientMsgClassShapeShiftSequenceChangeRequest) == 0x000038, "Wrong size on FClientMsgClassShapeShiftSequenceChangeRequest");

// ScriptStruct DungeonCrawler.DesignDataActorStatusTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataActorStatusTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> StatusEffect;                                      // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataActorStatusTableRow) == 0x000008, "Wrong alignment on FDesignDataActorStatusTableRow");
static_assert(sizeof(FDesignDataActorStatusTableRow) == 0x000058, "Wrong size on FDesignDataActorStatusTableRow");
static_assert(offsetof(FDesignDataActorStatusTableRow, StatusEffect) == 0x000008, "Member 'FDesignDataActorStatusTableRow::StatusEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTradeRequestRequest
// 0x0060 (0x0080 - 0x0020)
struct FClientMsgTradeRequestRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20B3[0x60];                                    // 0x0020(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeRequestRequest) == 0x000008, "Wrong alignment on FClientMsgTradeRequestRequest");
static_assert(sizeof(FClientMsgTradeRequestRequest) == 0x000080, "Wrong size on FClientMsgTradeRequestRequest");

// ScriptStruct DungeonCrawler.ClientMsgClassShapeShiftSequenceChangeResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgClassShapeShiftSequenceChangeResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20B4[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgClassShapeShiftSequenceChangeResponse) == 0x000008, "Wrong alignment on FClientMsgClassShapeShiftSequenceChangeResponse");
static_assert(sizeof(FClientMsgClassShapeShiftSequenceChangeResponse) == 0x000030, "Wrong size on FClientMsgClassShapeShiftSequenceChangeResponse");

// ScriptStruct DungeonCrawler.ClientMsgMetaLocationResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMetaLocationResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20B5[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMetaLocationResponse) == 0x000008, "Wrong alignment on FClientMsgMetaLocationResponse");
static_assert(sizeof(FClientMsgMetaLocationResponse) == 0x000020, "Wrong size on FClientMsgMetaLocationResponse");

// ScriptStruct DungeonCrawler.ClientMsgBlockCharacterResponse
// 0x0090 (0x00A8 - 0x0018)
struct FClientMsgBlockCharacterResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20B6[0x90];                                    // 0x0018(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgBlockCharacterResponse) == 0x000008, "Wrong alignment on FClientMsgBlockCharacterResponse");
static_assert(sizeof(FClientMsgBlockCharacterResponse) == 0x0000A8, "Wrong size on FClientMsgBlockCharacterResponse");

// ScriptStruct DungeonCrawler.DCShopItemInfo
// 0x0030 (0x0030 - 0x0000)
struct FDCShopItemInfo
{
public:
	class UDCShopDataAsset*                       Data;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOwnedItem;                                      // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B7[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCTableDataAsset*                      StockData;                                         // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              DiscountEndTime;                                   // 0x0018(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDCShopItemPriceInfo                   PriceInfo;                                         // 0x0020(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDCShopItemInfo) == 0x000008, "Wrong alignment on FDCShopItemInfo");
static_assert(sizeof(FDCShopItemInfo) == 0x000030, "Wrong size on FDCShopItemInfo");
static_assert(offsetof(FDCShopItemInfo, Data) == 0x000000, "Member 'FDCShopItemInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCShopItemInfo, bIsOwnedItem) == 0x000008, "Member 'FDCShopItemInfo::bIsOwnedItem' has a wrong offset!");
static_assert(offsetof(FDCShopItemInfo, StockData) == 0x000010, "Member 'FDCShopItemInfo::StockData' has a wrong offset!");
static_assert(offsetof(FDCShopItemInfo, DiscountEndTime) == 0x000018, "Member 'FDCShopItemInfo::DiscountEndTime' has a wrong offset!");
static_assert(offsetof(FDCShopItemInfo, PriceInfo) == 0x000020, "Member 'FDCShopItemInfo::PriceInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCEmoteShopItemInfo
// 0x0000 (0x0030 - 0x0030)
struct FDCEmoteShopItemInfo final : public FDCShopItemInfo
{
};
static_assert(alignof(FDCEmoteShopItemInfo) == 0x000008, "Wrong alignment on FDCEmoteShopItemInfo");
static_assert(sizeof(FDCEmoteShopItemInfo) == 0x000030, "Wrong size on FDCEmoteShopItemInfo");

// ScriptStruct DungeonCrawler.ClientMsgUnblockCharacterResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgUnblockCharacterResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20B8[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgUnblockCharacterResponse) == 0x000008, "Wrong alignment on FClientMsgUnblockCharacterResponse");
static_assert(sizeof(FClientMsgUnblockCharacterResponse) == 0x000030, "Wrong size on FClientMsgUnblockCharacterResponse");

// ScriptStruct DungeonCrawler.DCHitboxData
// 0x0070 (0x0070 - 0x0000)
struct FDCHitboxData final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitBoxType                                   HitBoxType;                                        // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20B9[0xF];                                     // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCHitboxData) == 0x000010, "Wrong alignment on FDCHitboxData");
static_assert(sizeof(FDCHitboxData) == 0x000070, "Wrong size on FDCHitboxData");
static_assert(offsetof(FDCHitboxData, Transform) == 0x000000, "Member 'FDCHitboxData::Transform' has a wrong offset!");
static_assert(offsetof(FDCHitboxData, HitBoxType) == 0x000060, "Member 'FDCHitboxData::HitBoxType' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgBlockCharacterListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgBlockCharacterListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20BA[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgBlockCharacterListResponse) == 0x000008, "Wrong alignment on FClientMsgBlockCharacterListResponse");
static_assert(sizeof(FClientMsgBlockCharacterListResponse) == 0x000028, "Wrong size on FClientMsgBlockCharacterListResponse");

// ScriptStruct DungeonCrawler.ClientMsgHackLogResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgHackLogResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20BB[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgHackLogResponse) == 0x000008, "Wrong alignment on FClientMsgHackLogResponse");
static_assert(sizeof(FClientMsgHackLogResponse) == 0x000020, "Wrong size on FClientMsgHackLogResponse");

// ScriptStruct DungeonCrawler.ClientMsgServicePolicyNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgServicePolicyNotify final : public FMsgBase
{
public:
	uint8                                         Pad_20BC[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgServicePolicyNotify) == 0x000008, "Wrong alignment on FClientMsgServicePolicyNotify");
static_assert(sizeof(FClientMsgServicePolicyNotify) == 0x000028, "Wrong size on FClientMsgServicePolicyNotify");

// ScriptStruct DungeonCrawler.DesignDataTriumphLevel
// 0x0008 (0x0008 - 0x0000)
struct FDesignDataTriumphLevel final
{
public:
	int32                                         ExpForNextLevel;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalExp;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataTriumphLevel) == 0x000004, "Wrong alignment on FDesignDataTriumphLevel");
static_assert(sizeof(FDesignDataTriumphLevel) == 0x000008, "Wrong size on FDesignDataTriumphLevel");
static_assert(offsetof(FDesignDataTriumphLevel, ExpForNextLevel) == 0x000000, "Member 'FDesignDataTriumphLevel::ExpForNextLevel' has a wrong offset!");
static_assert(offsetof(FDesignDataTriumphLevel, TotalExp) == 0x000004, "Member 'FDesignDataTriumphLevel::TotalExp' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgReLoginResponse
// 0x0040 (0x0058 - 0x0018)
struct FClientMsgReLoginResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20BD[0x40];                                    // 0x0018(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReLoginResponse) == 0x000008, "Wrong alignment on FClientMsgReLoginResponse");
static_assert(sizeof(FClientMsgReLoginResponse) == 0x000058, "Wrong size on FClientMsgReLoginResponse");

// ScriptStruct DungeonCrawler.ClientMsgUserCharacterInfoRequest
// 0x0078 (0x0098 - 0x0020)
struct FClientMsgUserCharacterInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20BE[0x78];                                    // 0x0020(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgUserCharacterInfoRequest) == 0x000008, "Wrong alignment on FClientMsgUserCharacterInfoRequest");
static_assert(sizeof(FClientMsgUserCharacterInfoRequest) == 0x000098, "Wrong size on FClientMsgUserCharacterInfoRequest");

// ScriptStruct DungeonCrawler.ClientMsgGmEnterGameSpectatorRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgGmEnterGameSpectatorRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20BF[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGmEnterGameSpectatorRequest) == 0x000008, "Wrong alignment on FClientMsgGmEnterGameSpectatorRequest");
static_assert(sizeof(FClientMsgGmEnterGameSpectatorRequest) == 0x000040, "Wrong size on FClientMsgGmEnterGameSpectatorRequest");

// ScriptStruct DungeonCrawler.MsgGameTestClassSpellSequenceChangeRequest
// 0x0020 (0x0038 - 0x0018)
struct FMsgGameTestClassSpellSequenceChangeRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C0[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpellId;                                           // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DstSequenceIndex;                                  // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C1[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameTestClassSpellSequenceChangeRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassSpellSequenceChangeRequest");
static_assert(sizeof(FMsgGameTestClassSpellSequenceChangeRequest) == 0x000038, "Wrong size on FMsgGameTestClassSpellSequenceChangeRequest");
static_assert(offsetof(FMsgGameTestClassSpellSequenceChangeRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassSpellSequenceChangeRequest::RequestCommand' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassSpellSequenceChangeRequest, SpellId) == 0x000020, "Member 'FMsgGameTestClassSpellSequenceChangeRequest::SpellId' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassSpellSequenceChangeRequest, DstSequenceIndex) == 0x000030, "Member 'FMsgGameTestClassSpellSequenceChangeRequest::DstSequenceIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgAllMapMatchmakingNotify
// 0x0030 (0x0048 - 0x0018)
struct FClientMsgAllMapMatchmakingNotify final : public FMsgBase
{
public:
	uint8                                         Pad_20C2[0x30];                                    // 0x0018(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAllMapMatchmakingNotify) == 0x000008, "Wrong alignment on FClientMsgAllMapMatchmakingNotify");
static_assert(sizeof(FClientMsgAllMapMatchmakingNotify) == 0x000048, "Wrong size on FClientMsgAllMapMatchmakingNotify");

// ScriptStruct DungeonCrawler.GameplayAbilityTargetData_SingleTargetHitWithTag
// 0x0178 (0x0180 - 0x0008)
struct FGameplayAbilityTargetData_SingleTargetHitWithTag final : public FGameplayAbilityTargetData
{
public:
	struct FHitResult                             HitResult;                                         // 0x0008(0x00E8)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHitReplaced;                                      // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C3[0x3];                                     // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           TargetTag;                                         // 0x00F4(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ChannelTag;                                        // 0x00FC(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C4[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SocketName;                                        // 0x0108(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C5[0x8];                                     // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ActorPrevTickTransform;                            // 0x0120(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayAbilityTargetData_SingleTargetHitWithTag) == 0x000010, "Wrong alignment on FGameplayAbilityTargetData_SingleTargetHitWithTag");
static_assert(sizeof(FGameplayAbilityTargetData_SingleTargetHitWithTag) == 0x000180, "Wrong size on FGameplayAbilityTargetData_SingleTargetHitWithTag");
static_assert(offsetof(FGameplayAbilityTargetData_SingleTargetHitWithTag, HitResult) == 0x000008, "Member 'FGameplayAbilityTargetData_SingleTargetHitWithTag::HitResult' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_SingleTargetHitWithTag, bHitReplaced) == 0x0000F0, "Member 'FGameplayAbilityTargetData_SingleTargetHitWithTag::bHitReplaced' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_SingleTargetHitWithTag, TargetTag) == 0x0000F4, "Member 'FGameplayAbilityTargetData_SingleTargetHitWithTag::TargetTag' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_SingleTargetHitWithTag, ChannelTag) == 0x0000FC, "Member 'FGameplayAbilityTargetData_SingleTargetHitWithTag::ChannelTag' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_SingleTargetHitWithTag, SocketName) == 0x000108, "Member 'FGameplayAbilityTargetData_SingleTargetHitWithTag::SocketName' has a wrong offset!");
static_assert(offsetof(FGameplayAbilityTargetData_SingleTargetHitWithTag, ActorPrevTickTransform) == 0x000120, "Member 'FGameplayAbilityTargetData_SingleTargetHitWithTag::ActorPrevTickTransform' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgLobbyCompleteNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgLobbyCompleteNotify final : public FMsgBase
{
public:
	uint8                                         Pad_20C6[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyCompleteNotify) == 0x000008, "Wrong alignment on FClientMsgLobbyCompleteNotify");
static_assert(sizeof(FClientMsgLobbyCompleteNotify) == 0x000020, "Wrong size on FClientMsgLobbyCompleteNotify");

// ScriptStruct DungeonCrawler.ClientMsgChatHackReportResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgChatHackReportResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20C7[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgChatHackReportResponse) == 0x000008, "Wrong alignment on FClientMsgChatHackReportResponse");
static_assert(sizeof(FClientMsgChatHackReportResponse) == 0x000020, "Wrong size on FClientMsgChatHackReportResponse");

// ScriptStruct DungeonCrawler.MsgGameTestClassSpellSlotMoveRequest
// 0x0020 (0x0038 - 0x0018)
struct FMsgGameTestClassSpellSlotMoveRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C8[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpellId;                                           // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DstSlotIndex;                                      // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C9[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameTestClassSpellSlotMoveRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassSpellSlotMoveRequest");
static_assert(sizeof(FMsgGameTestClassSpellSlotMoveRequest) == 0x000038, "Wrong size on FMsgGameTestClassSpellSlotMoveRequest");
static_assert(offsetof(FMsgGameTestClassSpellSlotMoveRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassSpellSlotMoveRequest::RequestCommand' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassSpellSlotMoveRequest, SpellId) == 0x000020, "Member 'FMsgGameTestClassSpellSlotMoveRequest::SpellId' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassSpellSlotMoveRequest, DstSlotIndex) == 0x000030, "Member 'FMsgGameTestClassSpellSlotMoveRequest::DstSlotIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantStockBuyRequest
// 0x0040 (0x0060 - 0x0020)
struct FClientMsgMerchantStockBuyRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20CA[0x40];                                    // 0x0020(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantStockBuyRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantStockBuyRequest");
static_assert(sizeof(FClientMsgMerchantStockBuyRequest) == 0x000060, "Wrong size on FClientMsgMerchantStockBuyRequest");

// ScriptStruct DungeonCrawler.ClientMsgJoinLastGameRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgJoinLastGameRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20CB[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgJoinLastGameRequest) == 0x000008, "Wrong alignment on FClientMsgJoinLastGameRequest");
static_assert(sizeof(FClientMsgJoinLastGameRequest) == 0x000028, "Wrong size on FClientMsgJoinLastGameRequest");

// ScriptStruct DungeonCrawler.ClientMsgJoinLastGameResponse
// 0x0048 (0x0060 - 0x0018)
struct FClientMsgJoinLastGameResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20CC[0x48];                                    // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgJoinLastGameResponse) == 0x000008, "Wrong alignment on FClientMsgJoinLastGameResponse");
static_assert(sizeof(FClientMsgJoinLastGameResponse) == 0x000060, "Wrong size on FClientMsgJoinLastGameResponse");

// ScriptStruct DungeonCrawler.MsgGameTestClassShapeShiftListRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgGameTestClassShapeShiftListRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20CD[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameTestClassShapeShiftListRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassShapeShiftListRequest");
static_assert(sizeof(FMsgGameTestClassShapeShiftListRequest) == 0x000020, "Wrong size on FMsgGameTestClassShapeShiftListRequest");
static_assert(offsetof(FMsgGameTestClassShapeShiftListRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassShapeShiftListRequest::RequestCommand' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgWhisperChatResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgWhisperChatResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20CE[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgWhisperChatResponse) == 0x000008, "Wrong alignment on FClientMsgWhisperChatResponse");
static_assert(sizeof(FClientMsgWhisperChatResponse) == 0x000020, "Wrong size on FClientMsgWhisperChatResponse");

// ScriptStruct DungeonCrawler.ClientMsgAccountStatusNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgAccountStatusNotify final : public FMsgBase
{
public:
	uint8                                         Pad_20CF[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAccountStatusNotify) == 0x000008, "Wrong alignment on FClientMsgAccountStatusNotify");
static_assert(sizeof(FClientMsgAccountStatusNotify) == 0x000020, "Wrong size on FClientMsgAccountStatusNotify");

// ScriptStruct DungeonCrawler.MsgPartySessionArrayResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgPartySessionArrayResponse final : public FMsgBase
{
public:
	TArray<class UPartySession*>                  PartySessionArray;                                 // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPartySessionArrayResponse) == 0x000008, "Wrong alignment on FMsgPartySessionArrayResponse");
static_assert(sizeof(FMsgPartySessionArrayResponse) == 0x000028, "Wrong size on FMsgPartySessionArrayResponse");
static_assert(offsetof(FMsgPartySessionArrayResponse, PartySessionArray) == 0x000018, "Member 'FMsgPartySessionArrayResponse::PartySessionArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPlatformLinkCodeGenRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgPlatformLinkCodeGenRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20D0[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPlatformLinkCodeGenRequest) == 0x000008, "Wrong alignment on FClientMsgPlatformLinkCodeGenRequest");
static_assert(sizeof(FClientMsgPlatformLinkCodeGenRequest) == 0x000028, "Wrong size on FClientMsgPlatformLinkCodeGenRequest");

// ScriptStruct DungeonCrawler.ClientMsgPlatformLinkCodeGenResponse
// 0x0020 (0x0038 - 0x0018)
struct FClientMsgPlatformLinkCodeGenResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20D1[0x20];                                    // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPlatformLinkCodeGenResponse) == 0x000008, "Wrong alignment on FClientMsgPlatformLinkCodeGenResponse");
static_assert(sizeof(FClientMsgPlatformLinkCodeGenResponse) == 0x000038, "Wrong size on FClientMsgPlatformLinkCodeGenResponse");

// ScriptStruct DungeonCrawler.MsgGameTestClassMusicSlotMoveRequest
// 0x0020 (0x0038 - 0x0018)
struct FMsgGameTestClassMusicSlotMoveRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D2[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MusicId;                                           // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DstSlotIndex;                                      // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D3[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameTestClassMusicSlotMoveRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassMusicSlotMoveRequest");
static_assert(sizeof(FMsgGameTestClassMusicSlotMoveRequest) == 0x000038, "Wrong size on FMsgGameTestClassMusicSlotMoveRequest");
static_assert(offsetof(FMsgGameTestClassMusicSlotMoveRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassMusicSlotMoveRequest::RequestCommand' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassMusicSlotMoveRequest, MusicId) == 0x000020, "Member 'FMsgGameTestClassMusicSlotMoveRequest::MusicId' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassMusicSlotMoveRequest, DstSlotIndex) == 0x000030, "Member 'FMsgGameTestClassMusicSlotMoveRequest::DstSlotIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPlatformLinkCodeActiveResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPlatformLinkCodeActiveResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20D4[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPlatformLinkCodeActiveResponse) == 0x000008, "Wrong alignment on FClientMsgPlatformLinkCodeActiveResponse");
static_assert(sizeof(FClientMsgPlatformLinkCodeActiveResponse) == 0x000020, "Wrong size on FClientMsgPlatformLinkCodeActiveResponse");

// ScriptStruct DungeonCrawler.ClientMsgPlatformLinkInfoListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgPlatformLinkInfoListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20D5[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPlatformLinkInfoListResponse) == 0x000008, "Wrong alignment on FClientMsgPlatformLinkInfoListResponse");
static_assert(sizeof(FClientMsgPlatformLinkInfoListResponse) == 0x000028, "Wrong size on FClientMsgPlatformLinkInfoListResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradeMembershipRequirementRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradeMembershipRequirementRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20D6[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeMembershipRequirementRequest) == 0x000008, "Wrong alignment on FClientMsgTradeMembershipRequirementRequest");
static_assert(sizeof(FClientMsgTradeMembershipRequirementRequest) == 0x000028, "Wrong size on FClientMsgTradeMembershipRequirementRequest");

// ScriptStruct DungeonCrawler.ClientMsgPlatformLinkFaqUrlResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgPlatformLinkFaqUrlResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20D7[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPlatformLinkFaqUrlResponse) == 0x000008, "Wrong alignment on FClientMsgPlatformLinkFaqUrlResponse");
static_assert(sizeof(FClientMsgPlatformLinkFaqUrlResponse) == 0x000028, "Wrong size on FClientMsgPlatformLinkFaqUrlResponse");

// ScriptStruct DungeonCrawler.DCEquipHoldableInfo
// 0x0028 (0x0028 - 0x0000)
struct FDCEquipHoldableInfo final
{
public:
	EDCEquipHoldType                              HoldType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20D8[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EDCEquipmentSlotIndex>                 Keys;                                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class AItemActor*>                     Values;                                            // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCEquipHoldableInfo) == 0x000008, "Wrong alignment on FDCEquipHoldableInfo");
static_assert(sizeof(FDCEquipHoldableInfo) == 0x000028, "Wrong size on FDCEquipHoldableInfo");
static_assert(offsetof(FDCEquipHoldableInfo, HoldType) == 0x000000, "Member 'FDCEquipHoldableInfo::HoldType' has a wrong offset!");
static_assert(offsetof(FDCEquipHoldableInfo, Keys) == 0x000008, "Member 'FDCEquipHoldableInfo::Keys' has a wrong offset!");
static_assert(offsetof(FDCEquipHoldableInfo, Values) == 0x000018, "Member 'FDCEquipHoldableInfo::Values' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTwitchDropsConnectRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTwitchDropsConnectRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20D9[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTwitchDropsConnectRequest) == 0x000008, "Wrong alignment on FClientMsgTwitchDropsConnectRequest");
static_assert(sizeof(FClientMsgTwitchDropsConnectRequest) == 0x000028, "Wrong size on FClientMsgTwitchDropsConnectRequest");

// ScriptStruct DungeonCrawler.ClientMsgTwitchDropsConnectNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgTwitchDropsConnectNotify final : public FMsgBase
{
public:
	uint8                                         Pad_20DA[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTwitchDropsConnectNotify) == 0x000008, "Wrong alignment on FClientMsgTwitchDropsConnectNotify");
static_assert(sizeof(FClientMsgTwitchDropsConnectNotify) == 0x000028, "Wrong size on FClientMsgTwitchDropsConnectNotify");

// ScriptStruct DungeonCrawler.ClientMsgTerminateNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTerminateNotify final : public FMsgBase
{
public:
	uint8                                         Pad_20DB[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTerminateNotify) == 0x000008, "Wrong alignment on FClientMsgTerminateNotify");
static_assert(sizeof(FClientMsgTerminateNotify) == 0x000020, "Wrong size on FClientMsgTerminateNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradeAnswerResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTradeAnswerResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20DC[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeAnswerResponse) == 0x000008, "Wrong alignment on FClientMsgTradeAnswerResponse");
static_assert(sizeof(FClientMsgTradeAnswerResponse) == 0x000020, "Wrong size on FClientMsgTradeAnswerResponse");

// ScriptStruct DungeonCrawler.ClientMsgDlcInstalledCheckRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgDlcInstalledCheckRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20DD[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgDlcInstalledCheckRequest) == 0x000008, "Wrong alignment on FClientMsgDlcInstalledCheckRequest");
static_assert(sizeof(FClientMsgDlcInstalledCheckRequest) == 0x000030, "Wrong size on FClientMsgDlcInstalledCheckRequest");

// ScriptStruct DungeonCrawler.DCPropertyAttributePerk
// 0x0014 (0x0014 - 0x0000)
struct FDCPropertyAttributePerk final
{
public:
	struct FPrimaryAssetId                        PerkId;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerkValue;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCPropertyAttributePerk) == 0x000004, "Wrong alignment on FDCPropertyAttributePerk");
static_assert(sizeof(FDCPropertyAttributePerk) == 0x000014, "Wrong size on FDCPropertyAttributePerk");
static_assert(offsetof(FDCPropertyAttributePerk, PerkId) == 0x000000, "Member 'FDCPropertyAttributePerk::PerkId' has a wrong offset!");
static_assert(offsetof(FDCPropertyAttributePerk, PerkValue) == 0x000010, "Member 'FDCPropertyAttributePerk::PerkValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCPropertyAttributeSkill
// 0x0014 (0x0014 - 0x0000)
struct FDCPropertyAttributeSkill final
{
public:
	struct FPrimaryAssetId                        SkillId;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillValue;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCPropertyAttributeSkill) == 0x000004, "Wrong alignment on FDCPropertyAttributeSkill");
static_assert(sizeof(FDCPropertyAttributeSkill) == 0x000014, "Wrong size on FDCPropertyAttributeSkill");
static_assert(offsetof(FDCPropertyAttributeSkill, SkillId) == 0x000000, "Member 'FDCPropertyAttributeSkill::SkillId' has a wrong offset!");
static_assert(offsetof(FDCPropertyAttributeSkill, SkillValue) == 0x000010, "Member 'FDCPropertyAttributeSkill::SkillValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCPropertyAttributeSpell
// 0x0014 (0x0014 - 0x0000)
struct FDCPropertyAttributeSpell final
{
public:
	struct FPrimaryAssetId                        SpellId;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpellValue;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCPropertyAttributeSpell) == 0x000004, "Wrong alignment on FDCPropertyAttributeSpell");
static_assert(sizeof(FDCPropertyAttributeSpell) == 0x000014, "Wrong size on FDCPropertyAttributeSpell");
static_assert(offsetof(FDCPropertyAttributeSpell, SpellId) == 0x000000, "Member 'FDCPropertyAttributeSpell::SpellId' has a wrong offset!");
static_assert(offsetof(FDCPropertyAttributeSpell, SpellValue) == 0x000010, "Member 'FDCPropertyAttributeSpell::SpellValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCPropertyAttribute
// 0x0030 (0x0030 - 0x0000)
struct FDCPropertyAttribute final
{
public:
	TArray<struct FDCPropertyAttributePerk>       PerkAttributeArray;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDCPropertyAttributeSkill>      SkillAttributeArray;                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDCPropertyAttributeSpell>      SpellAttributeArray;                               // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCPropertyAttribute) == 0x000008, "Wrong alignment on FDCPropertyAttribute");
static_assert(sizeof(FDCPropertyAttribute) == 0x000030, "Wrong size on FDCPropertyAttribute");
static_assert(offsetof(FDCPropertyAttribute, PerkAttributeArray) == 0x000000, "Member 'FDCPropertyAttribute::PerkAttributeArray' has a wrong offset!");
static_assert(offsetof(FDCPropertyAttribute, SkillAttributeArray) == 0x000010, "Member 'FDCPropertyAttribute::SkillAttributeArray' has a wrong offset!");
static_assert(offsetof(FDCPropertyAttribute, SpellAttributeArray) == 0x000020, "Member 'FDCPropertyAttribute::SpellAttributeArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgCustomizeInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgCustomizeInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20DE[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCustomizeInfoRequest) == 0x000008, "Wrong alignment on FClientMsgCustomizeInfoRequest");
static_assert(sizeof(FClientMsgCustomizeInfoRequest) == 0x000028, "Wrong size on FClientMsgCustomizeInfoRequest");

// ScriptStruct DungeonCrawler.ClientMsgCustomizeMountRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgCustomizeMountRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20DF[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCustomizeMountRequest) == 0x000008, "Wrong alignment on FClientMsgCustomizeMountRequest");
static_assert(sizeof(FClientMsgCustomizeMountRequest) == 0x000040, "Wrong size on FClientMsgCustomizeMountRequest");

// ScriptStruct DungeonCrawler.ClientMsgCustomizeUnmountRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgCustomizeUnmountRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20E0[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCustomizeUnmountRequest) == 0x000008, "Wrong alignment on FClientMsgCustomizeUnmountRequest");
static_assert(sizeof(FClientMsgCustomizeUnmountRequest) == 0x000038, "Wrong size on FClientMsgCustomizeUnmountRequest");

// ScriptStruct DungeonCrawler.DCModifyBoneData
// 0x0060 (0x0060 - 0x0000)
struct FDCModifyBoneData final
{
public:
	EBoneModificationMode                         ScaleMode;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20E1[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoneScale;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneModificationMode                         RotationMode;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20E2[0x7];                                     // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BoneRotation;                                      // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneModificationMode                         TranslationMode;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20E3[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoneTranslation;                                   // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCModifyBoneData) == 0x000008, "Wrong alignment on FDCModifyBoneData");
static_assert(sizeof(FDCModifyBoneData) == 0x000060, "Wrong size on FDCModifyBoneData");
static_assert(offsetof(FDCModifyBoneData, ScaleMode) == 0x000000, "Member 'FDCModifyBoneData::ScaleMode' has a wrong offset!");
static_assert(offsetof(FDCModifyBoneData, BoneScale) == 0x000008, "Member 'FDCModifyBoneData::BoneScale' has a wrong offset!");
static_assert(offsetof(FDCModifyBoneData, RotationMode) == 0x000020, "Member 'FDCModifyBoneData::RotationMode' has a wrong offset!");
static_assert(offsetof(FDCModifyBoneData, BoneRotation) == 0x000028, "Member 'FDCModifyBoneData::BoneRotation' has a wrong offset!");
static_assert(offsetof(FDCModifyBoneData, TranslationMode) == 0x000040, "Member 'FDCModifyBoneData::TranslationMode' has a wrong offset!");
static_assert(offsetof(FDCModifyBoneData, BoneTranslation) == 0x000048, "Member 'FDCModifyBoneData::BoneTranslation' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCCharacterModifyBoneData
// 0x0058 (0x0058 - 0x0000)
struct FDCCharacterModifyBoneData final
{
public:
	bool                                          bIsModifyBone;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20E4[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FDCModifyBoneData>   ModifyBonesData;                                   // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCCharacterModifyBoneData) == 0x000008, "Wrong alignment on FDCCharacterModifyBoneData");
static_assert(sizeof(FDCCharacterModifyBoneData) == 0x000058, "Wrong size on FDCCharacterModifyBoneData");
static_assert(offsetof(FDCCharacterModifyBoneData, bIsModifyBone) == 0x000000, "Member 'FDCCharacterModifyBoneData::bIsModifyBone' has a wrong offset!");
static_assert(offsetof(FDCCharacterModifyBoneData, ModifyBonesData) == 0x000008, "Member 'FDCCharacterModifyBoneData::ModifyBonesData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgCustomizeNewItemCheckRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgCustomizeNewItemCheckRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20E5[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCustomizeNewItemCheckRequest) == 0x000008, "Wrong alignment on FClientMsgCustomizeNewItemCheckRequest");
static_assert(sizeof(FClientMsgCustomizeNewItemCheckRequest) == 0x000030, "Wrong size on FClientMsgCustomizeNewItemCheckRequest");

// ScriptStruct DungeonCrawler.DCArenaForceResult
// 0x0003 (0x0003 - 0x0000)
struct FDCArenaForceResult final
{
public:
	bool                                          bSet;                                              // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCArenaTeam                                  Winner;                                            // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCArenaForceResultReason                     Reason;                                            // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCArenaForceResult) == 0x000001, "Wrong alignment on FDCArenaForceResult");
static_assert(sizeof(FDCArenaForceResult) == 0x000003, "Wrong size on FDCArenaForceResult");
static_assert(offsetof(FDCArenaForceResult, bSet) == 0x000000, "Member 'FDCArenaForceResult::bSet' has a wrong offset!");
static_assert(offsetof(FDCArenaForceResult, Winner) == 0x000001, "Member 'FDCArenaForceResult::Winner' has a wrong offset!");
static_assert(offsetof(FDCArenaForceResult, Reason) == 0x000002, "Member 'FDCArenaForceResult::Reason' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgCustomizeNewItemAlertNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgCustomizeNewItemAlertNotify final : public FMsgBase
{
public:
	uint8                                         Pad_20E6[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCustomizeNewItemAlertNotify) == 0x000008, "Wrong alignment on FClientMsgCustomizeNewItemAlertNotify");
static_assert(sizeof(FClientMsgCustomizeNewItemAlertNotify) == 0x000020, "Wrong size on FClientMsgCustomizeNewItemAlertNotify");

// ScriptStruct DungeonCrawler.ClientMsgFriendCheckAccountnicknameResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendCheckAccountnicknameResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20E7[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendCheckAccountnicknameResponse) == 0x000008, "Wrong alignment on FClientMsgFriendCheckAccountnicknameResponse");
static_assert(sizeof(FClientMsgFriendCheckAccountnicknameResponse) == 0x000020, "Wrong size on FClientMsgFriendCheckAccountnicknameResponse");

// ScriptStruct DungeonCrawler.ClientMsgFriendCreateAccountnicknameResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgFriendCreateAccountnicknameResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20E8[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendCreateAccountnicknameResponse) == 0x000008, "Wrong alignment on FClientMsgFriendCreateAccountnicknameResponse");
static_assert(sizeof(FClientMsgFriendCreateAccountnicknameResponse) == 0x000030, "Wrong size on FClientMsgFriendCreateAccountnicknameResponse");

// ScriptStruct DungeonCrawler.ClientMsgFriendSetStatusResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendSetStatusResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20E9[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendSetStatusResponse) == 0x000008, "Wrong alignment on FClientMsgFriendSetStatusResponse");
static_assert(sizeof(FClientMsgFriendSetStatusResponse) == 0x000020, "Wrong size on FClientMsgFriendSetStatusResponse");

// ScriptStruct DungeonCrawler.DCChannelPlayerInfo
// 0x0080 (0x0080 - 0x0000)
struct FDCChannelPlayerInfo final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AccountNickname;                                   // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNickname                              Nickname;                                          // 0x0020(0x0040)(Transient, NativeAccessSpecifierPrivate)
	EDCCharacterClass                             CharacterClass;                                    // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20EA[0x7];                                     // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCCharacterId                         CharacterId;                                       // 0x0068(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCGender                                     Gender;                                            // 0x0078(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20EB[0x3];                                     // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Level;                                             // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCChannelPlayerInfo) == 0x000008, "Wrong alignment on FDCChannelPlayerInfo");
static_assert(sizeof(FDCChannelPlayerInfo) == 0x000080, "Wrong size on FDCChannelPlayerInfo");
static_assert(offsetof(FDCChannelPlayerInfo, AccountId) == 0x000000, "Member 'FDCChannelPlayerInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCChannelPlayerInfo, AccountNickname) == 0x000010, "Member 'FDCChannelPlayerInfo::AccountNickname' has a wrong offset!");
static_assert(offsetof(FDCChannelPlayerInfo, Nickname) == 0x000020, "Member 'FDCChannelPlayerInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FDCChannelPlayerInfo, CharacterClass) == 0x000060, "Member 'FDCChannelPlayerInfo::CharacterClass' has a wrong offset!");
static_assert(offsetof(FDCChannelPlayerInfo, CharacterId) == 0x000068, "Member 'FDCChannelPlayerInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FDCChannelPlayerInfo, Gender) == 0x000078, "Member 'FDCChannelPlayerInfo::Gender' has a wrong offset!");
static_assert(offsetof(FDCChannelPlayerInfo, Level) == 0x00007C, "Member 'FDCChannelPlayerInfo::Level' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendSetPrivacyResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendSetPrivacyResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20EC[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendSetPrivacyResponse) == 0x000008, "Wrong alignment on FClientMsgFriendSetPrivacyResponse");
static_assert(sizeof(FClientMsgFriendSetPrivacyResponse) == 0x000020, "Wrong size on FClientMsgFriendSetPrivacyResponse");

// ScriptStruct DungeonCrawler.MsgPopup
// 0x0020 (0x0038 - 0x0018)
struct FMsgPopup : public FMsgBase
{
public:
	EPopupResult                                  PopupResult;                                       // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20ED[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDCCommonActivatableWidgetBase> WidgetClass;                                       // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPopupDataBase*                         PopupData;                                         // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBackHandler;                                    // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20EE[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgPopup) == 0x000008, "Wrong alignment on FMsgPopup");
static_assert(sizeof(FMsgPopup) == 0x000038, "Wrong size on FMsgPopup");
static_assert(offsetof(FMsgPopup, PopupResult) == 0x000018, "Member 'FMsgPopup::PopupResult' has a wrong offset!");
static_assert(offsetof(FMsgPopup, WidgetClass) == 0x000020, "Member 'FMsgPopup::WidgetClass' has a wrong offset!");
static_assert(offsetof(FMsgPopup, PopupData) == 0x000028, "Member 'FMsgPopup::PopupData' has a wrong offset!");
static_assert(offsetof(FMsgPopup, bIsBackHandler) == 0x000030, "Member 'FMsgPopup::bIsBackHandler' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetPopupMessageResponse
// 0x0000 (0x0038 - 0x0038)
struct FMsgWidgetPopupMessageResponse final : public FMsgPopup
{
};
static_assert(alignof(FMsgWidgetPopupMessageResponse) == 0x000008, "Wrong alignment on FMsgWidgetPopupMessageResponse");
static_assert(sizeof(FMsgWidgetPopupMessageResponse) == 0x000038, "Wrong size on FMsgWidgetPopupMessageResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopItemListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgShopItemListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20EF[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopItemListRequest) == 0x000008, "Wrong alignment on FClientMsgShopItemListRequest");
static_assert(sizeof(FClientMsgShopItemListRequest) == 0x000028, "Wrong size on FClientMsgShopItemListRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendInviteRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgFriendInviteRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20F0[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInviteRequest) == 0x000008, "Wrong alignment on FClientMsgFriendInviteRequest");
static_assert(sizeof(FClientMsgFriendInviteRequest) == 0x000030, "Wrong size on FClientMsgFriendInviteRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendInviteResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendInviteResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20F1[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInviteResponse) == 0x000008, "Wrong alignment on FClientMsgFriendInviteResponse");
static_assert(sizeof(FClientMsgFriendInviteResponse) == 0x000020, "Wrong size on FClientMsgFriendInviteResponse");

// ScriptStruct DungeonCrawler.MsgGASActorStatusUpdated
// 0x0010 (0x0028 - 0x0018)
struct FMsgGASActorStatusUpdated final : public FMsgBase
{
public:
	TArray<struct FActorStatusData>               ActorStatusDatas;                                  // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGASActorStatusUpdated) == 0x000008, "Wrong alignment on FMsgGASActorStatusUpdated");
static_assert(sizeof(FMsgGASActorStatusUpdated) == 0x000028, "Wrong size on FMsgGASActorStatusUpdated");
static_assert(offsetof(FMsgGASActorStatusUpdated, ActorStatusDatas) == 0x000018, "Member 'FMsgGASActorStatusUpdated::ActorStatusDatas' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestContentValueStackRequest
// 0x0040 (0x0060 - 0x0020)
struct FClientMsgMerchantQuestContentValueStackRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20F2[0x40];                                    // 0x0020(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestContentValueStackRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestContentValueStackRequest");
static_assert(sizeof(FClientMsgMerchantQuestContentValueStackRequest) == 0x000060, "Wrong size on FClientMsgMerchantQuestContentValueStackRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendInviteByAccountnicknameRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgFriendInviteByAccountnicknameRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20F3[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInviteByAccountnicknameRequest) == 0x000008, "Wrong alignment on FClientMsgFriendInviteByAccountnicknameRequest");
static_assert(sizeof(FClientMsgFriendInviteByAccountnicknameRequest) == 0x000030, "Wrong size on FClientMsgFriendInviteByAccountnicknameRequest");

// ScriptStruct DungeonCrawler.MsgGameClassMoveInfo
// 0x0020 (0x0038 - 0x0018)
struct FMsgGameClassMoveInfo final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MoveId;                                            // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Move;                                              // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F4[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameClassMoveInfo) == 0x000008, "Wrong alignment on FMsgGameClassMoveInfo");
static_assert(sizeof(FMsgGameClassMoveInfo) == 0x000038, "Wrong size on FMsgGameClassMoveInfo");
static_assert(offsetof(FMsgGameClassMoveInfo, Index) == 0x000018, "Member 'FMsgGameClassMoveInfo::Index' has a wrong offset!");
static_assert(offsetof(FMsgGameClassMoveInfo, Type) == 0x00001C, "Member 'FMsgGameClassMoveInfo::Type' has a wrong offset!");
static_assert(offsetof(FMsgGameClassMoveInfo, MoveId) == 0x000020, "Member 'FMsgGameClassMoveInfo::MoveId' has a wrong offset!");
static_assert(offsetof(FMsgGameClassMoveInfo, Move) == 0x000030, "Member 'FMsgGameClassMoveInfo::Move' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassItemMoveRequest
// 0x0078 (0x0090 - 0x0018)
struct FMsgGameTestClassItemMoveRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F5[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMsgGameClassMoveInfo                  OldMove;                                           // 0x0020(0x0038)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMsgGameClassMoveInfo                  NewMove;                                           // 0x0058(0x0038)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassItemMoveRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassItemMoveRequest");
static_assert(sizeof(FMsgGameTestClassItemMoveRequest) == 0x000090, "Wrong size on FMsgGameTestClassItemMoveRequest");
static_assert(offsetof(FMsgGameTestClassItemMoveRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassItemMoveRequest::RequestCommand' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassItemMoveRequest, OldMove) == 0x000020, "Member 'FMsgGameTestClassItemMoveRequest::OldMove' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassItemMoveRequest, NewMove) == 0x000058, "Member 'FMsgGameTestClassItemMoveRequest::NewMove' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendInviteByAccountnicknameResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendInviteByAccountnicknameResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20F6[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInviteByAccountnicknameResponse) == 0x000008, "Wrong alignment on FClientMsgFriendInviteByAccountnicknameResponse");
static_assert(sizeof(FClientMsgFriendInviteByAccountnicknameResponse) == 0x000020, "Wrong size on FClientMsgFriendInviteByAccountnicknameResponse");

// ScriptStruct DungeonCrawler.MsgWidgetStreamingModeNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetStreamingModeNotify final : public FMsgBase
{
public:
	bool                                          bCurrentStreamingMode;                             // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F7[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetStreamingModeNotify) == 0x000008, "Wrong alignment on FMsgWidgetStreamingModeNotify");
static_assert(sizeof(FMsgWidgetStreamingModeNotify) == 0x000020, "Wrong size on FMsgWidgetStreamingModeNotify");
static_assert(offsetof(FMsgWidgetStreamingModeNotify, bCurrentStreamingMode) == 0x000018, "Member 'FMsgWidgetStreamingModeNotify::bCurrentStreamingMode' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyMemberInfoNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgPartyMemberInfoNotify final : public FMsgBase
{
public:
	uint8                                         Pad_20F8[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyMemberInfoNotify) == 0x000008, "Wrong alignment on FClientMsgPartyMemberInfoNotify");
static_assert(sizeof(FClientMsgPartyMemberInfoNotify) == 0x000028, "Wrong size on FClientMsgPartyMemberInfoNotify");

// ScriptStruct DungeonCrawler.ClientMsgFriendInviteAcceptRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgFriendInviteAcceptRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20F9[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInviteAcceptRequest) == 0x000008, "Wrong alignment on FClientMsgFriendInviteAcceptRequest");
static_assert(sizeof(FClientMsgFriendInviteAcceptRequest) == 0x000030, "Wrong size on FClientMsgFriendInviteAcceptRequest");

// ScriptStruct DungeonCrawler.MsgGameTestClassSpellListRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgGameTestClassSpellListRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpellMemory;                                    // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassSpellListRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassSpellListRequest");
static_assert(sizeof(FMsgGameTestClassSpellListRequest) == 0x000020, "Wrong size on FMsgGameTestClassSpellListRequest");
static_assert(offsetof(FMsgGameTestClassSpellListRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassSpellListRequest::RequestCommand' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassSpellListRequest, MaxSpellMemory) == 0x00001C, "Member 'FMsgGameTestClassSpellListRequest::MaxSpellMemory' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendInviteAcceptResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendInviteAcceptResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20FA[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInviteAcceptResponse) == 0x000008, "Wrong alignment on FClientMsgFriendInviteAcceptResponse");
static_assert(sizeof(FClientMsgFriendInviteAcceptResponse) == 0x000020, "Wrong size on FClientMsgFriendInviteAcceptResponse");

// ScriptStruct DungeonCrawler.ClientMsgFriendInviteDeclineRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgFriendInviteDeclineRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20FB[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInviteDeclineRequest) == 0x000008, "Wrong alignment on FClientMsgFriendInviteDeclineRequest");
static_assert(sizeof(FClientMsgFriendInviteDeclineRequest) == 0x000030, "Wrong size on FClientMsgFriendInviteDeclineRequest");

// ScriptStruct DungeonCrawler.ClientMsgMerchantExpressBuyResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgMerchantExpressBuyResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20FC[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantExpressBuyResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantExpressBuyResponse");
static_assert(sizeof(FClientMsgMerchantExpressBuyResponse) == 0x000030, "Wrong size on FClientMsgMerchantExpressBuyResponse");

// ScriptStruct DungeonCrawler.ClientMsgFriendInviteDeclineResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendInviteDeclineResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20FD[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInviteDeclineResponse) == 0x000008, "Wrong alignment on FClientMsgFriendInviteDeclineResponse");
static_assert(sizeof(FClientMsgFriendInviteDeclineResponse) == 0x000020, "Wrong size on FClientMsgFriendInviteDeclineResponse");

// ScriptStruct DungeonCrawler.MsgGASActorStatusRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgGASActorStatusRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgGASActorStatusRequest) == 0x000008, "Wrong alignment on FMsgGASActorStatusRequest");
static_assert(sizeof(FMsgGASActorStatusRequest) == 0x000018, "Wrong size on FMsgGASActorStatusRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendInviteCancelRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgFriendInviteCancelRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_20FE[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInviteCancelRequest) == 0x000008, "Wrong alignment on FClientMsgFriendInviteCancelRequest");
static_assert(sizeof(FClientMsgFriendInviteCancelRequest) == 0x000030, "Wrong size on FClientMsgFriendInviteCancelRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendInviteCancelResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendInviteCancelResponse final : public FMsgBase
{
public:
	uint8                                         Pad_20FF[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInviteCancelResponse) == 0x000008, "Wrong alignment on FClientMsgFriendInviteCancelResponse");
static_assert(sizeof(FClientMsgFriendInviteCancelResponse) == 0x000020, "Wrong size on FClientMsgFriendInviteCancelResponse");

// ScriptStruct DungeonCrawler.MsgGameTestClassPerkListRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgGameTestClassPerkListRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2100[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameTestClassPerkListRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassPerkListRequest");
static_assert(sizeof(FMsgGameTestClassPerkListRequest) == 0x000020, "Wrong size on FMsgGameTestClassPerkListRequest");
static_assert(offsetof(FMsgGameTestClassPerkListRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassPerkListRequest::RequestCommand' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantEquipBaseGearSetRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMerchantEquipBaseGearSetRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2101[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantEquipBaseGearSetRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantEquipBaseGearSetRequest");
static_assert(sizeof(FClientMsgMerchantEquipBaseGearSetRequest) == 0x000028, "Wrong size on FClientMsgMerchantEquipBaseGearSetRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendDelFriendRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgFriendDelFriendRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2102[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendDelFriendRequest) == 0x000008, "Wrong alignment on FClientMsgFriendDelFriendRequest");
static_assert(sizeof(FClientMsgFriendDelFriendRequest) == 0x000030, "Wrong size on FClientMsgFriendDelFriendRequest");

// ScriptStruct DungeonCrawler.MsgGameTestClassShapeShiftSlotMoveRequest
// 0x0020 (0x0038 - 0x0018)
struct FMsgGameTestClassShapeShiftSlotMoveRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2103[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ShapeShiftId;                                      // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DstSlotIndex;                                      // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2104[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameTestClassShapeShiftSlotMoveRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassShapeShiftSlotMoveRequest");
static_assert(sizeof(FMsgGameTestClassShapeShiftSlotMoveRequest) == 0x000038, "Wrong size on FMsgGameTestClassShapeShiftSlotMoveRequest");
static_assert(offsetof(FMsgGameTestClassShapeShiftSlotMoveRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassShapeShiftSlotMoveRequest::RequestCommand' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassShapeShiftSlotMoveRequest, ShapeShiftId) == 0x000020, "Member 'FMsgGameTestClassShapeShiftSlotMoveRequest::ShapeShiftId' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassShapeShiftSlotMoveRequest, DstSlotIndex) == 0x000030, "Member 'FMsgGameTestClassShapeShiftSlotMoveRequest::DstSlotIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendDelFriendResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendDelFriendResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2105[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendDelFriendResponse) == 0x000008, "Wrong alignment on FClientMsgFriendDelFriendResponse");
static_assert(sizeof(FClientMsgFriendDelFriendResponse) == 0x000020, "Wrong size on FClientMsgFriendDelFriendResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantStockBuyItemListRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgMerchantStockBuyItemListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2106[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantStockBuyItemListRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantStockBuyItemListRequest");
static_assert(sizeof(FClientMsgMerchantStockBuyItemListRequest) == 0x000030, "Wrong size on FClientMsgMerchantStockBuyItemListRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendInfoNotify
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgFriendInfoNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2107[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendInfoNotify) == 0x000008, "Wrong alignment on FClientMsgFriendInfoNotify");
static_assert(sizeof(FClientMsgFriendInfoNotify) == 0x000030, "Wrong size on FClientMsgFriendInfoNotify");

// ScriptStruct DungeonCrawler.MsgGameTestClassMusicListRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgGameTestClassMusicListRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2108[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameTestClassMusicListRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassMusicListRequest");
static_assert(sizeof(FMsgGameTestClassMusicListRequest) == 0x000020, "Wrong size on FMsgGameTestClassMusicListRequest");
static_assert(offsetof(FMsgGameTestClassMusicListRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassMusicListRequest::RequestCommand' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendSetFriendInfosNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgFriendSetFriendInfosNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2109[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendSetFriendInfosNotify) == 0x000008, "Wrong alignment on FClientMsgFriendSetFriendInfosNotify");
static_assert(sizeof(FClientMsgFriendSetFriendInfosNotify) == 0x000028, "Wrong size on FClientMsgFriendSetFriendInfosNotify");

// ScriptStruct DungeonCrawler.ClientMsgFriendDelFriendInfosNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgFriendDelFriendInfosNotify final : public FMsgBase
{
public:
	uint8                                         Pad_210A[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendDelFriendInfosNotify) == 0x000008, "Wrong alignment on FClientMsgFriendDelFriendInfosNotify");
static_assert(sizeof(FClientMsgFriendDelFriendInfosNotify) == 0x000028, "Wrong size on FClientMsgFriendDelFriendInfosNotify");

// ScriptStruct DungeonCrawler.ClientMsgPartyExitRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgPartyExitRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_210B[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyExitRequest) == 0x000008, "Wrong alignment on FClientMsgPartyExitRequest");
static_assert(sizeof(FClientMsgPartyExitRequest) == 0x000028, "Wrong size on FClientMsgPartyExitRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendSetAcceptInfosNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgFriendSetAcceptInfosNotify final : public FMsgBase
{
public:
	uint8                                         Pad_210C[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendSetAcceptInfosNotify) == 0x000008, "Wrong alignment on FClientMsgFriendSetAcceptInfosNotify");
static_assert(sizeof(FClientMsgFriendSetAcceptInfosNotify) == 0x000028, "Wrong size on FClientMsgFriendSetAcceptInfosNotify");

// ScriptStruct DungeonCrawler.MsgGameTestClassLevelInfoRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgGameTestClassLevelInfoRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_210D[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameTestClassLevelInfoRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassLevelInfoRequest");
static_assert(sizeof(FMsgGameTestClassLevelInfoRequest) == 0x000020, "Wrong size on FMsgGameTestClassLevelInfoRequest");
static_assert(offsetof(FMsgGameTestClassLevelInfoRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassLevelInfoRequest::RequestCommand' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendDelAcceptInfosNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgFriendDelAcceptInfosNotify final : public FMsgBase
{
public:
	uint8                                         Pad_210E[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendDelAcceptInfosNotify) == 0x000008, "Wrong alignment on FClientMsgFriendDelAcceptInfosNotify");
static_assert(sizeof(FClientMsgFriendDelAcceptInfosNotify) == 0x000028, "Wrong size on FClientMsgFriendDelAcceptInfosNotify");

// ScriptStruct DungeonCrawler.ClientMsgFriendSetInviteInfosNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgFriendSetInviteInfosNotify final : public FMsgBase
{
public:
	uint8                                         Pad_210F[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendSetInviteInfosNotify) == 0x000008, "Wrong alignment on FClientMsgFriendSetInviteInfosNotify");
static_assert(sizeof(FClientMsgFriendSetInviteInfosNotify) == 0x000028, "Wrong size on FClientMsgFriendSetInviteInfosNotify");

// ScriptStruct DungeonCrawler.MsgEnableAddItemResponse
// 0x0018 (0x0030 - 0x0018)
struct FMsgEnableAddItemResponse final : public FMsgBase
{
public:
	bool                                          bCanAdd;                                           // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvalidRequest;                                   // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2110[0x6];                                     // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      ResultItemDataArray;                               // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgEnableAddItemResponse) == 0x000008, "Wrong alignment on FMsgEnableAddItemResponse");
static_assert(sizeof(FMsgEnableAddItemResponse) == 0x000030, "Wrong size on FMsgEnableAddItemResponse");
static_assert(offsetof(FMsgEnableAddItemResponse, bCanAdd) == 0x000018, "Member 'FMsgEnableAddItemResponse::bCanAdd' has a wrong offset!");
static_assert(offsetof(FMsgEnableAddItemResponse, bInvalidRequest) == 0x000019, "Member 'FMsgEnableAddItemResponse::bInvalidRequest' has a wrong offset!");
static_assert(offsetof(FMsgEnableAddItemResponse, ResultItemDataArray) == 0x000020, "Member 'FMsgEnableAddItemResponse::ResultItemDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgReligionPersonalRankingRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgReligionPersonalRankingRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2111[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionPersonalRankingRequest) == 0x000008, "Wrong alignment on FClientMsgReligionPersonalRankingRequest");
static_assert(sizeof(FClientMsgReligionPersonalRankingRequest) == 0x000040, "Wrong size on FClientMsgReligionPersonalRankingRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendDelInviteInfosNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgFriendDelInviteInfosNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2112[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendDelInviteInfosNotify) == 0x000008, "Wrong alignment on FClientMsgFriendDelInviteInfosNotify");
static_assert(sizeof(FClientMsgFriendDelInviteInfosNotify) == 0x000028, "Wrong size on FClientMsgFriendDelInviteInfosNotify");

// ScriptStruct DungeonCrawler.GameUserSettingControls
// 0x0040 (0x0040 - 0x0000)
struct FGameUserSettingControls final
{
public:
	float                                         MouseSensitivity;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInvertVerticalAxis;                             // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInvertHorizontalAxis;                           // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2113[0x2];                                     // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Culture;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCWhisperReceiveType                         WhisperReceiveType;                                // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreInvitation;                                 // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStreamingMode;                                    // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2114[0x1];                                     // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RegionIndex;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchModeIndex;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameTypeIndex;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotRandomPartyMember;                             // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2115[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           LoadingDungeonIdTag;                               // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadingFloorIdx;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoFillUtilitySlot;                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoNextUtilitySlot;                              // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowKnightLink;                                 // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeathCam;                                         // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSquireMessage;                                // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowSquireIndicator;                              // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLowViolenceMode;                               // 0x003E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2116[0x1];                                     // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameUserSettingControls) == 0x000008, "Wrong alignment on FGameUserSettingControls");
static_assert(sizeof(FGameUserSettingControls) == 0x000040, "Wrong size on FGameUserSettingControls");
static_assert(offsetof(FGameUserSettingControls, MouseSensitivity) == 0x000000, "Member 'FGameUserSettingControls::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bIsInvertVerticalAxis) == 0x000004, "Member 'FGameUserSettingControls::bIsInvertVerticalAxis' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bIsInvertHorizontalAxis) == 0x000005, "Member 'FGameUserSettingControls::bIsInvertHorizontalAxis' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, Culture) == 0x000008, "Member 'FGameUserSettingControls::Culture' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, WhisperReceiveType) == 0x000018, "Member 'FGameUserSettingControls::WhisperReceiveType' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bIgnoreInvitation) == 0x000019, "Member 'FGameUserSettingControls::bIgnoreInvitation' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bStreamingMode) == 0x00001A, "Member 'FGameUserSettingControls::bStreamingMode' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, RegionIndex) == 0x00001C, "Member 'FGameUserSettingControls::RegionIndex' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, MatchModeIndex) == 0x000020, "Member 'FGameUserSettingControls::MatchModeIndex' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, GameTypeIndex) == 0x000024, "Member 'FGameUserSettingControls::GameTypeIndex' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bNotRandomPartyMember) == 0x000028, "Member 'FGameUserSettingControls::bNotRandomPartyMember' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, LoadingDungeonIdTag) == 0x00002C, "Member 'FGameUserSettingControls::LoadingDungeonIdTag' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, LoadingFloorIdx) == 0x000034, "Member 'FGameUserSettingControls::LoadingFloorIdx' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bAutoFillUtilitySlot) == 0x000038, "Member 'FGameUserSettingControls::bAutoFillUtilitySlot' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bAutoNextUtilitySlot) == 0x000039, "Member 'FGameUserSettingControls::bAutoNextUtilitySlot' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bIsShowKnightLink) == 0x00003A, "Member 'FGameUserSettingControls::bIsShowKnightLink' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bDeathCam) == 0x00003B, "Member 'FGameUserSettingControls::bDeathCam' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bShowSquireMessage) == 0x00003C, "Member 'FGameUserSettingControls::bShowSquireMessage' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bShowSquireIndicator) == 0x00003D, "Member 'FGameUserSettingControls::bShowSquireIndicator' has a wrong offset!");
static_assert(offsetof(FGameUserSettingControls, bUseLowViolenceMode) == 0x00003E, "Member 'FGameUserSettingControls::bUseLowViolenceMode' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendSetStatusNotify
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgFriendSetStatusNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2117[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendSetStatusNotify) == 0x000008, "Wrong alignment on FClientMsgFriendSetStatusNotify");
static_assert(sizeof(FClientMsgFriendSetStatusNotify) == 0x000030, "Wrong size on FClientMsgFriendSetStatusNotify");

// ScriptStruct DungeonCrawler.ClientMsgMerchantServiceCraftListRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgMerchantServiceCraftListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2118[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantServiceCraftListRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantServiceCraftListRequest");
static_assert(sizeof(FClientMsgMerchantServiceCraftListRequest) == 0x000030, "Wrong size on FClientMsgMerchantServiceCraftListRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgFriendListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2119[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendListRequest) == 0x000008, "Wrong alignment on FClientMsgFriendListRequest");
static_assert(sizeof(FClientMsgFriendListRequest) == 0x000028, "Wrong size on FClientMsgFriendListRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendListAllRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgFriendListAllRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_211A[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendListAllRequest) == 0x000008, "Wrong alignment on FClientMsgFriendListAllRequest");
static_assert(sizeof(FClientMsgFriendListAllRequest) == 0x000028, "Wrong size on FClientMsgFriendListAllRequest");

// ScriptStruct DungeonCrawler.ClientMsgPartyCharacterSkinListNotify
// 0x0030 (0x0048 - 0x0018)
struct FClientMsgPartyCharacterSkinListNotify final : public FMsgBase
{
public:
	uint8                                         Pad_211B[0x30];                                    // 0x0018(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyCharacterSkinListNotify) == 0x000008, "Wrong alignment on FClientMsgPartyCharacterSkinListNotify");
static_assert(sizeof(FClientMsgPartyCharacterSkinListNotify) == 0x000048, "Wrong size on FClientMsgPartyCharacterSkinListNotify");

// ScriptStruct DungeonCrawler.ClientMsgFriendListAllResponse
// 0x0020 (0x0038 - 0x0018)
struct FClientMsgFriendListAllResponse final : public FMsgBase
{
public:
	uint8                                         Pad_211C[0x20];                                    // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendListAllResponse) == 0x000008, "Wrong alignment on FClientMsgFriendListAllResponse");
static_assert(sizeof(FClientMsgFriendListAllResponse) == 0x000038, "Wrong size on FClientMsgFriendListAllResponse");

// ScriptStruct DungeonCrawler.LootingTargetPlayerInventory
// 0x0018 (0x0018 - 0x0000)
struct FLootingTargetPlayerInventory final
{
public:
	class UEquipmentInventoryComponent*           EquipmentInventory;                                // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInventoryComponent*>            ContainerInventoryArray;                           // 0x0008(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootingTargetPlayerInventory) == 0x000008, "Wrong alignment on FLootingTargetPlayerInventory");
static_assert(sizeof(FLootingTargetPlayerInventory) == 0x000018, "Wrong size on FLootingTargetPlayerInventory");
static_assert(offsetof(FLootingTargetPlayerInventory, EquipmentInventory) == 0x000000, "Member 'FLootingTargetPlayerInventory::EquipmentInventory' has a wrong offset!");
static_assert(offsetof(FLootingTargetPlayerInventory, ContainerInventoryArray) == 0x000008, "Member 'FLootingTargetPlayerInventory::ContainerInventoryArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgLootingTargetPlayerInventoryNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgLootingTargetPlayerInventoryNotify final : public FMsgBase
{
public:
	struct FLootingTargetPlayerInventory          TargetPlayerInventory;                             // 0x0018(0x0018)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgLootingTargetPlayerInventoryNotify) == 0x000008, "Wrong alignment on FMsgLootingTargetPlayerInventoryNotify");
static_assert(sizeof(FMsgLootingTargetPlayerInventoryNotify) == 0x000030, "Wrong size on FMsgLootingTargetPlayerInventoryNotify");
static_assert(offsetof(FMsgLootingTargetPlayerInventoryNotify, TargetPlayerInventory) == 0x000018, "Member 'FMsgLootingTargetPlayerInventoryNotify::TargetPlayerInventory' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyGameTypeChangeNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyGameTypeChangeNotify final : public FMsgBase
{
public:
	uint8                                         Pad_211D[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyGameTypeChangeNotify) == 0x000008, "Wrong alignment on FClientMsgPartyGameTypeChangeNotify");
static_assert(sizeof(FClientMsgPartyGameTypeChangeNotify) == 0x000020, "Wrong size on FClientMsgPartyGameTypeChangeNotify");

// ScriptStruct DungeonCrawler.ClientMsgFriendFindRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgFriendFindRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_211E[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendFindRequest) == 0x000008, "Wrong alignment on FClientMsgFriendFindRequest");
static_assert(sizeof(FClientMsgFriendFindRequest) == 0x000030, "Wrong size on FClientMsgFriendFindRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendFindResponse
// 0x00A0 (0x00B8 - 0x0018)
struct FClientMsgFriendFindResponse final : public FMsgBase
{
public:
	uint8                                         Pad_211F[0xA0];                                    // 0x0018(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendFindResponse) == 0x000008, "Wrong alignment on FClientMsgFriendFindResponse");
static_assert(sizeof(FClientMsgFriendFindResponse) == 0x0000B8, "Wrong size on FClientMsgFriendFindResponse");

// ScriptStruct DungeonCrawler.MsgWidgetMoveItem
// 0x0120 (0x0138 - 0x0018)
struct FMsgWidgetMoveItem final : public FMsgBase
{
public:
	class AActor*                                 OldOwner;                                          // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              OldItemData;                                       // 0x0020(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
	class AActor*                                 NewOwner;                                          // 0x0120(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemData>                      NewItemDataArray;                                  // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetMoveItem) == 0x000008, "Wrong alignment on FMsgWidgetMoveItem");
static_assert(sizeof(FMsgWidgetMoveItem) == 0x000138, "Wrong size on FMsgWidgetMoveItem");
static_assert(offsetof(FMsgWidgetMoveItem, OldOwner) == 0x000018, "Member 'FMsgWidgetMoveItem::OldOwner' has a wrong offset!");
static_assert(offsetof(FMsgWidgetMoveItem, OldItemData) == 0x000020, "Member 'FMsgWidgetMoveItem::OldItemData' has a wrong offset!");
static_assert(offsetof(FMsgWidgetMoveItem, NewOwner) == 0x000120, "Member 'FMsgWidgetMoveItem::NewOwner' has a wrong offset!");
static_assert(offsetof(FMsgWidgetMoveItem, NewItemDataArray) == 0x000128, "Member 'FMsgWidgetMoveItem::NewItemDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgReligionGetSeasonInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgReligionGetSeasonInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2120[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionGetSeasonInfoRequest) == 0x000008, "Wrong alignment on FClientMsgReligionGetSeasonInfoRequest");
static_assert(sizeof(FClientMsgReligionGetSeasonInfoRequest) == 0x000028, "Wrong size on FClientMsgReligionGetSeasonInfoRequest");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgGatheringHallChannelListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2121[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelListRequest) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelListRequest");
static_assert(sizeof(FClientMsgGatheringHallChannelListRequest) == 0x000028, "Wrong size on FClientMsgGatheringHallChannelListRequest");

// ScriptStruct DungeonCrawler.GameAnnounceData
// 0x0090 (0x0090 - 0x0000)
struct FGameAnnounceData final
{
public:
	class FText                                   FormatText;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParamText_0;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParamText_1;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParamText_2;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParamText_3;                                       // 0x0060(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParamText_4;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameAnnounceData) == 0x000008, "Wrong alignment on FGameAnnounceData");
static_assert(sizeof(FGameAnnounceData) == 0x000090, "Wrong size on FGameAnnounceData");
static_assert(offsetof(FGameAnnounceData, FormatText) == 0x000000, "Member 'FGameAnnounceData::FormatText' has a wrong offset!");
static_assert(offsetof(FGameAnnounceData, ParamText_0) == 0x000018, "Member 'FGameAnnounceData::ParamText_0' has a wrong offset!");
static_assert(offsetof(FGameAnnounceData, ParamText_1) == 0x000030, "Member 'FGameAnnounceData::ParamText_1' has a wrong offset!");
static_assert(offsetof(FGameAnnounceData, ParamText_2) == 0x000048, "Member 'FGameAnnounceData::ParamText_2' has a wrong offset!");
static_assert(offsetof(FGameAnnounceData, ParamText_3) == 0x000060, "Member 'FGameAnnounceData::ParamText_3' has a wrong offset!");
static_assert(offsetof(FGameAnnounceData, ParamText_4) == 0x000078, "Member 'FGameAnnounceData::ParamText_4' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgGatheringHallChannelListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2122[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelListResponse) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelListResponse");
static_assert(sizeof(FClientMsgGatheringHallChannelListResponse) == 0x000028, "Wrong size on FClientMsgGatheringHallChannelListResponse");

// ScriptStruct DungeonCrawler.MsgWidgetClassShapeShiftUnequipNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassShapeShiftUnequipNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ShapeShiftId;                                      // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2123[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassShapeShiftUnequipNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassShapeShiftUnequipNotify");
static_assert(sizeof(FMsgWidgetClassShapeShiftUnequipNotify) == 0x000030, "Wrong size on FMsgWidgetClassShapeShiftUnequipNotify");
static_assert(offsetof(FMsgWidgetClassShapeShiftUnequipNotify, Index) == 0x000018, "Member 'FMsgWidgetClassShapeShiftUnequipNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassShapeShiftUnequipNotify, ShapeShiftId) == 0x00001C, "Member 'FMsgWidgetClassShapeShiftUnequipNotify::ShapeShiftId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestCompleteRequest
// 0x0050 (0x0070 - 0x0020)
struct FClientMsgMerchantQuestCompleteRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2124[0x50];                                    // 0x0020(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestCompleteRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestCompleteRequest");
static_assert(sizeof(FClientMsgMerchantQuestCompleteRequest) == 0x000070, "Wrong size on FClientMsgMerchantQuestCompleteRequest");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelSelectRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgGatheringHallChannelSelectRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2125[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelSelectRequest) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelSelectRequest");
static_assert(sizeof(FClientMsgGatheringHallChannelSelectRequest) == 0x000028, "Wrong size on FClientMsgGatheringHallChannelSelectRequest");

// ScriptStruct DungeonCrawler.GameUserSettingAudiosVoipPartyMember
// 0x0018 (0x0018 - 0x0000)
struct FGameUserSettingAudiosVoipPartyMember final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMute;                                             // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2126[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReceiveVolume;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameUserSettingAudiosVoipPartyMember) == 0x000008, "Wrong alignment on FGameUserSettingAudiosVoipPartyMember");
static_assert(sizeof(FGameUserSettingAudiosVoipPartyMember) == 0x000018, "Wrong size on FGameUserSettingAudiosVoipPartyMember");
static_assert(offsetof(FGameUserSettingAudiosVoipPartyMember, AccountId) == 0x000000, "Member 'FGameUserSettingAudiosVoipPartyMember::AccountId' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudiosVoipPartyMember, bMute) == 0x000010, "Member 'FGameUserSettingAudiosVoipPartyMember::bMute' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudiosVoipPartyMember, ReceiveVolume) == 0x000014, "Member 'FGameUserSettingAudiosVoipPartyMember::ReceiveVolume' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelSelectResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgGatheringHallChannelSelectResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2127[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelSelectResponse) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelSelectResponse");
static_assert(sizeof(FClientMsgGatheringHallChannelSelectResponse) == 0x000020, "Wrong size on FClientMsgGatheringHallChannelSelectResponse");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelExitRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgGatheringHallChannelExitRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2128[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelExitRequest) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelExitRequest");
static_assert(sizeof(FClientMsgGatheringHallChannelExitRequest) == 0x000028, "Wrong size on FClientMsgGatheringHallChannelExitRequest");

// ScriptStruct DungeonCrawler.ClientMsgMerchantStockSellBackRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgMerchantStockSellBackRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2129[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantStockSellBackRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantStockSellBackRequest");
static_assert(sizeof(FClientMsgMerchantStockSellBackRequest) == 0x000040, "Wrong size on FClientMsgMerchantStockSellBackRequest");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelExitResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgGatheringHallChannelExitResponse final : public FMsgBase
{
public:
	uint8                                         Pad_212A[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelExitResponse) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelExitResponse");
static_assert(sizeof(FClientMsgGatheringHallChannelExitResponse) == 0x000020, "Wrong size on FClientMsgGatheringHallChannelExitResponse");

// ScriptStruct DungeonCrawler.MsgInventoryItemAmmoReduceResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgInventoryItemAmmoReduceResponse final : public FMsgBase
{
public:
	bool                                          bIsSucceed;                                        // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_212B[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgInventoryItemAmmoReduceResponse) == 0x000008, "Wrong alignment on FMsgInventoryItemAmmoReduceResponse");
static_assert(sizeof(FMsgInventoryItemAmmoReduceResponse) == 0x000020, "Wrong size on FMsgInventoryItemAmmoReduceResponse");
static_assert(offsetof(FMsgInventoryItemAmmoReduceResponse, bIsSucceed) == 0x000018, "Member 'FMsgInventoryItemAmmoReduceResponse::bIsSucceed' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestListInfoRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgMerchantQuestListInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_212C[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestListInfoRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestListInfoRequest");
static_assert(sizeof(FClientMsgMerchantQuestListInfoRequest) == 0x000030, "Wrong size on FClientMsgMerchantQuestListInfoRequest");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelUserListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgGatheringHallChannelUserListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_212D[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelUserListRequest) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelUserListRequest");
static_assert(sizeof(FClientMsgGatheringHallChannelUserListRequest) == 0x000028, "Wrong size on FClientMsgGatheringHallChannelUserListRequest");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelUserListResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgGatheringHallChannelUserListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_212E[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelUserListResponse) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelUserListResponse");
static_assert(sizeof(FClientMsgGatheringHallChannelUserListResponse) == 0x000030, "Wrong size on FClientMsgGatheringHallChannelUserListResponse");

// ScriptStruct DungeonCrawler.ObjectLinkEventMethod
// 0x0028 (0x0028 - 0x0000)
struct FObjectLinkEventMethod final
{
public:
	EDCObjectLinkEventMethodType                  MethodType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_212F[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectLinkEventMethod) == 0x000008, "Wrong alignment on FObjectLinkEventMethod");
static_assert(sizeof(FObjectLinkEventMethod) == 0x000028, "Wrong size on FObjectLinkEventMethod");
static_assert(offsetof(FObjectLinkEventMethod, MethodType) == 0x000000, "Member 'FObjectLinkEventMethod::MethodType' has a wrong offset!");
static_assert(offsetof(FObjectLinkEventMethod, GameplayTags) == 0x000008, "Member 'FObjectLinkEventMethod::GameplayTags' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyInviteNotify
// 0x0060 (0x0078 - 0x0018)
struct FClientMsgPartyInviteNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2130[0x60];                                    // 0x0018(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyInviteNotify) == 0x000008, "Wrong alignment on FClientMsgPartyInviteNotify");
static_assert(sizeof(FClientMsgPartyInviteNotify) == 0x000078, "Wrong size on FClientMsgPartyInviteNotify");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelUserUpdateNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgGatheringHallChannelUserUpdateNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2131[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelUserUpdateNotify) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelUserUpdateNotify");
static_assert(sizeof(FClientMsgGatheringHallChannelUserUpdateNotify) == 0x000028, "Wrong size on FClientMsgGatheringHallChannelUserUpdateNotify");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelChatRequest
// 0x00A8 (0x00C8 - 0x0020)
struct FClientMsgGatheringHallChannelChatRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2132[0xA8];                                    // 0x0020(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelChatRequest) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelChatRequest");
static_assert(sizeof(FClientMsgGatheringHallChannelChatRequest) == 0x0000C8, "Wrong size on FClientMsgGatheringHallChannelChatRequest");

// ScriptStruct DungeonCrawler.PreloadInfo
// 0x000C (0x000C - 0x0000)
struct FPreloadInfo final
{
public:
	bool                                          bPreloadComplete;                                  // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2133[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PreloadTotalCount;                                 // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PreloadCurrentCount;                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreloadInfo) == 0x000004, "Wrong alignment on FPreloadInfo");
static_assert(sizeof(FPreloadInfo) == 0x00000C, "Wrong size on FPreloadInfo");
static_assert(offsetof(FPreloadInfo, bPreloadComplete) == 0x000000, "Member 'FPreloadInfo::bPreloadComplete' has a wrong offset!");
static_assert(offsetof(FPreloadInfo, PreloadTotalCount) == 0x000004, "Member 'FPreloadInfo::PreloadTotalCount' has a wrong offset!");
static_assert(offsetof(FPreloadInfo, PreloadCurrentCount) == 0x000008, "Member 'FPreloadInfo::PreloadCurrentCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgProjectileHit
// 0x0178 (0x0190 - 0x0018)
struct FMsgProjectileHit final : public FMsgBase
{
public:
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0018(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0040(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2134[0x8];                                     // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ActorPrevTickTransform;                            // 0x0130(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgProjectileHit) == 0x000010, "Wrong alignment on FMsgProjectileHit");
static_assert(sizeof(FMsgProjectileHit) == 0x000190, "Wrong size on FMsgProjectileHit");
static_assert(offsetof(FMsgProjectileHit, TargetDataHandle) == 0x000018, "Member 'FMsgProjectileHit::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(FMsgProjectileHit, Hit) == 0x000040, "Member 'FMsgProjectileHit::Hit' has a wrong offset!");
static_assert(offsetof(FMsgProjectileHit, ActorPrevTickTransform) == 0x000130, "Member 'FMsgProjectileHit::ActorPrevTickTransform' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelChatResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgGatheringHallChannelChatResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2135[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelChatResponse) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelChatResponse");
static_assert(sizeof(FClientMsgGatheringHallChannelChatResponse) == 0x000030, "Wrong size on FClientMsgGatheringHallChannelChatResponse");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallChannelChatNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgGatheringHallChannelChatNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2136[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallChannelChatNotify) == 0x000008, "Wrong alignment on FClientMsgGatheringHallChannelChatNotify");
static_assert(sizeof(FClientMsgGatheringHallChannelChatNotify) == 0x000028, "Wrong size on FClientMsgGatheringHallChannelChatNotify");

// ScriptStruct DungeonCrawler.MsgCharacterResurrectionRequest
// 0x00A8 (0x00C0 - 0x0018)
struct FMsgCharacterResurrectionRequest final : public FMsgBase
{
public:
	class FString                                 AccountId;                                         // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstigatorAccountId;                               // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2137[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0040(0x0060)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDelay;                                        // 0x00A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRemoveAllItem;                                  // 0x00A4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2138[0x3];                                     // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ADCCharacterBase>           DCCharacterBase;                                   // 0x00A8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCGameplayEffectData>          InitGameplayEffectDataArray;                       // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgCharacterResurrectionRequest) == 0x000010, "Wrong alignment on FMsgCharacterResurrectionRequest");
static_assert(sizeof(FMsgCharacterResurrectionRequest) == 0x0000C0, "Wrong size on FMsgCharacterResurrectionRequest");
static_assert(offsetof(FMsgCharacterResurrectionRequest, AccountId) == 0x000018, "Member 'FMsgCharacterResurrectionRequest::AccountId' has a wrong offset!");
static_assert(offsetof(FMsgCharacterResurrectionRequest, InstigatorAccountId) == 0x000028, "Member 'FMsgCharacterResurrectionRequest::InstigatorAccountId' has a wrong offset!");
static_assert(offsetof(FMsgCharacterResurrectionRequest, Transform) == 0x000040, "Member 'FMsgCharacterResurrectionRequest::Transform' has a wrong offset!");
static_assert(offsetof(FMsgCharacterResurrectionRequest, SpawnDelay) == 0x0000A0, "Member 'FMsgCharacterResurrectionRequest::SpawnDelay' has a wrong offset!");
static_assert(offsetof(FMsgCharacterResurrectionRequest, bIsRemoveAllItem) == 0x0000A4, "Member 'FMsgCharacterResurrectionRequest::bIsRemoveAllItem' has a wrong offset!");
static_assert(offsetof(FMsgCharacterResurrectionRequest, DCCharacterBase) == 0x0000A8, "Member 'FMsgCharacterResurrectionRequest::DCCharacterBase' has a wrong offset!");
static_assert(offsetof(FMsgCharacterResurrectionRequest, InitGameplayEffectDataArray) == 0x0000B0, "Member 'FMsgCharacterResurrectionRequest::InitGameplayEffectDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallTargetEquippedItemRequest
// 0x0028 (0x0048 - 0x0020)
struct FClientMsgGatheringHallTargetEquippedItemRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2139[0x28];                                    // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallTargetEquippedItemRequest) == 0x000008, "Wrong alignment on FClientMsgGatheringHallTargetEquippedItemRequest");
static_assert(sizeof(FClientMsgGatheringHallTargetEquippedItemRequest) == 0x000048, "Wrong size on FClientMsgGatheringHallTargetEquippedItemRequest");

// ScriptStruct DungeonCrawler.ClientMsgGatheringHallTargetEquippedItemResponse
// 0x00A0 (0x00B8 - 0x0018)
struct FClientMsgGatheringHallTargetEquippedItemResponse final : public FMsgBase
{
public:
	uint8                                         Pad_213A[0xA0];                                    // 0x0018(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGatheringHallTargetEquippedItemResponse) == 0x000008, "Wrong alignment on FClientMsgGatheringHallTargetEquippedItemResponse");
static_assert(sizeof(FClientMsgGatheringHallTargetEquippedItemResponse) == 0x0000B8, "Wrong size on FClientMsgGatheringHallTargetEquippedItemResponse");

// ScriptStruct DungeonCrawler.GameAnnounceInfo
// 0x0098 (0x0098 - 0x0000)
struct FGameAnnounceInfo final
{
public:
	class FName                                   WinnerPlayerCharacterBlackboardKey;                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameAnnounceData                      AnnounceData;                                      // 0x0008(0x0090)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameAnnounceInfo) == 0x000008, "Wrong alignment on FGameAnnounceInfo");
static_assert(sizeof(FGameAnnounceInfo) == 0x000098, "Wrong size on FGameAnnounceInfo");
static_assert(offsetof(FGameAnnounceInfo, WinnerPlayerCharacterBlackboardKey) == 0x000000, "Member 'FGameAnnounceInfo::WinnerPlayerCharacterBlackboardKey' has a wrong offset!");
static_assert(offsetof(FGameAnnounceInfo, AnnounceData) == 0x000008, "Member 'FGameAnnounceInfo::AnnounceData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgGmPartyAllRandomResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgGmPartyAllRandomResponse final : public FMsgBase
{
public:
	uint8                                         Pad_213B[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGmPartyAllRandomResponse) == 0x000008, "Wrong alignment on FClientMsgGmPartyAllRandomResponse");
static_assert(sizeof(FClientMsgGmPartyAllRandomResponse) == 0x000020, "Wrong size on FClientMsgGmPartyAllRandomResponse");

// ScriptStruct DungeonCrawler.AuraTargetData
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FAuraTargetData final
{
public:
	uint8                                         Pad_213C[0x90];                                    // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAuraTargetData) == 0x000008, "Wrong alignment on FAuraTargetData");
static_assert(sizeof(FAuraTargetData) == 0x000090, "Wrong size on FAuraTargetData");

// ScriptStruct DungeonCrawler.ClientMsgPartyReadyResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyReadyResponse final : public FMsgBase
{
public:
	uint8                                         Pad_213D[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyReadyResponse) == 0x000008, "Wrong alignment on FClientMsgPartyReadyResponse");
static_assert(sizeof(FClientMsgPartyReadyResponse) == 0x000020, "Wrong size on FClientMsgPartyReadyResponse");

// ScriptStruct DungeonCrawler.ClientMsgEnterGameServerNotify
// 0x0088 (0x00A0 - 0x0018)
struct FClientMsgEnterGameServerNotify final : public FMsgBase
{
public:
	uint8                                         Pad_213E[0x88];                                    // 0x0018(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgEnterGameServerNotify) == 0x000008, "Wrong alignment on FClientMsgEnterGameServerNotify");
static_assert(sizeof(FClientMsgEnterGameServerNotify) == 0x0000A0, "Wrong size on FClientMsgEnterGameServerNotify");

// ScriptStruct DungeonCrawler.ClientMsgAutoMatchRegRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgAutoMatchRegRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_213F[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAutoMatchRegRequest) == 0x000008, "Wrong alignment on FClientMsgAutoMatchRegRequest");
static_assert(sizeof(FClientMsgAutoMatchRegRequest) == 0x000030, "Wrong size on FClientMsgAutoMatchRegRequest");

// ScriptStruct DungeonCrawler.DCApplyGasInfoBase
// 0x0040 (0x0040 - 0x0000)
struct FDCApplyGasInfoBase
{
public:
	TArray<struct FGameplayAbilitySpecHandle>     AbilityHandles;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActiveGameplayEffectHandle>    EffectHandles;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FActiveGameplayEffectHandle>    TagHandles;                                        // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AActor*                                 SourceObject;                                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 OwnerActor;                                        // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCApplyGasInfoBase) == 0x000008, "Wrong alignment on FDCApplyGasInfoBase");
static_assert(sizeof(FDCApplyGasInfoBase) == 0x000040, "Wrong size on FDCApplyGasInfoBase");
static_assert(offsetof(FDCApplyGasInfoBase, AbilityHandles) == 0x000000, "Member 'FDCApplyGasInfoBase::AbilityHandles' has a wrong offset!");
static_assert(offsetof(FDCApplyGasInfoBase, EffectHandles) == 0x000010, "Member 'FDCApplyGasInfoBase::EffectHandles' has a wrong offset!");
static_assert(offsetof(FDCApplyGasInfoBase, TagHandles) == 0x000020, "Member 'FDCApplyGasInfoBase::TagHandles' has a wrong offset!");
static_assert(offsetof(FDCApplyGasInfoBase, SourceObject) == 0x000030, "Member 'FDCApplyGasInfoBase::SourceObject' has a wrong offset!");
static_assert(offsetof(FDCApplyGasInfoBase, OwnerActor) == 0x000038, "Member 'FDCApplyGasInfoBase::OwnerActor' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCPerkGasInfo
// 0x0000 (0x0040 - 0x0040)
struct FDCPerkGasInfo final : public FDCApplyGasInfoBase
{
};
static_assert(alignof(FDCPerkGasInfo) == 0x000008, "Wrong alignment on FDCPerkGasInfo");
static_assert(sizeof(FDCPerkGasInfo) == 0x000040, "Wrong size on FDCPerkGasInfo");

// ScriptStruct DungeonCrawler.MsgWidgetTradeChatUserListUpdateNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetTradeChatUserListUpdateNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2140[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetTradeChatUserListUpdateNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeChatUserListUpdateNotify");
static_assert(sizeof(FMsgWidgetTradeChatUserListUpdateNotify) == 0x000028, "Wrong size on FMsgWidgetTradeChatUserListUpdateNotify");

// ScriptStruct DungeonCrawler.ClientMsgMerchantRecoveryListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMerchantRecoveryListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2141[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantRecoveryListRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantRecoveryListRequest");
static_assert(sizeof(FClientMsgMerchantRecoveryListRequest) == 0x000028, "Wrong size on FClientMsgMerchantRecoveryListRequest");

// ScriptStruct DungeonCrawler.DCHttpReqInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FDCHttpReqInfo final
{
public:
	uint8                                         Pad_2142[0x30];                                    // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCHttpReqInfo) == 0x000008, "Wrong alignment on FDCHttpReqInfo");
static_assert(sizeof(FDCHttpReqInfo) == 0x000030, "Wrong size on FDCHttpReqInfo");

// ScriptStruct DungeonCrawler.ClientMsgAutoMatchRegResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgAutoMatchRegResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2143[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAutoMatchRegResponse) == 0x000008, "Wrong alignment on FClientMsgAutoMatchRegResponse");
static_assert(sizeof(FClientMsgAutoMatchRegResponse) == 0x000020, "Wrong size on FClientMsgAutoMatchRegResponse");

// ScriptStruct DungeonCrawler.ClientMsgGameEnterCompleteNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgGameEnterCompleteNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2144[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGameEnterCompleteNotify) == 0x000008, "Wrong alignment on FClientMsgGameEnterCompleteNotify");
static_assert(sizeof(FClientMsgGameEnterCompleteNotify) == 0x000020, "Wrong size on FClientMsgGameEnterCompleteNotify");

// ScriptStruct DungeonCrawler.MsgProjectileSetFireData
// 0x00E8 (0x0100 - 0x0018)
struct FMsgProjectileSetFireData final : public FMsgBase
{
public:
	struct FHitResult                             Hit;                                               // 0x0018(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgProjectileSetFireData) == 0x000008, "Wrong alignment on FMsgProjectileSetFireData");
static_assert(sizeof(FMsgProjectileSetFireData) == 0x000100, "Wrong size on FMsgProjectileSetFireData");
static_assert(offsetof(FMsgProjectileSetFireData, Hit) == 0x000018, "Member 'FMsgProjectileSetFireData::Hit' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgAutoMatchRegTeamNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgAutoMatchRegTeamNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2145[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAutoMatchRegTeamNotify) == 0x000008, "Wrong alignment on FClientMsgAutoMatchRegTeamNotify");
static_assert(sizeof(FClientMsgAutoMatchRegTeamNotify) == 0x000020, "Wrong size on FClientMsgAutoMatchRegTeamNotify");

// ScriptStruct DungeonCrawler.ClientMsgReconnectIngameRequest
// 0x0048 (0x0068 - 0x0020)
struct FClientMsgReconnectIngameRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2146[0x48];                                    // 0x0020(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReconnectIngameRequest) == 0x000008, "Wrong alignment on FClientMsgReconnectIngameRequest");
static_assert(sizeof(FClientMsgReconnectIngameRequest) == 0x000068, "Wrong size on FClientMsgReconnectIngameRequest");

// ScriptStruct DungeonCrawler.BindAccountUserData
// 0x0028 (0x0028 - 0x0000)
struct FBindAccountUserData final
{
public:
	class AActor*                                 DummyActor;                                        // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2147[0x20];                                    // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBindAccountUserData) == 0x000008, "Wrong alignment on FBindAccountUserData");
static_assert(sizeof(FBindAccountUserData) == 0x000028, "Wrong size on FBindAccountUserData");
static_assert(offsetof(FBindAccountUserData, DummyActor) == 0x000000, "Member 'FBindAccountUserData::DummyActor' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetInvitePartyNotify
// 0x0060 (0x0078 - 0x0018)
struct FMsgWidgetInvitePartyNotify final : public FMsgBase
{
public:
	struct FNickname                              InviteeNickName;                                   // 0x0018(0x0040)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 InviteeAccountId;                                  // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InviteeCharacterId;                                // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetInvitePartyNotify) == 0x000008, "Wrong alignment on FMsgWidgetInvitePartyNotify");
static_assert(sizeof(FMsgWidgetInvitePartyNotify) == 0x000078, "Wrong size on FMsgWidgetInvitePartyNotify");
static_assert(offsetof(FMsgWidgetInvitePartyNotify, InviteeNickName) == 0x000018, "Member 'FMsgWidgetInvitePartyNotify::InviteeNickName' has a wrong offset!");
static_assert(offsetof(FMsgWidgetInvitePartyNotify, InviteeAccountId) == 0x000058, "Member 'FMsgWidgetInvitePartyNotify::InviteeAccountId' has a wrong offset!");
static_assert(offsetof(FMsgWidgetInvitePartyNotify, InviteeCharacterId) == 0x000068, "Member 'FMsgWidgetInvitePartyNotify::InviteeCharacterId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantServiceMindwipeInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMerchantServiceMindwipeInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2148[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantServiceMindwipeInfoRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantServiceMindwipeInfoRequest");
static_assert(sizeof(FClientMsgMerchantServiceMindwipeInfoRequest) == 0x000028, "Wrong size on FClientMsgMerchantServiceMindwipeInfoRequest");

// ScriptStruct DungeonCrawler.ClientMsgReconnectIngameResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgReconnectIngameResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2149[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReconnectIngameResponse) == 0x000008, "Wrong alignment on FClientMsgReconnectIngameResponse");
static_assert(sizeof(FClientMsgReconnectIngameResponse) == 0x000030, "Wrong size on FClientMsgReconnectIngameResponse");

// ScriptStruct DungeonCrawler.ClientMsgGearBaseScoreListNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgGearBaseScoreListNotify final : public FMsgBase
{
public:
	uint8                                         Pad_214A[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGearBaseScoreListNotify) == 0x000008, "Wrong alignment on FClientMsgGearBaseScoreListNotify");
static_assert(sizeof(FClientMsgGearBaseScoreListNotify) == 0x000028, "Wrong size on FClientMsgGearBaseScoreListNotify");

// ScriptStruct DungeonCrawler.GameFloorLogData
// 0x0098 (0x0098 - 0x0000)
struct FGameFloorLogData final
{
public:
	struct FAccountDataReplication                AccountDataReplication;                            // 0x0000(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
	EFloorLogType                                 FloorLogType;                                      // 0x0090(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214B[0x3];                                     // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0094(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameFloorLogData) == 0x000008, "Wrong alignment on FGameFloorLogData");
static_assert(sizeof(FGameFloorLogData) == 0x000098, "Wrong size on FGameFloorLogData");
static_assert(offsetof(FGameFloorLogData, AccountDataReplication) == 0x000000, "Member 'FGameFloorLogData::AccountDataReplication' has a wrong offset!");
static_assert(offsetof(FGameFloorLogData, FloorLogType) == 0x000090, "Member 'FGameFloorLogData::FloorLogType' has a wrong offset!");
static_assert(offsetof(FGameFloorLogData, Count) == 0x000094, "Member 'FGameFloorLogData::Count' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMatchmakingFailNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMatchmakingFailNotify final : public FMsgBase
{
public:
	uint8                                         Pad_214C[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMatchmakingFailNotify) == 0x000008, "Wrong alignment on FClientMsgMatchmakingFailNotify");
static_assert(sizeof(FClientMsgMatchmakingFailNotify) == 0x000020, "Wrong size on FClientMsgMatchmakingFailNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassLevelNotifyBody
// 0x0068 (0x0068 - 0x0000)
struct FMsgWidgetClassLevelNotifyBody final
{
public:
	struct FNickname                              Nickname;                                          // 0x0000(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UDCPlayerCharacterDataAsset*            PlayerCharacterData;                               // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpBegin;                                          // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpLimit;                                          // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardPoint;                                       // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextRewardLevel;                                   // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LearningPoint;                                     // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextLearningLevel;                                 // 0x0064(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassLevelNotifyBody) == 0x000008, "Wrong alignment on FMsgWidgetClassLevelNotifyBody");
static_assert(sizeof(FMsgWidgetClassLevelNotifyBody) == 0x000068, "Wrong size on FMsgWidgetClassLevelNotifyBody");
static_assert(offsetof(FMsgWidgetClassLevelNotifyBody, Nickname) == 0x000000, "Member 'FMsgWidgetClassLevelNotifyBody::Nickname' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassLevelNotifyBody, PlayerCharacterData) == 0x000040, "Member 'FMsgWidgetClassLevelNotifyBody::PlayerCharacterData' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassLevelNotifyBody, Level) == 0x000048, "Member 'FMsgWidgetClassLevelNotifyBody::Level' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassLevelNotifyBody, Exp) == 0x00004C, "Member 'FMsgWidgetClassLevelNotifyBody::Exp' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassLevelNotifyBody, ExpBegin) == 0x000050, "Member 'FMsgWidgetClassLevelNotifyBody::ExpBegin' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassLevelNotifyBody, ExpLimit) == 0x000054, "Member 'FMsgWidgetClassLevelNotifyBody::ExpLimit' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassLevelNotifyBody, RewardPoint) == 0x000058, "Member 'FMsgWidgetClassLevelNotifyBody::RewardPoint' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassLevelNotifyBody, NextRewardLevel) == 0x00005C, "Member 'FMsgWidgetClassLevelNotifyBody::NextRewardLevel' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassLevelNotifyBody, LearningPoint) == 0x000060, "Member 'FMsgWidgetClassLevelNotifyBody::LearningPoint' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassLevelNotifyBody, NextLearningLevel) == 0x000064, "Member 'FMsgWidgetClassLevelNotifyBody::NextLearningLevel' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantRecoveryItemCheckNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMerchantRecoveryItemCheckNotify final : public FMsgBase
{
public:
	uint8                                         Pad_214D[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantRecoveryItemCheckNotify) == 0x000008, "Wrong alignment on FClientMsgMerchantRecoveryItemCheckNotify");
static_assert(sizeof(FClientMsgMerchantRecoveryItemCheckNotify) == 0x000020, "Wrong size on FClientMsgMerchantRecoveryItemCheckNotify");

// ScriptStruct DungeonCrawler.ClientMsgInventoryInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgInventoryInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_214E[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryInfoRequest) == 0x000008, "Wrong alignment on FClientMsgInventoryInfoRequest");
static_assert(sizeof(FClientMsgInventoryInfoRequest) == 0x000028, "Wrong size on FClientMsgInventoryInfoRequest");

// ScriptStruct DungeonCrawler.ClientMsgInventoryInfoResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgInventoryInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_214F[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryInfoResponse) == 0x000008, "Wrong alignment on FClientMsgInventoryInfoResponse");
static_assert(sizeof(FClientMsgInventoryInfoResponse) == 0x000030, "Wrong size on FClientMsgInventoryInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgInventoryAllUpdateRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgInventoryAllUpdateRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2150[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryAllUpdateRequest) == 0x000008, "Wrong alignment on FClientMsgInventoryAllUpdateRequest");
static_assert(sizeof(FClientMsgInventoryAllUpdateRequest) == 0x000030, "Wrong size on FClientMsgInventoryAllUpdateRequest");

// ScriptStruct DungeonCrawler.ClientMsgInventoryAllUpdateResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgInventoryAllUpdateResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2151[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryAllUpdateResponse) == 0x000008, "Wrong alignment on FClientMsgInventoryAllUpdateResponse");
static_assert(sizeof(FClientMsgInventoryAllUpdateResponse) == 0x000030, "Wrong size on FClientMsgInventoryAllUpdateResponse");

// ScriptStruct DungeonCrawler.GameKillLogData
// 0x0118 (0x0118 - 0x0000)
struct FGameKillLogData final
{
public:
	struct FAccountDataReplication                AccountDataReplication;                            // 0x0000(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FInstigatorData                        InstigatorData;                                    // 0x0090(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FEffectCauserData                      EffectCauserData;                                  // 0x00F8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	EHitBoxType                                   HitBoxType;                                        // 0x0110(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2152[0x7];                                     // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameKillLogData) == 0x000008, "Wrong alignment on FGameKillLogData");
static_assert(sizeof(FGameKillLogData) == 0x000118, "Wrong size on FGameKillLogData");
static_assert(offsetof(FGameKillLogData, AccountDataReplication) == 0x000000, "Member 'FGameKillLogData::AccountDataReplication' has a wrong offset!");
static_assert(offsetof(FGameKillLogData, InstigatorData) == 0x000090, "Member 'FGameKillLogData::InstigatorData' has a wrong offset!");
static_assert(offsetof(FGameKillLogData, EffectCauserData) == 0x0000F8, "Member 'FGameKillLogData::EffectCauserData' has a wrong offset!");
static_assert(offsetof(FGameKillLogData, HitBoxType) == 0x000110, "Member 'FGameKillLogData::HitBoxType' has a wrong offset!");

// ScriptStruct DungeonCrawler.KarmaMemberInfo
// 0x0080 (0x0080 - 0x0000)
struct FKarmaMemberInfo final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountNickname;                                   // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0030(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EDCCharacterClass                             DCCharacterClass;                                  // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCGender                                     DCGender;                                          // 0x0071(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVote;                                            // 0x0072(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2153[0x1];                                     // 0x0073(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KarmaAction;                                       // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KarmaStatus;                                       // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2154[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKarmaMemberInfo) == 0x000008, "Wrong alignment on FKarmaMemberInfo");
static_assert(sizeof(FKarmaMemberInfo) == 0x000080, "Wrong size on FKarmaMemberInfo");
static_assert(offsetof(FKarmaMemberInfo, AccountId) == 0x000000, "Member 'FKarmaMemberInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FKarmaMemberInfo, CharacterId) == 0x000010, "Member 'FKarmaMemberInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FKarmaMemberInfo, AccountNickname) == 0x000020, "Member 'FKarmaMemberInfo::AccountNickname' has a wrong offset!");
static_assert(offsetof(FKarmaMemberInfo, Nickname) == 0x000030, "Member 'FKarmaMemberInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FKarmaMemberInfo, DCCharacterClass) == 0x000070, "Member 'FKarmaMemberInfo::DCCharacterClass' has a wrong offset!");
static_assert(offsetof(FKarmaMemberInfo, DCGender) == 0x000071, "Member 'FKarmaMemberInfo::DCGender' has a wrong offset!");
static_assert(offsetof(FKarmaMemberInfo, IsVote) == 0x000072, "Member 'FKarmaMemberInfo::IsVote' has a wrong offset!");
static_assert(offsetof(FKarmaMemberInfo, KarmaAction) == 0x000074, "Member 'FKarmaMemberInfo::KarmaAction' has a wrong offset!");
static_assert(offsetof(FKarmaMemberInfo, KarmaStatus) == 0x000078, "Member 'FKarmaMemberInfo::KarmaStatus' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetKarmaReportActionResponse
// 0x0098 (0x00B0 - 0x0018)
struct FMsgWidgetKarmaReportActionResponse final : public FMsgBase
{
public:
	int32                                         Result;                                            // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchIdx;                                          // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKarmaMemberInfo                       UpdatedMemberInfo;                                 // 0x0020(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CurrentTicketCount;                                // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollectionStepCount;                               // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCollectionCount;                                // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTicketCount;                                    // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetKarmaReportActionResponse) == 0x000008, "Wrong alignment on FMsgWidgetKarmaReportActionResponse");
static_assert(sizeof(FMsgWidgetKarmaReportActionResponse) == 0x0000B0, "Wrong size on FMsgWidgetKarmaReportActionResponse");
static_assert(offsetof(FMsgWidgetKarmaReportActionResponse, Result) == 0x000018, "Member 'FMsgWidgetKarmaReportActionResponse::Result' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportActionResponse, MatchIdx) == 0x00001C, "Member 'FMsgWidgetKarmaReportActionResponse::MatchIdx' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportActionResponse, UpdatedMemberInfo) == 0x000020, "Member 'FMsgWidgetKarmaReportActionResponse::UpdatedMemberInfo' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportActionResponse, CurrentTicketCount) == 0x0000A0, "Member 'FMsgWidgetKarmaReportActionResponse::CurrentTicketCount' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportActionResponse, CollectionStepCount) == 0x0000A4, "Member 'FMsgWidgetKarmaReportActionResponse::CollectionStepCount' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportActionResponse, MaxCollectionCount) == 0x0000A8, "Member 'FMsgWidgetKarmaReportActionResponse::MaxCollectionCount' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportActionResponse, MaxTicketCount) == 0x0000AC, "Member 'FMsgWidgetKarmaReportActionResponse::MaxTicketCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgReligionUpdateOfferingRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgReligionUpdateOfferingRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2155[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionUpdateOfferingRequest) == 0x000008, "Wrong alignment on FClientMsgReligionUpdateOfferingRequest");
static_assert(sizeof(FClientMsgReligionUpdateOfferingRequest) == 0x000038, "Wrong size on FClientMsgReligionUpdateOfferingRequest");

// ScriptStruct DungeonCrawler.ClientMsgInventoryMoveRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgInventoryMoveRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2156[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryMoveRequest) == 0x000008, "Wrong alignment on FClientMsgInventoryMoveRequest");
static_assert(sizeof(FClientMsgInventoryMoveRequest) == 0x000038, "Wrong size on FClientMsgInventoryMoveRequest");

// ScriptStruct DungeonCrawler.ClientMsgInventoryMoveResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgInventoryMoveResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2157[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryMoveResponse) == 0x000008, "Wrong alignment on FClientMsgInventoryMoveResponse");
static_assert(sizeof(FClientMsgInventoryMoveResponse) == 0x000020, "Wrong size on FClientMsgInventoryMoveResponse");

// ScriptStruct DungeonCrawler.MsgGASActorRigidNotify
// 0x0040 (0x0058 - 0x0018)
struct FMsgGASActorRigidNotify final : public FMsgBase
{
public:
	bool                                          bRigid;                                            // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2158[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          RigidPoseSnapshot;                                 // 0x0020(0x0038)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGASActorRigidNotify) == 0x000008, "Wrong alignment on FMsgGASActorRigidNotify");
static_assert(sizeof(FMsgGASActorRigidNotify) == 0x000058, "Wrong size on FMsgGASActorRigidNotify");
static_assert(offsetof(FMsgGASActorRigidNotify, bRigid) == 0x000018, "Member 'FMsgGASActorRigidNotify::bRigid' has a wrong offset!");
static_assert(offsetof(FMsgGASActorRigidNotify, RigidPoseSnapshot) == 0x000020, "Member 'FMsgGASActorRigidNotify::RigidPoseSnapshot' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantServiceCraftRequest
// 0x0038 (0x0058 - 0x0020)
struct FClientMsgMerchantServiceCraftRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2159[0x38];                                    // 0x0020(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantServiceCraftRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantServiceCraftRequest");
static_assert(sizeof(FClientMsgMerchantServiceCraftRequest) == 0x000058, "Wrong size on FClientMsgMerchantServiceCraftRequest");

// ScriptStruct DungeonCrawler.ClientMsgInventoryMergeRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgInventoryMergeRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_215A[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryMergeRequest) == 0x000008, "Wrong alignment on FClientMsgInventoryMergeRequest");
static_assert(sizeof(FClientMsgInventoryMergeRequest) == 0x000040, "Wrong size on FClientMsgInventoryMergeRequest");

// ScriptStruct DungeonCrawler.MsgGameTestClassSkillListRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgGameTestClassSkillListRequest final : public FMsgBase
{
public:
	int32                                         RequestCommand;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215B[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameTestClassSkillListRequest) == 0x000008, "Wrong alignment on FMsgGameTestClassSkillListRequest");
static_assert(sizeof(FMsgGameTestClassSkillListRequest) == 0x000020, "Wrong size on FMsgGameTestClassSkillListRequest");
static_assert(offsetof(FMsgGameTestClassSkillListRequest, RequestCommand) == 0x000018, "Member 'FMsgGameTestClassSkillListRequest::RequestCommand' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgInventoryMergeResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgInventoryMergeResponse final : public FMsgBase
{
public:
	uint8                                         Pad_215C[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryMergeResponse) == 0x000008, "Wrong alignment on FClientMsgInventoryMergeResponse");
static_assert(sizeof(FClientMsgInventoryMergeResponse) == 0x000020, "Wrong size on FClientMsgInventoryMergeResponse");

// ScriptStruct DungeonCrawler.MsgWidgetProgressBarUpdate
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetProgressBarUpdate final : public FMsgBase
{
public:
	bool                                          bIsUpdate;                                         // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215D[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateDuration;                                    // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetProgressBarUpdate) == 0x000008, "Wrong alignment on FMsgWidgetProgressBarUpdate");
static_assert(sizeof(FMsgWidgetProgressBarUpdate) == 0x000020, "Wrong size on FMsgWidgetProgressBarUpdate");
static_assert(offsetof(FMsgWidgetProgressBarUpdate, bIsUpdate) == 0x000018, "Member 'FMsgWidgetProgressBarUpdate::bIsUpdate' has a wrong offset!");
static_assert(offsetof(FMsgWidgetProgressBarUpdate, UpdateDuration) == 0x00001C, "Member 'FMsgWidgetProgressBarUpdate::UpdateDuration' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyInviteRequest
// 0x0060 (0x0080 - 0x0020)
struct FClientMsgPartyInviteRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_215E[0x60];                                    // 0x0020(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyInviteRequest) == 0x000008, "Wrong alignment on FClientMsgPartyInviteRequest");
static_assert(sizeof(FClientMsgPartyInviteRequest) == 0x000080, "Wrong size on FClientMsgPartyInviteRequest");

// ScriptStruct DungeonCrawler.ClientMsgInventorySwapRequest
// 0x0030 (0x0050 - 0x0020)
struct FClientMsgInventorySwapRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_215F[0x30];                                    // 0x0020(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventorySwapRequest) == 0x000008, "Wrong alignment on FClientMsgInventorySwapRequest");
static_assert(sizeof(FClientMsgInventorySwapRequest) == 0x000050, "Wrong size on FClientMsgInventorySwapRequest");

// ScriptStruct DungeonCrawler.ClientMsgInventorySwapResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgInventorySwapResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2160[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventorySwapResponse) == 0x000008, "Wrong alignment on FClientMsgInventorySwapResponse");
static_assert(sizeof(FClientMsgInventorySwapResponse) == 0x000020, "Wrong size on FClientMsgInventorySwapResponse");

// ScriptStruct DungeonCrawler.ClientMsgInventorySplitMoveRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgInventorySplitMoveRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2161[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventorySplitMoveRequest) == 0x000008, "Wrong alignment on FClientMsgInventorySplitMoveRequest");
static_assert(sizeof(FClientMsgInventorySplitMoveRequest) == 0x000040, "Wrong size on FClientMsgInventorySplitMoveRequest");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestLogAcceptAllRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMerchantQuestLogAcceptAllRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2162[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestLogAcceptAllRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestLogAcceptAllRequest");
static_assert(sizeof(FClientMsgMerchantQuestLogAcceptAllRequest) == 0x000028, "Wrong size on FClientMsgMerchantQuestLogAcceptAllRequest");

// ScriptStruct DungeonCrawler.ClientMsgInventorySplitMoveResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgInventorySplitMoveResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2163[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventorySplitMoveResponse) == 0x000008, "Wrong alignment on FClientMsgInventorySplitMoveResponse");
static_assert(sizeof(FClientMsgInventorySplitMoveResponse) == 0x000028, "Wrong size on FClientMsgInventorySplitMoveResponse");

// ScriptStruct DungeonCrawler.MsgGASGameplayTagNotify
// 0x0030 (0x0048 - 0x0018)
struct FMsgGASGameplayTagNotify final : public FMsgBase
{
public:
	struct FGameplayTagContainer                  GameplayTagContainer;                              // 0x0018(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayTag;                                       // 0x0038(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2164[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGASGameplayTagNotify) == 0x000008, "Wrong alignment on FMsgGASGameplayTagNotify");
static_assert(sizeof(FMsgGASGameplayTagNotify) == 0x000048, "Wrong size on FMsgGASGameplayTagNotify");
static_assert(offsetof(FMsgGASGameplayTagNotify, GameplayTagContainer) == 0x000018, "Member 'FMsgGASGameplayTagNotify::GameplayTagContainer' has a wrong offset!");
static_assert(offsetof(FMsgGASGameplayTagNotify, GameplayTag) == 0x000038, "Member 'FMsgGASGameplayTagNotify::GameplayTag' has a wrong offset!");
static_assert(offsetof(FMsgGASGameplayTagNotify, Count) == 0x000040, "Member 'FMsgGASGameplayTagNotify::Count' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgInventorySplitMergeRequest
// 0x0028 (0x0048 - 0x0020)
struct FClientMsgInventorySplitMergeRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2165[0x28];                                    // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventorySplitMergeRequest) == 0x000008, "Wrong alignment on FClientMsgInventorySplitMergeRequest");
static_assert(sizeof(FClientMsgInventorySplitMergeRequest) == 0x000048, "Wrong size on FClientMsgInventorySplitMergeRequest");

// ScriptStruct DungeonCrawler.DCPlayerCharacterKey
// 0x0002 (0x0002 - 0x0000)
struct FDCPlayerCharacterKey final
{
public:
	EDCCharacterClass                             CharacterClass;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCGender                                     Gender;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCPlayerCharacterKey) == 0x000001, "Wrong alignment on FDCPlayerCharacterKey");
static_assert(sizeof(FDCPlayerCharacterKey) == 0x000002, "Wrong size on FDCPlayerCharacterKey");
static_assert(offsetof(FDCPlayerCharacterKey, CharacterClass) == 0x000000, "Member 'FDCPlayerCharacterKey::CharacterClass' has a wrong offset!");
static_assert(offsetof(FDCPlayerCharacterKey, Gender) == 0x000001, "Member 'FDCPlayerCharacterKey::Gender' has a wrong offset!");

// ScriptStruct DungeonCrawler.GameResultItemInfo
// 0x000C (0x000C - 0x0000)
struct FGameResultItemInfo final
{
public:
	EDCLogEventType                               ResultType;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2166[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResultCount;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResultAdvPoint;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameResultItemInfo) == 0x000004, "Wrong alignment on FGameResultItemInfo");
static_assert(sizeof(FGameResultItemInfo) == 0x00000C, "Wrong size on FGameResultItemInfo");
static_assert(offsetof(FGameResultItemInfo, ResultType) == 0x000000, "Member 'FGameResultItemInfo::ResultType' has a wrong offset!");
static_assert(offsetof(FGameResultItemInfo, ResultCount) == 0x000004, "Member 'FGameResultItemInfo::ResultCount' has a wrong offset!");
static_assert(offsetof(FGameResultItemInfo, ResultAdvPoint) == 0x000008, "Member 'FGameResultItemInfo::ResultAdvPoint' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCLeaderboardRankChangeData
// 0x0028 (0x0028 - 0x0000)
struct FDCLeaderboardRankChangeData final
{
public:
	bool                                          bRankUp;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2167[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCLeaderboardRankDataAsset*            LeaderboardRankData;                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCLeaderboardRankDataAsset*            NextLeaderboardRankData;                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRankAdvPoint;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankAdvPointFrom;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankAdvPointTo;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2168[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCLeaderboardRankChangeData) == 0x000008, "Wrong alignment on FDCLeaderboardRankChangeData");
static_assert(sizeof(FDCLeaderboardRankChangeData) == 0x000028, "Wrong size on FDCLeaderboardRankChangeData");
static_assert(offsetof(FDCLeaderboardRankChangeData, bRankUp) == 0x000000, "Member 'FDCLeaderboardRankChangeData::bRankUp' has a wrong offset!");
static_assert(offsetof(FDCLeaderboardRankChangeData, LeaderboardRankData) == 0x000008, "Member 'FDCLeaderboardRankChangeData::LeaderboardRankData' has a wrong offset!");
static_assert(offsetof(FDCLeaderboardRankChangeData, NextLeaderboardRankData) == 0x000010, "Member 'FDCLeaderboardRankChangeData::NextLeaderboardRankData' has a wrong offset!");
static_assert(offsetof(FDCLeaderboardRankChangeData, MaxRankAdvPoint) == 0x000018, "Member 'FDCLeaderboardRankChangeData::MaxRankAdvPoint' has a wrong offset!");
static_assert(offsetof(FDCLeaderboardRankChangeData, RankAdvPointFrom) == 0x00001C, "Member 'FDCLeaderboardRankChangeData::RankAdvPointFrom' has a wrong offset!");
static_assert(offsetof(FDCLeaderboardRankChangeData, RankAdvPointTo) == 0x000020, "Member 'FDCLeaderboardRankChangeData::RankAdvPointTo' has a wrong offset!");

// ScriptStruct DungeonCrawler.GameResultInfo
// 0x0048 (0x0048 - 0x0000)
struct FGameResultInfo final
{
public:
	struct FDCPlayerCharacterKey                  PlayerCharacterKey;                                // 0x0000(0x0002)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowResult;                                       // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2169[0x5];                                     // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRankInfo                              RankInfo;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         EscapeMod;                                         // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_216A[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameResultItemInfo>            GameResultItemInfoArray;                           // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AdvPointEarned;                                    // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_216B[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCLeaderboardRankChangeData>   LeaderboardRankChangeDataArray;                    // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameResultInfo) == 0x000008, "Wrong alignment on FGameResultInfo");
static_assert(sizeof(FGameResultInfo) == 0x000048, "Wrong size on FGameResultInfo");
static_assert(offsetof(FGameResultInfo, PlayerCharacterKey) == 0x000000, "Member 'FGameResultInfo::PlayerCharacterKey' has a wrong offset!");
static_assert(offsetof(FGameResultInfo, bShowResult) == 0x000002, "Member 'FGameResultInfo::bShowResult' has a wrong offset!");
static_assert(offsetof(FGameResultInfo, RankInfo) == 0x000008, "Member 'FGameResultInfo::RankInfo' has a wrong offset!");
static_assert(offsetof(FGameResultInfo, EscapeMod) == 0x000018, "Member 'FGameResultInfo::EscapeMod' has a wrong offset!");
static_assert(offsetof(FGameResultInfo, GameResultItemInfoArray) == 0x000020, "Member 'FGameResultInfo::GameResultItemInfoArray' has a wrong offset!");
static_assert(offsetof(FGameResultInfo, AdvPointEarned) == 0x000030, "Member 'FGameResultInfo::AdvPointEarned' has a wrong offset!");
static_assert(offsetof(FGameResultInfo, LeaderboardRankChangeDataArray) == 0x000038, "Member 'FGameResultInfo::LeaderboardRankChangeDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgInventorySplitMergeResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgInventorySplitMergeResponse final : public FMsgBase
{
public:
	uint8                                         Pad_216C[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventorySplitMergeResponse) == 0x000008, "Wrong alignment on FClientMsgInventorySplitMergeResponse");
static_assert(sizeof(FClientMsgInventorySplitMergeResponse) == 0x000020, "Wrong size on FClientMsgInventorySplitMergeResponse");

// ScriptStruct DungeonCrawler.MsgRemoveAllContainingItem
// 0x0008 (0x0020 - 0x0018)
struct FMsgRemoveAllContainingItem final : public FMsgBase
{
public:
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_216D[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgRemoveAllContainingItem) == 0x000008, "Wrong alignment on FMsgRemoveAllContainingItem");
static_assert(sizeof(FMsgRemoveAllContainingItem) == 0x000020, "Wrong size on FMsgRemoveAllContainingItem");
static_assert(offsetof(FMsgRemoveAllContainingItem, InventoryId) == 0x000018, "Member 'FMsgRemoveAllContainingItem::InventoryId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyLastGameMemberInfoNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgPartyLastGameMemberInfoNotify final : public FMsgBase
{
public:
	uint8                                         Pad_216E[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyLastGameMemberInfoNotify) == 0x000008, "Wrong alignment on FClientMsgPartyLastGameMemberInfoNotify");
static_assert(sizeof(FClientMsgPartyLastGameMemberInfoNotify) == 0x000028, "Wrong size on FClientMsgPartyLastGameMemberInfoNotify");

// ScriptStruct DungeonCrawler.ClientMsgInventorySplitSwapRequest
// 0x0030 (0x0050 - 0x0020)
struct FClientMsgInventorySplitSwapRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_216F[0x30];                                    // 0x0020(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventorySplitSwapRequest) == 0x000008, "Wrong alignment on FClientMsgInventorySplitSwapRequest");
static_assert(sizeof(FClientMsgInventorySplitSwapRequest) == 0x000050, "Wrong size on FClientMsgInventorySplitSwapRequest");

// ScriptStruct DungeonCrawler.MsgSetLootingTargetPlayerInventory
// 0x0018 (0x0030 - 0x0018)
struct FMsgSetLootingTargetPlayerInventory final : public FMsgBase
{
public:
	struct FLootingTargetPlayerInventory          TargetPlayerInventory;                             // 0x0018(0x0018)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSetLootingTargetPlayerInventory) == 0x000008, "Wrong alignment on FMsgSetLootingTargetPlayerInventory");
static_assert(sizeof(FMsgSetLootingTargetPlayerInventory) == 0x000030, "Wrong size on FMsgSetLootingTargetPlayerInventory");
static_assert(offsetof(FMsgSetLootingTargetPlayerInventory, TargetPlayerInventory) == 0x000018, "Member 'FMsgSetLootingTargetPlayerInventory::TargetPlayerInventory' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgInventoryTwoHandedWeaponSwapResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgInventoryTwoHandedWeaponSwapResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2170[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryTwoHandedWeaponSwapResponse) == 0x000008, "Wrong alignment on FClientMsgInventoryTwoHandedWeaponSwapResponse");
static_assert(sizeof(FClientMsgInventoryTwoHandedWeaponSwapResponse) == 0x000020, "Wrong size on FClientMsgInventoryTwoHandedWeaponSwapResponse");

// ScriptStruct DungeonCrawler.ClientMsgInventorySingleUpdateRequest
// 0x0028 (0x0048 - 0x0020)
struct FClientMsgInventorySingleUpdateRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2171[0x28];                                    // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventorySingleUpdateRequest) == 0x000008, "Wrong alignment on FClientMsgInventorySingleUpdateRequest");
static_assert(sizeof(FClientMsgInventorySingleUpdateRequest) == 0x000048, "Wrong size on FClientMsgInventorySingleUpdateRequest");

// ScriptStruct DungeonCrawler.ClientMsgShopItemBuyRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgShopItemBuyRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2172[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopItemBuyRequest) == 0x000008, "Wrong alignment on FClientMsgShopItemBuyRequest");
static_assert(sizeof(FClientMsgShopItemBuyRequest) == 0x000040, "Wrong size on FClientMsgShopItemBuyRequest");

// ScriptStruct DungeonCrawler.ClientMsgInventorySingleUpdateResponse
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgInventorySingleUpdateResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2173[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventorySingleUpdateResponse) == 0x000008, "Wrong alignment on FClientMsgInventorySingleUpdateResponse");
static_assert(sizeof(FClientMsgInventorySingleUpdateResponse) == 0x000040, "Wrong size on FClientMsgInventorySingleUpdateResponse");

// ScriptStruct DungeonCrawler.DCAttackerInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCAttackerInfo final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalDamage;                                       // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKiller;                                           // 0x0014(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2174[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCAttackerInfo) == 0x000008, "Wrong alignment on FDCAttackerInfo");
static_assert(sizeof(FDCAttackerInfo) == 0x000018, "Wrong size on FDCAttackerInfo");
static_assert(offsetof(FDCAttackerInfo, AccountId) == 0x000000, "Member 'FDCAttackerInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCAttackerInfo, TotalDamage) == 0x000010, "Member 'FDCAttackerInfo::TotalDamage' has a wrong offset!");
static_assert(offsetof(FDCAttackerInfo, bKiller) == 0x000014, "Member 'FDCAttackerInfo::bKiller' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAddContainingItemRequest
// 0x0110 (0x0128 - 0x0018)
struct FMsgAddContainingItemRequest final : public FMsgBase
{
public:
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2175[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemData                              ItemData;                                          // 0x0020(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          BySystem;                                          // 0x0120(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoStack;                                          // 0x0121(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2176[0x6];                                     // 0x0122(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgAddContainingItemRequest) == 0x000008, "Wrong alignment on FMsgAddContainingItemRequest");
static_assert(sizeof(FMsgAddContainingItemRequest) == 0x000128, "Wrong size on FMsgAddContainingItemRequest");
static_assert(offsetof(FMsgAddContainingItemRequest, InventoryId) == 0x000018, "Member 'FMsgAddContainingItemRequest::InventoryId' has a wrong offset!");
static_assert(offsetof(FMsgAddContainingItemRequest, ItemData) == 0x000020, "Member 'FMsgAddContainingItemRequest::ItemData' has a wrong offset!");
static_assert(offsetof(FMsgAddContainingItemRequest, BySystem) == 0x000120, "Member 'FMsgAddContainingItemRequest::BySystem' has a wrong offset!");
static_assert(offsetof(FMsgAddContainingItemRequest, bNoStack) == 0x000121, "Member 'FMsgAddContainingItemRequest::bNoStack' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgStorageInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgStorageInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2177[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgStorageInfoRequest) == 0x000008, "Wrong alignment on FClientMsgStorageInfoRequest");
static_assert(sizeof(FClientMsgStorageInfoRequest) == 0x000028, "Wrong size on FClientMsgStorageInfoRequest");

// ScriptStruct DungeonCrawler.DesignDataMarketplace
// 0x0030 (0x0030 - 0x0000)
struct FDesignDataMarketplace final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2178[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                BasePayments;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMarketplace) == 0x000008, "Wrong alignment on FDesignDataMarketplace");
static_assert(sizeof(FDesignDataMarketplace) == 0x000030, "Wrong size on FDesignDataMarketplace");
static_assert(offsetof(FDesignDataMarketplace, Name) == 0x000000, "Member 'FDesignDataMarketplace::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataMarketplace, Order) == 0x000018, "Member 'FDesignDataMarketplace::Order' has a wrong offset!");
static_assert(offsetof(FDesignDataMarketplace, BasePayments) == 0x000020, "Member 'FDesignDataMarketplace::BasePayments' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMarketplacePayment
// 0x0020 (0x0020 - 0x0000)
struct FDesignDataMarketplacePayment final
{
public:
	struct FPrimaryAssetId                        BaseItem;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                AllowedBaseItemContainers;                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMarketplacePayment) == 0x000008, "Wrong alignment on FDesignDataMarketplacePayment");
static_assert(sizeof(FDesignDataMarketplacePayment) == 0x000020, "Wrong size on FDesignDataMarketplacePayment");
static_assert(offsetof(FDesignDataMarketplacePayment, BaseItem) == 0x000000, "Member 'FDesignDataMarketplacePayment::BaseItem' has a wrong offset!");
static_assert(offsetof(FDesignDataMarketplacePayment, AllowedBaseItemContainers) == 0x000010, "Member 'FDesignDataMarketplacePayment::AllowedBaseItemContainers' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMarketplaceTableRow
// 0x00A0 (0x00A8 - 0x0008)
struct FDesignDataMarketplaceTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataMarketplace> Marketplace;                                       // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataMarketplacePayment> MarketplacePayment;                                // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMarketplaceTableRow) == 0x000008, "Wrong alignment on FDesignDataMarketplaceTableRow");
static_assert(sizeof(FDesignDataMarketplaceTableRow) == 0x0000A8, "Wrong size on FDesignDataMarketplaceTableRow");
static_assert(offsetof(FDesignDataMarketplaceTableRow, Marketplace) == 0x000008, "Member 'FDesignDataMarketplaceTableRow::Marketplace' has a wrong offset!");
static_assert(offsetof(FDesignDataMarketplaceTableRow, MarketplacePayment) == 0x000058, "Member 'FDesignDataMarketplaceTableRow::MarketplacePayment' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgStorageInfoResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgStorageInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2179[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgStorageInfoResponse) == 0x000008, "Wrong alignment on FClientMsgStorageInfoResponse");
static_assert(sizeof(FClientMsgStorageInfoResponse) == 0x000030, "Wrong size on FClientMsgStorageInfoResponse");

// ScriptStruct DungeonCrawler.MsgInventoryItemDataArrayResponse
// 0x0018 (0x0030 - 0x0018)
struct FMsgInventoryItemDataArrayResponse final : public FMsgBase
{
public:
	EInventoryType                                InventoryType;                                     // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_217A[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      ItemDataArray;                                     // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgInventoryItemDataArrayResponse) == 0x000008, "Wrong alignment on FMsgInventoryItemDataArrayResponse");
static_assert(sizeof(FMsgInventoryItemDataArrayResponse) == 0x000030, "Wrong size on FMsgInventoryItemDataArrayResponse");
static_assert(offsetof(FMsgInventoryItemDataArrayResponse, InventoryType) == 0x000018, "Member 'FMsgInventoryItemDataArrayResponse::InventoryType' has a wrong offset!");
static_assert(offsetof(FMsgInventoryItemDataArrayResponse, ItemDataArray) == 0x000020, "Member 'FMsgInventoryItemDataArrayResponse::ItemDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgRankingCharacterResponse
// 0x00C8 (0x00E0 - 0x0018)
struct FClientMsgRankingCharacterResponse final : public FMsgBase
{
public:
	uint8                                         Pad_217B[0xC8];                                    // 0x0018(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingCharacterResponse) == 0x000008, "Wrong alignment on FClientMsgRankingCharacterResponse");
static_assert(sizeof(FClientMsgRankingCharacterResponse) == 0x0000E0, "Wrong size on FClientMsgRankingCharacterResponse");

// ScriptStruct DungeonCrawler.ClientMsgInventoryExpandStorageRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgInventoryExpandStorageRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_217C[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryExpandStorageRequest) == 0x000008, "Wrong alignment on FClientMsgInventoryExpandStorageRequest");
static_assert(sizeof(FClientMsgInventoryExpandStorageRequest) == 0x000028, "Wrong size on FClientMsgInventoryExpandStorageRequest");

// ScriptStruct DungeonCrawler.MsgEquippedItemActors
// 0x0010 (0x0028 - 0x0018)
struct FMsgEquippedItemActors final : public FMsgBase
{
public:
	TArray<class AItemActor*>                     EquippedItemActors;                                // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgEquippedItemActors) == 0x000008, "Wrong alignment on FMsgEquippedItemActors");
static_assert(sizeof(FMsgEquippedItemActors) == 0x000028, "Wrong size on FMsgEquippedItemActors");
static_assert(offsetof(FMsgEquippedItemActors, EquippedItemActors) == 0x000018, "Member 'FMsgEquippedItemActors::EquippedItemActors' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgInventoryExpandStorageResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgInventoryExpandStorageResponse final : public FMsgBase
{
public:
	uint8                                         Pad_217D[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgInventoryExpandStorageResponse) == 0x000008, "Wrong alignment on FClientMsgInventoryExpandStorageResponse");
static_assert(sizeof(FClientMsgInventoryExpandStorageResponse) == 0x000020, "Wrong size on FClientMsgInventoryExpandStorageResponse");

// ScriptStruct DungeonCrawler.ClientMsgPartyItemSkinListNotify
// 0x0030 (0x0048 - 0x0018)
struct FClientMsgPartyItemSkinListNotify final : public FMsgBase
{
public:
	uint8                                         Pad_217E[0x30];                                    // 0x0018(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyItemSkinListNotify) == 0x000008, "Wrong alignment on FClientMsgPartyItemSkinListNotify");
static_assert(sizeof(FClientMsgPartyItemSkinListNotify) == 0x000048, "Wrong size on FClientMsgPartyItemSkinListNotify");

// ScriptStruct DungeonCrawler.ClientMsgKarmaReportListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgKarmaReportListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_217F[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgKarmaReportListRequest) == 0x000008, "Wrong alignment on FClientMsgKarmaReportListRequest");
static_assert(sizeof(FClientMsgKarmaReportListRequest) == 0x000028, "Wrong size on FClientMsgKarmaReportListRequest");

// ScriptStruct DungeonCrawler.MsgInventoryItemAmmoAddResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgInventoryItemAmmoAddResponse final : public FMsgBase
{
public:
	bool                                          bIsSucceed;                                        // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2180[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgInventoryItemAmmoAddResponse) == 0x000008, "Wrong alignment on FMsgInventoryItemAmmoAddResponse");
static_assert(sizeof(FMsgInventoryItemAmmoAddResponse) == 0x000020, "Wrong size on FMsgInventoryItemAmmoAddResponse");
static_assert(offsetof(FMsgInventoryItemAmmoAddResponse, bIsSucceed) == 0x000018, "Member 'FMsgInventoryItemAmmoAddResponse::bIsSucceed' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgKarmaReportListResponse
// 0x0020 (0x0038 - 0x0018)
struct FClientMsgKarmaReportListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2181[0x20];                                    // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgKarmaReportListResponse) == 0x000008, "Wrong alignment on FClientMsgKarmaReportListResponse");
static_assert(sizeof(FClientMsgKarmaReportListResponse) == 0x000038, "Wrong size on FClientMsgKarmaReportListResponse");

// ScriptStruct DungeonCrawler.ClientMsgKarmaReportActionResponse
// 0x00A8 (0x00C0 - 0x0018)
struct FClientMsgKarmaReportActionResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2182[0xA8];                                    // 0x0018(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgKarmaReportActionResponse) == 0x000008, "Wrong alignment on FClientMsgKarmaReportActionResponse");
static_assert(sizeof(FClientMsgKarmaReportActionResponse) == 0x0000C0, "Wrong size on FClientMsgKarmaReportActionResponse");

// ScriptStruct DungeonCrawler.MappableConfigPair
// 0x0058 (0x0058 - 0x0000)
struct FMappableConfigPair final
{
public:
	class UPlayerMappableInputConfig*             Config;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommonInputType                              Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2183[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DependentPlatformTraits;                           // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExcludedPlatformTraits;                            // 0x0030(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShouldActivateAutomatically;                      // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2184[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMappableConfigPair) == 0x000008, "Wrong alignment on FMappableConfigPair");
static_assert(sizeof(FMappableConfigPair) == 0x000058, "Wrong size on FMappableConfigPair");
static_assert(offsetof(FMappableConfigPair, Config) == 0x000000, "Member 'FMappableConfigPair::Config' has a wrong offset!");
static_assert(offsetof(FMappableConfigPair, Type) == 0x000008, "Member 'FMappableConfigPair::Type' has a wrong offset!");
static_assert(offsetof(FMappableConfigPair, DependentPlatformTraits) == 0x000010, "Member 'FMappableConfigPair::DependentPlatformTraits' has a wrong offset!");
static_assert(offsetof(FMappableConfigPair, ExcludedPlatformTraits) == 0x000030, "Member 'FMappableConfigPair::ExcludedPlatformTraits' has a wrong offset!");
static_assert(offsetof(FMappableConfigPair, bShouldActivateAutomatically) == 0x000050, "Member 'FMappableConfigPair::bShouldActivateAutomatically' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgTotalGoldCountNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgTotalGoldCountNotify final : public FMsgBase
{
public:
	class UInventoryComponent*                    InventoryComponent;                                // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         TotalGoldCount;                                    // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgTotalGoldCountNotify) == 0x000008, "Wrong alignment on FMsgTotalGoldCountNotify");
static_assert(sizeof(FMsgTotalGoldCountNotify) == 0x000028, "Wrong size on FMsgTotalGoldCountNotify");
static_assert(offsetof(FMsgTotalGoldCountNotify, InventoryComponent) == 0x000018, "Member 'FMsgTotalGoldCountNotify::InventoryComponent' has a wrong offset!");
static_assert(offsetof(FMsgTotalGoldCountNotify, TotalGoldCount) == 0x000020, "Member 'FMsgTotalGoldCountNotify::TotalGoldCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgKarmaRatingUpdateNotify
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgKarmaRatingUpdateNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2185[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgKarmaRatingUpdateNotify) == 0x000008, "Wrong alignment on FClientMsgKarmaRatingUpdateNotify");
static_assert(sizeof(FClientMsgKarmaRatingUpdateNotify) == 0x000040, "Wrong size on FClientMsgKarmaRatingUpdateNotify");

// ScriptStruct DungeonCrawler.MarketplaceTradeSlotInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FMarketplaceTradeSlotInfo final
{
public:
	uint8                                         Pad_2186[0x30];                                    // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMarketplaceTradeSlotInfo) == 0x000008, "Wrong alignment on FMarketplaceTradeSlotInfo");
static_assert(sizeof(FMarketplaceTradeSlotInfo) == 0x000030, "Wrong size on FMarketplaceTradeSlotInfo");

// ScriptStruct DungeonCrawler.ClientMsgCharacterSelectEnterRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgCharacterSelectEnterRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2187[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCharacterSelectEnterRequest) == 0x000008, "Wrong alignment on FClientMsgCharacterSelectEnterRequest");
static_assert(sizeof(FClientMsgCharacterSelectEnterRequest) == 0x000028, "Wrong size on FClientMsgCharacterSelectEnterRequest");

// ScriptStruct DungeonCrawler.ClientMsgCharacterSelectEnterResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgCharacterSelectEnterResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2188[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgCharacterSelectEnterResponse) == 0x000008, "Wrong alignment on FClientMsgCharacterSelectEnterResponse");
static_assert(sizeof(FClientMsgCharacterSelectEnterResponse) == 0x000020, "Wrong size on FClientMsgCharacterSelectEnterResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradingReadyRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradingReadyRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2189[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingReadyRequest) == 0x000008, "Wrong alignment on FClientMsgTradingReadyRequest");
static_assert(sizeof(FClientMsgTradingReadyRequest) == 0x000028, "Wrong size on FClientMsgTradingReadyRequest");

// ScriptStruct DungeonCrawler.ClientMsgLobbyCharacterInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgLobbyCharacterInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_218A[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyCharacterInfoRequest) == 0x000008, "Wrong alignment on FClientMsgLobbyCharacterInfoRequest");
static_assert(sizeof(FClientMsgLobbyCharacterInfoRequest) == 0x000028, "Wrong size on FClientMsgLobbyCharacterInfoRequest");

// ScriptStruct DungeonCrawler.ClientMsgPartyChatResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyChatResponse final : public FMsgBase
{
public:
	uint8                                         Pad_218B[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyChatResponse) == 0x000008, "Wrong alignment on FClientMsgPartyChatResponse");
static_assert(sizeof(FClientMsgPartyChatResponse) == 0x000020, "Wrong size on FClientMsgPartyChatResponse");

// ScriptStruct DungeonCrawler.ClientMsgLobbyCharacterInfoResponse
// 0x00D0 (0x00E8 - 0x0018)
struct FClientMsgLobbyCharacterInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_218C[0xD0];                                    // 0x0018(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyCharacterInfoResponse) == 0x000008, "Wrong alignment on FClientMsgLobbyCharacterInfoResponse");
static_assert(sizeof(FClientMsgLobbyCharacterInfoResponse) == 0x0000E8, "Wrong size on FClientMsgLobbyCharacterInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopItemCheckNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgShopItemCheckNotify final : public FMsgBase
{
public:
	uint8                                         Pad_218D[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopItemCheckNotify) == 0x000008, "Wrong alignment on FClientMsgShopItemCheckNotify");
static_assert(sizeof(FClientMsgShopItemCheckNotify) == 0x000020, "Wrong size on FClientMsgShopItemCheckNotify");

// ScriptStruct DungeonCrawler.ClientMsgOpenLobbyMapResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgOpenLobbyMapResponse final : public FMsgBase
{
public:
	uint8                                         Pad_218E[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgOpenLobbyMapResponse) == 0x000008, "Wrong alignment on FClientMsgOpenLobbyMapResponse");
static_assert(sizeof(FClientMsgOpenLobbyMapResponse) == 0x000020, "Wrong size on FClientMsgOpenLobbyMapResponse");

// ScriptStruct DungeonCrawler.DCDungeonRecoveryPriceInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCDungeonRecoveryPriceInfo final
{
public:
	class UDCItemDataAsset*                       PriceItemData;                                     // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OriginPrice;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FinalPrice;                                        // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCDungeonRecoveryPriceInfo) == 0x000008, "Wrong alignment on FDCDungeonRecoveryPriceInfo");
static_assert(sizeof(FDCDungeonRecoveryPriceInfo) == 0x000010, "Wrong size on FDCDungeonRecoveryPriceInfo");
static_assert(offsetof(FDCDungeonRecoveryPriceInfo, PriceItemData) == 0x000000, "Member 'FDCDungeonRecoveryPriceInfo::PriceItemData' has a wrong offset!");
static_assert(offsetof(FDCDungeonRecoveryPriceInfo, OriginPrice) == 0x000008, "Member 'FDCDungeonRecoveryPriceInfo::OriginPrice' has a wrong offset!");
static_assert(offsetof(FDCDungeonRecoveryPriceInfo, FinalPrice) == 0x00000C, "Member 'FDCDungeonRecoveryPriceInfo::FinalPrice' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgLobbyRegionSelectRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgLobbyRegionSelectRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_218F[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyRegionSelectRequest) == 0x000008, "Wrong alignment on FClientMsgLobbyRegionSelectRequest");
static_assert(sizeof(FClientMsgLobbyRegionSelectRequest) == 0x000028, "Wrong size on FClientMsgLobbyRegionSelectRequest");

// ScriptStruct DungeonCrawler.DCMarketplaceItemInfo
// 0x01C0 (0x01C0 - 0x0000)
struct FDCMarketplaceItemInfo final
{
public:
	int32                                         ListingId;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2190[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCItemInfo                            ListingItem;                                       // 0x0008(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpirationDate;                                    // 0x0170(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0178(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2191[0x4];                                     // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNickname                              SellerNickname;                                    // 0x0180(0x0040)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCMarketplaceItemInfo) == 0x000008, "Wrong alignment on FDCMarketplaceItemInfo");
static_assert(sizeof(FDCMarketplaceItemInfo) == 0x0001C0, "Wrong size on FDCMarketplaceItemInfo");
static_assert(offsetof(FDCMarketplaceItemInfo, ListingId) == 0x000000, "Member 'FDCMarketplaceItemInfo::ListingId' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceItemInfo, ListingItem) == 0x000008, "Member 'FDCMarketplaceItemInfo::ListingItem' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceItemInfo, ExpirationDate) == 0x000170, "Member 'FDCMarketplaceItemInfo::ExpirationDate' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceItemInfo, Price) == 0x000178, "Member 'FDCMarketplaceItemInfo::Price' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceItemInfo, SellerNickname) == 0x000180, "Member 'FDCMarketplaceItemInfo::SellerNickname' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMarketplaceMyListInfo
// 0x01D0 (0x01D0 - 0x0000)
struct FDCMarketplaceMyListInfo final
{
public:
	struct FDCMarketplaceItemInfo                 ListItemInfo;                                      // 0x0000(0x01C0)(Transient, NativeAccessSpecifierPublic)
	EDCMarketplaceMyListState                     State;                                             // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2192[0x7];                                     // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              DestructionDate;                                   // 0x01C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCMarketplaceMyListInfo) == 0x000008, "Wrong alignment on FDCMarketplaceMyListInfo");
static_assert(sizeof(FDCMarketplaceMyListInfo) == 0x0001D0, "Wrong size on FDCMarketplaceMyListInfo");
static_assert(offsetof(FDCMarketplaceMyListInfo, ListItemInfo) == 0x000000, "Member 'FDCMarketplaceMyListInfo::ListItemInfo' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceMyListInfo, State) == 0x0001C0, "Member 'FDCMarketplaceMyListInfo::State' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceMyListInfo, DestructionDate) == 0x0001C8, "Member 'FDCMarketplaceMyListInfo::DestructionDate' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgLobbyRegionSelectResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgLobbyRegionSelectResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2193[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyRegionSelectResponse) == 0x000008, "Wrong alignment on FClientMsgLobbyRegionSelectResponse");
static_assert(sizeof(FClientMsgLobbyRegionSelectResponse) == 0x000020, "Wrong size on FClientMsgLobbyRegionSelectResponse");

// ScriptStruct DungeonCrawler.StatisticsItemInfo
// 0x0008 (0x0008 - 0x0000)
struct FStatisticsItemInfo final
{
public:
	EStatisticsType                               StatisticsType;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2194[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StatisticsCount;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatisticsItemInfo) == 0x000004, "Wrong alignment on FStatisticsItemInfo");
static_assert(sizeof(FStatisticsItemInfo) == 0x000008, "Wrong size on FStatisticsItemInfo");
static_assert(offsetof(FStatisticsItemInfo, StatisticsType) == 0x000000, "Member 'FStatisticsItemInfo::StatisticsType' has a wrong offset!");
static_assert(offsetof(FStatisticsItemInfo, StatisticsCount) == 0x000004, "Member 'FStatisticsItemInfo::StatisticsCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.StatisticsInfo
// 0x0010 (0x0010 - 0x0000)
struct FStatisticsInfo final
{
public:
	TArray<struct FStatisticsItemInfo>            StatisticsItemInfoArray;                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatisticsInfo) == 0x000008, "Wrong alignment on FStatisticsInfo");
static_assert(sizeof(FStatisticsInfo) == 0x000010, "Wrong size on FStatisticsInfo");
static_assert(offsetof(FStatisticsInfo, StatisticsItemInfoArray) == 0x000000, "Member 'FStatisticsInfo::StatisticsItemInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgLobbyEnterFromGameRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgLobbyEnterFromGameRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2195[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyEnterFromGameRequest) == 0x000008, "Wrong alignment on FClientMsgLobbyEnterFromGameRequest");
static_assert(sizeof(FClientMsgLobbyEnterFromGameRequest) == 0x000028, "Wrong size on FClientMsgLobbyEnterFromGameRequest");

// ScriptStruct DungeonCrawler.ClientMsgLobbyEnterFromGameResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgLobbyEnterFromGameResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2196[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyEnterFromGameResponse) == 0x000008, "Wrong alignment on FClientMsgLobbyEnterFromGameResponse");
static_assert(sizeof(FClientMsgLobbyEnterFromGameResponse) == 0x000020, "Wrong size on FClientMsgLobbyEnterFromGameResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradingConfirmCancelResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTradingConfirmCancelResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2197[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingConfirmCancelResponse) == 0x000008, "Wrong alignment on FClientMsgTradingConfirmCancelResponse");
static_assert(sizeof(FClientMsgTradingConfirmCancelResponse) == 0x000020, "Wrong size on FClientMsgTradingConfirmCancelResponse");

// ScriptStruct DungeonCrawler.ClientMsgPartyGearScoreChangeNotify
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgPartyGearScoreChangeNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2198[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyGearScoreChangeNotify) == 0x000008, "Wrong alignment on FClientMsgPartyGearScoreChangeNotify");
static_assert(sizeof(FClientMsgPartyGearScoreChangeNotify) == 0x000040, "Wrong size on FClientMsgPartyGearScoreChangeNotify");

// ScriptStruct DungeonCrawler.ClientMsgLobbyGameTypeSelectResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgLobbyGameTypeSelectResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2199[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyGameTypeSelectResponse) == 0x000008, "Wrong alignment on FClientMsgLobbyGameTypeSelectResponse");
static_assert(sizeof(FClientMsgLobbyGameTypeSelectResponse) == 0x000020, "Wrong size on FClientMsgLobbyGameTypeSelectResponse");

// ScriptStruct DungeonCrawler.ClientMsgLobbyAccountCurrencyListNotify
// 0x0020 (0x0038 - 0x0018)
struct FClientMsgLobbyAccountCurrencyListNotify final : public FMsgBase
{
public:
	uint8                                         Pad_219A[0x20];                                    // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyAccountCurrencyListNotify) == 0x000008, "Wrong alignment on FClientMsgLobbyAccountCurrencyListNotify");
static_assert(sizeof(FClientMsgLobbyAccountCurrencyListNotify) == 0x000038, "Wrong size on FClientMsgLobbyAccountCurrencyListNotify");

// ScriptStruct DungeonCrawler.ClientMsgLobbyCharacterLobbyEmoteNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgLobbyCharacterLobbyEmoteNotify final : public FMsgBase
{
public:
	uint8                                         Pad_219B[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyCharacterLobbyEmoteNotify) == 0x000008, "Wrong alignment on FClientMsgLobbyCharacterLobbyEmoteNotify");
static_assert(sizeof(FClientMsgLobbyCharacterLobbyEmoteNotify) == 0x000028, "Wrong size on FClientMsgLobbyCharacterLobbyEmoteNotify");

// ScriptStruct DungeonCrawler.ClientMsgPartyMemberKickResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyMemberKickResponse final : public FMsgBase
{
public:
	uint8                                         Pad_219C[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyMemberKickResponse) == 0x000008, "Wrong alignment on FClientMsgPartyMemberKickResponse");
static_assert(sizeof(FClientMsgPartyMemberKickResponse) == 0x000020, "Wrong size on FClientMsgPartyMemberKickResponse");

// ScriptStruct DungeonCrawler.LeaderboardContentInfo
// 0x0090 (0x0090 - 0x0000)
struct FLeaderboardContentInfo final
{
public:
	class UDCLeaderboardContentDataAsset*         LeaderboardContentData;                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayGameCount;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BatchGameCount;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRankRecord                            RankRecordMine;                                    // 0x0010(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FRankRecord>                    RankRecordArray;                                   // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeaderboardContentInfo) == 0x000008, "Wrong alignment on FLeaderboardContentInfo");
static_assert(sizeof(FLeaderboardContentInfo) == 0x000090, "Wrong size on FLeaderboardContentInfo");
static_assert(offsetof(FLeaderboardContentInfo, LeaderboardContentData) == 0x000000, "Member 'FLeaderboardContentInfo::LeaderboardContentData' has a wrong offset!");
static_assert(offsetof(FLeaderboardContentInfo, PlayGameCount) == 0x000008, "Member 'FLeaderboardContentInfo::PlayGameCount' has a wrong offset!");
static_assert(offsetof(FLeaderboardContentInfo, BatchGameCount) == 0x00000C, "Member 'FLeaderboardContentInfo::BatchGameCount' has a wrong offset!");
static_assert(offsetof(FLeaderboardContentInfo, RankRecordMine) == 0x000010, "Member 'FLeaderboardContentInfo::RankRecordMine' has a wrong offset!");
static_assert(offsetof(FLeaderboardContentInfo, RankRecordArray) == 0x000080, "Member 'FLeaderboardContentInfo::RankRecordArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgLobbyReportPunishListNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgLobbyReportPunishListNotify final : public FMsgBase
{
public:
	uint8                                         Pad_219D[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyReportPunishListNotify) == 0x000008, "Wrong alignment on FClientMsgLobbyReportPunishListNotify");
static_assert(sizeof(FClientMsgLobbyReportPunishListNotify) == 0x000028, "Wrong size on FClientMsgLobbyReportPunishListNotify");

// ScriptStruct DungeonCrawler.ClientMsgPartyMemberLobbyEmoteNotify
// 0x0030 (0x0048 - 0x0018)
struct FClientMsgPartyMemberLobbyEmoteNotify final : public FMsgBase
{
public:
	uint8                                         Pad_219E[0x30];                                    // 0x0018(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyMemberLobbyEmoteNotify) == 0x000008, "Wrong alignment on FClientMsgPartyMemberLobbyEmoteNotify");
static_assert(sizeof(FClientMsgPartyMemberLobbyEmoteNotify) == 0x000048, "Wrong size on FClientMsgPartyMemberLobbyEmoteNotify");

// ScriptStruct DungeonCrawler.ClientMsgUserCharacterGameStatInfoRequest
// 0x0028 (0x0048 - 0x0020)
struct FClientMsgUserCharacterGameStatInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_219F[0x28];                                    // 0x0020(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgUserCharacterGameStatInfoRequest) == 0x000008, "Wrong alignment on FClientMsgUserCharacterGameStatInfoRequest");
static_assert(sizeof(FClientMsgUserCharacterGameStatInfoRequest) == 0x000048, "Wrong size on FClientMsgUserCharacterGameStatInfoRequest");

// ScriptStruct DungeonCrawler.NotifyData
// 0x0020 (0x0020 - 0x0000)
struct FNotifyData final
{
public:
	uint32                                        Type;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A0[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Value1;                                            // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Value2;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Value3;                                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNotifyData) == 0x000008, "Wrong alignment on FNotifyData");
static_assert(sizeof(FNotifyData) == 0x000020, "Wrong size on FNotifyData");
static_assert(offsetof(FNotifyData, Type) == 0x000000, "Member 'FNotifyData::Type' has a wrong offset!");
static_assert(offsetof(FNotifyData, Value1) == 0x000008, "Member 'FNotifyData::Value1' has a wrong offset!");
static_assert(offsetof(FNotifyData, Value2) == 0x000018, "Member 'FNotifyData::Value2' has a wrong offset!");
static_assert(offsetof(FNotifyData, Value3) == 0x00001C, "Member 'FNotifyData::Value3' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgUserCharacterGameStatInfoResponse
// 0x0038 (0x0050 - 0x0018)
struct FClientMsgUserCharacterGameStatInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21A1[0x38];                                    // 0x0018(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgUserCharacterGameStatInfoResponse) == 0x000008, "Wrong alignment on FClientMsgUserCharacterGameStatInfoResponse");
static_assert(sizeof(FClientMsgUserCharacterGameStatInfoResponse) == 0x000050, "Wrong size on FClientMsgUserCharacterGameStatInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgKnightProgramLinkSelectRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgKnightProgramLinkSelectRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21A2[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgKnightProgramLinkSelectRequest) == 0x000008, "Wrong alignment on FClientMsgKnightProgramLinkSelectRequest");
static_assert(sizeof(FClientMsgKnightProgramLinkSelectRequest) == 0x000028, "Wrong size on FClientMsgKnightProgramLinkSelectRequest");

// ScriptStruct DungeonCrawler.ClientMsgShopRedStoneShardInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgShopRedStoneShardInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21A3[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopRedStoneShardInfoRequest) == 0x000008, "Wrong alignment on FClientMsgShopRedStoneShardInfoRequest");
static_assert(sizeof(FClientMsgShopRedStoneShardInfoRequest) == 0x000028, "Wrong size on FClientMsgShopRedStoneShardInfoRequest");

// ScriptStruct DungeonCrawler.MsgGASAttributeSetResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgGASAttributeSetResponse final : public FMsgBase
{
public:
	class UDCAttributeSet*                        AttributeSet;                                      // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGASAttributeSetResponse) == 0x000008, "Wrong alignment on FMsgGASAttributeSetResponse");
static_assert(sizeof(FMsgGASAttributeSetResponse) == 0x000020, "Wrong size on FMsgGASAttributeSetResponse");
static_assert(offsetof(FMsgGASAttributeSetResponse, AttributeSet) == 0x000018, "Member 'FMsgGASAttributeSetResponse::AttributeSet' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgKnightProgramLinkSelectResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgKnightProgramLinkSelectResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21A4[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgKnightProgramLinkSelectResponse) == 0x000008, "Wrong alignment on FClientMsgKnightProgramLinkSelectResponse");
static_assert(sizeof(FClientMsgKnightProgramLinkSelectResponse) == 0x000030, "Wrong size on FClientMsgKnightProgramLinkSelectResponse");

// ScriptStruct DungeonCrawler.MsgWidgetClassMusicHideEquippableSlotNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassMusicHideEquippableSlotNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassMusicHideEquippableSlotNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassMusicHideEquippableSlotNotify");
static_assert(sizeof(FMsgWidgetClassMusicHideEquippableSlotNotify) == 0x000018, "Wrong size on FMsgWidgetClassMusicHideEquippableSlotNotify");

// ScriptStruct DungeonCrawler.ClientMsgMerchantSaveBaseGearSetRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgMerchantSaveBaseGearSetRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21A5[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantSaveBaseGearSetRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantSaveBaseGearSetRequest");
static_assert(sizeof(FClientMsgMerchantSaveBaseGearSetRequest) == 0x000040, "Wrong size on FClientMsgMerchantSaveBaseGearSetRequest");

// ScriptStruct DungeonCrawler.ClientMsgGmTradeChatBanRequest
// 0x0048 (0x0068 - 0x0020)
struct FClientMsgGmTradeChatBanRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21A6[0x48];                                    // 0x0020(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGmTradeChatBanRequest) == 0x000008, "Wrong alignment on FClientMsgGmTradeChatBanRequest");
static_assert(sizeof(FClientMsgGmTradeChatBanRequest) == 0x000068, "Wrong size on FClientMsgGmTradeChatBanRequest");

// ScriptStruct DungeonCrawler.GameStateData
// 0x0008 (0x0008 - 0x0000)
struct FGameStateData final
{
public:
	EGameStateType                                GameState;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A7[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerWorldTime;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameStateData) == 0x000004, "Wrong alignment on FGameStateData");
static_assert(sizeof(FGameStateData) == 0x000008, "Wrong size on FGameStateData");
static_assert(offsetof(FGameStateData, GameState) == 0x000000, "Member 'FGameStateData::GameState' has a wrong offset!");
static_assert(offsetof(FGameStateData, ServerWorldTime) == 0x000004, "Member 'FGameStateData::ServerWorldTime' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgGmTradeChatBanResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgGmTradeChatBanResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21A8[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgGmTradeChatBanResponse) == 0x000008, "Wrong alignment on FClientMsgGmTradeChatBanResponse");
static_assert(sizeof(FClientMsgGmTradeChatBanResponse) == 0x000020, "Wrong size on FClientMsgGmTradeChatBanResponse");

// ScriptStruct DungeonCrawler.ClientMsgFriendItemRecoveredNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgFriendItemRecoveredNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21A9[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendItemRecoveredNotify) == 0x000008, "Wrong alignment on FClientMsgFriendItemRecoveredNotify");
static_assert(sizeof(FClientMsgFriendItemRecoveredNotify) == 0x000028, "Wrong size on FClientMsgFriendItemRecoveredNotify");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestSelectRequest
// 0x0030 (0x0050 - 0x0020)
struct FClientMsgMerchantQuestSelectRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21AA[0x30];                                    // 0x0020(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestSelectRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestSelectRequest");
static_assert(sizeof(FClientMsgMerchantQuestSelectRequest) == 0x000050, "Wrong size on FClientMsgMerchantQuestSelectRequest");

// ScriptStruct DungeonCrawler.MsgUsingItemUniqueFunction
// 0x0010 (0x0028 - 0x0018)
struct FMsgUsingItemUniqueFunction final : public FMsgBase
{
public:
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21AB[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUniqueId;                                      // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgUsingItemUniqueFunction) == 0x000008, "Wrong alignment on FMsgUsingItemUniqueFunction");
static_assert(sizeof(FMsgUsingItemUniqueFunction) == 0x000028, "Wrong size on FMsgUsingItemUniqueFunction");
static_assert(offsetof(FMsgUsingItemUniqueFunction, InventoryId) == 0x000018, "Member 'FMsgUsingItemUniqueFunction::InventoryId' has a wrong offset!");
static_assert(offsetof(FMsgUsingItemUniqueFunction, ItemUniqueId) == 0x000020, "Member 'FMsgUsingItemUniqueFunction::ItemUniqueId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendItemRecoveryReceiveNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendItemRecoveryReceiveNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21AC[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendItemRecoveryReceiveNotify) == 0x000008, "Wrong alignment on FClientMsgFriendItemRecoveryReceiveNotify");
static_assert(sizeof(FClientMsgFriendItemRecoveryReceiveNotify) == 0x000020, "Wrong size on FClientMsgFriendItemRecoveryReceiveNotify");

// ScriptStruct DungeonCrawler.MsgFinishedLoadItemArtData
// 0x0008 (0x0020 - 0x0018)
struct FMsgFinishedLoadItemArtData final : public FMsgBase
{
public:
	class UItem*                                  Item;                                              // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgFinishedLoadItemArtData) == 0x000008, "Wrong alignment on FMsgFinishedLoadItemArtData");
static_assert(sizeof(FMsgFinishedLoadItemArtData) == 0x000020, "Wrong size on FMsgFinishedLoadItemArtData");
static_assert(offsetof(FMsgFinishedLoadItemArtData, Item) == 0x000018, "Member 'FMsgFinishedLoadItemArtData::Item' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgFriendItemRecoveredNotCheckResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendItemRecoveredNotCheckResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21AD[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendItemRecoveredNotCheckResponse) == 0x000008, "Wrong alignment on FClientMsgFriendItemRecoveredNotCheckResponse");
static_assert(sizeof(FClientMsgFriendItemRecoveredNotCheckResponse) == 0x000020, "Wrong size on FClientMsgFriendItemRecoveredNotCheckResponse");

// ScriptStruct DungeonCrawler.ClientMsgFriendItemRecoveryReceiveNotCheckRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgFriendItemRecoveryReceiveNotCheckRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21AE[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendItemRecoveryReceiveNotCheckRequest) == 0x000008, "Wrong alignment on FClientMsgFriendItemRecoveryReceiveNotCheckRequest");
static_assert(sizeof(FClientMsgFriendItemRecoveryReceiveNotCheckRequest) == 0x000028, "Wrong size on FClientMsgFriendItemRecoveryReceiveNotCheckRequest");

// ScriptStruct DungeonCrawler.ClientMsgRefreshRedStoneShardRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgRefreshRedStoneShardRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21AF[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRefreshRedStoneShardRequest) == 0x000008, "Wrong alignment on FClientMsgRefreshRedStoneShardRequest");
static_assert(sizeof(FClientMsgRefreshRedStoneShardRequest) == 0x000030, "Wrong size on FClientMsgRefreshRedStoneShardRequest");

// ScriptStruct DungeonCrawler.MsgGASInstigatorDataRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgGASInstigatorDataRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgGASInstigatorDataRequest) == 0x000008, "Wrong alignment on FMsgGASInstigatorDataRequest");
static_assert(sizeof(FMsgGASInstigatorDataRequest) == 0x000018, "Wrong size on FMsgGASInstigatorDataRequest");

// ScriptStruct DungeonCrawler.ClientMsgFriendItemRecoveryReceiveNotCheckResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgFriendItemRecoveryReceiveNotCheckResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21B0[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgFriendItemRecoveryReceiveNotCheckResponse) == 0x000008, "Wrong alignment on FClientMsgFriendItemRecoveryReceiveNotCheckResponse");
static_assert(sizeof(FClientMsgFriendItemRecoveryReceiveNotCheckResponse) == 0x000020, "Wrong size on FClientMsgFriendItemRecoveryReceiveNotCheckResponse");

// ScriptStruct DungeonCrawler.KarmaMatchInfo
// 0x0018 (0x0018 - 0x0000)
struct FKarmaMatchInfo final
{
public:
	int32                                         MatchIdx;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21B1[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKarmaMemberInfo>               MemberInfoArray;                                   // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKarmaMatchInfo) == 0x000008, "Wrong alignment on FKarmaMatchInfo");
static_assert(sizeof(FKarmaMatchInfo) == 0x000018, "Wrong size on FKarmaMatchInfo");
static_assert(offsetof(FKarmaMatchInfo, MatchIdx) == 0x000000, "Member 'FKarmaMatchInfo::MatchIdx' has a wrong offset!");
static_assert(offsetof(FKarmaMatchInfo, MemberInfoArray) == 0x000008, "Member 'FKarmaMatchInfo::MemberInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgReligionRankingListRequest
// 0x0038 (0x0058 - 0x0020)
struct FClientMsgReligionRankingListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21B2[0x38];                                    // 0x0020(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionRankingListRequest) == 0x000008, "Wrong alignment on FClientMsgReligionRankingListRequest");
static_assert(sizeof(FClientMsgReligionRankingListRequest) == 0x000058, "Wrong size on FClientMsgReligionRankingListRequest");

// ScriptStruct DungeonCrawler.ClientMsgLobbyRandomMatchmakingRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgLobbyRandomMatchmakingRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21B3[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyRandomMatchmakingRequest) == 0x000008, "Wrong alignment on FClientMsgLobbyRandomMatchmakingRequest");
static_assert(sizeof(FClientMsgLobbyRandomMatchmakingRequest) == 0x000028, "Wrong size on FClientMsgLobbyRandomMatchmakingRequest");

// ScriptStruct DungeonCrawler.MsgGASGameplayTagContainerRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgGASGameplayTagContainerRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgGASGameplayTagContainerRequest) == 0x000008, "Wrong alignment on FMsgGASGameplayTagContainerRequest");
static_assert(sizeof(FMsgGASGameplayTagContainerRequest) == 0x000018, "Wrong size on FMsgGASGameplayTagContainerRequest");

// ScriptStruct DungeonCrawler.ClientMsgLobbyRandomMatchmakingResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgLobbyRandomMatchmakingResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21B4[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgLobbyRandomMatchmakingResponse) == 0x000008, "Wrong alignment on FClientMsgLobbyRandomMatchmakingResponse");
static_assert(sizeof(FClientMsgLobbyRandomMatchmakingResponse) == 0x000020, "Wrong size on FClientMsgLobbyRandomMatchmakingResponse");

// ScriptStruct DungeonCrawler.ClientMsgDlcLegendaryStatusDuplicateWarningNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgDlcLegendaryStatusDuplicateWarningNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21B5[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgDlcLegendaryStatusDuplicateWarningNotify) == 0x000008, "Wrong alignment on FClientMsgDlcLegendaryStatusDuplicateWarningNotify");
static_assert(sizeof(FClientMsgDlcLegendaryStatusDuplicateWarningNotify) == 0x000020, "Wrong size on FClientMsgDlcLegendaryStatusDuplicateWarningNotify");

// ScriptStruct DungeonCrawler.ClientMsgMerchantBaseGearSetRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMerchantBaseGearSetRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21B6[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantBaseGearSetRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantBaseGearSetRequest");
static_assert(sizeof(FClientMsgMerchantBaseGearSetRequest) == 0x000028, "Wrong size on FClientMsgMerchantBaseGearSetRequest");

// ScriptStruct DungeonCrawler.MsgRemoveFromInventory
// 0x0000 (0x0018 - 0x0018)
struct FMsgRemoveFromInventory final : public FMsgBase
{
};
static_assert(alignof(FMsgRemoveFromInventory) == 0x000008, "Wrong alignment on FMsgRemoveFromInventory");
static_assert(sizeof(FMsgRemoveFromInventory) == 0x000018, "Wrong size on FMsgRemoveFromInventory");

// ScriptStruct DungeonCrawler.ClientMsgArenaStatNotify
// 0x0020 (0x0038 - 0x0018)
struct FClientMsgArenaStatNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21B7[0x20];                                    // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgArenaStatNotify) == 0x000008, "Wrong alignment on FClientMsgArenaStatNotify");
static_assert(sizeof(FClientMsgArenaStatNotify) == 0x000038, "Wrong size on FClientMsgArenaStatNotify");

// ScriptStruct DungeonCrawler.ClientMsgRankingApConfigResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgRankingApConfigResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21B8[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingApConfigResponse) == 0x000008, "Wrong alignment on FClientMsgRankingApConfigResponse");
static_assert(sizeof(FClientMsgRankingApConfigResponse) == 0x000028, "Wrong size on FClientMsgRankingApConfigResponse");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceItemListRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgMarketplaceItemListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21B9[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceItemListRequest) == 0x000008, "Wrong alignment on FClientMsgMarketplaceItemListRequest");
static_assert(sizeof(FClientMsgMarketplaceItemListRequest) == 0x000040, "Wrong size on FClientMsgMarketplaceItemListRequest");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceItemListResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgMarketplaceItemListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21BA[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceItemListResponse) == 0x000008, "Wrong alignment on FClientMsgMarketplaceItemListResponse");
static_assert(sizeof(FClientMsgMarketplaceItemListResponse) == 0x000030, "Wrong size on FClientMsgMarketplaceItemListResponse");

// ScriptStruct DungeonCrawler.MsgInteractFound
// 0x0010 (0x0028 - 0x0018)
struct FMsgInteractFound final : public FMsgBase
{
public:
	class AActor*                                 Interacter;                                        // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    InteractPart;                                      // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgInteractFound) == 0x000008, "Wrong alignment on FMsgInteractFound");
static_assert(sizeof(FMsgInteractFound) == 0x000028, "Wrong size on FMsgInteractFound");
static_assert(offsetof(FMsgInteractFound, Interacter) == 0x000018, "Member 'FMsgInteractFound::Interacter' has a wrong offset!");
static_assert(offsetof(FMsgInteractFound, InteractPart) == 0x000020, "Member 'FMsgInteractFound::InteractPart' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCTrainingClassAbilityId
// 0x0004 (0x0014 - 0x0010)
struct FDCTrainingClassAbilityId final : public FPrimaryAssetId
{
public:
	uint8                                         Pad_21BB[0x4];                                     // 0x0010(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCTrainingClassAbilityId) == 0x000004, "Wrong alignment on FDCTrainingClassAbilityId");
static_assert(sizeof(FDCTrainingClassAbilityId) == 0x000014, "Wrong size on FDCTrainingClassAbilityId");

// ScriptStruct DungeonCrawler.DCTrainingClassAbilityIdArray
// 0x0010 (0x0010 - 0x0000)
struct FDCTrainingClassAbilityIdArray final
{
public:
	TArray<struct FDCTrainingClassAbilityId>      Value;                                             // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCTrainingClassAbilityIdArray) == 0x000008, "Wrong alignment on FDCTrainingClassAbilityIdArray");
static_assert(sizeof(FDCTrainingClassAbilityIdArray) == 0x000010, "Wrong size on FDCTrainingClassAbilityIdArray");
static_assert(offsetof(FDCTrainingClassAbilityIdArray, Value) == 0x000000, "Member 'FDCTrainingClassAbilityIdArray::Value' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceMyItemListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgMarketplaceMyItemListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21BC[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceMyItemListResponse) == 0x000008, "Wrong alignment on FClientMsgMarketplaceMyItemListResponse");
static_assert(sizeof(FClientMsgMarketplaceMyItemListResponse) == 0x000028, "Wrong size on FClientMsgMarketplaceMyItemListResponse");

// ScriptStruct DungeonCrawler.ClientMsgReligionRegisterRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgReligionRegisterRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21BD[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionRegisterRequest) == 0x000008, "Wrong alignment on FClientMsgReligionRegisterRequest");
static_assert(sizeof(FClientMsgReligionRegisterRequest) == 0x000040, "Wrong size on FClientMsgReligionRegisterRequest");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceItemBuyRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgMarketplaceItemBuyRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21BE[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceItemBuyRequest) == 0x000008, "Wrong alignment on FClientMsgMarketplaceItemBuyRequest");
static_assert(sizeof(FClientMsgMarketplaceItemBuyRequest) == 0x000038, "Wrong size on FClientMsgMarketplaceItemBuyRequest");

// ScriptStruct DungeonCrawler.MsgGASEffectCauserDataRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgGASEffectCauserDataRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgGASEffectCauserDataRequest) == 0x000008, "Wrong alignment on FMsgGASEffectCauserDataRequest");
static_assert(sizeof(FMsgGASEffectCauserDataRequest) == 0x000018, "Wrong size on FMsgGASEffectCauserDataRequest");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceItemBuyResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMarketplaceItemBuyResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21BF[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceItemBuyResponse) == 0x000008, "Wrong alignment on FClientMsgMarketplaceItemBuyResponse");
static_assert(sizeof(FClientMsgMarketplaceItemBuyResponse) == 0x000020, "Wrong size on FClientMsgMarketplaceItemBuyResponse");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceItemRegisterRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgMarketplaceItemRegisterRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21C0[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceItemRegisterRequest) == 0x000008, "Wrong alignment on FClientMsgMarketplaceItemRegisterRequest");
static_assert(sizeof(FClientMsgMarketplaceItemRegisterRequest) == 0x000040, "Wrong size on FClientMsgMarketplaceItemRegisterRequest");

// ScriptStruct DungeonCrawler.ClientMsgMerchantServiceMindwipeRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMerchantServiceMindwipeRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21C1[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantServiceMindwipeRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantServiceMindwipeRequest");
static_assert(sizeof(FClientMsgMerchantServiceMindwipeRequest) == 0x000028, "Wrong size on FClientMsgMerchantServiceMindwipeRequest");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceItemCancelRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMarketplaceItemCancelRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21C2[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceItemCancelRequest) == 0x000008, "Wrong alignment on FClientMsgMarketplaceItemCancelRequest");
static_assert(sizeof(FClientMsgMarketplaceItemCancelRequest) == 0x000028, "Wrong size on FClientMsgMarketplaceItemCancelRequest");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceItemCancelResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMarketplaceItemCancelResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21C3[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceItemCancelResponse) == 0x000008, "Wrong alignment on FClientMsgMarketplaceItemCancelResponse");
static_assert(sizeof(FClientMsgMarketplaceItemCancelResponse) == 0x000020, "Wrong size on FClientMsgMarketplaceItemCancelResponse");

// ScriptStruct DungeonCrawler.MsgRemoveContainingItemRequest
// 0x0010 (0x0028 - 0x0018)
struct FMsgRemoveContainingItemRequest final : public FMsgBase
{
public:
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C4[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUniqueId;                                      // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgRemoveContainingItemRequest) == 0x000008, "Wrong alignment on FMsgRemoveContainingItemRequest");
static_assert(sizeof(FMsgRemoveContainingItemRequest) == 0x000028, "Wrong size on FMsgRemoveContainingItemRequest");
static_assert(offsetof(FMsgRemoveContainingItemRequest, InventoryId) == 0x000018, "Member 'FMsgRemoveContainingItemRequest::InventoryId' has a wrong offset!");
static_assert(offsetof(FMsgRemoveContainingItemRequest, ItemUniqueId) == 0x000020, "Member 'FMsgRemoveContainingItemRequest::ItemUniqueId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgPartyReadyChangeNotify
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgPartyReadyChangeNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21C5[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyReadyChangeNotify) == 0x000008, "Wrong alignment on FClientMsgPartyReadyChangeNotify");
static_assert(sizeof(FClientMsgPartyReadyChangeNotify) == 0x000040, "Wrong size on FClientMsgPartyReadyChangeNotify");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceTransferItemsRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgMarketplaceTransferItemsRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21C6[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceTransferItemsRequest) == 0x000008, "Wrong alignment on FClientMsgMarketplaceTransferItemsRequest");
static_assert(sizeof(FClientMsgMarketplaceTransferItemsRequest) == 0x000038, "Wrong size on FClientMsgMarketplaceTransferItemsRequest");

// ScriptStruct DungeonCrawler.MsgContainingItemDataResponse
// 0x0108 (0x0120 - 0x0018)
struct FMsgContainingItemDataResponse final : public FMsgBase
{
public:
	struct FItemData                              ItemData;                                          // 0x0018(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsActiveSlot;                                     // 0x0118(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C7[0x7];                                     // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgContainingItemDataResponse) == 0x000008, "Wrong alignment on FMsgContainingItemDataResponse");
static_assert(sizeof(FMsgContainingItemDataResponse) == 0x000120, "Wrong size on FMsgContainingItemDataResponse");
static_assert(offsetof(FMsgContainingItemDataResponse, ItemData) == 0x000018, "Member 'FMsgContainingItemDataResponse::ItemData' has a wrong offset!");
static_assert(offsetof(FMsgContainingItemDataResponse, bIsActiveSlot) == 0x000118, "Member 'FMsgContainingItemDataResponse::bIsActiveSlot' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceTransferItemsResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMarketplaceTransferItemsResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21C8[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceTransferItemsResponse) == 0x000008, "Wrong alignment on FClientMsgMarketplaceTransferItemsResponse");
static_assert(sizeof(FClientMsgMarketplaceTransferItemsResponse) == 0x000020, "Wrong size on FClientMsgMarketplaceTransferItemsResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopEnterGiftCodeRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgShopEnterGiftCodeRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21C9[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopEnterGiftCodeRequest) == 0x000008, "Wrong alignment on FClientMsgShopEnterGiftCodeRequest");
static_assert(sizeof(FClientMsgShopEnterGiftCodeRequest) == 0x000030, "Wrong size on FClientMsgShopEnterGiftCodeRequest");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceItemHasSoldNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMarketplaceItemHasSoldNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21CA[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceItemHasSoldNotify) == 0x000008, "Wrong alignment on FClientMsgMarketplaceItemHasSoldNotify");
static_assert(sizeof(FClientMsgMarketplaceItemHasSoldNotify) == 0x000020, "Wrong size on FClientMsgMarketplaceItemHasSoldNotify");

// ScriptStruct DungeonCrawler.MsgGameTestChangePlayerCharacterClassResponse
// 0x0000 (0x0018 - 0x0018)
struct FMsgGameTestChangePlayerCharacterClassResponse final : public FMsgBase
{
};
static_assert(alignof(FMsgGameTestChangePlayerCharacterClassResponse) == 0x000008, "Wrong alignment on FMsgGameTestChangePlayerCharacterClassResponse");
static_assert(sizeof(FMsgGameTestChangePlayerCharacterClassResponse) == 0x000018, "Wrong size on FMsgGameTestChangePlayerCharacterClassResponse");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceEnterRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMarketplaceEnterRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21CB[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceEnterRequest) == 0x000008, "Wrong alignment on FClientMsgMarketplaceEnterRequest");
static_assert(sizeof(FClientMsgMarketplaceEnterRequest) == 0x000028, "Wrong size on FClientMsgMarketplaceEnterRequest");

// ScriptStruct DungeonCrawler.ClientMsgMarketplaceEnterResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMarketplaceEnterResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21CC[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMarketplaceEnterResponse) == 0x000008, "Wrong alignment on FClientMsgMarketplaceEnterResponse");
static_assert(sizeof(FClientMsgMarketplaceEnterResponse) == 0x000020, "Wrong size on FClientMsgMarketplaceEnterResponse");

// ScriptStruct DungeonCrawler.ClientMsgReligionKillCountListRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgReligionKillCountListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21CD[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionKillCountListRequest) == 0x000008, "Wrong alignment on FClientMsgReligionKillCountListRequest");
static_assert(sizeof(FClientMsgReligionKillCountListRequest) == 0x000030, "Wrong size on FClientMsgReligionKillCountListRequest");

// ScriptStruct DungeonCrawler.ClientMsgMerchantListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMerchantListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21CE[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantListRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantListRequest");
static_assert(sizeof(FClientMsgMerchantListRequest) == 0x000028, "Wrong size on FClientMsgMerchantListRequest");

// ScriptStruct DungeonCrawler.MsgInteractableHighlightNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgInteractableHighlightNotify final : public FMsgBase
{
public:
	int32                                         HighlightDepthValue;                               // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21CF[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgInteractableHighlightNotify) == 0x000008, "Wrong alignment on FMsgInteractableHighlightNotify");
static_assert(sizeof(FMsgInteractableHighlightNotify) == 0x000020, "Wrong size on FMsgInteractableHighlightNotify");
static_assert(offsetof(FMsgInteractableHighlightNotify, HighlightDepthValue) == 0x000018, "Member 'FMsgInteractableHighlightNotify::HighlightDepthValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgMerchantListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgMerchantListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21D0[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantListResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantListResponse");
static_assert(sizeof(FClientMsgMerchantListResponse) == 0x000028, "Wrong size on FClientMsgMerchantListResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantStockBuyItemListResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgMerchantStockBuyItemListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21D1[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantStockBuyItemListResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantStockBuyItemListResponse");
static_assert(sizeof(FClientMsgMerchantStockBuyItemListResponse) == 0x000030, "Wrong size on FClientMsgMerchantStockBuyItemListResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantStockSellBackItemListResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgMerchantStockSellBackItemListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21D2[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantStockSellBackItemListResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantStockSellBackItemListResponse");
static_assert(sizeof(FClientMsgMerchantStockSellBackItemListResponse) == 0x000030, "Wrong size on FClientMsgMerchantStockSellBackItemListResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantStockSellBackResponse
// 0x0048 (0x0060 - 0x0018)
struct FClientMsgMerchantStockSellBackResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21D3[0x48];                                    // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantStockSellBackResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantStockSellBackResponse");
static_assert(sizeof(FClientMsgMerchantStockSellBackResponse) == 0x000060, "Wrong size on FClientMsgMerchantStockSellBackResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantServiceCraftListResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgMerchantServiceCraftListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21D4[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantServiceCraftListResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantServiceCraftListResponse");
static_assert(sizeof(FClientMsgMerchantServiceCraftListResponse) == 0x000030, "Wrong size on FClientMsgMerchantServiceCraftListResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantServiceCraftResponse
// 0x0048 (0x0060 - 0x0018)
struct FClientMsgMerchantServiceCraftResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21D5[0x48];                                    // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantServiceCraftResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantServiceCraftResponse");
static_assert(sizeof(FClientMsgMerchantServiceCraftResponse) == 0x000060, "Wrong size on FClientMsgMerchantServiceCraftResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestListInfoResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgMerchantQuestListInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21D6[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestListInfoResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestListInfoResponse");
static_assert(sizeof(FClientMsgMerchantQuestListInfoResponse) == 0x000030, "Wrong size on FClientMsgMerchantQuestListInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestSelectResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMerchantQuestSelectResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21D7[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestSelectResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestSelectResponse");
static_assert(sizeof(FClientMsgMerchantQuestSelectResponse) == 0x000020, "Wrong size on FClientMsgMerchantQuestSelectResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestCompleteResponse
// 0x0038 (0x0050 - 0x0018)
struct FClientMsgMerchantQuestCompleteResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21D8[0x38];                                    // 0x0018(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestCompleteResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestCompleteResponse");
static_assert(sizeof(FClientMsgMerchantQuestCompleteResponse) == 0x000050, "Wrong size on FClientMsgMerchantQuestCompleteResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestContentValueStackResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMerchantQuestContentValueStackResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21D9[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestContentValueStackResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestContentValueStackResponse");
static_assert(sizeof(FClientMsgMerchantQuestContentValueStackResponse) == 0x000020, "Wrong size on FClientMsgMerchantQuestContentValueStackResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantBaseGearListResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgMerchantBaseGearListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21DA[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantBaseGearListResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantBaseGearListResponse");
static_assert(sizeof(FClientMsgMerchantBaseGearListResponse) == 0x000030, "Wrong size on FClientMsgMerchantBaseGearListResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantBaseGearSetResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgMerchantBaseGearSetResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21DB[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantBaseGearSetResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantBaseGearSetResponse");
static_assert(sizeof(FClientMsgMerchantBaseGearSetResponse) == 0x000028, "Wrong size on FClientMsgMerchantBaseGearSetResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantSaveBaseGearSetResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMerchantSaveBaseGearSetResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21DC[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantSaveBaseGearSetResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantSaveBaseGearSetResponse");
static_assert(sizeof(FClientMsgMerchantSaveBaseGearSetResponse) == 0x000020, "Wrong size on FClientMsgMerchantSaveBaseGearSetResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantEquipBaseGearSetResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMerchantEquipBaseGearSetResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21DD[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantEquipBaseGearSetResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantEquipBaseGearSetResponse");
static_assert(sizeof(FClientMsgMerchantEquipBaseGearSetResponse) == 0x000020, "Wrong size on FClientMsgMerchantEquipBaseGearSetResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantServiceMindwipeInfoResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgMerchantServiceMindwipeInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21DE[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantServiceMindwipeInfoResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantServiceMindwipeInfoResponse");
static_assert(sizeof(FClientMsgMerchantServiceMindwipeInfoResponse) == 0x000030, "Wrong size on FClientMsgMerchantServiceMindwipeInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantRecoveryListResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgMerchantRecoveryListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21DF[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantRecoveryListResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantRecoveryListResponse");
static_assert(sizeof(FClientMsgMerchantRecoveryListResponse) == 0x000028, "Wrong size on FClientMsgMerchantRecoveryListResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantQuestLogAcceptAllResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMerchantQuestLogAcceptAllResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21E0[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantQuestLogAcceptAllResponse) == 0x000008, "Wrong alignment on FClientMsgMerchantQuestLogAcceptAllResponse");
static_assert(sizeof(FClientMsgMerchantQuestLogAcceptAllResponse) == 0x000020, "Wrong size on FClientMsgMerchantQuestLogAcceptAllResponse");

// ScriptStruct DungeonCrawler.ClientMsgMerchantRecoveryCheckRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgMerchantRecoveryCheckRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21E1[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantRecoveryCheckRequest) == 0x000008, "Wrong alignment on FClientMsgMerchantRecoveryCheckRequest");
static_assert(sizeof(FClientMsgMerchantRecoveryCheckRequest) == 0x000028, "Wrong size on FClientMsgMerchantRecoveryCheckRequest");

// ScriptStruct DungeonCrawler.ClientMsgMerchantExpressItemCheckNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgMerchantExpressItemCheckNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21E2[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgMerchantExpressItemCheckNotify) == 0x000008, "Wrong alignment on FClientMsgMerchantExpressItemCheckNotify");
static_assert(sizeof(FClientMsgMerchantExpressItemCheckNotify) == 0x000020, "Wrong size on FClientMsgMerchantExpressItemCheckNotify");

// ScriptStruct DungeonCrawler.ClientMsgPartyInviteResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyInviteResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21E3[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyInviteResponse) == 0x000008, "Wrong alignment on FClientMsgPartyInviteResponse");
static_assert(sizeof(FClientMsgPartyInviteResponse) == 0x000020, "Wrong size on FClientMsgPartyInviteResponse");

// ScriptStruct DungeonCrawler.ClientMsgPartyInviteAnswerRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgPartyInviteAnswerRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21E4[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyInviteAnswerRequest) == 0x000008, "Wrong alignment on FClientMsgPartyInviteAnswerRequest");
static_assert(sizeof(FClientMsgPartyInviteAnswerRequest) == 0x000038, "Wrong size on FClientMsgPartyInviteAnswerRequest");

// ScriptStruct DungeonCrawler.ClientMsgPartyReadyRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgPartyReadyRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21E5[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyReadyRequest) == 0x000008, "Wrong alignment on FClientMsgPartyReadyRequest");
static_assert(sizeof(FClientMsgPartyReadyRequest) == 0x000028, "Wrong size on FClientMsgPartyReadyRequest");

// ScriptStruct DungeonCrawler.ClientMsgPartyItemSkinChangeNotify
// 0x0040 (0x0058 - 0x0018)
struct FClientMsgPartyItemSkinChangeNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21E6[0x40];                                    // 0x0018(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyItemSkinChangeNotify) == 0x000008, "Wrong alignment on FClientMsgPartyItemSkinChangeNotify");
static_assert(sizeof(FClientMsgPartyItemSkinChangeNotify) == 0x000058, "Wrong size on FClientMsgPartyItemSkinChangeNotify");

// ScriptStruct DungeonCrawler.ClientMsgPartyArmorSkinChangeNotify
// 0x0040 (0x0058 - 0x0018)
struct FClientMsgPartyArmorSkinChangeNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21E7[0x40];                                    // 0x0018(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyArmorSkinChangeNotify) == 0x000008, "Wrong alignment on FClientMsgPartyArmorSkinChangeNotify");
static_assert(sizeof(FClientMsgPartyArmorSkinChangeNotify) == 0x000058, "Wrong size on FClientMsgPartyArmorSkinChangeNotify");

// ScriptStruct DungeonCrawler.ClientMsgPartyMemberKickRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgPartyMemberKickRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21E8[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyMemberKickRequest) == 0x000008, "Wrong alignment on FClientMsgPartyMemberKickRequest");
static_assert(sizeof(FClientMsgPartyMemberKickRequest) == 0x000040, "Wrong size on FClientMsgPartyMemberKickRequest");

// ScriptStruct DungeonCrawler.ClientMsgPartyChatNotify
// 0x0088 (0x00A0 - 0x0018)
struct FClientMsgPartyChatNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21E9[0x88];                                    // 0x0018(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyChatNotify) == 0x000008, "Wrong alignment on FClientMsgPartyChatNotify");
static_assert(sizeof(FClientMsgPartyChatNotify) == 0x0000A0, "Wrong size on FClientMsgPartyChatNotify");

// ScriptStruct DungeonCrawler.ClientMsgPartyKickedOutNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyKickedOutNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21EA[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyKickedOutNotify) == 0x000008, "Wrong alignment on FClientMsgPartyKickedOutNotify");
static_assert(sizeof(FClientMsgPartyKickedOutNotify) == 0x000020, "Wrong size on FClientMsgPartyKickedOutNotify");

// ScriptStruct DungeonCrawler.ClientMsgPartyStartLobbyEmoteRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgPartyStartLobbyEmoteRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21EB[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyStartLobbyEmoteRequest) == 0x000008, "Wrong alignment on FClientMsgPartyStartLobbyEmoteRequest");
static_assert(sizeof(FClientMsgPartyStartLobbyEmoteRequest) == 0x000030, "Wrong size on FClientMsgPartyStartLobbyEmoteRequest");

// ScriptStruct DungeonCrawler.ClientMsgPartyStartLobbyEmoteResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgPartyStartLobbyEmoteResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21EC[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgPartyStartLobbyEmoteResponse) == 0x000008, "Wrong alignment on FClientMsgPartyStartLobbyEmoteResponse");
static_assert(sizeof(FClientMsgPartyStartLobbyEmoteResponse) == 0x000020, "Wrong size on FClientMsgPartyStartLobbyEmoteResponse");

// ScriptStruct DungeonCrawler.MsgWidgetLobbyGroupHideRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetLobbyGroupHideRequest final : public FMsgBase
{
public:
	EWidgetLobbyGroupType                         WidgetLobbyGroupType;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21ED[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetLobbyGroupHideRequest) == 0x000008, "Wrong alignment on FMsgWidgetLobbyGroupHideRequest");
static_assert(sizeof(FMsgWidgetLobbyGroupHideRequest) == 0x000020, "Wrong size on FMsgWidgetLobbyGroupHideRequest");
static_assert(offsetof(FMsgWidgetLobbyGroupHideRequest, WidgetLobbyGroupType) == 0x000018, "Member 'FMsgWidgetLobbyGroupHideRequest::WidgetLobbyGroupType' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgRankingInfoRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgRankingInfoRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21EE[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingInfoRequest) == 0x000008, "Wrong alignment on FClientMsgRankingInfoRequest");
static_assert(sizeof(FClientMsgRankingInfoRequest) == 0x000028, "Wrong size on FClientMsgRankingInfoRequest");

// ScriptStruct DungeonCrawler.ClientMsgRankingRangeRequest
// 0x0048 (0x0068 - 0x0020)
struct FClientMsgRankingRangeRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21EF[0x48];                                    // 0x0020(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingRangeRequest) == 0x000008, "Wrong alignment on FClientMsgRankingRangeRequest");
static_assert(sizeof(FClientMsgRankingRangeRequest) == 0x000068, "Wrong size on FClientMsgRankingRangeRequest");

// ScriptStruct DungeonCrawler.ClientMsgRankingRangeResponse
// 0x0068 (0x0080 - 0x0018)
struct FClientMsgRankingRangeResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21F0[0x68];                                    // 0x0018(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingRangeResponse) == 0x000008, "Wrong alignment on FClientMsgRankingRangeResponse");
static_assert(sizeof(FClientMsgRankingRangeResponse) == 0x000080, "Wrong size on FClientMsgRankingRangeResponse");

// ScriptStruct DungeonCrawler.ClientMsgRankingRewardGetRequest
// 0x0020 (0x0040 - 0x0020)
struct FClientMsgRankingRewardGetRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21F1[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingRewardGetRequest) == 0x000008, "Wrong alignment on FClientMsgRankingRewardGetRequest");
static_assert(sizeof(FClientMsgRankingRewardGetRequest) == 0x000040, "Wrong size on FClientMsgRankingRewardGetRequest");

// ScriptStruct DungeonCrawler.MsgWidgetLeaderboardClassIconButtonClickNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetLeaderboardClassIconButtonClickNotify final : public FMsgBase
{
public:
	class ULeaderboardClassIconWidgetData*        ClickData;                                         // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetLeaderboardClassIconButtonClickNotify) == 0x000008, "Wrong alignment on FMsgWidgetLeaderboardClassIconButtonClickNotify");
static_assert(sizeof(FMsgWidgetLeaderboardClassIconButtonClickNotify) == 0x000020, "Wrong size on FMsgWidgetLeaderboardClassIconButtonClickNotify");
static_assert(offsetof(FMsgWidgetLeaderboardClassIconButtonClickNotify, ClickData) == 0x000018, "Member 'FMsgWidgetLeaderboardClassIconButtonClickNotify::ClickData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgRankingApConfigRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgRankingApConfigRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21F2[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingApConfigRequest) == 0x000008, "Wrong alignment on FClientMsgRankingApConfigRequest");
static_assert(sizeof(FClientMsgRankingApConfigRequest) == 0x000038, "Wrong size on FClientMsgRankingApConfigRequest");

// ScriptStruct DungeonCrawler.ClientMsgRankingHasRewardNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgRankingHasRewardNotify final : public FMsgBase
{
public:
	uint8                                         Pad_21F3[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgRankingHasRewardNotify) == 0x000008, "Wrong alignment on FClientMsgRankingHasRewardNotify");
static_assert(sizeof(FClientMsgRankingHasRewardNotify) == 0x000020, "Wrong size on FClientMsgRankingHasRewardNotify");

// ScriptStruct DungeonCrawler.ClientMsgReligionListRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgReligionListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21F4[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionListRequest) == 0x000008, "Wrong alignment on FClientMsgReligionListRequest");
static_assert(sizeof(FClientMsgReligionListRequest) == 0x000030, "Wrong size on FClientMsgReligionListRequest");

// ScriptStruct DungeonCrawler.ClientMsgReligionListResponse
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgReligionListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21F5[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionListResponse) == 0x000008, "Wrong alignment on FClientMsgReligionListResponse");
static_assert(sizeof(FClientMsgReligionListResponse) == 0x000040, "Wrong size on FClientMsgReligionListResponse");

// ScriptStruct DungeonCrawler.ClientMsgReligionRankingListResponse
// 0x0038 (0x0050 - 0x0018)
struct FClientMsgReligionRankingListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21F6[0x38];                                    // 0x0018(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionRankingListResponse) == 0x000008, "Wrong alignment on FClientMsgReligionRankingListResponse");
static_assert(sizeof(FClientMsgReligionRankingListResponse) == 0x000050, "Wrong size on FClientMsgReligionRankingListResponse");

// ScriptStruct DungeonCrawler.ClientMsgReligionPersonalRankingResponse
// 0x0050 (0x0068 - 0x0018)
struct FClientMsgReligionPersonalRankingResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21F7[0x50];                                    // 0x0018(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionPersonalRankingResponse) == 0x000008, "Wrong alignment on FClientMsgReligionPersonalRankingResponse");
static_assert(sizeof(FClientMsgReligionPersonalRankingResponse) == 0x000068, "Wrong size on FClientMsgReligionPersonalRankingResponse");

// ScriptStruct DungeonCrawler.ClientMsgReligionUpdateOfferingResponse
// 0x0038 (0x0050 - 0x0018)
struct FClientMsgReligionUpdateOfferingResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21F8[0x38];                                    // 0x0018(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionUpdateOfferingResponse) == 0x000008, "Wrong alignment on FClientMsgReligionUpdateOfferingResponse");
static_assert(sizeof(FClientMsgReligionUpdateOfferingResponse) == 0x000050, "Wrong size on FClientMsgReligionUpdateOfferingResponse");

// ScriptStruct DungeonCrawler.ClientMsgReligionKillCountListResponse
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgReligionKillCountListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21F9[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionKillCountListResponse) == 0x000008, "Wrong alignment on FClientMsgReligionKillCountListResponse");
static_assert(sizeof(FClientMsgReligionKillCountListResponse) == 0x000040, "Wrong size on FClientMsgReligionKillCountListResponse");

// ScriptStruct DungeonCrawler.ClientMsgReligionGetSeasonInfoResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgReligionGetSeasonInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21FA[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReligionGetSeasonInfoResponse) == 0x000008, "Wrong alignment on FClientMsgReligionGetSeasonInfoResponse");
static_assert(sizeof(FClientMsgReligionGetSeasonInfoResponse) == 0x000030, "Wrong size on FClientMsgReligionGetSeasonInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopItemListResponse
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgShopItemListResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21FB[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopItemListResponse) == 0x000008, "Wrong alignment on FClientMsgShopItemListResponse");
static_assert(sizeof(FClientMsgShopItemListResponse) == 0x000040, "Wrong size on FClientMsgShopItemListResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopItemBuyResponse
// 0x0020 (0x0038 - 0x0018)
struct FClientMsgShopItemBuyResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21FC[0x20];                                    // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopItemBuyResponse) == 0x000008, "Wrong alignment on FClientMsgShopItemBuyResponse");
static_assert(sizeof(FClientMsgShopItemBuyResponse) == 0x000038, "Wrong size on FClientMsgShopItemBuyResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopEnterGiftCodeResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgShopEnterGiftCodeResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21FD[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopEnterGiftCodeResponse) == 0x000008, "Wrong alignment on FClientMsgShopEnterGiftCodeResponse");
static_assert(sizeof(FClientMsgShopEnterGiftCodeResponse) == 0x000030, "Wrong size on FClientMsgShopEnterGiftCodeResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopRedStoneShardInfoResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgShopRedStoneShardInfoResponse final : public FMsgBase
{
public:
	uint8                                         Pad_21FE[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopRedStoneShardInfoResponse) == 0x000008, "Wrong alignment on FClientMsgShopRedStoneShardInfoResponse");
static_assert(sizeof(FClientMsgShopRedStoneShardInfoResponse) == 0x000030, "Wrong size on FClientMsgShopRedStoneShardInfoResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopRedStoneShardBuyRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgShopRedStoneShardBuyRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_21FF[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopRedStoneShardBuyRequest) == 0x000008, "Wrong alignment on FClientMsgShopRedStoneShardBuyRequest");
static_assert(sizeof(FClientMsgShopRedStoneShardBuyRequest) == 0x000028, "Wrong size on FClientMsgShopRedStoneShardBuyRequest");

// ScriptStruct DungeonCrawler.ClientMsgShopRedStoneShardBuyResponse
// 0x0050 (0x0068 - 0x0018)
struct FClientMsgShopRedStoneShardBuyResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2200[0x50];                                    // 0x0018(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopRedStoneShardBuyResponse) == 0x000008, "Wrong alignment on FClientMsgShopRedStoneShardBuyResponse");
static_assert(sizeof(FClientMsgShopRedStoneShardBuyResponse) == 0x000068, "Wrong size on FClientMsgShopRedStoneShardBuyResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopRedStoneShardBuyCheckResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgShopRedStoneShardBuyCheckResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2201[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopRedStoneShardBuyCheckResponse) == 0x000008, "Wrong alignment on FClientMsgShopRedStoneShardBuyCheckResponse");
static_assert(sizeof(FClientMsgShopRedStoneShardBuyCheckResponse) == 0x000020, "Wrong size on FClientMsgShopRedStoneShardBuyCheckResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopLegendUpgradeResponse
// 0x0028 (0x0040 - 0x0018)
struct FClientMsgShopLegendUpgradeResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2202[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopLegendUpgradeResponse) == 0x000008, "Wrong alignment on FClientMsgShopLegendUpgradeResponse");
static_assert(sizeof(FClientMsgShopLegendUpgradeResponse) == 0x000040, "Wrong size on FClientMsgShopLegendUpgradeResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopChangeAccountNameRequest
// 0x0010 (0x0030 - 0x0020)
struct FClientMsgShopChangeAccountNameRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2203[0x10];                                    // 0x0020(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopChangeAccountNameRequest) == 0x000008, "Wrong alignment on FClientMsgShopChangeAccountNameRequest");
static_assert(sizeof(FClientMsgShopChangeAccountNameRequest) == 0x000030, "Wrong size on FClientMsgShopChangeAccountNameRequest");

// ScriptStruct DungeonCrawler.ClientMsgShopChangeAccountNameResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgShopChangeAccountNameResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2204[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopChangeAccountNameResponse) == 0x000008, "Wrong alignment on FClientMsgShopChangeAccountNameResponse");
static_assert(sizeof(FClientMsgShopChangeAccountNameResponse) == 0x000030, "Wrong size on FClientMsgShopChangeAccountNameResponse");

// ScriptStruct DungeonCrawler.MsgWidgetHitDirectionHealingNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetHitDirectionHealingNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetHitDirectionHealingNotify) == 0x000008, "Wrong alignment on FMsgWidgetHitDirectionHealingNotify");
static_assert(sizeof(FMsgWidgetHitDirectionHealingNotify) == 0x000018, "Wrong size on FMsgWidgetHitDirectionHealingNotify");

// ScriptStruct DungeonCrawler.ClientMsgShopLegendDlcInstallRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgShopLegendDlcInstallRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2205[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopLegendDlcInstallRequest) == 0x000008, "Wrong alignment on FClientMsgShopLegendDlcInstallRequest");
static_assert(sizeof(FClientMsgShopLegendDlcInstallRequest) == 0x000028, "Wrong size on FClientMsgShopLegendDlcInstallRequest");

// ScriptStruct DungeonCrawler.ClientMsgShopLegendDlcInstallResponse
// 0x0070 (0x0088 - 0x0018)
struct FClientMsgShopLegendDlcInstallResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2206[0x70];                                    // 0x0018(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopLegendDlcInstallResponse) == 0x000008, "Wrong alignment on FClientMsgShopLegendDlcInstallResponse");
static_assert(sizeof(FClientMsgShopLegendDlcInstallResponse) == 0x000088, "Wrong size on FClientMsgShopLegendDlcInstallResponse");

// ScriptStruct DungeonCrawler.ClientMsgShopLegendDlcInstallCheckResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgShopLegendDlcInstallCheckResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2207[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopLegendDlcInstallCheckResponse) == 0x000008, "Wrong alignment on FClientMsgShopLegendDlcInstallCheckResponse");
static_assert(sizeof(FClientMsgShopLegendDlcInstallCheckResponse) == 0x000020, "Wrong size on FClientMsgShopLegendDlcInstallCheckResponse");

// ScriptStruct DungeonCrawler.MsgWidgetInitCrossHairNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetInitCrossHairNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetInitCrossHairNotify) == 0x000008, "Wrong alignment on FMsgWidgetInitCrossHairNotify");
static_assert(sizeof(FMsgWidgetInitCrossHairNotify) == 0x000018, "Wrong size on FMsgWidgetInitCrossHairNotify");

// ScriptStruct DungeonCrawler.ClientMsgShopTwitchDropsRewardNotify
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgShopTwitchDropsRewardNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2208[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgShopTwitchDropsRewardNotify) == 0x000008, "Wrong alignment on FClientMsgShopTwitchDropsRewardNotify");
static_assert(sizeof(FClientMsgShopTwitchDropsRewardNotify) == 0x000030, "Wrong size on FClientMsgShopTwitchDropsRewardNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradeChannelListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2209[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelListRequest) == 0x000008, "Wrong alignment on FClientMsgTradeChannelListRequest");
static_assert(sizeof(FClientMsgTradeChannelListRequest) == 0x000028, "Wrong size on FClientMsgTradeChannelListRequest");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelSelectRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradeChannelSelectRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_220A[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelSelectRequest) == 0x000008, "Wrong alignment on FClientMsgTradeChannelSelectRequest");
static_assert(sizeof(FClientMsgTradeChannelSelectRequest) == 0x000028, "Wrong size on FClientMsgTradeChannelSelectRequest");

// ScriptStruct DungeonCrawler.MsgWidgetOnActivateSpellCrossHairNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetOnActivateSpellCrossHairNotify final : public FMsgBase
{
public:
	uint8                                         Pad_220B[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetOnActivateSpellCrossHairNotify) == 0x000008, "Wrong alignment on FMsgWidgetOnActivateSpellCrossHairNotify");
static_assert(sizeof(FMsgWidgetOnActivateSpellCrossHairNotify) == 0x000020, "Wrong size on FMsgWidgetOnActivateSpellCrossHairNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelSelectResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTradeChannelSelectResponse final : public FMsgBase
{
public:
	uint8                                         Pad_220C[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelSelectResponse) == 0x000008, "Wrong alignment on FClientMsgTradeChannelSelectResponse");
static_assert(sizeof(FClientMsgTradeChannelSelectResponse) == 0x000020, "Wrong size on FClientMsgTradeChannelSelectResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelExitRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradeChannelExitRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_220D[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelExitRequest) == 0x000008, "Wrong alignment on FClientMsgTradeChannelExitRequest");
static_assert(sizeof(FClientMsgTradeChannelExitRequest) == 0x000028, "Wrong size on FClientMsgTradeChannelExitRequest");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelUserListRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradeChannelUserListRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_220E[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelUserListRequest) == 0x000008, "Wrong alignment on FClientMsgTradeChannelUserListRequest");
static_assert(sizeof(FClientMsgTradeChannelUserListRequest) == 0x000028, "Wrong size on FClientMsgTradeChannelUserListRequest");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelUserUpdateNotify
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgTradeChannelUserUpdateNotify final : public FMsgBase
{
public:
	uint8                                         Pad_220F[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelUserUpdateNotify) == 0x000008, "Wrong alignment on FClientMsgTradeChannelUserUpdateNotify");
static_assert(sizeof(FClientMsgTradeChannelUserUpdateNotify) == 0x000028, "Wrong size on FClientMsgTradeChannelUserUpdateNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelChatResponse
// 0x0018 (0x0030 - 0x0018)
struct FClientMsgTradeChannelChatResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2210[0x18];                                    // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelChatResponse) == 0x000008, "Wrong alignment on FClientMsgTradeChannelChatResponse");
static_assert(sizeof(FClientMsgTradeChannelChatResponse) == 0x000030, "Wrong size on FClientMsgTradeChannelChatResponse");

// ScriptStruct DungeonCrawler.MsgWidgetClassSpellBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassSpellBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassSpellBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSpellBeginNotify");
static_assert(sizeof(FMsgWidgetClassSpellBeginNotify) == 0x000018, "Wrong size on FMsgWidgetClassSpellBeginNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelChatTextRangeRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradeChannelChatTextRangeRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2211[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelChatTextRangeRequest) == 0x000008, "Wrong alignment on FClientMsgTradeChannelChatTextRangeRequest");
static_assert(sizeof(FClientMsgTradeChannelChatTextRangeRequest) == 0x000028, "Wrong size on FClientMsgTradeChannelChatTextRangeRequest");

// ScriptStruct DungeonCrawler.ClientMsgTradeChannelChatTextRangeResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgTradeChannelChatTextRangeResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2212[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeChannelChatTextRangeResponse) == 0x000008, "Wrong alignment on FClientMsgTradeChannelChatTextRangeResponse");
static_assert(sizeof(FClientMsgTradeChannelChatTextRangeResponse) == 0x000028, "Wrong size on FClientMsgTradeChannelChatTextRangeResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradeMembershipRequirementResponse
// 0x0010 (0x0028 - 0x0018)
struct FClientMsgTradeMembershipRequirementResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2213[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeMembershipRequirementResponse) == 0x000008, "Wrong alignment on FClientMsgTradeMembershipRequirementResponse");
static_assert(sizeof(FClientMsgTradeMembershipRequirementResponse) == 0x000028, "Wrong size on FClientMsgTradeMembershipRequirementResponse");

// ScriptStruct DungeonCrawler.MusicData
// 0x0024 (0x0024 - 0x0000)
struct FMusicData final
{
public:
	struct FPrimaryAssetId                        MusicId;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MusicTag;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SequenceIndex;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCapacityOverloaded;                             // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProperItemEquipped;                               // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2214[0x2];                                     // 0x0022(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMusicData) == 0x000004, "Wrong alignment on FMusicData");
static_assert(sizeof(FMusicData) == 0x000024, "Wrong size on FMusicData");
static_assert(offsetof(FMusicData, MusicId) == 0x000000, "Member 'FMusicData::MusicId' has a wrong offset!");
static_assert(offsetof(FMusicData, MusicTag) == 0x000010, "Member 'FMusicData::MusicTag' has a wrong offset!");
static_assert(offsetof(FMusicData, SlotIndex) == 0x000018, "Member 'FMusicData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FMusicData, SequenceIndex) == 0x00001C, "Member 'FMusicData::SequenceIndex' has a wrong offset!");
static_assert(offsetof(FMusicData, bIsCapacityOverloaded) == 0x000020, "Member 'FMusicData::bIsCapacityOverloaded' has a wrong offset!");
static_assert(offsetof(FMusicData, bProperItemEquipped) == 0x000021, "Member 'FMusicData::bProperItemEquipped' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassMusicEquippedListNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassMusicEquippedListNotify final : public FMsgBase
{
public:
	TArray<struct FMusicData>                     MusicArray;                                        // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassMusicEquippedListNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassMusicEquippedListNotify");
static_assert(sizeof(FMsgWidgetClassMusicEquippedListNotify) == 0x000028, "Wrong size on FMsgWidgetClassMusicEquippedListNotify");
static_assert(offsetof(FMsgWidgetClassMusicEquippedListNotify, MusicArray) == 0x000018, "Member 'FMsgWidgetClassMusicEquippedListNotify::MusicArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTradeMembershipRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradeMembershipRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2215[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeMembershipRequest) == 0x000008, "Wrong alignment on FClientMsgTradeMembershipRequest");
static_assert(sizeof(FClientMsgTradeMembershipRequest) == 0x000028, "Wrong size on FClientMsgTradeMembershipRequest");

// ScriptStruct DungeonCrawler.ClientMsgTradeMembershipResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTradeMembershipResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2216[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeMembershipResponse) == 0x000008, "Wrong alignment on FClientMsgTradeMembershipResponse");
static_assert(sizeof(FClientMsgTradeMembershipResponse) == 0x000020, "Wrong size on FClientMsgTradeMembershipResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradeRequestResponse
// 0x0048 (0x0060 - 0x0018)
struct FClientMsgTradeRequestResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2217[0x48];                                    // 0x0018(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeRequestResponse) == 0x000008, "Wrong alignment on FClientMsgTradeRequestResponse");
static_assert(sizeof(FClientMsgTradeRequestResponse) == 0x000060, "Wrong size on FClientMsgTradeRequestResponse");

// ScriptStruct DungeonCrawler.MsgWidgetClassItemMoveRequestNotify
// 0x0040 (0x0058 - 0x0018)
struct FMsgWidgetClassItemMoveRequestNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2218[0x40];                                    // 0x0018(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassItemMoveRequestNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassItemMoveRequestNotify");
static_assert(sizeof(FMsgWidgetClassItemMoveRequestNotify) == 0x000058, "Wrong size on FMsgWidgetClassItemMoveRequestNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradeRequestNotify
// 0x0050 (0x0068 - 0x0018)
struct FClientMsgTradeRequestNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2219[0x50];                                    // 0x0018(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeRequestNotify) == 0x000008, "Wrong alignment on FClientMsgTradeRequestNotify");
static_assert(sizeof(FClientMsgTradeRequestNotify) == 0x000068, "Wrong size on FClientMsgTradeRequestNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradeAnswerRequest
// 0x0058 (0x0078 - 0x0020)
struct FClientMsgTradeAnswerRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_221A[0x58];                                    // 0x0020(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeAnswerRequest) == 0x000008, "Wrong alignment on FClientMsgTradeAnswerRequest");
static_assert(sizeof(FClientMsgTradeAnswerRequest) == 0x000078, "Wrong size on FClientMsgTradeAnswerRequest");

// ScriptStruct DungeonCrawler.ClientMsgTradeAnswerRefusalNotify
// 0x0050 (0x0068 - 0x0018)
struct FClientMsgTradeAnswerRefusalNotify final : public FMsgBase
{
public:
	uint8                                         Pad_221B[0x50];                                    // 0x0018(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradeAnswerRefusalNotify) == 0x000008, "Wrong alignment on FClientMsgTradeAnswerRefusalNotify");
static_assert(sizeof(FClientMsgTradeAnswerRefusalNotify) == 0x000068, "Wrong size on FClientMsgTradeAnswerRefusalNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassMusicSlotMoveRequestNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassMusicSlotMoveRequestNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        MusicId;                                           // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221C[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassMusicSlotMoveRequestNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassMusicSlotMoveRequestNotify");
static_assert(sizeof(FMsgWidgetClassMusicSlotMoveRequestNotify) == 0x000030, "Wrong size on FMsgWidgetClassMusicSlotMoveRequestNotify");
static_assert(offsetof(FMsgWidgetClassMusicSlotMoveRequestNotify, Index) == 0x000018, "Member 'FMsgWidgetClassMusicSlotMoveRequestNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassMusicSlotMoveRequestNotify, MusicId) == 0x00001C, "Member 'FMsgWidgetClassMusicSlotMoveRequestNotify::MusicId' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTradingBeginNotify
// 0x00A8 (0x00C0 - 0x0018)
struct FClientMsgTradingBeginNotify final : public FMsgBase
{
public:
	uint8                                         Pad_221D[0xA8];                                    // 0x0018(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingBeginNotify) == 0x000008, "Wrong alignment on FClientMsgTradingBeginNotify");
static_assert(sizeof(FClientMsgTradingBeginNotify) == 0x0000C0, "Wrong size on FClientMsgTradingBeginNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradingCloseRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradingCloseRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_221E[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingCloseRequest) == 0x000008, "Wrong alignment on FClientMsgTradingCloseRequest");
static_assert(sizeof(FClientMsgTradingCloseRequest) == 0x000028, "Wrong size on FClientMsgTradingCloseRequest");

// ScriptStruct DungeonCrawler.ClientMsgTradingChatRequest
// 0x00A8 (0x00C8 - 0x0020)
struct FClientMsgTradingChatRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_221F[0xA8];                                    // 0x0020(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingChatRequest) == 0x000008, "Wrong alignment on FClientMsgTradingChatRequest");
static_assert(sizeof(FClientMsgTradingChatRequest) == 0x0000C8, "Wrong size on FClientMsgTradingChatRequest");

// ScriptStruct DungeonCrawler.CharacterPartyInfoWidget
// 0x00B8 (0x00B8 - 0x0000)
struct FCharacterPartyInfoWidget final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0010(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 CharacterClass;                                    // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gender;                                            // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsPartyLeader;                                     // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsReady;                                           // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsInGame;                                          // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2220[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAccountDataItem>               EquipItemList;                                     // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PartyIdx;                                          // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2221[0x4];                                     // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAccountDataPerk>               Perks;                                             // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         GearScore;                                         // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2222[0x4];                                     // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterPartyInfoWidget) == 0x000008, "Wrong alignment on FCharacterPartyInfoWidget");
static_assert(sizeof(FCharacterPartyInfoWidget) == 0x0000B8, "Wrong size on FCharacterPartyInfoWidget");
static_assert(offsetof(FCharacterPartyInfoWidget, AccountId) == 0x000000, "Member 'FCharacterPartyInfoWidget::AccountId' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, Nickname) == 0x000010, "Member 'FCharacterPartyInfoWidget::Nickname' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, CharacterClass) == 0x000050, "Member 'FCharacterPartyInfoWidget::CharacterClass' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, CharacterId) == 0x000060, "Member 'FCharacterPartyInfoWidget::CharacterId' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, Gender) == 0x000070, "Member 'FCharacterPartyInfoWidget::Gender' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, Level) == 0x000074, "Member 'FCharacterPartyInfoWidget::Level' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, IsPartyLeader) == 0x000078, "Member 'FCharacterPartyInfoWidget::IsPartyLeader' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, IsReady) == 0x00007C, "Member 'FCharacterPartyInfoWidget::IsReady' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, IsInGame) == 0x000080, "Member 'FCharacterPartyInfoWidget::IsInGame' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, EquipItemList) == 0x000088, "Member 'FCharacterPartyInfoWidget::EquipItemList' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, PartyIdx) == 0x000098, "Member 'FCharacterPartyInfoWidget::PartyIdx' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, Perks) == 0x0000A0, "Member 'FCharacterPartyInfoWidget::Perks' has a wrong offset!");
static_assert(offsetof(FCharacterPartyInfoWidget, GearScore) == 0x0000B0, "Member 'FCharacterPartyInfoWidget::GearScore' has a wrong offset!");

// ScriptStruct DungeonCrawler.PlayPartyUserInfo
// 0x00C0 (0x00C0 - 0x0000)
struct FPlayPartyUserInfo final
{
public:
	EWidgetPlayUserPartyState                     PartyState;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWidgetPartyUserLocate                        WidgetLocate;                                      // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2223[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterPartyInfoWidget              PartyCharacterInfo;                                // 0x0008(0x00B8)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayPartyUserInfo) == 0x000008, "Wrong alignment on FPlayPartyUserInfo");
static_assert(sizeof(FPlayPartyUserInfo) == 0x0000C0, "Wrong size on FPlayPartyUserInfo");
static_assert(offsetof(FPlayPartyUserInfo, PartyState) == 0x000000, "Member 'FPlayPartyUserInfo::PartyState' has a wrong offset!");
static_assert(offsetof(FPlayPartyUserInfo, WidgetLocate) == 0x000001, "Member 'FPlayPartyUserInfo::WidgetLocate' has a wrong offset!");
static_assert(offsetof(FPlayPartyUserInfo, PartyCharacterInfo) == 0x000008, "Member 'FPlayPartyUserInfo::PartyCharacterInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgTradingChatResponse
// 0x00A0 (0x00B8 - 0x0018)
struct FClientMsgTradingChatResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2224[0xA0];                                    // 0x0018(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingChatResponse) == 0x000008, "Wrong alignment on FClientMsgTradingChatResponse");
static_assert(sizeof(FClientMsgTradingChatResponse) == 0x0000B8, "Wrong size on FClientMsgTradingChatResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradingItemUpdateRequest
// 0x0018 (0x0038 - 0x0020)
struct FClientMsgTradingItemUpdateRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2225[0x18];                                    // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingItemUpdateRequest) == 0x000008, "Wrong alignment on FClientMsgTradingItemUpdateRequest");
static_assert(sizeof(FClientMsgTradingItemUpdateRequest) == 0x000038, "Wrong size on FClientMsgTradingItemUpdateRequest");

// ScriptStruct DungeonCrawler.MsgWidgetLoadoutBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetLoadoutBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetLoadoutBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetLoadoutBeginNotify");
static_assert(sizeof(FMsgWidgetLoadoutBeginNotify) == 0x000018, "Wrong size on FMsgWidgetLoadoutBeginNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradingReadyResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTradingReadyResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2226[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingReadyResponse) == 0x000008, "Wrong alignment on FClientMsgTradingReadyResponse");
static_assert(sizeof(FClientMsgTradingReadyResponse) == 0x000020, "Wrong size on FClientMsgTradingReadyResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradingReadyNotify
// 0x0058 (0x0070 - 0x0018)
struct FClientMsgTradingReadyNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2227[0x58];                                    // 0x0018(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingReadyNotify) == 0x000008, "Wrong alignment on FClientMsgTradingReadyNotify");
static_assert(sizeof(FClientMsgTradingReadyNotify) == 0x000070, "Wrong size on FClientMsgTradingReadyNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradingConfirmNotify
// 0x00C0 (0x00D8 - 0x0018)
struct FClientMsgTradingConfirmNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2228[0xC0];                                    // 0x0018(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingConfirmNotify) == 0x000008, "Wrong alignment on FClientMsgTradingConfirmNotify");
static_assert(sizeof(FClientMsgTradingConfirmNotify) == 0x0000D8, "Wrong size on FClientMsgTradingConfirmNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradingConfirmReadyRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgTradingConfirmReadyRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_2229[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingConfirmReadyRequest) == 0x000008, "Wrong alignment on FClientMsgTradingConfirmReadyRequest");
static_assert(sizeof(FClientMsgTradingConfirmReadyRequest) == 0x000028, "Wrong size on FClientMsgTradingConfirmReadyRequest");

// ScriptStruct DungeonCrawler.MsgWidgetStorageBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetStorageBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetStorageBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetStorageBeginNotify");
static_assert(sizeof(FMsgWidgetStorageBeginNotify) == 0x000018, "Wrong size on FMsgWidgetStorageBeginNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradingConfirmReadyResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTradingConfirmReadyResponse final : public FMsgBase
{
public:
	uint8                                         Pad_222A[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingConfirmReadyResponse) == 0x000008, "Wrong alignment on FClientMsgTradingConfirmReadyResponse");
static_assert(sizeof(FClientMsgTradingConfirmReadyResponse) == 0x000020, "Wrong size on FClientMsgTradingConfirmReadyResponse");

// ScriptStruct DungeonCrawler.ClientMsgTradingConfirmReadyNotify
// 0x0058 (0x0070 - 0x0018)
struct FClientMsgTradingConfirmReadyNotify final : public FMsgBase
{
public:
	uint8                                         Pad_222B[0x58];                                    // 0x0018(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingConfirmReadyNotify) == 0x000008, "Wrong alignment on FClientMsgTradingConfirmReadyNotify");
static_assert(sizeof(FClientMsgTradingConfirmReadyNotify) == 0x000070, "Wrong size on FClientMsgTradingConfirmReadyNotify");

// ScriptStruct DungeonCrawler.MsgWidgetMerchantListBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetMerchantListBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetMerchantListBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetMerchantListBeginNotify");
static_assert(sizeof(FMsgWidgetMerchantListBeginNotify) == 0x000018, "Wrong size on FMsgWidgetMerchantListBeginNotify");

// ScriptStruct DungeonCrawler.ClientMsgTradingResultNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgTradingResultNotify final : public FMsgBase
{
public:
	uint8                                         Pad_222C[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgTradingResultNotify) == 0x000008, "Wrong alignment on FClientMsgTradingResultNotify");
static_assert(sizeof(FClientMsgTradingResultNotify) == 0x000020, "Wrong size on FClientMsgTradingResultNotify");

// ScriptStruct DungeonCrawler.ClientMsgAliveRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgAliveRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_222D[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAliveRequest) == 0x000008, "Wrong alignment on FClientMsgAliveRequest");
static_assert(sizeof(FClientMsgAliveRequest) == 0x000028, "Wrong size on FClientMsgAliveRequest");

// ScriptStruct DungeonCrawler.ClientMsgAliveResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgAliveResponse final : public FMsgBase
{
public:
	uint8                                         Pad_222E[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAliveResponse) == 0x000008, "Wrong alignment on FClientMsgAliveResponse");
static_assert(sizeof(FClientMsgAliveResponse) == 0x000020, "Wrong size on FClientMsgAliveResponse");

// ScriptStruct DungeonCrawler.ClientMsgReconnectRequest
// 0x0008 (0x0028 - 0x0020)
struct FClientMsgReconnectRequest final : public FRequestMsg
{
public:
	uint8                                         Pad_222F[0x8];                                     // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReconnectRequest) == 0x000008, "Wrong alignment on FClientMsgReconnectRequest");
static_assert(sizeof(FClientMsgReconnectRequest) == 0x000028, "Wrong size on FClientMsgReconnectRequest");

// ScriptStruct DungeonCrawler.VoipPartyMemberData
// 0x0050 (0x0050 - 0x0000)
struct FVoipPartyMemberData final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0010(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoipPartyMemberData) == 0x000008, "Wrong alignment on FVoipPartyMemberData");
static_assert(sizeof(FVoipPartyMemberData) == 0x000050, "Wrong size on FVoipPartyMemberData");
static_assert(offsetof(FVoipPartyMemberData, AccountId) == 0x000000, "Member 'FVoipPartyMemberData::AccountId' has a wrong offset!");
static_assert(offsetof(FVoipPartyMemberData, Nickname) == 0x000010, "Member 'FVoipPartyMemberData::Nickname' has a wrong offset!");

// ScriptStruct DungeonCrawler.VoipPartyData
// 0x0020 (0x0020 - 0x0000)
struct FVoipPartyData final
{
public:
	struct FDCPartyId                             PartyId;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVoipPartyMemberData>           VoipPartyMemberDataArray;                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoipPartyData) == 0x000008, "Wrong alignment on FVoipPartyData");
static_assert(sizeof(FVoipPartyData) == 0x000020, "Wrong size on FVoipPartyData");
static_assert(offsetof(FVoipPartyData, PartyId) == 0x000000, "Member 'FVoipPartyData::PartyId' has a wrong offset!");
static_assert(offsetof(FVoipPartyData, VoipPartyMemberDataArray) == 0x000010, "Member 'FVoipPartyData::VoipPartyMemberDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ClientMsgReconnectResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgReconnectResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2230[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgReconnectResponse) == 0x000008, "Wrong alignment on FClientMsgReconnectResponse");
static_assert(sizeof(FClientMsgReconnectResponse) == 0x000020, "Wrong size on FClientMsgReconnectResponse");

// ScriptStruct DungeonCrawler.ClientMsgAliveReverseNotify
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgAliveReverseNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2231[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAliveReverseNotify) == 0x000008, "Wrong alignment on FClientMsgAliveReverseNotify");
static_assert(sizeof(FClientMsgAliveReverseNotify) == 0x000020, "Wrong size on FClientMsgAliveReverseNotify");

// ScriptStruct DungeonCrawler.ClientMsgAliveReverseResponse
// 0x0008 (0x0020 - 0x0018)
struct FClientMsgAliveReverseResponse final : public FMsgBase
{
public:
	uint8                                         Pad_2232[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientMsgAliveReverseResponse) == 0x000008, "Wrong alignment on FClientMsgAliveReverseResponse");
static_assert(sizeof(FClientMsgAliveReverseResponse) == 0x000020, "Wrong size on FClientMsgAliveReverseResponse");

// ScriptStruct DungeonCrawler.MsgWidgetEnterCreateCharacterPageNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetEnterCreateCharacterPageNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetEnterCreateCharacterPageNotify) == 0x000008, "Wrong alignment on FMsgWidgetEnterCreateCharacterPageNotify");
static_assert(sizeof(FMsgWidgetEnterCreateCharacterPageNotify) == 0x000018, "Wrong size on FMsgWidgetEnterCreateCharacterPageNotify");

// ScriptStruct DungeonCrawler.ClientShopItemListBuildData
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FClientShopItemListBuildData final
{
public:
	uint8                                         Pad_2233[0x80];                                    // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientShopItemListBuildData) == 0x000008, "Wrong alignment on FClientShopItemListBuildData");
static_assert(sizeof(FClientShopItemListBuildData) == 0x000080, "Wrong size on FClientShopItemListBuildData");

// ScriptStruct DungeonCrawler.DCClientShopSimpleInfo
// 0x0001 (0x0001 - 0x0000)
struct FDCClientShopSimpleInfo final
{
public:
	EDCShopState                                  ShopState;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCClientShopSimpleInfo) == 0x000001, "Wrong alignment on FDCClientShopSimpleInfo");
static_assert(sizeof(FDCClientShopSimpleInfo) == 0x000001, "Wrong size on FDCClientShopSimpleInfo");
static_assert(offsetof(FDCClientShopSimpleInfo, ShopState) == 0x000000, "Member 'FDCClientShopSimpleInfo::ShopState' has a wrong offset!");

// ScriptStruct DungeonCrawler.PopupSWidgetData
// 0x0020 (0x0020 - 0x0000)
struct FPopupSWidgetData final
{
public:
	EPopupButtonType                              PopupButtonType;                                   // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2234[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DescMessage;                                       // 0x0008(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPopupSWidgetData) == 0x000008, "Wrong alignment on FPopupSWidgetData");
static_assert(sizeof(FPopupSWidgetData) == 0x000020, "Wrong size on FPopupSWidgetData");
static_assert(offsetof(FPopupSWidgetData, PopupButtonType) == 0x000000, "Member 'FPopupSWidgetData::PopupButtonType' has a wrong offset!");
static_assert(offsetof(FPopupSWidgetData, DescMessage) == 0x000008, "Member 'FPopupSWidgetData::DescMessage' has a wrong offset!");

// ScriptStruct DungeonCrawler.ContainerSlotArrayData
// 0x0010 (0x0010 - 0x0000)
struct FContainerSlotArrayData final
{
public:
	TArray<class UContainerSlotWidget*>           SlotWidgetArray;                                   // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContainerSlotArrayData) == 0x000008, "Wrong alignment on FContainerSlotArrayData");
static_assert(sizeof(FContainerSlotArrayData) == 0x000010, "Wrong size on FContainerSlotArrayData");
static_assert(offsetof(FContainerSlotArrayData, SlotWidgetArray) == 0x000000, "Member 'FContainerSlotArrayData::SlotWidgetArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetUpdatePageNumberNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetUpdatePageNumberNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2235[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetUpdatePageNumberNotify) == 0x000008, "Wrong alignment on FMsgWidgetUpdatePageNumberNotify");
static_assert(sizeof(FMsgWidgetUpdatePageNumberNotify) == 0x000020, "Wrong size on FMsgWidgetUpdatePageNumberNotify");

// ScriptStruct DungeonCrawler.DCPrice
// 0x0008 (0x0008 - 0x0000)
struct FDCPrice final
{
public:
	EDCCurrencyType                               Type;                                              // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2236[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCPrice) == 0x000004, "Wrong alignment on FDCPrice");
static_assert(sizeof(FDCPrice) == 0x000008, "Wrong size on FDCPrice");
static_assert(offsetof(FDCPrice, Type) == 0x000000, "Member 'FDCPrice::Type' has a wrong offset!");
static_assert(offsetof(FDCPrice, Value) == 0x000004, "Member 'FDCPrice::Value' has a wrong offset!");

// ScriptStruct DungeonCrawler.GameplayEffectDescData
// 0x000C (0x000C - 0x0000)
struct FGameplayEffectDescData final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectValue;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectDescData) == 0x000004, "Wrong alignment on FGameplayEffectDescData");
static_assert(sizeof(FGameplayEffectDescData) == 0x00000C, "Wrong size on FGameplayEffectDescData");
static_assert(offsetof(FGameplayEffectDescData, GameplayTag) == 0x000000, "Member 'FGameplayEffectDescData::GameplayTag' has a wrong offset!");
static_assert(offsetof(FGameplayEffectDescData, EffectValue) == 0x000008, "Member 'FGameplayEffectDescData::EffectValue' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetGameGroupToggleRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetGameGroupToggleRequest final : public FMsgBase
{
public:
	EWidgetGameGroupType                          WidgetGameGroupType;                               // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2237[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetGameGroupToggleRequest) == 0x000008, "Wrong alignment on FMsgWidgetGameGroupToggleRequest");
static_assert(sizeof(FMsgWidgetGameGroupToggleRequest) == 0x000020, "Wrong size on FMsgWidgetGameGroupToggleRequest");
static_assert(offsetof(FMsgWidgetGameGroupToggleRequest, WidgetGameGroupType) == 0x000018, "Member 'FMsgWidgetGameGroupToggleRequest::WidgetGameGroupType' has a wrong offset!");

// ScriptStruct DungeonCrawler.ActorDieData
// 0x06D0 (0x06D0 - 0x0000)
struct FActorDieData final
{
public:
	bool                                          bAlive;                                            // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRigid;                                            // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2238[0x6];                                     // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0010(0x0420)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0430(0x0298)(BlueprintVisible, NativeAccessSpecifierPublic)
	EDCKillReason                                 KillReason;                                        // 0x06C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2239[0x7];                                     // 0x06C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActorDieData) == 0x000008, "Wrong alignment on FActorDieData");
static_assert(sizeof(FActorDieData) == 0x0006D0, "Wrong size on FActorDieData");
static_assert(offsetof(FActorDieData, bAlive) == 0x000000, "Member 'FActorDieData::bAlive' has a wrong offset!");
static_assert(offsetof(FActorDieData, bRigid) == 0x000001, "Member 'FActorDieData::bRigid' has a wrong offset!");
static_assert(offsetof(FActorDieData, GameplayEffectClass) == 0x000008, "Member 'FActorDieData::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FActorDieData, EffectContext) == 0x000010, "Member 'FActorDieData::EffectContext' has a wrong offset!");
static_assert(offsetof(FActorDieData, EffectSpec) == 0x000430, "Member 'FActorDieData::EffectSpec' has a wrong offset!");
static_assert(offsetof(FActorDieData, KillReason) == 0x0006C8, "Member 'FActorDieData::KillReason' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryEventDataCache
// 0x01A0 (0x01A0 - 0x0000)
struct FDCInventoryEventDataCache final
{
public:
	uint8                                         Pad_223A[0x18];                                    // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCInventoryEventData                  Data;                                              // 0x0018(0x0188)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCInventoryEventDataCache) == 0x000008, "Wrong alignment on FDCInventoryEventDataCache");
static_assert(sizeof(FDCInventoryEventDataCache) == 0x0001A0, "Wrong size on FDCInventoryEventDataCache");
static_assert(offsetof(FDCInventoryEventDataCache, Data) == 0x000018, "Member 'FDCInventoryEventDataCache::Data' has a wrong offset!");

// ScriptStruct DungeonCrawler.ImpactEnduranceExhaustedData
// 0x06C8 (0x06C8 - 0x0000)
struct FImpactEnduranceExhaustedData final
{
public:
	bool                                          bExhausted;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_223B[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExhaustedTime;                                     // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0010(0x0420)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0430(0x0298)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactEnduranceExhaustedData) == 0x000008, "Wrong alignment on FImpactEnduranceExhaustedData");
static_assert(sizeof(FImpactEnduranceExhaustedData) == 0x0006C8, "Wrong size on FImpactEnduranceExhaustedData");
static_assert(offsetof(FImpactEnduranceExhaustedData, bExhausted) == 0x000000, "Member 'FImpactEnduranceExhaustedData::bExhausted' has a wrong offset!");
static_assert(offsetof(FImpactEnduranceExhaustedData, ExhaustedTime) == 0x000004, "Member 'FImpactEnduranceExhaustedData::ExhaustedTime' has a wrong offset!");
static_assert(offsetof(FImpactEnduranceExhaustedData, GameplayEffectClass) == 0x000008, "Member 'FImpactEnduranceExhaustedData::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FImpactEnduranceExhaustedData, EffectContext) == 0x000010, "Member 'FImpactEnduranceExhaustedData::EffectContext' has a wrong offset!");
static_assert(offsetof(FImpactEnduranceExhaustedData, EffectSpec) == 0x000430, "Member 'FImpactEnduranceExhaustedData::EffectSpec' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradeRequestSelected
// 0x0090 (0x00A8 - 0x0018)
struct FMsgWidgetTradeRequestSelected final : public FMsgBase
{
public:
	uint8                                         Pad_223C[0x90];                                    // 0x0018(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetTradeRequestSelected) == 0x000008, "Wrong alignment on FMsgWidgetTradeRequestSelected");
static_assert(sizeof(FMsgWidgetTradeRequestSelected) == 0x0000A8, "Wrong size on FMsgWidgetTradeRequestSelected");

// ScriptStruct DungeonCrawler.DCGameplayAbilityHandleData
// 0x0030 (0x0030 - 0x0000)
struct FDCGameplayAbilityHandleData final
{
public:
	struct FGameplayAbilitySpecHandle             AbilitySpecHandle;                                 // 0x0000(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_223D[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCGameplayAbilityData                 GameplayAbilityData;                               // 0x0008(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCGameplayAbilityHandleData) == 0x000008, "Wrong alignment on FDCGameplayAbilityHandleData");
static_assert(sizeof(FDCGameplayAbilityHandleData) == 0x000030, "Wrong size on FDCGameplayAbilityHandleData");
static_assert(offsetof(FDCGameplayAbilityHandleData, AbilitySpecHandle) == 0x000000, "Member 'FDCGameplayAbilityHandleData::AbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(FDCGameplayAbilityHandleData, GameplayAbilityData) == 0x000008, "Member 'FDCGameplayAbilityHandleData::GameplayAbilityData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCGameplayEffectContainerSpec
// 0x0048 (0x0048 - 0x0000)
struct FDCGameplayEffectContainerSpec final
{
public:
	TSubclassOf<class UDCTargetType>              TargetType;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAbilityTargetDataHandle       TargetDataHandle;                                  // 0x0008(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectSpecHandle>      TargetGameplayEffectSpecHandles;                   // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ContainerTag;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCGameplayEffectContainerSpec) == 0x000008, "Wrong alignment on FDCGameplayEffectContainerSpec");
static_assert(sizeof(FDCGameplayEffectContainerSpec) == 0x000048, "Wrong size on FDCGameplayEffectContainerSpec");
static_assert(offsetof(FDCGameplayEffectContainerSpec, TargetType) == 0x000000, "Member 'FDCGameplayEffectContainerSpec::TargetType' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContainerSpec, TargetDataHandle) == 0x000008, "Member 'FDCGameplayEffectContainerSpec::TargetDataHandle' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContainerSpec, TargetGameplayEffectSpecHandles) == 0x000030, "Member 'FDCGameplayEffectContainerSpec::TargetGameplayEffectSpecHandles' has a wrong offset!");
static_assert(offsetof(FDCGameplayEffectContainerSpec, ContainerTag) == 0x000040, "Member 'FDCGameplayEffectContainerSpec::ContainerTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradeConfirmBeginNotify
// 0x0038 (0x0050 - 0x0018)
struct FMsgWidgetTradeConfirmBeginNotify final : public FMsgBase
{
public:
	class FText                                   MyNickName;                                        // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TargetNickname;                                    // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         TradeFee;                                          // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_223E[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetTradeConfirmBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeConfirmBeginNotify");
static_assert(sizeof(FMsgWidgetTradeConfirmBeginNotify) == 0x000050, "Wrong size on FMsgWidgetTradeConfirmBeginNotify");
static_assert(offsetof(FMsgWidgetTradeConfirmBeginNotify, MyNickName) == 0x000018, "Member 'FMsgWidgetTradeConfirmBeginNotify::MyNickName' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradeConfirmBeginNotify, TargetNickname) == 0x000030, "Member 'FMsgWidgetTradeConfirmBeginNotify::TargetNickname' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradeConfirmBeginNotify, TradeFee) == 0x000048, "Member 'FMsgWidgetTradeConfirmBeginNotify::TradeFee' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCDesignDataActionSkin
// 0x0068 (0x0068 - 0x0000)
struct FDCDesignDataActionSkin final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EDCActionSkinType                             ActionSkinType;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_223F[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        Art;                                               // 0x0034(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        TargetAction;                                      // 0x0044(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkinAction;                                        // 0x0054(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2240[0x4];                                     // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCDesignDataActionSkin) == 0x000008, "Wrong alignment on FDCDesignDataActionSkin");
static_assert(sizeof(FDCDesignDataActionSkin) == 0x000068, "Wrong size on FDCDesignDataActionSkin");
static_assert(offsetof(FDCDesignDataActionSkin, Name) == 0x000000, "Member 'FDCDesignDataActionSkin::Name' has a wrong offset!");
static_assert(offsetof(FDCDesignDataActionSkin, FlavorText) == 0x000018, "Member 'FDCDesignDataActionSkin::FlavorText' has a wrong offset!");
static_assert(offsetof(FDCDesignDataActionSkin, ActionSkinType) == 0x000030, "Member 'FDCDesignDataActionSkin::ActionSkinType' has a wrong offset!");
static_assert(offsetof(FDCDesignDataActionSkin, Art) == 0x000034, "Member 'FDCDesignDataActionSkin::Art' has a wrong offset!");
static_assert(offsetof(FDCDesignDataActionSkin, TargetAction) == 0x000044, "Member 'FDCDesignDataActionSkin::TargetAction' has a wrong offset!");
static_assert(offsetof(FDCDesignDataActionSkin, SkinAction) == 0x000054, "Member 'FDCDesignDataActionSkin::SkinAction' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataActionSkinTableRow
// 0x00A0 (0x00A8 - 0x0008)
struct FDesignDataActionSkinTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDCDesignDataActionSkin> ActionSkin;                                        // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> ActionSkinAbility;                                 // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataActionSkinTableRow) == 0x000008, "Wrong alignment on FDesignDataActionSkinTableRow");
static_assert(sizeof(FDesignDataActionSkinTableRow) == 0x0000A8, "Wrong size on FDesignDataActionSkinTableRow");
static_assert(offsetof(FDesignDataActionSkinTableRow, ActionSkin) == 0x000008, "Member 'FDesignDataActionSkinTableRow::ActionSkin' has a wrong offset!");
static_assert(offsetof(FDesignDataActionSkinTableRow, ActionSkinAbility) == 0x000058, "Member 'FDesignDataActionSkinTableRow::ActionSkinAbility' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassLevelNotify
// 0x0068 (0x0080 - 0x0018)
struct FMsgWidgetClassLevelNotify final : public FMsgBase
{
public:
	struct FMsgWidgetClassLevelNotifyBody         ClassLevelInfo;                                    // 0x0018(0x0068)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassLevelNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassLevelNotify");
static_assert(sizeof(FMsgWidgetClassLevelNotify) == 0x000080, "Wrong size on FMsgWidgetClassLevelNotify");
static_assert(offsetof(FMsgWidgetClassLevelNotify, ClassLevelInfo) == 0x000018, "Member 'FMsgWidgetClassLevelNotify::ClassLevelInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCAnimNode_CharSkinModBone
// 0x0030 (0x00F8 - 0x00C8)
struct FDCAnimNode_CharSkinModBone final : public FAnimNode_SkeletalControlBase
{
public:
	uint8                                         Pad_2241[0x10];                                    // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EBoneControlSpace                             TranslationSpace;                                  // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             RotationSpace;                                     // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             ScaleSpace;                                        // 0x00DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2242[0x1D];                                    // 0x00DB(0x001D)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCAnimNode_CharSkinModBone) == 0x000008, "Wrong alignment on FDCAnimNode_CharSkinModBone");
static_assert(sizeof(FDCAnimNode_CharSkinModBone) == 0x0000F8, "Wrong size on FDCAnimNode_CharSkinModBone");
static_assert(offsetof(FDCAnimNode_CharSkinModBone, TranslationSpace) == 0x0000D8, "Member 'FDCAnimNode_CharSkinModBone::TranslationSpace' has a wrong offset!");
static_assert(offsetof(FDCAnimNode_CharSkinModBone, RotationSpace) == 0x0000D9, "Member 'FDCAnimNode_CharSkinModBone::RotationSpace' has a wrong offset!");
static_assert(offsetof(FDCAnimNode_CharSkinModBone, ScaleSpace) == 0x0000DA, "Member 'FDCAnimNode_CharSkinModBone::ScaleSpace' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassPerkBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassPerkBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassPerkBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassPerkBeginNotify");
static_assert(sizeof(FMsgWidgetClassPerkBeginNotify) == 0x000018, "Wrong size on FMsgWidgetClassPerkBeginNotify");

// ScriptStruct DungeonCrawler.DesignDataAnnounce
// 0x0018 (0x0018 - 0x0000)
struct FDesignDataAnnounce final
{
public:
	class FText                                   AnnounceText;                                      // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataAnnounce) == 0x000008, "Wrong alignment on FDesignDataAnnounce");
static_assert(sizeof(FDesignDataAnnounce) == 0x000018, "Wrong size on FDesignDataAnnounce");
static_assert(offsetof(FDesignDataAnnounce, AnnounceText) == 0x000000, "Member 'FDesignDataAnnounce::AnnounceText' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataAnnounceTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataAnnounceTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataAnnounce> Announce;                                          // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataAnnounceTableRow) == 0x000008, "Wrong alignment on FDesignDataAnnounceTableRow");
static_assert(sizeof(FDesignDataAnnounceTableRow) == 0x000058, "Wrong size on FDesignDataAnnounceTableRow");
static_assert(offsetof(FDesignDataAnnounceTableRow, Announce) == 0x000008, "Member 'FDesignDataAnnounceTableRow::Announce' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCArenaStartPoint
// 0x0010 (0x0010 - 0x0000)
struct FDCArenaStartPoint final
{
public:
	class ADCPlayerStart*                         RedTeamStartPoint;                                 // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCPlayerStart*                         BlueTeamStartPoint;                                // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCArenaStartPoint) == 0x000008, "Wrong alignment on FDCArenaStartPoint");
static_assert(sizeof(FDCArenaStartPoint) == 0x000010, "Wrong size on FDCArenaStartPoint");
static_assert(offsetof(FDCArenaStartPoint, RedTeamStartPoint) == 0x000000, "Member 'FDCArenaStartPoint::RedTeamStartPoint' has a wrong offset!");
static_assert(offsetof(FDCArenaStartPoint, BlueTeamStartPoint) == 0x000008, "Member 'FDCArenaStartPoint::BlueTeamStartPoint' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetProgressBarPause
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetProgressBarPause final : public FMsgBase
{
public:
	float                                         StartDuration;                                     // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2243[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetProgressBarPause) == 0x000008, "Wrong alignment on FMsgWidgetProgressBarPause");
static_assert(sizeof(FMsgWidgetProgressBarPause) == 0x000020, "Wrong size on FMsgWidgetProgressBarPause");
static_assert(offsetof(FMsgWidgetProgressBarPause, StartDuration) == 0x000018, "Member 'FMsgWidgetProgressBarPause::StartDuration' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataArmorSkin
// 0x0050 (0x0050 - 0x0000)
struct FDesignDataArmorSkin final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Art;                                               // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetItem;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCItemPreviewDataAsset*                ItemPreview;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataArmorSkin) == 0x000008, "Wrong alignment on FDesignDataArmorSkin");
static_assert(sizeof(FDesignDataArmorSkin) == 0x000050, "Wrong size on FDesignDataArmorSkin");
static_assert(offsetof(FDesignDataArmorSkin, Name) == 0x000000, "Member 'FDesignDataArmorSkin::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataArmorSkin, FlavorText) == 0x000018, "Member 'FDesignDataArmorSkin::FlavorText' has a wrong offset!");
static_assert(offsetof(FDesignDataArmorSkin, Art) == 0x000030, "Member 'FDesignDataArmorSkin::Art' has a wrong offset!");
static_assert(offsetof(FDesignDataArmorSkin, TargetItem) == 0x000040, "Member 'FDesignDataArmorSkin::TargetItem' has a wrong offset!");
static_assert(offsetof(FDesignDataArmorSkin, ItemPreview) == 0x000048, "Member 'FDesignDataArmorSkin::ItemPreview' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataArmorSkinTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataArmorSkinTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataArmorSkin> ArmorSkin;                                         // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataArmorSkinTableRow) == 0x000008, "Wrong alignment on FDesignDataArmorSkinTableRow");
static_assert(sizeof(FDesignDataArmorSkinTableRow) == 0x000058, "Wrong size on FDesignDataArmorSkinTableRow");
static_assert(offsetof(FDesignDataArmorSkinTableRow, ArmorSkin) == 0x000008, "Member 'FDesignDataArmorSkinTableRow::ArmorSkin' has a wrong offset!");

// ScriptStruct DungeonCrawler.LoadPrimaryAssetType
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLoadPrimaryAssetType
{
public:
	uint8                                         Pad_2244[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadPrimaryAssetType) == 0x000008, "Wrong alignment on FLoadPrimaryAssetType");
static_assert(sizeof(FLoadPrimaryAssetType) == 0x000010, "Wrong size on FLoadPrimaryAssetType");

// ScriptStruct DungeonCrawler.MsgWidgetContextMenuOpenNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetContextMenuOpenNotify final : public FMsgBase
{
public:
	class UObject*                                ContextMenuHolder;                                 // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EContextOptionType>                    ContextOptions;                                    // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetContextMenuOpenNotify) == 0x000008, "Wrong alignment on FMsgWidgetContextMenuOpenNotify");
static_assert(sizeof(FMsgWidgetContextMenuOpenNotify) == 0x000030, "Wrong size on FMsgWidgetContextMenuOpenNotify");
static_assert(offsetof(FMsgWidgetContextMenuOpenNotify, ContextMenuHolder) == 0x000018, "Member 'FMsgWidgetContextMenuOpenNotify::ContextMenuHolder' has a wrong offset!");
static_assert(offsetof(FMsgWidgetContextMenuOpenNotify, ContextOptions) == 0x000020, "Member 'FMsgWidgetContextMenuOpenNotify::ContextOptions' has a wrong offset!");

// ScriptStruct DungeonCrawler.LoadPrimaryAssetData
// 0x0030 (0x0040 - 0x0010)
struct FLoadPrimaryAssetData final : public FLoadPrimaryAssetType
{
public:
	FMulticastInlineDelegateProperty_             LoadPrimaryAssetDynamicMulticastDelegate;          // 0x0010(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2245[0x20];                                    // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadPrimaryAssetData) == 0x000008, "Wrong alignment on FLoadPrimaryAssetData");
static_assert(sizeof(FLoadPrimaryAssetData) == 0x000040, "Wrong size on FLoadPrimaryAssetData");
static_assert(offsetof(FLoadPrimaryAssetData, LoadPrimaryAssetDynamicMulticastDelegate) == 0x000010, "Member 'FLoadPrimaryAssetData::LoadPrimaryAssetDynamicMulticastDelegate' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryBoxView
// 0x0020 (0x0020 - 0x0000)
struct FDCInventoryBoxView final
{
public:
	class UDCBoxInventory*                        Inventory;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntPoint                              StartPos;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntPoint                              Size;                                              // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bValid;                                            // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2246[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCInventoryBoxView) == 0x000008, "Wrong alignment on FDCInventoryBoxView");
static_assert(sizeof(FDCInventoryBoxView) == 0x000020, "Wrong size on FDCInventoryBoxView");
static_assert(offsetof(FDCInventoryBoxView, Inventory) == 0x000000, "Member 'FDCInventoryBoxView::Inventory' has a wrong offset!");
static_assert(offsetof(FDCInventoryBoxView, StartPos) == 0x000008, "Member 'FDCInventoryBoxView::StartPos' has a wrong offset!");
static_assert(offsetof(FDCInventoryBoxView, Size) == 0x000010, "Member 'FDCInventoryBoxView::Size' has a wrong offset!");
static_assert(offsetof(FDCInventoryBoxView, bValid) == 0x000018, "Member 'FDCInventoryBoxView::bValid' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCChannelPlayerWidgetInfo
// 0x0090 (0x0090 - 0x0000)
struct FDCChannelPlayerWidgetInfo final
{
public:
	struct FDCChannelPlayerInfo                   ChannelPlayer;                                     // 0x0000(0x0080)(Transient, NativeAccessSpecifierPrivate)
	TArray<EContextOptionType>                    ContextOptions;                                    // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCChannelPlayerWidgetInfo) == 0x000008, "Wrong alignment on FDCChannelPlayerWidgetInfo");
static_assert(sizeof(FDCChannelPlayerWidgetInfo) == 0x000090, "Wrong size on FDCChannelPlayerWidgetInfo");
static_assert(offsetof(FDCChannelPlayerWidgetInfo, ChannelPlayer) == 0x000000, "Member 'FDCChannelPlayerWidgetInfo::ChannelPlayer' has a wrong offset!");
static_assert(offsetof(FDCChannelPlayerWidgetInfo, ContextOptions) == 0x000080, "Member 'FDCChannelPlayerWidgetInfo::ContextOptions' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCConnectionAlwaysRelevantNodePair
// 0x0010 (0x0010 - 0x0000)
struct FDCConnectionAlwaysRelevantNodePair final
{
public:
	class UNetConnection*                         NetConnection;                                     // 0x0000(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReplicationGraphNode_AlwaysRelevant_ForConnection* Node;                                              // 0x0008(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCConnectionAlwaysRelevantNodePair) == 0x000008, "Wrong alignment on FDCConnectionAlwaysRelevantNodePair");
static_assert(sizeof(FDCConnectionAlwaysRelevantNodePair) == 0x000010, "Wrong size on FDCConnectionAlwaysRelevantNodePair");
static_assert(offsetof(FDCConnectionAlwaysRelevantNodePair, NetConnection) == 0x000000, "Member 'FDCConnectionAlwaysRelevantNodePair::NetConnection' has a wrong offset!");
static_assert(offsetof(FDCConnectionAlwaysRelevantNodePair, Node) == 0x000008, "Member 'FDCConnectionAlwaysRelevantNodePair::Node' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCCharacterGasInfo
// 0x0000 (0x0040 - 0x0040)
struct FDCCharacterGasInfo final : public FDCApplyGasInfoBase
{
};
static_assert(alignof(FDCCharacterGasInfo) == 0x000008, "Wrong alignment on FDCCharacterGasInfo");
static_assert(sizeof(FDCCharacterGasInfo) == 0x000040, "Wrong size on FDCCharacterGasInfo");

// ScriptStruct DungeonCrawler.DCItemGasInfo
// 0x0170 (0x01B0 - 0x0040)
struct FDCItemGasInfo final : public FDCApplyGasInfoBase
{
public:
	struct FDCItemInfo                            Value;                                             // 0x0040(0x0168)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplied;                                          // 0x01A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEquip;                                          // 0x01A9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2247[0x6];                                     // 0x01AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCItemGasInfo) == 0x000008, "Wrong alignment on FDCItemGasInfo");
static_assert(sizeof(FDCItemGasInfo) == 0x0001B0, "Wrong size on FDCItemGasInfo");
static_assert(offsetof(FDCItemGasInfo, Value) == 0x000040, "Member 'FDCItemGasInfo::Value' has a wrong offset!");
static_assert(offsetof(FDCItemGasInfo, bApplied) == 0x0001A8, "Member 'FDCItemGasInfo::bApplied' has a wrong offset!");
static_assert(offsetof(FDCItemGasInfo, bIsEquip) == 0x0001A9, "Member 'FDCItemGasInfo::bIsEquip' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemSkinGasInfo
// 0x0000 (0x0040 - 0x0040)
struct FDCItemSkinGasInfo final : public FDCApplyGasInfoBase
{
};
static_assert(alignof(FDCItemSkinGasInfo) == 0x000008, "Wrong alignment on FDCItemSkinGasInfo");
static_assert(sizeof(FDCItemSkinGasInfo) == 0x000040, "Wrong size on FDCItemSkinGasInfo");

// ScriptStruct DungeonCrawler.AggroRate
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FAggroRate final
{
public:
	uint8                                         Pad_2248[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAggroRate) == 0x000008, "Wrong alignment on FAggroRate");
static_assert(sizeof(FAggroRate) == 0x000010, "Wrong size on FAggroRate");

// ScriptStruct DungeonCrawler.MsgWidgetClassAddUnEquipPerkNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassAddUnEquipPerkNotify final : public FMsgBase
{
public:
	struct FPrimaryAssetId                        PerkId;                                            // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassAddUnEquipPerkNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassAddUnEquipPerkNotify");
static_assert(sizeof(FMsgWidgetClassAddUnEquipPerkNotify) == 0x000028, "Wrong size on FMsgWidgetClassAddUnEquipPerkNotify");
static_assert(offsetof(FMsgWidgetClassAddUnEquipPerkNotify, PerkId) == 0x000018, "Member 'FMsgWidgetClassAddUnEquipPerkNotify::PerkId' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCPlayerCharacterData
// 0x0018 (0x0018 - 0x0000)
struct FDCPlayerCharacterData final
{
public:
	class UDesignDataAssetPlayerCharacter*        DesignData;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCCharacterPartsArtData*               PartsResourceData;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArtDataPlayerCharacter*                ArtData;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCPlayerCharacterData) == 0x000008, "Wrong alignment on FDCPlayerCharacterData");
static_assert(sizeof(FDCPlayerCharacterData) == 0x000018, "Wrong size on FDCPlayerCharacterData");
static_assert(offsetof(FDCPlayerCharacterData, DesignData) == 0x000000, "Member 'FDCPlayerCharacterData::DesignData' has a wrong offset!");
static_assert(offsetof(FDCPlayerCharacterData, PartsResourceData) == 0x000008, "Member 'FDCPlayerCharacterData::PartsResourceData' has a wrong offset!");
static_assert(offsetof(FDCPlayerCharacterData, ArtData) == 0x000010, "Member 'FDCPlayerCharacterData::ArtData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataCharacterSkin
// 0x0080 (0x0080 - 0x0000)
struct FDesignDataCharacterSkin final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Desc;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Art;                                               // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                TargetCharacterClasses;                            // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataCharacterSkin) == 0x000008, "Wrong alignment on FDesignDataCharacterSkin");
static_assert(sizeof(FDesignDataCharacterSkin) == 0x000080, "Wrong size on FDesignDataCharacterSkin");
static_assert(offsetof(FDesignDataCharacterSkin, Name) == 0x000000, "Member 'FDesignDataCharacterSkin::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataCharacterSkin, Desc) == 0x000018, "Member 'FDesignDataCharacterSkin::Desc' has a wrong offset!");
static_assert(offsetof(FDesignDataCharacterSkin, FlavorText) == 0x000028, "Member 'FDesignDataCharacterSkin::FlavorText' has a wrong offset!");
static_assert(offsetof(FDesignDataCharacterSkin, Art) == 0x000040, "Member 'FDesignDataCharacterSkin::Art' has a wrong offset!");
static_assert(offsetof(FDesignDataCharacterSkin, TargetCharacterClasses) == 0x000050, "Member 'FDesignDataCharacterSkin::TargetCharacterClasses' has a wrong offset!");
static_assert(offsetof(FDesignDataCharacterSkin, Abilities) == 0x000060, "Member 'FDesignDataCharacterSkin::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataCharacterSkin, Effects) == 0x000070, "Member 'FDesignDataCharacterSkin::Effects' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataCharacterSkinTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataCharacterSkinTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataCharacterSkin> CharacterSkin;                                     // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataCharacterSkinTableRow) == 0x000008, "Wrong alignment on FDesignDataCharacterSkinTableRow");
static_assert(sizeof(FDesignDataCharacterSkinTableRow) == 0x000058, "Wrong size on FDesignDataCharacterSkinTableRow");
static_assert(offsetof(FDesignDataCharacterSkinTableRow, CharacterSkin) == 0x000008, "Member 'FDesignDataCharacterSkinTableRow::CharacterSkin' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassAddUnEquipSkillNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassAddUnEquipSkillNotify final : public FMsgBase
{
public:
	struct FPrimaryAssetId                        SkillId;                                           // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassAddUnEquipSkillNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassAddUnEquipSkillNotify");
static_assert(sizeof(FMsgWidgetClassAddUnEquipSkillNotify) == 0x000028, "Wrong size on FMsgWidgetClassAddUnEquipSkillNotify");
static_assert(offsetof(FMsgWidgetClassAddUnEquipSkillNotify, SkillId) == 0x000018, "Member 'FMsgWidgetClassAddUnEquipSkillNotify::SkillId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassSkillEventNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassSkillEventNotify final : public FMsgBase
{
public:
	int32                                         Move;                                              // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkillId;                                           // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassSkillEventNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSkillEventNotify");
static_assert(sizeof(FMsgWidgetClassSkillEventNotify) == 0x000030, "Wrong size on FMsgWidgetClassSkillEventNotify");
static_assert(offsetof(FMsgWidgetClassSkillEventNotify, Move) == 0x000018, "Member 'FMsgWidgetClassSkillEventNotify::Move' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassSkillEventNotify, Index) == 0x00001C, "Member 'FMsgWidgetClassSkillEventNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassSkillEventNotify, SkillId) == 0x000020, "Member 'FMsgWidgetClassSkillEventNotify::SkillId' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCActionSkinShopItemInfo
// 0x0000 (0x0030 - 0x0030)
struct FDCActionSkinShopItemInfo final : public FDCShopItemInfo
{
};
static_assert(alignof(FDCActionSkinShopItemInfo) == 0x000008, "Wrong alignment on FDCActionSkinShopItemInfo");
static_assert(sizeof(FDCActionSkinShopItemInfo) == 0x000030, "Wrong size on FDCActionSkinShopItemInfo");

// ScriptStruct DungeonCrawler.DCCharacterSkinShopItemInfo
// 0x0000 (0x0030 - 0x0030)
struct FDCCharacterSkinShopItemInfo final : public FDCShopItemInfo
{
};
static_assert(alignof(FDCCharacterSkinShopItemInfo) == 0x000008, "Wrong alignment on FDCCharacterSkinShopItemInfo");
static_assert(sizeof(FDCCharacterSkinShopItemInfo) == 0x000030, "Wrong size on FDCCharacterSkinShopItemInfo");

// ScriptStruct DungeonCrawler.DCRedstoneShardShopItemInfo
// 0x0028 (0x0028 - 0x0000)
struct FDCRedstoneShardShopItemInfo final
{
public:
	class UDCRedstoneShardShopDataAsset*          Data;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Index;                                             // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SalesCount;                                        // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Price;                                             // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2249[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ShopURL;                                           // 0x0018(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDCRedstoneShardShopItemInfo) == 0x000008, "Wrong alignment on FDCRedstoneShardShopItemInfo");
static_assert(sizeof(FDCRedstoneShardShopItemInfo) == 0x000028, "Wrong size on FDCRedstoneShardShopItemInfo");
static_assert(offsetof(FDCRedstoneShardShopItemInfo, Data) == 0x000000, "Member 'FDCRedstoneShardShopItemInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCRedstoneShardShopItemInfo, Index) == 0x000008, "Member 'FDCRedstoneShardShopItemInfo::Index' has a wrong offset!");
static_assert(offsetof(FDCRedstoneShardShopItemInfo, SalesCount) == 0x00000C, "Member 'FDCRedstoneShardShopItemInfo::SalesCount' has a wrong offset!");
static_assert(offsetof(FDCRedstoneShardShopItemInfo, Price) == 0x000010, "Member 'FDCRedstoneShardShopItemInfo::Price' has a wrong offset!");
static_assert(offsetof(FDCRedstoneShardShopItemInfo, ShopURL) == 0x000018, "Member 'FDCRedstoneShardShopItemInfo::ShopURL' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemSkinShopItemInfo
// 0x0000 (0x0030 - 0x0030)
struct FDCItemSkinShopItemInfo final : public FDCShopItemInfo
{
};
static_assert(alignof(FDCItemSkinShopItemInfo) == 0x000008, "Wrong alignment on FDCItemSkinShopItemInfo");
static_assert(sizeof(FDCItemSkinShopItemInfo) == 0x000030, "Wrong size on FDCItemSkinShopItemInfo");

// ScriptStruct DungeonCrawler.DCLobbyEmoteShopItemInfo
// 0x0000 (0x0030 - 0x0030)
struct FDCLobbyEmoteShopItemInfo final : public FDCShopItemInfo
{
};
static_assert(alignof(FDCLobbyEmoteShopItemInfo) == 0x000008, "Wrong alignment on FDCLobbyEmoteShopItemInfo");
static_assert(sizeof(FDCLobbyEmoteShopItemInfo) == 0x000030, "Wrong size on FDCLobbyEmoteShopItemInfo");

// ScriptStruct DungeonCrawler.DCClassPackageShopItemInfo
// 0x0000 (0x0030 - 0x0030)
struct FDCClassPackageShopItemInfo final : public FDCShopItemInfo
{
};
static_assert(alignof(FDCClassPackageShopItemInfo) == 0x000008, "Wrong alignment on FDCClassPackageShopItemInfo");
static_assert(sizeof(FDCClassPackageShopItemInfo) == 0x000030, "Wrong size on FDCClassPackageShopItemInfo");

// ScriptStruct DungeonCrawler.DCClientShopInfo
// 0x02D0 (0x02D0 - 0x0000)
struct FDCClientShopInfo final
{
public:
	TMap<struct FPrimaryAssetId, struct FDCCharacterSkinShopItemInfo> CharacterSkinShopItems;                            // 0x0000(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCItemSkinShopItemInfo> ItemSkinShopItems;                                 // 0x0050(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCEmoteShopItemInfo> EmoteShopItems;                                    // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCLobbyEmoteShopItemInfo> LobbyEmoteShopItems;                               // 0x00F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCActionSkinShopItemInfo> ActionSkinShopItems;                               // 0x0140(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCClassPackageShopItemInfo> ClassPackageShopItems;                             // 0x0190(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UDCShopDataAsset*>               NewShopItemDataArray;                              // 0x01E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UDCShopDataAsset*>               ExclusiveShopItemDataArray;                        // 0x01F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UDCShopDataAsset*>               PromotionShopItemDataArray;                        // 0x0200(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetId, struct FDCRedstoneShardShopItemInfo> RedstoneShardShopItems;                            // 0x0210(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<EDCShopCurrencyType, int32>              CurrencyMap;                                       // 0x0260(0x0050)(Transient, NativeAccessSpecifierPrivate)
	int32                                         TriumphLevel;                                      // 0x02B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentTriumphExp;                                 // 0x02B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NextTriumphExp;                                    // 0x02B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224A[0x4];                                     // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ShopURL;                                           // 0x02C0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCClientShopInfo) == 0x000008, "Wrong alignment on FDCClientShopInfo");
static_assert(sizeof(FDCClientShopInfo) == 0x0002D0, "Wrong size on FDCClientShopInfo");
static_assert(offsetof(FDCClientShopInfo, CharacterSkinShopItems) == 0x000000, "Member 'FDCClientShopInfo::CharacterSkinShopItems' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, ItemSkinShopItems) == 0x000050, "Member 'FDCClientShopInfo::ItemSkinShopItems' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, EmoteShopItems) == 0x0000A0, "Member 'FDCClientShopInfo::EmoteShopItems' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, LobbyEmoteShopItems) == 0x0000F0, "Member 'FDCClientShopInfo::LobbyEmoteShopItems' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, ActionSkinShopItems) == 0x000140, "Member 'FDCClientShopInfo::ActionSkinShopItems' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, ClassPackageShopItems) == 0x000190, "Member 'FDCClientShopInfo::ClassPackageShopItems' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, NewShopItemDataArray) == 0x0001E0, "Member 'FDCClientShopInfo::NewShopItemDataArray' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, ExclusiveShopItemDataArray) == 0x0001F0, "Member 'FDCClientShopInfo::ExclusiveShopItemDataArray' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, PromotionShopItemDataArray) == 0x000200, "Member 'FDCClientShopInfo::PromotionShopItemDataArray' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, RedstoneShardShopItems) == 0x000210, "Member 'FDCClientShopInfo::RedstoneShardShopItems' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, CurrencyMap) == 0x000260, "Member 'FDCClientShopInfo::CurrencyMap' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, TriumphLevel) == 0x0002B0, "Member 'FDCClientShopInfo::TriumphLevel' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, CurrentTriumphExp) == 0x0002B4, "Member 'FDCClientShopInfo::CurrentTriumphExp' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, NextTriumphExp) == 0x0002B8, "Member 'FDCClientShopInfo::NextTriumphExp' has a wrong offset!");
static_assert(offsetof(FDCClientShopInfo, ShopURL) == 0x0002C0, "Member 'FDCClientShopInfo::ShopURL' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassSpellEquipNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassSpellEquipNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SpellId;                                           // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224B[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassSpellEquipNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSpellEquipNotify");
static_assert(sizeof(FMsgWidgetClassSpellEquipNotify) == 0x000030, "Wrong size on FMsgWidgetClassSpellEquipNotify");
static_assert(offsetof(FMsgWidgetClassSpellEquipNotify, Index) == 0x000018, "Member 'FMsgWidgetClassSpellEquipNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassSpellEquipNotify, SpellId) == 0x00001C, "Member 'FMsgWidgetClassSpellEquipNotify::SpellId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetRemoveItemFromDealTableSuccessNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetRemoveItemFromDealTableSuccessNotify final : public FMsgBase
{
public:
	int64                                         ItemUniqueId;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetRemoveItemFromDealTableSuccessNotify) == 0x000008, "Wrong alignment on FMsgWidgetRemoveItemFromDealTableSuccessNotify");
static_assert(sizeof(FMsgWidgetRemoveItemFromDealTableSuccessNotify) == 0x000020, "Wrong size on FMsgWidgetRemoveItemFromDealTableSuccessNotify");
static_assert(offsetof(FMsgWidgetRemoveItemFromDealTableSuccessNotify, ItemUniqueId) == 0x000018, "Member 'FMsgWidgetRemoveItemFromDealTableSuccessNotify::ItemUniqueId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradeChannelListBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetTradeChannelListBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetTradeChannelListBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeChannelListBeginNotify");
static_assert(sizeof(FMsgWidgetTradeChannelListBeginNotify) == 0x000018, "Wrong size on FMsgWidgetTradeChannelListBeginNotify");

// ScriptStruct DungeonCrawler.DCDamageIndicateData
// 0x0040 (0x0040 - 0x0000)
struct FDCDamageIndicateData final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPenetration;                                    // 0x000C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHeadShotted;                                    // 0x000D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCDamageIndicateType                         DamageType;                                        // 0x000E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224C[0x1];                                     // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0010(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0028(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCDamageIndicateData) == 0x000008, "Wrong alignment on FDCDamageIndicateData");
static_assert(sizeof(FDCDamageIndicateData) == 0x000040, "Wrong size on FDCDamageIndicateData");
static_assert(offsetof(FDCDamageIndicateData, SourceActor) == 0x000000, "Member 'FDCDamageIndicateData::SourceActor' has a wrong offset!");
static_assert(offsetof(FDCDamageIndicateData, Damage) == 0x000008, "Member 'FDCDamageIndicateData::Damage' has a wrong offset!");
static_assert(offsetof(FDCDamageIndicateData, bIsPenetration) == 0x00000C, "Member 'FDCDamageIndicateData::bIsPenetration' has a wrong offset!");
static_assert(offsetof(FDCDamageIndicateData, bIsHeadShotted) == 0x00000D, "Member 'FDCDamageIndicateData::bIsHeadShotted' has a wrong offset!");
static_assert(offsetof(FDCDamageIndicateData, DamageType) == 0x00000E, "Member 'FDCDamageIndicateData::DamageType' has a wrong offset!");
static_assert(offsetof(FDCDamageIndicateData, HitLocation) == 0x000010, "Member 'FDCDamageIndicateData::HitLocation' has a wrong offset!");
static_assert(offsetof(FDCDamageIndicateData, HitDirection) == 0x000028, "Member 'FDCDamageIndicateData::HitDirection' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLobbyEmote
// 0x0068 (0x0068 - 0x0000)
struct FDesignDataLobbyEmote final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LobbyEmoteTag;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLobbyEmote) == 0x000008, "Wrong alignment on FDesignDataLobbyEmote");
static_assert(sizeof(FDesignDataLobbyEmote) == 0x000068, "Wrong size on FDesignDataLobbyEmote");
static_assert(offsetof(FDesignDataLobbyEmote, Name) == 0x000000, "Member 'FDesignDataLobbyEmote::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataLobbyEmote, FlavorText) == 0x000018, "Member 'FDesignDataLobbyEmote::FlavorText' has a wrong offset!");
static_assert(offsetof(FDesignDataLobbyEmote, LobbyEmoteTag) == 0x000030, "Member 'FDesignDataLobbyEmote::LobbyEmoteTag' has a wrong offset!");
static_assert(offsetof(FDesignDataLobbyEmote, ArtData) == 0x000038, "Member 'FDesignDataLobbyEmote::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataLobbyEmote, Abilities) == 0x000048, "Member 'FDesignDataLobbyEmote::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataLobbyEmote, Effects) == 0x000058, "Member 'FDesignDataLobbyEmote::Effects' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradeChannelListNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetTradeChannelListNotify final : public FMsgBase
{
public:
	bool                                          bIsTrader;                                         // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224D[0x17];                                    // 0x0019(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetTradeChannelListNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeChannelListNotify");
static_assert(sizeof(FMsgWidgetTradeChannelListNotify) == 0x000030, "Wrong size on FMsgWidgetTradeChannelListNotify");
static_assert(offsetof(FMsgWidgetTradeChannelListNotify, bIsTrader) == 0x000018, "Member 'FMsgWidgetTradeChannelListNotify::bIsTrader' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCWheelInteractData
// 0x0010 (0x0010 - 0x0000)
struct FDCWheelInteractData final
{
public:
	bool                                          bIsInteract;                                       // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224E[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressDuration;                                  // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADCPlayerCharacterBase*                 Interacter;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCWheelInteractData) == 0x000008, "Wrong alignment on FDCWheelInteractData");
static_assert(sizeof(FDCWheelInteractData) == 0x000010, "Wrong size on FDCWheelInteractData");
static_assert(offsetof(FDCWheelInteractData, bIsInteract) == 0x000000, "Member 'FDCWheelInteractData::bIsInteract' has a wrong offset!");
static_assert(offsetof(FDCWheelInteractData, ProgressDuration) == 0x000004, "Member 'FDCWheelInteractData::ProgressDuration' has a wrong offset!");
static_assert(offsetof(FDCWheelInteractData, Interacter) == 0x000008, "Member 'FDCWheelInteractData::Interacter' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradeChannelBeginNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgWidgetTradeChannelBeginNotify final : public FMsgBase
{
public:
	uint8                                         Pad_224F[0x28];                                    // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetTradeChannelBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeChannelBeginNotify");
static_assert(sizeof(FMsgWidgetTradeChannelBeginNotify) == 0x000040, "Wrong size on FMsgWidgetTradeChannelBeginNotify");

// ScriptStruct DungeonCrawler.DCSkeletalMeshAttachInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCSkeletalMeshAttachInfo final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimInstance;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCSkeletalMeshAttachInfo) == 0x000008, "Wrong alignment on FDCSkeletalMeshAttachInfo");
static_assert(sizeof(FDCSkeletalMeshAttachInfo) == 0x000018, "Wrong size on FDCSkeletalMeshAttachInfo");
static_assert(offsetof(FDCSkeletalMeshAttachInfo, SkeletalMesh) == 0x000000, "Member 'FDCSkeletalMeshAttachInfo::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FDCSkeletalMeshAttachInfo, AnimInstance) == 0x000008, "Member 'FDCSkeletalMeshAttachInfo::AnimInstance' has a wrong offset!");
static_assert(offsetof(FDCSkeletalMeshAttachInfo, SocketName) == 0x000010, "Member 'FDCSkeletalMeshAttachInfo::SocketName' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCEquipHoldInfo
// 0x0028 (0x0028 - 0x0000)
struct FDCEquipHoldInfo final
{
public:
	EDCEquipHoldType                              HoldType;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2250[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EDCEquipHoldType>                      Keys;                                              // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 Values;                                            // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCEquipHoldInfo) == 0x000008, "Wrong alignment on FDCEquipHoldInfo");
static_assert(sizeof(FDCEquipHoldInfo) == 0x000028, "Wrong size on FDCEquipHoldInfo");
static_assert(offsetof(FDCEquipHoldInfo, HoldType) == 0x000000, "Member 'FDCEquipHoldInfo::HoldType' has a wrong offset!");
static_assert(offsetof(FDCEquipHoldInfo, Keys) == 0x000008, "Member 'FDCEquipHoldInfo::Keys' has a wrong offset!");
static_assert(offsetof(FDCEquipHoldInfo, Values) == 0x000018, "Member 'FDCEquipHoldInfo::Values' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCEquipItemsDiff
// 0x00C0 (0x00C0 - 0x0000)
struct alignas(0x08) FDCEquipItemsDiff final
{
public:
	uint8                                         Pad_2251[0xC0];                                    // 0x0000(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCEquipItemsDiff) == 0x000008, "Wrong alignment on FDCEquipItemsDiff");
static_assert(sizeof(FDCEquipItemsDiff) == 0x0000C0, "Wrong size on FDCEquipItemsDiff");

// ScriptStruct DungeonCrawler.DCMiniMapDataContainer
// 0x0010 (0x0010 - 0x0000)
struct FDCMiniMapDataContainer final
{
public:
	class UTexture2D*                             Texture2D;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMiniMapConfigData*                     ConfigData;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCMiniMapDataContainer) == 0x000008, "Wrong alignment on FDCMiniMapDataContainer");
static_assert(sizeof(FDCMiniMapDataContainer) == 0x000010, "Wrong size on FDCMiniMapDataContainer");
static_assert(offsetof(FDCMiniMapDataContainer, Texture2D) == 0x000000, "Member 'FDCMiniMapDataContainer::Texture2D' has a wrong offset!");
static_assert(offsetof(FDCMiniMapDataContainer, ConfigData) == 0x000008, "Member 'FDCMiniMapDataContainer::ConfigData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCHideItemActorsWhileAction
// 0x0028 (0x0028 - 0x0000)
struct FDCHideItemActorsWhileAction final
{
public:
	bool                                          bHide;                                             // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2252[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ExcludeTags;                                       // 0x0008(0x0020)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCHideItemActorsWhileAction) == 0x000008, "Wrong alignment on FDCHideItemActorsWhileAction");
static_assert(sizeof(FDCHideItemActorsWhileAction) == 0x000028, "Wrong size on FDCHideItemActorsWhileAction");
static_assert(offsetof(FDCHideItemActorsWhileAction, bHide) == 0x000000, "Member 'FDCHideItemActorsWhileAction::bHide' has a wrong offset!");
static_assert(offsetof(FDCHideItemActorsWhileAction, ExcludeTags) == 0x000008, "Member 'FDCHideItemActorsWhileAction::ExcludeTags' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCEquipmentInventoryData
// 0x0010 (0x0010 - 0x0000)
struct FDCEquipmentInventoryData final
{
public:
	TArray<struct FItemData>                      Values;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCEquipmentInventoryData) == 0x000008, "Wrong alignment on FDCEquipmentInventoryData");
static_assert(sizeof(FDCEquipmentInventoryData) == 0x000010, "Wrong size on FDCEquipmentInventoryData");
static_assert(offsetof(FDCEquipmentInventoryData, Values) == 0x000000, "Member 'FDCEquipmentInventoryData::Values' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgMonsterIdResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgMonsterIdResponse final : public FMsgBase
{
public:
	struct FPrimaryAssetId                        MonsterId;                                         // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgMonsterIdResponse) == 0x000008, "Wrong alignment on FMsgMonsterIdResponse");
static_assert(sizeof(FMsgMonsterIdResponse) == 0x000028, "Wrong size on FMsgMonsterIdResponse");
static_assert(offsetof(FMsgMonsterIdResponse, MonsterId) == 0x000018, "Member 'FMsgMonsterIdResponse::MonsterId' has a wrong offset!");

// ScriptStruct DungeonCrawler.DeliveryItemInfo
// 0x0050 (0x0050 - 0x0000)
struct FDeliveryItemInfo final
{
public:
	TMap<int32, struct FDCItemInfo>               ItemInfos;                                         // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeliveryItemInfo) == 0x000008, "Wrong alignment on FDeliveryItemInfo");
static_assert(sizeof(FDeliveryItemInfo) == 0x000050, "Wrong size on FDeliveryItemInfo");
static_assert(offsetof(FDeliveryItemInfo, ItemInfos) == 0x000000, "Member 'FDeliveryItemInfo::ItemInfos' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCFloorRuleDeathSwarmItemData
// 0x0068 (0x0068 - 0x0000)
struct FDCFloorRuleDeathSwarmItemData final
{
public:
	float                                         DeathSwarmSize;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DeathSwarmAbilityTag;                              // 0x0004(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayPhaseDuration;                              // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDCFloorPortalDataAsset>> DisplayPhaseFloorPortalArray;                      // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         ShrinkPhaseDuration;                               // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2253[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UDCFloorPortalDataAsset>> ShrinkPhaseFloorPortalArray;                       // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          HideDeathSwarmTimer;                               // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2254[0x7];                                     // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundData>              SoundData;                                         // 0x0040(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCFloorRuleDeathSwarmItemData) == 0x000008, "Wrong alignment on FDCFloorRuleDeathSwarmItemData");
static_assert(sizeof(FDCFloorRuleDeathSwarmItemData) == 0x000068, "Wrong size on FDCFloorRuleDeathSwarmItemData");
static_assert(offsetof(FDCFloorRuleDeathSwarmItemData, DeathSwarmSize) == 0x000000, "Member 'FDCFloorRuleDeathSwarmItemData::DeathSwarmSize' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleDeathSwarmItemData, DeathSwarmAbilityTag) == 0x000004, "Member 'FDCFloorRuleDeathSwarmItemData::DeathSwarmAbilityTag' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleDeathSwarmItemData, DisplayPhaseDuration) == 0x00000C, "Member 'FDCFloorRuleDeathSwarmItemData::DisplayPhaseDuration' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleDeathSwarmItemData, DisplayPhaseFloorPortalArray) == 0x000010, "Member 'FDCFloorRuleDeathSwarmItemData::DisplayPhaseFloorPortalArray' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleDeathSwarmItemData, ShrinkPhaseDuration) == 0x000020, "Member 'FDCFloorRuleDeathSwarmItemData::ShrinkPhaseDuration' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleDeathSwarmItemData, ShrinkPhaseFloorPortalArray) == 0x000028, "Member 'FDCFloorRuleDeathSwarmItemData::ShrinkPhaseFloorPortalArray' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleDeathSwarmItemData, HideDeathSwarmTimer) == 0x000038, "Member 'FDCFloorRuleDeathSwarmItemData::HideDeathSwarmTimer' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleDeathSwarmItemData, SoundData) == 0x000040, "Member 'FDCFloorRuleDeathSwarmItemData::SoundData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCFrameTimeMonitorInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDCFrameTimeMonitorInfo final
{
public:
	uint8                                         Pad_2255[0x10];                                    // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCFrameTimeMonitorInfo) == 0x000008, "Wrong alignment on FDCFrameTimeMonitorInfo");
static_assert(sizeof(FDCFrameTimeMonitorInfo) == 0x000010, "Wrong size on FDCFrameTimeMonitorInfo");

// ScriptStruct DungeonCrawler.PlayerPointData
// 0x0070 (0x0070 - 0x0000)
struct FPlayerPointData final
{
public:
	class AActor*                                 PlayerStartPIE;                                    // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2256[0x68];                                    // 0x0008(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerPointData) == 0x000008, "Wrong alignment on FPlayerPointData");
static_assert(sizeof(FPlayerPointData) == 0x000070, "Wrong size on FPlayerPointData");
static_assert(offsetof(FPlayerPointData, PlayerStartPIE) == 0x000000, "Member 'FPlayerPointData::PlayerStartPIE' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgMusicPlayEnd
// 0x0000 (0x0018 - 0x0018)
struct FMsgMusicPlayEnd final : public FMsgBase
{
};
static_assert(alignof(FMsgMusicPlayEnd) == 0x000008, "Wrong alignment on FMsgMusicPlayEnd");
static_assert(sizeof(FMsgMusicPlayEnd) == 0x000018, "Wrong size on FMsgMusicPlayEnd");

// ScriptStruct DungeonCrawler.DCGameplayCueTagGroupItemData
// 0x0010 (0x0010 - 0x0000)
struct FDCGameplayCueTagGroupItemData final
{
public:
	struct FGameplayTag                           StateTag;                                          // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CueTag;                                            // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCGameplayCueTagGroupItemData) == 0x000004, "Wrong alignment on FDCGameplayCueTagGroupItemData");
static_assert(sizeof(FDCGameplayCueTagGroupItemData) == 0x000010, "Wrong size on FDCGameplayCueTagGroupItemData");
static_assert(offsetof(FDCGameplayCueTagGroupItemData, StateTag) == 0x000000, "Member 'FDCGameplayCueTagGroupItemData::StateTag' has a wrong offset!");
static_assert(offsetof(FDCGameplayCueTagGroupItemData, CueTag) == 0x000008, "Member 'FDCGameplayCueTagGroupItemData::CueTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.ServerInfo
// 0x0030 (0x0030 - 0x0000)
struct FServerInfo final
{
public:
	class FString                                 ServerAddress;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerName;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerDescription;                                 // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerInfo) == 0x000008, "Wrong alignment on FServerInfo");
static_assert(sizeof(FServerInfo) == 0x000030, "Wrong size on FServerInfo");
static_assert(offsetof(FServerInfo, ServerAddress) == 0x000000, "Member 'FServerInfo::ServerAddress' has a wrong offset!");
static_assert(offsetof(FServerInfo, ServerName) == 0x000010, "Member 'FServerInfo::ServerName' has a wrong offset!");
static_assert(offsetof(FServerInfo, ServerDescription) == 0x000020, "Member 'FServerInfo::ServerDescription' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCIdTagGroupItemData
// 0x0008 (0x0008 - 0x0000)
struct FDCIdTagGroupItemData final
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCIdTagGroupItemData) == 0x000004, "Wrong alignment on FDCIdTagGroupItemData");
static_assert(sizeof(FDCIdTagGroupItemData) == 0x000008, "Wrong size on FDCIdTagGroupItemData");
static_assert(offsetof(FDCIdTagGroupItemData, IdTag) == 0x000000, "Member 'FDCIdTagGroupItemData::IdTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgMusicMemoryCapacityChangedNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgMusicMemoryCapacityChangedNotify final : public FMsgBase
{
public:
	float                                         MusicCurrentCapacity;                              // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicMaxCapacity;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgMusicMemoryCapacityChangedNotify) == 0x000008, "Wrong alignment on FMsgMusicMemoryCapacityChangedNotify");
static_assert(sizeof(FMsgMusicMemoryCapacityChangedNotify) == 0x000020, "Wrong size on FMsgMusicMemoryCapacityChangedNotify");
static_assert(offsetof(FMsgMusicMemoryCapacityChangedNotify, MusicCurrentCapacity) == 0x000018, "Member 'FMsgMusicMemoryCapacityChangedNotify::MusicCurrentCapacity' has a wrong offset!");
static_assert(offsetof(FMsgMusicMemoryCapacityChangedNotify, MusicMaxCapacity) == 0x00001C, "Member 'FMsgMusicMemoryCapacityChangedNotify::MusicMaxCapacity' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCProgressInfo
// 0x01A8 (0x01A8 - 0x0000)
struct FDCProgressInfo final
{
public:
	EDCProgressType                               Type;                                              // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2257[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0008(0x0018)(Transient, NativeAccessSpecifierPublic)
	float                                         DurationSeconds;                                   // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2258[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCCharacterBase*                       EquipCharacter;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCItemInfo                            EquipSourceItemInfo;                               // 0x0030(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EDCEquipmentSlotIndex>                 EquipTargetIndexes;                                // 0x0198(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCProgressInfo) == 0x000008, "Wrong alignment on FDCProgressInfo");
static_assert(sizeof(FDCProgressInfo) == 0x0001A8, "Wrong size on FDCProgressInfo");
static_assert(offsetof(FDCProgressInfo, Type) == 0x000000, "Member 'FDCProgressInfo::Type' has a wrong offset!");
static_assert(offsetof(FDCProgressInfo, Description) == 0x000008, "Member 'FDCProgressInfo::Description' has a wrong offset!");
static_assert(offsetof(FDCProgressInfo, DurationSeconds) == 0x000020, "Member 'FDCProgressInfo::DurationSeconds' has a wrong offset!");
static_assert(offsetof(FDCProgressInfo, EquipCharacter) == 0x000028, "Member 'FDCProgressInfo::EquipCharacter' has a wrong offset!");
static_assert(offsetof(FDCProgressInfo, EquipSourceItemInfo) == 0x000030, "Member 'FDCProgressInfo::EquipSourceItemInfo' has a wrong offset!");
static_assert(offsetof(FDCProgressInfo, EquipTargetIndexes) == 0x000198, "Member 'FDCProgressInfo::EquipTargetIndexes' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCSwapTargetContainerInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCSwapTargetContainerInfo final
{
public:
	class UDCInventoryBase*                       Inventory;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2259[0x8];                                     // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCSwapTargetContainerInfo) == 0x000008, "Wrong alignment on FDCSwapTargetContainerInfo");
static_assert(sizeof(FDCSwapTargetContainerInfo) == 0x000010, "Wrong size on FDCSwapTargetContainerInfo");
static_assert(offsetof(FDCSwapTargetContainerInfo, Inventory) == 0x000000, "Member 'FDCSwapTargetContainerInfo::Inventory' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgItemConsumeDataRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgItemConsumeDataRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgItemConsumeDataRequest) == 0x000008, "Wrong alignment on FMsgItemConsumeDataRequest");
static_assert(sizeof(FMsgItemConsumeDataRequest) == 0x000018, "Wrong size on FMsgItemConsumeDataRequest");

// ScriptStruct DungeonCrawler.DCInventoryDataElement
// 0x016C (0x0178 - 0x000C)
struct FDCInventoryDataElement final : public FFastArraySerializerItem
{
public:
	int32                                         Index;                                             // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCItemInfo                            Value;                                             // 0x0010(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCInventoryDataElement) == 0x000008, "Wrong alignment on FDCInventoryDataElement");
static_assert(sizeof(FDCInventoryDataElement) == 0x000178, "Wrong size on FDCInventoryDataElement");
static_assert(offsetof(FDCInventoryDataElement, Index) == 0x00000C, "Member 'FDCInventoryDataElement::Index' has a wrong offset!");
static_assert(offsetof(FDCInventoryDataElement, Value) == 0x000010, "Member 'FDCInventoryDataElement::Value' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgUpdateMeshEvent
// 0x0008 (0x0020 - 0x0018)
struct FMsgUpdateMeshEvent final : public FMsgBase
{
public:
	class UMeshComponent*                         MeshComponent;                                     // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgUpdateMeshEvent) == 0x000008, "Wrong alignment on FMsgUpdateMeshEvent");
static_assert(sizeof(FMsgUpdateMeshEvent) == 0x000020, "Wrong size on FMsgUpdateMeshEvent");
static_assert(offsetof(FMsgUpdateMeshEvent, MeshComponent) == 0x000018, "Member 'FMsgUpdateMeshEvent::MeshComponent' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryData
// 0x0018 (0x0120 - 0x0108)
struct FDCInventoryData final : public FFastArraySerializer
{
public:
	EDCInventoryId                                InventoryType;                                     // 0x0108(0x0001)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225A[0x7];                                     // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDCInventoryDataElement>        Items;                                             // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCInventoryData) == 0x000008, "Wrong alignment on FDCInventoryData");
static_assert(sizeof(FDCInventoryData) == 0x000120, "Wrong size on FDCInventoryData");
static_assert(offsetof(FDCInventoryData, InventoryType) == 0x000108, "Member 'FDCInventoryData::InventoryType' has a wrong offset!");
static_assert(offsetof(FDCInventoryData, Items) == 0x000110, "Member 'FDCInventoryData::Items' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCInventoryBuilder
// 0x0020 (0x0020 - 0x0000)
struct FDCInventoryBuilder final
{
public:
	TArray<class UDCInventoryBase*>               ClonedInventories;                                 // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCInventoryTask>               Tasks;                                             // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCInventoryBuilder) == 0x000008, "Wrong alignment on FDCInventoryBuilder");
static_assert(sizeof(FDCInventoryBuilder) == 0x000020, "Wrong size on FDCInventoryBuilder");
static_assert(offsetof(FDCInventoryBuilder, ClonedInventories) == 0x000000, "Member 'FDCInventoryBuilder::ClonedInventories' has a wrong offset!");
static_assert(offsetof(FDCInventoryBuilder, Tasks) == 0x000010, "Member 'FDCInventoryBuilder::Tasks' has a wrong offset!");

// ScriptStruct DungeonCrawler.DDCItemBundleInfoItem
// 0x0030 (0x0030 - 0x0000)
struct FDDCItemBundleInfoItem final
{
public:
	TSoftObjectPtr<class UArtDataItem>            BundleArtData;                                     // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BundleGrade;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemMinCount;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDDCItemBundleInfoItem) == 0x000008, "Wrong alignment on FDDCItemBundleInfoItem");
static_assert(sizeof(FDDCItemBundleInfoItem) == 0x000030, "Wrong size on FDDCItemBundleInfoItem");
static_assert(offsetof(FDDCItemBundleInfoItem, BundleArtData) == 0x000000, "Member 'FDDCItemBundleInfoItem::BundleArtData' has a wrong offset!");
static_assert(offsetof(FDDCItemBundleInfoItem, BundleGrade) == 0x000028, "Member 'FDDCItemBundleInfoItem::BundleGrade' has a wrong offset!");
static_assert(offsetof(FDDCItemBundleInfoItem, ItemMinCount) == 0x00002C, "Member 'FDDCItemBundleInfoItem::ItemMinCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DDCItemPropertyItem
// 0x0038 (0x0038 - 0x0000)
struct FDDCItemPropertyItem final
{
public:
	TSoftObjectPtr<class UDCItemPropertyTypeDataAsset> PropertyTypeId;                                    // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinValue;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxValue;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PropertyRate;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225B[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDDCItemPropertyItem) == 0x000008, "Wrong alignment on FDDCItemPropertyItem");
static_assert(sizeof(FDDCItemPropertyItem) == 0x000038, "Wrong size on FDDCItemPropertyItem");
static_assert(offsetof(FDDCItemPropertyItem, PropertyTypeId) == 0x000000, "Member 'FDDCItemPropertyItem::PropertyTypeId' has a wrong offset!");
static_assert(offsetof(FDDCItemPropertyItem, MinValue) == 0x000028, "Member 'FDDCItemPropertyItem::MinValue' has a wrong offset!");
static_assert(offsetof(FDDCItemPropertyItem, MaxValue) == 0x00002C, "Member 'FDDCItemPropertyItem::MaxValue' has a wrong offset!");
static_assert(offsetof(FDDCItemPropertyItem, PropertyRate) == 0x000030, "Member 'FDDCItemPropertyItem::PropertyRate' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemGroupInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCItemGroupInfo final
{
public:
	struct FGameplayTag                           TypeTag;                                           // 0x0000(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           Rarity;                                            // 0x0008(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCItemGroupInfo) == 0x000004, "Wrong alignment on FDCItemGroupInfo");
static_assert(sizeof(FDCItemGroupInfo) == 0x000010, "Wrong size on FDCItemGroupInfo");
static_assert(offsetof(FDCItemGroupInfo, TypeTag) == 0x000000, "Member 'FDCItemGroupInfo::TypeTag' has a wrong offset!");
static_assert(offsetof(FDCItemGroupInfo, Rarity) == 0x000008, "Member 'FDCItemGroupInfo::Rarity' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataItemSkinTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataItemSkinTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataItemSkin> ItemSkin;                                          // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemSkinTableRow) == 0x000008, "Wrong alignment on FDesignDataItemSkinTableRow");
static_assert(sizeof(FDesignDataItemSkinTableRow) == 0x000058, "Wrong size on FDesignDataItemSkinTableRow");
static_assert(offsetof(FDesignDataItemSkinTableRow, ItemSkin) == 0x000008, "Member 'FDesignDataItemSkinTableRow::ItemSkin' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemTypeRarityIconData
// 0x0050 (0x0050 - 0x0000)
struct FDCItemTypeRarityIconData final
{
public:
	TMap<EDCItemRarity, class UTexture2D*>        IconByItemRarity;                                  // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCItemTypeRarityIconData) == 0x000008, "Wrong alignment on FDCItemTypeRarityIconData");
static_assert(sizeof(FDCItemTypeRarityIconData) == 0x000050, "Wrong size on FDCItemTypeRarityIconData");
static_assert(offsetof(FDCItemTypeRarityIconData, IconByItemRarity) == 0x000000, "Member 'FDCItemTypeRarityIconData::IconByItemRarity' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardRankGuideItemWidgetHandleData
// 0x0010 (0x0010 - 0x0000)
struct FLeaderboardRankGuideItemWidgetHandleData final
{
public:
	class ULeaderboardRankGuideItemWidgetData*    LeaderboardRankGuideItemWidgetData;                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELeaderboardState                             LeaderboardState;                                  // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELeaderboardRankRewardState                   LeaderboardRankRewardState;                        // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225C[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeaderboardRankGuideItemWidgetHandleData) == 0x000008, "Wrong alignment on FLeaderboardRankGuideItemWidgetHandleData");
static_assert(sizeof(FLeaderboardRankGuideItemWidgetHandleData) == 0x000010, "Wrong size on FLeaderboardRankGuideItemWidgetHandleData");
static_assert(offsetof(FLeaderboardRankGuideItemWidgetHandleData, LeaderboardRankGuideItemWidgetData) == 0x000000, "Member 'FLeaderboardRankGuideItemWidgetHandleData::LeaderboardRankGuideItemWidgetData' has a wrong offset!");
static_assert(offsetof(FLeaderboardRankGuideItemWidgetHandleData, LeaderboardState) == 0x000008, "Member 'FLeaderboardRankGuideItemWidgetHandleData::LeaderboardState' has a wrong offset!");
static_assert(offsetof(FLeaderboardRankGuideItemWidgetHandleData, LeaderboardRankRewardState) == 0x000009, "Member 'FLeaderboardRankGuideItemWidgetHandleData::LeaderboardRankRewardState' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCLobbyEmoteSlotInfo
// 0x0014 (0x0014 - 0x0000)
struct FDCLobbyEmoteSlotInfo final
{
public:
	struct FPrimaryAssetId                        LobbyEmoteId;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCLobbyEmoteSlotInfo) == 0x000004, "Wrong alignment on FDCLobbyEmoteSlotInfo");
static_assert(sizeof(FDCLobbyEmoteSlotInfo) == 0x000014, "Wrong size on FDCLobbyEmoteSlotInfo");
static_assert(offsetof(FDCLobbyEmoteSlotInfo, LobbyEmoteId) == 0x000000, "Member 'FDCLobbyEmoteSlotInfo::LobbyEmoteId' has a wrong offset!");
static_assert(offsetof(FDCLobbyEmoteSlotInfo, SlotIndex) == 0x000010, "Member 'FDCLobbyEmoteSlotInfo::SlotIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLobbyEmoteTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataLobbyEmoteTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataLobbyEmote> LobbyEmote;                                        // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> LobbyEmoteAbility;                                 // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> LobbyEmoteEffect;                                  // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLobbyEmoteTableRow) == 0x000008, "Wrong alignment on FDesignDataLobbyEmoteTableRow");
static_assert(sizeof(FDesignDataLobbyEmoteTableRow) == 0x0000F8, "Wrong size on FDesignDataLobbyEmoteTableRow");
static_assert(offsetof(FDesignDataLobbyEmoteTableRow, LobbyEmote) == 0x000008, "Member 'FDesignDataLobbyEmoteTableRow::LobbyEmote' has a wrong offset!");
static_assert(offsetof(FDesignDataLobbyEmoteTableRow, LobbyEmoteAbility) == 0x000058, "Member 'FDesignDataLobbyEmoteTableRow::LobbyEmoteAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataLobbyEmoteTableRow, LobbyEmoteEffect) == 0x0000A8, "Member 'FDesignDataLobbyEmoteTableRow::LobbyEmoteEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgReduceContainingItemRequest
// 0x0018 (0x0030 - 0x0018)
struct FMsgReduceContainingItemRequest final : public FMsgBase
{
public:
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225D[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUniqueId;                                      // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReduceCount;                                       // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225E[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgReduceContainingItemRequest) == 0x000008, "Wrong alignment on FMsgReduceContainingItemRequest");
static_assert(sizeof(FMsgReduceContainingItemRequest) == 0x000030, "Wrong size on FMsgReduceContainingItemRequest");
static_assert(offsetof(FMsgReduceContainingItemRequest, InventoryId) == 0x000018, "Member 'FMsgReduceContainingItemRequest::InventoryId' has a wrong offset!");
static_assert(offsetof(FMsgReduceContainingItemRequest, ItemUniqueId) == 0x000020, "Member 'FMsgReduceContainingItemRequest::ItemUniqueId' has a wrong offset!");
static_assert(offsetof(FMsgReduceContainingItemRequest, ReduceCount) == 0x000028, "Member 'FMsgReduceContainingItemRequest::ReduceCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCLobbyEmoteObjectAttachInfo
// 0x0020 (0x0020 - 0x0000)
struct FDCLobbyEmoteObjectAttachInfo final
{
public:
	class USkeletalMesh*                          ObjectSkeletalMesh;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectSocketCenter;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectSocketLeft;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectSocketRight;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCLobbyEmoteObjectAttachInfo) == 0x000008, "Wrong alignment on FDCLobbyEmoteObjectAttachInfo");
static_assert(sizeof(FDCLobbyEmoteObjectAttachInfo) == 0x000020, "Wrong size on FDCLobbyEmoteObjectAttachInfo");
static_assert(offsetof(FDCLobbyEmoteObjectAttachInfo, ObjectSkeletalMesh) == 0x000000, "Member 'FDCLobbyEmoteObjectAttachInfo::ObjectSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FDCLobbyEmoteObjectAttachInfo, ObjectSocketCenter) == 0x000008, "Member 'FDCLobbyEmoteObjectAttachInfo::ObjectSocketCenter' has a wrong offset!");
static_assert(offsetof(FDCLobbyEmoteObjectAttachInfo, ObjectSocketLeft) == 0x000010, "Member 'FDCLobbyEmoteObjectAttachInfo::ObjectSocketLeft' has a wrong offset!");
static_assert(offsetof(FDCLobbyEmoteObjectAttachInfo, ObjectSocketRight) == 0x000018, "Member 'FDCLobbyEmoteObjectAttachInfo::ObjectSocketRight' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCLogEventInfo
// 0x0030 (0x0030 - 0x0000)
struct FDCLogEventInfo final
{
public:
	int64                                         Timestamp;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDCAccountId                           AccountId;                                         // 0x0008(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDCLogEventType                               LogEventType;                                      // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_225F[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Params;                                            // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCLogEventInfo) == 0x000008, "Wrong alignment on FDCLogEventInfo");
static_assert(sizeof(FDCLogEventInfo) == 0x000030, "Wrong size on FDCLogEventInfo");
static_assert(offsetof(FDCLogEventInfo, Timestamp) == 0x000000, "Member 'FDCLogEventInfo::Timestamp' has a wrong offset!");
static_assert(offsetof(FDCLogEventInfo, AccountId) == 0x000008, "Member 'FDCLogEventInfo::AccountId' has a wrong offset!");
static_assert(offsetof(FDCLogEventInfo, LogEventType) == 0x000018, "Member 'FDCLogEventInfo::LogEventType' has a wrong offset!");
static_assert(offsetof(FDCLogEventInfo, Params) == 0x000020, "Member 'FDCLogEventInfo::Params' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCLootDropItemData
// 0x0030 (0x0030 - 0x0000)
struct FDCLootDropItemData final
{
public:
	TSoftObjectPtr<class UDCItemDataAsset>        ItemId;                                            // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LuckGrade;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCLootDropItemData) == 0x000008, "Wrong alignment on FDCLootDropItemData");
static_assert(sizeof(FDCLootDropItemData) == 0x000030, "Wrong size on FDCLootDropItemData");
static_assert(offsetof(FDCLootDropItemData, ItemId) == 0x000000, "Member 'FDCLootDropItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FDCLootDropItemData, ItemCount) == 0x000028, "Member 'FDCLootDropItemData::ItemCount' has a wrong offset!");
static_assert(offsetof(FDCLootDropItemData, LuckGrade) == 0x00002C, "Member 'FDCLootDropItemData::LuckGrade' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSlotItemDataResponse
// 0x0018 (0x0030 - 0x0018)
struct FMsgSlotItemDataResponse final : public FMsgBase
{
public:
	bool                                          bItemSet;                                          // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2260[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      ItemDataArray;                                     // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSlotItemDataResponse) == 0x000008, "Wrong alignment on FMsgSlotItemDataResponse");
static_assert(sizeof(FMsgSlotItemDataResponse) == 0x000030, "Wrong size on FMsgSlotItemDataResponse");
static_assert(offsetof(FMsgSlotItemDataResponse, bItemSet) == 0x000018, "Member 'FMsgSlotItemDataResponse::bItemSet' has a wrong offset!");
static_assert(offsetof(FMsgSlotItemDataResponse, ItemDataArray) == 0x000020, "Member 'FMsgSlotItemDataResponse::ItemDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCLootDropRateItemData
// 0x0008 (0x0008 - 0x0000)
struct FDCLootDropRateItemData final
{
public:
	int32                                         LuckGrade;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropRate;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCLootDropRateItemData) == 0x000004, "Wrong alignment on FDCLootDropRateItemData");
static_assert(sizeof(FDCLootDropRateItemData) == 0x000008, "Wrong size on FDCLootDropRateItemData");
static_assert(offsetof(FDCLootDropRateItemData, LuckGrade) == 0x000000, "Member 'FDCLootDropRateItemData::LuckGrade' has a wrong offset!");
static_assert(offsetof(FDCLootDropRateItemData, DropRate) == 0x000004, "Member 'FDCLootDropRateItemData::DropRate' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCLootDropGroupItemData
// 0x0058 (0x0058 - 0x0000)
struct FDCLootDropGroupItemData final
{
public:
	TSoftObjectPtr<class UDCLootDropDataAsset>    LootDropId;                                        // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCLootDropRateDataAsset> LootDropRateId;                                    // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LootDropCount;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2261[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCLootDropGroupItemData) == 0x000008, "Wrong alignment on FDCLootDropGroupItemData");
static_assert(sizeof(FDCLootDropGroupItemData) == 0x000058, "Wrong size on FDCLootDropGroupItemData");
static_assert(offsetof(FDCLootDropGroupItemData, LootDropId) == 0x000000, "Member 'FDCLootDropGroupItemData::LootDropId' has a wrong offset!");
static_assert(offsetof(FDCLootDropGroupItemData, LootDropRateId) == 0x000028, "Member 'FDCLootDropGroupItemData::LootDropRateId' has a wrong offset!");
static_assert(offsetof(FDCLootDropGroupItemData, LootDropCount) == 0x000050, "Member 'FDCLootDropGroupItemData::LootDropCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.LoadedMappableConfigPair
// 0x0010 (0x0010 - 0x0000)
struct FLoadedMappableConfigPair final
{
public:
	class UPlayerMappableInputConfig*             Config;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommonInputType                              Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2262[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadedMappableConfigPair) == 0x000008, "Wrong alignment on FLoadedMappableConfigPair");
static_assert(sizeof(FLoadedMappableConfigPair) == 0x000010, "Wrong size on FLoadedMappableConfigPair");
static_assert(offsetof(FLoadedMappableConfigPair, Config) == 0x000000, "Member 'FLoadedMappableConfigPair::Config' has a wrong offset!");
static_assert(offsetof(FLoadedMappableConfigPair, Type) == 0x000008, "Member 'FLoadedMappableConfigPair::Type' has a wrong offset!");
static_assert(offsetof(FLoadedMappableConfigPair, bIsActive) == 0x000009, "Member 'FLoadedMappableConfigPair::bIsActive' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMarketplaceSimpleInfo
// 0x0001 (0x0001 - 0x0000)
struct FDCMarketplaceSimpleInfo final
{
public:
	bool                                          bHasAnySoldItem;                                   // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCMarketplaceSimpleInfo) == 0x000001, "Wrong alignment on FDCMarketplaceSimpleInfo");
static_assert(sizeof(FDCMarketplaceSimpleInfo) == 0x000001, "Wrong size on FDCMarketplaceSimpleInfo");
static_assert(offsetof(FDCMarketplaceSimpleInfo, bHasAnySoldItem) == 0x000000, "Member 'FDCMarketplaceSimpleInfo::bHasAnySoldItem' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMarketplaceInfo
// 0x0020 (0x0020 - 0x0000)
struct FDCMarketplaceInfo final
{
public:
	int32                                         ConstListingFee;                                   // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2263[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ListingExpiredTime;                                // 0x0008(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              TransferExpiredTime;                               // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListingLimitCount;                                 // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPriceGoldCoinCount;                             // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCMarketplaceInfo) == 0x000008, "Wrong alignment on FDCMarketplaceInfo");
static_assert(sizeof(FDCMarketplaceInfo) == 0x000020, "Wrong size on FDCMarketplaceInfo");
static_assert(offsetof(FDCMarketplaceInfo, ConstListingFee) == 0x000000, "Member 'FDCMarketplaceInfo::ConstListingFee' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceInfo, ListingExpiredTime) == 0x000008, "Member 'FDCMarketplaceInfo::ListingExpiredTime' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceInfo, TransferExpiredTime) == 0x000010, "Member 'FDCMarketplaceInfo::TransferExpiredTime' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceInfo, ListingLimitCount) == 0x000018, "Member 'FDCMarketplaceInfo::ListingLimitCount' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceInfo, MaxPriceGoldCoinCount) == 0x00001C, "Member 'FDCMarketplaceInfo::MaxPriceGoldCoinCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.MerchantInfo
// 0x0038 (0x0038 - 0x0000)
struct FMerchantInfo final
{
public:
	struct FPrimaryAssetId                        MerchantId;                                        // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              RemainTime;                                        // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsUnidentified;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MerchantFlag;                                      // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Affinity;                                          // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        AffinityId;                                        // 0x0024(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2264[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMerchantInfo) == 0x000008, "Wrong alignment on FMerchantInfo");
static_assert(sizeof(FMerchantInfo) == 0x000038, "Wrong size on FMerchantInfo");
static_assert(offsetof(FMerchantInfo, MerchantId) == 0x000000, "Member 'FMerchantInfo::MerchantId' has a wrong offset!");
static_assert(offsetof(FMerchantInfo, RemainTime) == 0x000010, "Member 'FMerchantInfo::RemainTime' has a wrong offset!");
static_assert(offsetof(FMerchantInfo, IsUnidentified) == 0x000018, "Member 'FMerchantInfo::IsUnidentified' has a wrong offset!");
static_assert(offsetof(FMerchantInfo, MerchantFlag) == 0x00001C, "Member 'FMerchantInfo::MerchantFlag' has a wrong offset!");
static_assert(offsetof(FMerchantInfo, Affinity) == 0x000020, "Member 'FMerchantInfo::Affinity' has a wrong offset!");
static_assert(offsetof(FMerchantInfo, AffinityId) == 0x000024, "Member 'FMerchantInfo::AffinityId' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMarketplacePaymentItemInfo
// 0x0028 (0x0028 - 0x0000)
struct FDCMarketplacePaymentItemInfo final
{
public:
	struct FPrimaryAssetId                        PaymentItemId;                                     // 0x0000(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCItemDataAsset*                       PaymentData;                                       // 0x0010(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                AllowedPaymentItemContainers;                      // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCMarketplacePaymentItemInfo) == 0x000008, "Wrong alignment on FDCMarketplacePaymentItemInfo");
static_assert(sizeof(FDCMarketplacePaymentItemInfo) == 0x000028, "Wrong size on FDCMarketplacePaymentItemInfo");
static_assert(offsetof(FDCMarketplacePaymentItemInfo, PaymentItemId) == 0x000000, "Member 'FDCMarketplacePaymentItemInfo::PaymentItemId' has a wrong offset!");
static_assert(offsetof(FDCMarketplacePaymentItemInfo, PaymentData) == 0x000010, "Member 'FDCMarketplacePaymentItemInfo::PaymentData' has a wrong offset!");
static_assert(offsetof(FDCMarketplacePaymentItemInfo, AllowedPaymentItemContainers) == 0x000018, "Member 'FDCMarketplacePaymentItemInfo::AllowedPaymentItemContainers' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMarketplaceFilterInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCMarketplaceFilterInfo final
{
public:
	EDCMarketplaceFilterType                      Target;                                            // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2265[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Filters;                                           // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCMarketplaceFilterInfo) == 0x000008, "Wrong alignment on FDCMarketplaceFilterInfo");
static_assert(sizeof(FDCMarketplaceFilterInfo) == 0x000018, "Wrong size on FDCMarketplaceFilterInfo");
static_assert(offsetof(FDCMarketplaceFilterInfo, Target) == 0x000000, "Member 'FDCMarketplaceFilterInfo::Target' has a wrong offset!");
static_assert(offsetof(FDCMarketplaceFilterInfo, Filters) == 0x000008, "Member 'FDCMarketplaceFilterInfo::Filters' has a wrong offset!");

// ScriptStruct DungeonCrawler.FilterStringArray
// 0x0010 (0x0010 - 0x0000)
struct FFilterStringArray final
{
public:
	TArray<class FString>                         StringArray;                                       // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFilterStringArray) == 0x000008, "Wrong alignment on FFilterStringArray");
static_assert(sizeof(FFilterStringArray) == 0x000010, "Wrong size on FFilterStringArray");
static_assert(offsetof(FFilterStringArray, StringArray) == 0x000000, "Member 'FFilterStringArray::StringArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMaterialData
// 0x0018 (0x0018 - 0x0000)
struct FDCMaterialData final
{
public:
	uint8                                         Pad_2266[0x10];                                    // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     MaterialInterface;                                 // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCMaterialData) == 0x000008, "Wrong alignment on FDCMaterialData");
static_assert(sizeof(FDCMaterialData) == 0x000018, "Wrong size on FDCMaterialData");
static_assert(offsetof(FDCMaterialData, MaterialInterface) == 0x000010, "Member 'FDCMaterialData::MaterialInterface' has a wrong offset!");

// ScriptStruct DungeonCrawler.MerchantTradeResultItemSlotInfo
// 0x0028 (0x0028 - 0x0000)
struct FMerchantTradeResultItemSlotInfo final
{
public:
	int32                                         InventoryId;                                       // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotId;                                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemId;                                            // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ItemUniqueId;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemContentsCount;                                 // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMerchantTradeResultItemSlotInfo) == 0x000008, "Wrong alignment on FMerchantTradeResultItemSlotInfo");
static_assert(sizeof(FMerchantTradeResultItemSlotInfo) == 0x000028, "Wrong size on FMerchantTradeResultItemSlotInfo");
static_assert(offsetof(FMerchantTradeResultItemSlotInfo, InventoryId) == 0x000000, "Member 'FMerchantTradeResultItemSlotInfo::InventoryId' has a wrong offset!");
static_assert(offsetof(FMerchantTradeResultItemSlotInfo, SlotId) == 0x000004, "Member 'FMerchantTradeResultItemSlotInfo::SlotId' has a wrong offset!");
static_assert(offsetof(FMerchantTradeResultItemSlotInfo, ItemId) == 0x000008, "Member 'FMerchantTradeResultItemSlotInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FMerchantTradeResultItemSlotInfo, ItemUniqueId) == 0x000018, "Member 'FMerchantTradeResultItemSlotInfo::ItemUniqueId' has a wrong offset!");
static_assert(offsetof(FMerchantTradeResultItemSlotInfo, ItemCount) == 0x000020, "Member 'FMerchantTradeResultItemSlotInfo::ItemCount' has a wrong offset!");
static_assert(offsetof(FMerchantTradeResultItemSlotInfo, ItemContentsCount) == 0x000024, "Member 'FMerchantTradeResultItemSlotInfo::ItemContentsCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMaterialSetComponentData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FDCMaterialSetComponentData final
{
public:
	uint8                                         Pad_2267[0xC];                                     // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCMaterialSetComponentData) == 0x000004, "Wrong alignment on FDCMaterialSetComponentData");
static_assert(sizeof(FDCMaterialSetComponentData) == 0x00000C, "Wrong size on FDCMaterialSetComponentData");

// ScriptStruct DungeonCrawler.DCMaterialSetData
// 0x0070 (0x0070 - 0x0000)
struct FDCMaterialSetData final
{
public:
	class UMaterialInterface*                     OverrideMaterialInterface;                         // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2268[0x68];                                    // 0x0008(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCMaterialSetData) == 0x000008, "Wrong alignment on FDCMaterialSetData");
static_assert(sizeof(FDCMaterialSetData) == 0x000070, "Wrong size on FDCMaterialSetData");
static_assert(offsetof(FDCMaterialSetData, OverrideMaterialInterface) == 0x000000, "Member 'FDCMaterialSetData::OverrideMaterialInterface' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCBaseGearItemData
// 0x0060 (0x0060 - 0x0000)
struct FDCBaseGearItemData final
{
public:
	int64                                         UniqueID;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCItemDataAsset>        ItemId;                                            // 0x0008(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCMerchantDataAsset>    MerchantId;                                        // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAffinity;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2269[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCBaseGearItemData) == 0x000008, "Wrong alignment on FDCBaseGearItemData");
static_assert(sizeof(FDCBaseGearItemData) == 0x000060, "Wrong size on FDCBaseGearItemData");
static_assert(offsetof(FDCBaseGearItemData, UniqueID) == 0x000000, "Member 'FDCBaseGearItemData::UniqueID' has a wrong offset!");
static_assert(offsetof(FDCBaseGearItemData, ItemId) == 0x000008, "Member 'FDCBaseGearItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FDCBaseGearItemData, MerchantId) == 0x000030, "Member 'FDCBaseGearItemData::MerchantId' has a wrong offset!");
static_assert(offsetof(FDCBaseGearItemData, RequiredAffinity) == 0x000058, "Member 'FDCBaseGearItemData::RequiredAffinity' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSoundVolumeExit
// 0x0008 (0x0020 - 0x0018)
struct FMsgSoundVolumeExit final : public FMsgBase
{
public:
	class UPrimitiveComponent*                    Volume;                                            // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSoundVolumeExit) == 0x000008, "Wrong alignment on FMsgSoundVolumeExit");
static_assert(sizeof(FMsgSoundVolumeExit) == 0x000020, "Wrong size on FMsgSoundVolumeExit");
static_assert(offsetof(FMsgSoundVolumeExit, Volume) == 0x000018, "Member 'FMsgSoundVolumeExit::Volume' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCStockSellBackItemData
// 0x00E0 (0x00E0 - 0x0000)
struct FDCStockSellBackItemData final
{
public:
	int64                                         UniqueID;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ConversationText;                                  // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCItemDataAsset>        ItemId;                                            // 0x0020(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_226A[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        ReceivedItemId_01;                                 // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReceivedAmount01;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_226B[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        ReceivedItemId_02;                                 // 0x0080(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReceivedAmount02;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_226C[0x4];                                     // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        ReceivedItemId_03;                                 // 0x00B0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReceivedAmount03;                                  // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_226D[0x4];                                     // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCStockSellBackItemData) == 0x000008, "Wrong alignment on FDCStockSellBackItemData");
static_assert(sizeof(FDCStockSellBackItemData) == 0x0000E0, "Wrong size on FDCStockSellBackItemData");
static_assert(offsetof(FDCStockSellBackItemData, UniqueID) == 0x000000, "Member 'FDCStockSellBackItemData::UniqueID' has a wrong offset!");
static_assert(offsetof(FDCStockSellBackItemData, ConversationText) == 0x000008, "Member 'FDCStockSellBackItemData::ConversationText' has a wrong offset!");
static_assert(offsetof(FDCStockSellBackItemData, ItemId) == 0x000020, "Member 'FDCStockSellBackItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FDCStockSellBackItemData, ItemCount) == 0x000048, "Member 'FDCStockSellBackItemData::ItemCount' has a wrong offset!");
static_assert(offsetof(FDCStockSellBackItemData, ReceivedItemId_01) == 0x000050, "Member 'FDCStockSellBackItemData::ReceivedItemId_01' has a wrong offset!");
static_assert(offsetof(FDCStockSellBackItemData, ReceivedAmount01) == 0x000078, "Member 'FDCStockSellBackItemData::ReceivedAmount01' has a wrong offset!");
static_assert(offsetof(FDCStockSellBackItemData, ReceivedItemId_02) == 0x000080, "Member 'FDCStockSellBackItemData::ReceivedItemId_02' has a wrong offset!");
static_assert(offsetof(FDCStockSellBackItemData, ReceivedAmount02) == 0x0000A8, "Member 'FDCStockSellBackItemData::ReceivedAmount02' has a wrong offset!");
static_assert(offsetof(FDCStockSellBackItemData, ReceivedItemId_03) == 0x0000B0, "Member 'FDCStockSellBackItemData::ReceivedItemId_03' has a wrong offset!");
static_assert(offsetof(FDCStockSellBackItemData, ReceivedAmount03) == 0x0000D8, "Member 'FDCStockSellBackItemData::ReceivedAmount03' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCStockBuyItemData
// 0x0150 (0x0150 - 0x0000)
struct FDCStockBuyItemData final
{
public:
	int64                                         UniqueID;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ConversationText;                                  // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SaleCompleteText;                                  // 0x0020(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCItemDataAsset>        ItemId;                                            // 0x0038(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCItemDataAsset>        RequiredItemId_01;                                 // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount01;                                  // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_226E[0x4];                                     // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        RequiredItemId_02;                                 // 0x0090(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount02;                                  // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_226F[0x4];                                     // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        RequiredItemId_03;                                 // 0x00C0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount03;                                  // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2270[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        RequiredItemId_04;                                 // 0x00F0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount04;                                  // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2271[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDCItemDataAsset>        RequiredItemId_05;                                 // 0x0120(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount05;                                  // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2272[0x4];                                     // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCStockBuyItemData) == 0x000008, "Wrong alignment on FDCStockBuyItemData");
static_assert(sizeof(FDCStockBuyItemData) == 0x000150, "Wrong size on FDCStockBuyItemData");
static_assert(offsetof(FDCStockBuyItemData, UniqueID) == 0x000000, "Member 'FDCStockBuyItemData::UniqueID' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, ConversationText) == 0x000008, "Member 'FDCStockBuyItemData::ConversationText' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, SaleCompleteText) == 0x000020, "Member 'FDCStockBuyItemData::SaleCompleteText' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, ItemId) == 0x000038, "Member 'FDCStockBuyItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, RequiredItemId_01) == 0x000060, "Member 'FDCStockBuyItemData::RequiredItemId_01' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, RequiredAmount01) == 0x000088, "Member 'FDCStockBuyItemData::RequiredAmount01' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, RequiredItemId_02) == 0x000090, "Member 'FDCStockBuyItemData::RequiredItemId_02' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, RequiredAmount02) == 0x0000B8, "Member 'FDCStockBuyItemData::RequiredAmount02' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, RequiredItemId_03) == 0x0000C0, "Member 'FDCStockBuyItemData::RequiredItemId_03' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, RequiredAmount03) == 0x0000E8, "Member 'FDCStockBuyItemData::RequiredAmount03' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, RequiredItemId_04) == 0x0000F0, "Member 'FDCStockBuyItemData::RequiredItemId_04' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, RequiredAmount04) == 0x000118, "Member 'FDCStockBuyItemData::RequiredAmount04' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, RequiredItemId_05) == 0x000120, "Member 'FDCStockBuyItemData::RequiredItemId_05' has a wrong offset!");
static_assert(offsetof(FDCStockBuyItemData, RequiredAmount05) == 0x000148, "Member 'FDCStockBuyItemData::RequiredAmount05' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMerchantId
// 0x0000 (0x0010 - 0x0010)
struct FDCMerchantId final : public FDCStringIdBase
{
};
static_assert(alignof(FDCMerchantId) == 0x000008, "Wrong alignment on FDCMerchantId");
static_assert(sizeof(FDCMerchantId) == 0x000010, "Wrong size on FDCMerchantId");

// ScriptStruct DungeonCrawler.DCMerchantInfo
// 0x0040 (0x0040 - 0x0000)
struct FDCMerchantInfo final
{
public:
	struct FDCMerchantId                          MerchantId;                                        // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Affinity;                                          // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2273[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AffinityName;                                      // 0x0018(0x0018)(Transient, NativeAccessSpecifierPublic)
	int32                                         MerchantFlag;                                      // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpireTime;                                        // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2274[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCMerchantInfo) == 0x000008, "Wrong alignment on FDCMerchantInfo");
static_assert(sizeof(FDCMerchantInfo) == 0x000040, "Wrong size on FDCMerchantInfo");
static_assert(offsetof(FDCMerchantInfo, MerchantId) == 0x000000, "Member 'FDCMerchantInfo::MerchantId' has a wrong offset!");
static_assert(offsetof(FDCMerchantInfo, Affinity) == 0x000010, "Member 'FDCMerchantInfo::Affinity' has a wrong offset!");
static_assert(offsetof(FDCMerchantInfo, AffinityName) == 0x000018, "Member 'FDCMerchantInfo::AffinityName' has a wrong offset!");
static_assert(offsetof(FDCMerchantInfo, MerchantFlag) == 0x000030, "Member 'FDCMerchantInfo::MerchantFlag' has a wrong offset!");
static_assert(offsetof(FDCMerchantInfo, ExpireTime) == 0x000034, "Member 'FDCMerchantInfo::ExpireTime' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCPartyInfo
// 0x0030 (0x0030 - 0x0000)
struct FDCPartyInfo final
{
public:
	struct FDCPartyId                             PartyId;                                           // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDCAccountId>                   MemberAccounts;                                    // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FDCAccountId                           LeaderAccount;                                     // 0x0020(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCPartyInfo) == 0x000008, "Wrong alignment on FDCPartyInfo");
static_assert(sizeof(FDCPartyInfo) == 0x000030, "Wrong size on FDCPartyInfo");
static_assert(offsetof(FDCPartyInfo, PartyId) == 0x000000, "Member 'FDCPartyInfo::PartyId' has a wrong offset!");
static_assert(offsetof(FDCPartyInfo, MemberAccounts) == 0x000010, "Member 'FDCPartyInfo::MemberAccounts' has a wrong offset!");
static_assert(offsetof(FDCPartyInfo, LeaderAccount) == 0x000020, "Member 'FDCPartyInfo::LeaderAccount' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSpellCastStart
// 0x0020 (0x0038 - 0x0018)
struct FMsgSpellCastStart final : public FMsgBase
{
public:
	float                                         Duration;                                          // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2275[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0020(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSpellCastStart) == 0x000008, "Wrong alignment on FMsgSpellCastStart");
static_assert(sizeof(FMsgSpellCastStart) == 0x000038, "Wrong size on FMsgSpellCastStart");
static_assert(offsetof(FMsgSpellCastStart, Duration) == 0x000018, "Member 'FMsgSpellCastStart::Duration' has a wrong offset!");
static_assert(offsetof(FMsgSpellCastStart, Description) == 0x000020, "Member 'FMsgSpellCastStart::Description' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemBoneModify
// 0x0058 (0x0058 - 0x0000)
struct FDCItemBoneModify final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCItemId                              ItemId;                                            // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemBoneModifyData                    ItemBoneModifyData;                                // 0x0010(0x0048)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCItemBoneModify) == 0x000008, "Wrong alignment on FDCItemBoneModify");
static_assert(sizeof(FDCItemBoneModify) == 0x000058, "Wrong size on FDCItemBoneModify");
static_assert(offsetof(FDCItemBoneModify, BoneName) == 0x000000, "Member 'FDCItemBoneModify::BoneName' has a wrong offset!");
static_assert(offsetof(FDCItemBoneModify, ItemId) == 0x000008, "Member 'FDCItemBoneModify::ItemId' has a wrong offset!");
static_assert(offsetof(FDCItemBoneModify, ItemBoneModifyData) == 0x000010, "Member 'FDCItemBoneModify::ItemBoneModifyData' has a wrong offset!");

// ScriptStruct DungeonCrawler.GMEffectHandleType
// 0x0050 (0x0050 - 0x0000)
struct FGMEffectHandleType final
{
public:
	TMap<struct FPrimaryAssetId, struct FActiveGameplayEffectHandle> GMEffectHandleMap;                                 // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGMEffectHandleType) == 0x000008, "Wrong alignment on FGMEffectHandleType");
static_assert(sizeof(FGMEffectHandleType) == 0x000050, "Wrong size on FGMEffectHandleType");
static_assert(offsetof(FGMEffectHandleType, GMEffectHandleMap) == 0x000000, "Member 'FGMEffectHandleType::GMEffectHandleMap' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCPersonalPlayerInfo
// 0x0038 (0x0038 - 0x0000)
struct FDCPersonalPlayerInfo final
{
public:
	TArray<struct FDCQuestInfo>                   LastQuests;                                        // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCQuestInfo>                   Quests;                                            // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bHasDamaged;                                       // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEscape;                                         // 0x0021(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanEscape;                                        // 0x0022(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAlive;                                          // 0x0023(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2276[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCAccountId                           AccountId;                                         // 0x0028(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCPersonalPlayerInfo) == 0x000008, "Wrong alignment on FDCPersonalPlayerInfo");
static_assert(sizeof(FDCPersonalPlayerInfo) == 0x000038, "Wrong size on FDCPersonalPlayerInfo");
static_assert(offsetof(FDCPersonalPlayerInfo, LastQuests) == 0x000000, "Member 'FDCPersonalPlayerInfo::LastQuests' has a wrong offset!");
static_assert(offsetof(FDCPersonalPlayerInfo, Quests) == 0x000010, "Member 'FDCPersonalPlayerInfo::Quests' has a wrong offset!");
static_assert(offsetof(FDCPersonalPlayerInfo, bHasDamaged) == 0x000020, "Member 'FDCPersonalPlayerInfo::bHasDamaged' has a wrong offset!");
static_assert(offsetof(FDCPersonalPlayerInfo, bIsEscape) == 0x000021, "Member 'FDCPersonalPlayerInfo::bIsEscape' has a wrong offset!");
static_assert(offsetof(FDCPersonalPlayerInfo, bCanEscape) == 0x000022, "Member 'FDCPersonalPlayerInfo::bCanEscape' has a wrong offset!");
static_assert(offsetof(FDCPersonalPlayerInfo, bIsAlive) == 0x000023, "Member 'FDCPersonalPlayerInfo::bIsAlive' has a wrong offset!");
static_assert(offsetof(FDCPersonalPlayerInfo, AccountId) == 0x000028, "Member 'FDCPersonalPlayerInfo::AccountId' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCQuestLogInfo
// 0x0020 (0x0020 - 0x0000)
struct FDCQuestLogInfo final
{
public:
	TArray<struct FDCQuestInfo>                   QuestInfoArray;                                    // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 MerchantId;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCQuestLogInfo) == 0x000008, "Wrong alignment on FDCQuestLogInfo");
static_assert(sizeof(FDCQuestLogInfo) == 0x000020, "Wrong size on FDCQuestLogInfo");
static_assert(offsetof(FDCQuestLogInfo, QuestInfoArray) == 0x000000, "Member 'FDCQuestLogInfo::QuestInfoArray' has a wrong offset!");
static_assert(offsetof(FDCQuestLogInfo, MerchantId) == 0x000010, "Member 'FDCQuestLogInfo::MerchantId' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCQuestChapterInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCQuestChapterInfo final
{
public:
	class UDCQuestChapterDataAsset*               QuestChapterData;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCQuestInfo>                   QuestInfoArray;                                    // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCQuestChapterInfo) == 0x000008, "Wrong alignment on FDCQuestChapterInfo");
static_assert(sizeof(FDCQuestChapterInfo) == 0x000018, "Wrong size on FDCQuestChapterInfo");
static_assert(offsetof(FDCQuestChapterInfo, QuestChapterData) == 0x000000, "Member 'FDCQuestChapterInfo::QuestChapterData' has a wrong offset!");
static_assert(offsetof(FDCQuestChapterInfo, QuestInfoArray) == 0x000008, "Member 'FDCQuestChapterInfo::QuestInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCQuestCompleteInfo
// 0x0028 (0x0028 - 0x0000)
struct FDCQuestCompleteInfo final
{
public:
	struct FDCMerchantId                          MerchantId;                                        // 0x0000(0x0010)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CompleteText;                                      // 0x0010(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCQuestCompleteInfo) == 0x000008, "Wrong alignment on FDCQuestCompleteInfo");
static_assert(sizeof(FDCQuestCompleteInfo) == 0x000028, "Wrong size on FDCQuestCompleteInfo");
static_assert(offsetof(FDCQuestCompleteInfo, MerchantId) == 0x000000, "Member 'FDCQuestCompleteInfo::MerchantId' has a wrong offset!");
static_assert(offsetof(FDCQuestCompleteInfo, CompleteText) == 0x000010, "Member 'FDCQuestCompleteInfo::CompleteText' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassSkillListResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgGameTestClassSkillListResponse final : public FMsgBase
{
public:
	TArray<struct FAccountDataSkill>              Skills;                                            // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassSkillListResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassSkillListResponse");
static_assert(sizeof(FMsgGameTestClassSkillListResponse) == 0x000028, "Wrong size on FMsgGameTestClassSkillListResponse");
static_assert(offsetof(FMsgGameTestClassSkillListResponse, Skills) == 0x000018, "Member 'FMsgGameTestClassSkillListResponse::Skills' has a wrong offset!");

// ScriptStruct DungeonCrawler.NickNameWidgetData
// 0x0010 (0x0010 - 0x0000)
struct FNickNameWidgetData final
{
public:
	class FString                                 NickNameStr;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNickNameWidgetData) == 0x000008, "Wrong alignment on FNickNameWidgetData");
static_assert(sizeof(FNickNameWidgetData) == 0x000010, "Wrong size on FNickNameWidgetData");
static_assert(offsetof(FNickNameWidgetData, NickNameStr) == 0x000000, "Member 'FNickNameWidgetData::NickNameStr' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCQuestContentWidgetInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCQuestContentWidgetInfo final
{
public:
	TArray<struct FDCQuestContentInfo>            QuestContents;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCQuestContentWidgetInfo) == 0x000008, "Wrong alignment on FDCQuestContentWidgetInfo");
static_assert(sizeof(FDCQuestContentWidgetInfo) == 0x000010, "Wrong size on FDCQuestContentWidgetInfo");
static_assert(offsetof(FDCQuestContentWidgetInfo, QuestContents) == 0x000000, "Member 'FDCQuestContentWidgetInfo::QuestContents' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCQuestContentWidgetInfoArray
// 0x0010 (0x0010 - 0x0000)
struct FDCQuestContentWidgetInfoArray final
{
public:
	TArray<struct FDCQuestContentWidgetInfo>      WidgetInfoArray;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCQuestContentWidgetInfoArray) == 0x000008, "Wrong alignment on FDCQuestContentWidgetInfoArray");
static_assert(sizeof(FDCQuestContentWidgetInfoArray) == 0x000010, "Wrong size on FDCQuestContentWidgetInfoArray");
static_assert(offsetof(FDCQuestContentWidgetInfoArray, WidgetInfoArray) == 0x000000, "Member 'FDCQuestContentWidgetInfoArray::WidgetInfoArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPartyDataNotify
// 0x0020 (0x0038 - 0x0018)
struct FMsgPartyDataNotify final : public FMsgBase
{
public:
	struct FPartyData                             PartyData;                                         // 0x0018(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPartyDataNotify) == 0x000008, "Wrong alignment on FMsgPartyDataNotify");
static_assert(sizeof(FMsgPartyDataNotify) == 0x000038, "Wrong size on FMsgPartyDataNotify");
static_assert(offsetof(FMsgPartyDataNotify, PartyData) == 0x000018, "Member 'FMsgPartyDataNotify::PartyData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCRecruitInspectInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FDCRecruitInspectInfo final
{
public:
	struct FDCChannelPlayerInfo                   ChannelPlayer;                                     // 0x0000(0x0080)(Transient, NativeAccessSpecifierPrivate)
	TArray<int32>                                 Indexes;                                           // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FDCItemInfo>                    Values;                                            // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<int32, struct FDCItemInfo>               Items;                                             // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCRecruitInspectInfo) == 0x000008, "Wrong alignment on FDCRecruitInspectInfo");
static_assert(sizeof(FDCRecruitInspectInfo) == 0x0000F0, "Wrong size on FDCRecruitInspectInfo");
static_assert(offsetof(FDCRecruitInspectInfo, ChannelPlayer) == 0x000000, "Member 'FDCRecruitInspectInfo::ChannelPlayer' has a wrong offset!");
static_assert(offsetof(FDCRecruitInspectInfo, Indexes) == 0x000080, "Member 'FDCRecruitInspectInfo::Indexes' has a wrong offset!");
static_assert(offsetof(FDCRecruitInspectInfo, Values) == 0x000090, "Member 'FDCRecruitInspectInfo::Values' has a wrong offset!");
static_assert(offsetof(FDCRecruitInspectInfo, Items) == 0x0000A0, "Member 'FDCRecruitInspectInfo::Items' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCReligionInfo
// 0x0040 (0x0040 - 0x0000)
struct FDCReligionInfo final
{
public:
	class FString                                 ReligionId;                                        // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SeasonId;                                          // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         SeasonOffering;                                    // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         WeeklyOffering;                                    // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         OverallTime;                                       // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentBlessingLevel;                              // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2277[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCReligionInfo) == 0x000008, "Wrong alignment on FDCReligionInfo");
static_assert(sizeof(FDCReligionInfo) == 0x000040, "Wrong size on FDCReligionInfo");
static_assert(offsetof(FDCReligionInfo, ReligionId) == 0x000000, "Member 'FDCReligionInfo::ReligionId' has a wrong offset!");
static_assert(offsetof(FDCReligionInfo, SeasonId) == 0x000010, "Member 'FDCReligionInfo::SeasonId' has a wrong offset!");
static_assert(offsetof(FDCReligionInfo, SeasonOffering) == 0x000020, "Member 'FDCReligionInfo::SeasonOffering' has a wrong offset!");
static_assert(offsetof(FDCReligionInfo, WeeklyOffering) == 0x000028, "Member 'FDCReligionInfo::WeeklyOffering' has a wrong offset!");
static_assert(offsetof(FDCReligionInfo, OverallTime) == 0x000030, "Member 'FDCReligionInfo::OverallTime' has a wrong offset!");
static_assert(offsetof(FDCReligionInfo, CurrentBlessingLevel) == 0x000038, "Member 'FDCReligionInfo::CurrentBlessingLevel' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCReligionRankInfo
// 0x0020 (0x0020 - 0x0000)
struct FDCReligionRankInfo final
{
public:
	class FString                                 ReligionId;                                        // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCReligionRankEntryInfo>       RankList;                                          // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCReligionRankInfo) == 0x000008, "Wrong alignment on FDCReligionRankInfo");
static_assert(sizeof(FDCReligionRankInfo) == 0x000020, "Wrong size on FDCReligionRankInfo");
static_assert(offsetof(FDCReligionRankInfo, ReligionId) == 0x000000, "Member 'FDCReligionRankInfo::ReligionId' has a wrong offset!");
static_assert(offsetof(FDCReligionRankInfo, RankList) == 0x000010, "Member 'FDCReligionRankInfo::RankList' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassItemMoveResponse
// 0x0078 (0x0090 - 0x0018)
struct FMsgGameTestClassItemMoveResponse final : public FMsgBase
{
public:
	int32                                         Result;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2278[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMsgGameClassMoveInfo                  OldMove;                                           // 0x0020(0x0038)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMsgGameClassMoveInfo                  NewMove;                                           // 0x0058(0x0038)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassItemMoveResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassItemMoveResponse");
static_assert(sizeof(FMsgGameTestClassItemMoveResponse) == 0x000090, "Wrong size on FMsgGameTestClassItemMoveResponse");
static_assert(offsetof(FMsgGameTestClassItemMoveResponse, Result) == 0x000018, "Member 'FMsgGameTestClassItemMoveResponse::Result' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassItemMoveResponse, OldMove) == 0x000020, "Member 'FMsgGameTestClassItemMoveResponse::OldMove' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassItemMoveResponse, NewMove) == 0x000058, "Member 'FMsgGameTestClassItemMoveResponse::NewMove' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPartySessionArrayRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgPartySessionArrayRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgPartySessionArrayRequest) == 0x000008, "Wrong alignment on FMsgPartySessionArrayRequest");
static_assert(sizeof(FMsgPartySessionArrayRequest) == 0x000018, "Wrong size on FMsgPartySessionArrayRequest");

// ScriptStruct DungeonCrawler.ReligionRankTimerInfo
// 0x0010 (0x0010 - 0x0000)
struct FReligionRankTimerInfo final
{
public:
	int32                                         SeasonDays;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeasonHours;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeasonMinutes;                                     // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeasonSeconds;                                     // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReligionRankTimerInfo) == 0x000004, "Wrong alignment on FReligionRankTimerInfo");
static_assert(sizeof(FReligionRankTimerInfo) == 0x000010, "Wrong size on FReligionRankTimerInfo");
static_assert(offsetof(FReligionRankTimerInfo, SeasonDays) == 0x000000, "Member 'FReligionRankTimerInfo::SeasonDays' has a wrong offset!");
static_assert(offsetof(FReligionRankTimerInfo, SeasonHours) == 0x000004, "Member 'FReligionRankTimerInfo::SeasonHours' has a wrong offset!");
static_assert(offsetof(FReligionRankTimerInfo, SeasonMinutes) == 0x000008, "Member 'FReligionRankTimerInfo::SeasonMinutes' has a wrong offset!");
static_assert(offsetof(FReligionRankTimerInfo, SeasonSeconds) == 0x00000C, "Member 'FReligionRankTimerInfo::SeasonSeconds' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCReligionBlessingLevelWidgetData
// 0x0040 (0x0040 - 0x0000)
struct FDCReligionBlessingLevelWidgetData final
{
public:
	int32                                         CurrentLevel;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2279[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   BlessingId;                                        // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         BlessingLevel;                                     // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_227A[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   BlessingBurfText;                                  // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCReligionBlessingLevelWidgetData) == 0x000008, "Wrong alignment on FDCReligionBlessingLevelWidgetData");
static_assert(sizeof(FDCReligionBlessingLevelWidgetData) == 0x000040, "Wrong size on FDCReligionBlessingLevelWidgetData");
static_assert(offsetof(FDCReligionBlessingLevelWidgetData, CurrentLevel) == 0x000000, "Member 'FDCReligionBlessingLevelWidgetData::CurrentLevel' has a wrong offset!");
static_assert(offsetof(FDCReligionBlessingLevelWidgetData, BlessingId) == 0x000008, "Member 'FDCReligionBlessingLevelWidgetData::BlessingId' has a wrong offset!");
static_assert(offsetof(FDCReligionBlessingLevelWidgetData, BlessingLevel) == 0x000020, "Member 'FDCReligionBlessingLevelWidgetData::BlessingLevel' has a wrong offset!");
static_assert(offsetof(FDCReligionBlessingLevelWidgetData, BlessingBurfText) == 0x000028, "Member 'FDCReligionBlessingLevelWidgetData::BlessingBurfText' has a wrong offset!");

// ScriptStruct DungeonCrawler.ReligionRankRecordMineData
// 0x0048 (0x0048 - 0x0000)
struct FReligionRankRecordMineData final
{
public:
	struct FDCReligionRankEntryInfo               RankRecordData;                                    // 0x0000(0x0048)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReligionRankRecordMineData) == 0x000008, "Wrong alignment on FReligionRankRecordMineData");
static_assert(sizeof(FReligionRankRecordMineData) == 0x000048, "Wrong size on FReligionRankRecordMineData");
static_assert(offsetof(FReligionRankRecordMineData, RankRecordData) == 0x000000, "Member 'FReligionRankRecordMineData::RankRecordData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassMusicSlotMoveResponse
// 0x0018 (0x0030 - 0x0018)
struct FMsgGameTestClassMusicSlotMoveResponse final : public FMsgBase
{
public:
	int32                                         Result;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_227B[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAccountDataMusic>              EquipMusicList;                                    // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassMusicSlotMoveResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassMusicSlotMoveResponse");
static_assert(sizeof(FMsgGameTestClassMusicSlotMoveResponse) == 0x000030, "Wrong size on FMsgGameTestClassMusicSlotMoveResponse");
static_assert(offsetof(FMsgGameTestClassMusicSlotMoveResponse, Result) == 0x000018, "Member 'FMsgGameTestClassMusicSlotMoveResponse::Result' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassMusicSlotMoveResponse, EquipMusicList) == 0x000020, "Member 'FMsgGameTestClassMusicSlotMoveResponse::EquipMusicList' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPerkIdArrayNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgPerkIdArrayNotify final : public FMsgBase
{
public:
	TArray<struct FPrimaryAssetId>                PerkIdArray;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPerkIdArrayNotify) == 0x000008, "Wrong alignment on FMsgPerkIdArrayNotify");
static_assert(sizeof(FMsgPerkIdArrayNotify) == 0x000028, "Wrong size on FMsgPerkIdArrayNotify");
static_assert(offsetof(FMsgPerkIdArrayNotify, PerkIdArray) == 0x000018, "Member 'FMsgPerkIdArrayNotify::PerkIdArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ReligionRankRecordMineWidgetHandleData
// 0x0048 (0x0048 - 0x0000)
struct FReligionRankRecordMineWidgetHandleData final
{
public:
	struct FReligionRankRecordMineData            ReligionRankRecordMineData;                        // 0x0000(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReligionRankRecordMineWidgetHandleData) == 0x000008, "Wrong alignment on FReligionRankRecordMineWidgetHandleData");
static_assert(sizeof(FReligionRankRecordMineWidgetHandleData) == 0x000048, "Wrong size on FReligionRankRecordMineWidgetHandleData");
static_assert(offsetof(FReligionRankRecordMineWidgetHandleData, ReligionRankRecordMineData) == 0x000000, "Member 'FReligionRankRecordMineWidgetHandleData::ReligionRankRecordMineData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCReportPlayerInfo
// 0x0088 (0x0088 - 0x0000)
struct FDCReportPlayerInfo final
{
public:
	struct FDCAccountId                           ReporterAccountId;                                 // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCAccountId                           TargetAccountId;                                   // 0x0010(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              TargetNickname;                                    // 0x0020(0x0040)(Transient, NativeAccessSpecifierPublic)
	struct FDCCharacterId                         TargetCharacterId;                                 // 0x0060(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCReportPlayerCategory                       ReportCategory;                                    // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_227C[0x7];                                     // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReportText;                                        // 0x0078(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCReportPlayerInfo) == 0x000008, "Wrong alignment on FDCReportPlayerInfo");
static_assert(sizeof(FDCReportPlayerInfo) == 0x000088, "Wrong size on FDCReportPlayerInfo");
static_assert(offsetof(FDCReportPlayerInfo, ReporterAccountId) == 0x000000, "Member 'FDCReportPlayerInfo::ReporterAccountId' has a wrong offset!");
static_assert(offsetof(FDCReportPlayerInfo, TargetAccountId) == 0x000010, "Member 'FDCReportPlayerInfo::TargetAccountId' has a wrong offset!");
static_assert(offsetof(FDCReportPlayerInfo, TargetNickname) == 0x000020, "Member 'FDCReportPlayerInfo::TargetNickname' has a wrong offset!");
static_assert(offsetof(FDCReportPlayerInfo, TargetCharacterId) == 0x000060, "Member 'FDCReportPlayerInfo::TargetCharacterId' has a wrong offset!");
static_assert(offsetof(FDCReportPlayerInfo, ReportCategory) == 0x000070, "Member 'FDCReportPlayerInfo::ReportCategory' has a wrong offset!");
static_assert(offsetof(FDCReportPlayerInfo, ReportText) == 0x000078, "Member 'FDCReportPlayerInfo::ReportText' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCReportPlayerResultInfo
// 0x0050 (0x0050 - 0x0000)
struct FDCReportPlayerResultInfo final
{
public:
	EDCReportPlayerResultType                     ResultType;                                        // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_227D[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNickname                              TargetNickname;                                    // 0x0008(0x0040)(Transient, NativeAccessSpecifierPrivate)
	struct FDateTime                              ProcessedDate;                                     // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCReportPlayerResultInfo) == 0x000008, "Wrong alignment on FDCReportPlayerResultInfo");
static_assert(sizeof(FDCReportPlayerResultInfo) == 0x000050, "Wrong size on FDCReportPlayerResultInfo");
static_assert(offsetof(FDCReportPlayerResultInfo, ResultType) == 0x000000, "Member 'FDCReportPlayerResultInfo::ResultType' has a wrong offset!");
static_assert(offsetof(FDCReportPlayerResultInfo, TargetNickname) == 0x000008, "Member 'FDCReportPlayerResultInfo::TargetNickname' has a wrong offset!");
static_assert(offsetof(FDCReportPlayerResultInfo, ProcessedDate) == 0x000048, "Member 'FDCReportPlayerResultInfo::ProcessedDate' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCRewardItemData
// 0x0048 (0x0048 - 0x0000)
struct FDCRewardItemData final
{
public:
	EDCRewardType                                 RewardType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_227E[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RewardId;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardCount;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_227F[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UArtDataRewardItem>      ArtData;                                           // 0x0020(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCRewardItemData) == 0x000008, "Wrong alignment on FDCRewardItemData");
static_assert(sizeof(FDCRewardItemData) == 0x000048, "Wrong size on FDCRewardItemData");
static_assert(offsetof(FDCRewardItemData, RewardType) == 0x000000, "Member 'FDCRewardItemData::RewardType' has a wrong offset!");
static_assert(offsetof(FDCRewardItemData, RewardId) == 0x000008, "Member 'FDCRewardItemData::RewardId' has a wrong offset!");
static_assert(offsetof(FDCRewardItemData, RewardCount) == 0x000018, "Member 'FDCRewardItemData::RewardCount' has a wrong offset!");
static_assert(offsetof(FDCRewardItemData, ArtData) == 0x000020, "Member 'FDCRewardItemData::ArtData' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardRankRecordWidgetHandleData
// 0x0078 (0x0078 - 0x0000)
struct FLeaderboardRankRecordWidgetHandleData final
{
public:
	struct FLeaderboardRankRecordData             LeaderboardRankRecordData;                         // 0x0000(0x0078)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeaderboardRankRecordWidgetHandleData) == 0x000008, "Wrong alignment on FLeaderboardRankRecordWidgetHandleData");
static_assert(sizeof(FLeaderboardRankRecordWidgetHandleData) == 0x000078, "Wrong size on FLeaderboardRankRecordWidgetHandleData");
static_assert(offsetof(FLeaderboardRankRecordWidgetHandleData, LeaderboardRankRecordData) == 0x000000, "Member 'FLeaderboardRankRecordWidgetHandleData::LeaderboardRankRecordData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCRewardInfo
// 0x0020 (0x0020 - 0x0000)
struct FDCRewardInfo final
{
public:
	EDCRewardType                                 RewardType;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2280[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        RewardAssetId;                                     // 0x0004(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardCount;                                       // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArtDataRewardItem*                     ArtDataRewardItem;                                 // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCRewardInfo) == 0x000008, "Wrong alignment on FDCRewardInfo");
static_assert(sizeof(FDCRewardInfo) == 0x000020, "Wrong size on FDCRewardInfo");
static_assert(offsetof(FDCRewardInfo, RewardType) == 0x000000, "Member 'FDCRewardInfo::RewardType' has a wrong offset!");
static_assert(offsetof(FDCRewardInfo, RewardAssetId) == 0x000004, "Member 'FDCRewardInfo::RewardAssetId' has a wrong offset!");
static_assert(offsetof(FDCRewardInfo, RewardCount) == 0x000014, "Member 'FDCRewardInfo::RewardCount' has a wrong offset!");
static_assert(offsetof(FDCRewardInfo, ArtDataRewardItem) == 0x000018, "Member 'FDCRewardInfo::ArtDataRewardItem' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCRopeMoveData
// 0x0020 (0x0020 - 0x0000)
struct FDCRopeMoveData final
{
public:
	EDCRopeMoveType                               RopeMoveType;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2281[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RopeMoveStartServerWorldTime;                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RopeHeightFrom;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RopeHeightTo;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RopeMoveDuration;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2282[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADCPlayerCharacterBase*                 PlayerCharacter;                                   // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCRopeMoveData) == 0x000008, "Wrong alignment on FDCRopeMoveData");
static_assert(sizeof(FDCRopeMoveData) == 0x000020, "Wrong size on FDCRopeMoveData");
static_assert(offsetof(FDCRopeMoveData, RopeMoveType) == 0x000000, "Member 'FDCRopeMoveData::RopeMoveType' has a wrong offset!");
static_assert(offsetof(FDCRopeMoveData, RopeMoveStartServerWorldTime) == 0x000004, "Member 'FDCRopeMoveData::RopeMoveStartServerWorldTime' has a wrong offset!");
static_assert(offsetof(FDCRopeMoveData, RopeHeightFrom) == 0x000008, "Member 'FDCRopeMoveData::RopeHeightFrom' has a wrong offset!");
static_assert(offsetof(FDCRopeMoveData, RopeHeightTo) == 0x00000C, "Member 'FDCRopeMoveData::RopeHeightTo' has a wrong offset!");
static_assert(offsetof(FDCRopeMoveData, RopeMoveDuration) == 0x000010, "Member 'FDCRopeMoveData::RopeMoveDuration' has a wrong offset!");
static_assert(offsetof(FDCRopeMoveData, PlayerCharacter) == 0x000018, "Member 'FDCRopeMoveData::PlayerCharacter' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCAccountStatusUpgradeShopInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCAccountStatusUpgradeShopInfo final
{
public:
	EDCShopCurrencyType                           Currency;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2283[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShopURL;                                           // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCAccountStatusUpgradeShopInfo) == 0x000008, "Wrong alignment on FDCAccountStatusUpgradeShopInfo");
static_assert(sizeof(FDCAccountStatusUpgradeShopInfo) == 0x000018, "Wrong size on FDCAccountStatusUpgradeShopInfo");
static_assert(offsetof(FDCAccountStatusUpgradeShopInfo, Currency) == 0x000000, "Member 'FDCAccountStatusUpgradeShopInfo::Currency' has a wrong offset!");
static_assert(offsetof(FDCAccountStatusUpgradeShopInfo, Price) == 0x000004, "Member 'FDCAccountStatusUpgradeShopInfo::Price' has a wrong offset!");
static_assert(offsetof(FDCAccountStatusUpgradeShopInfo, ShopURL) == 0x000008, "Member 'FDCAccountStatusUpgradeShopInfo::ShopURL' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCAccountNameChangeShopInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCAccountNameChangeShopInfo final
{
public:
	EDCShopCurrencyType                           Currency;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2284[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ShopURL;                                           // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCAccountNameChangeShopInfo) == 0x000008, "Wrong alignment on FDCAccountNameChangeShopInfo");
static_assert(sizeof(FDCAccountNameChangeShopInfo) == 0x000018, "Wrong size on FDCAccountNameChangeShopInfo");
static_assert(offsetof(FDCAccountNameChangeShopInfo, Currency) == 0x000000, "Member 'FDCAccountNameChangeShopInfo::Currency' has a wrong offset!");
static_assert(offsetof(FDCAccountNameChangeShopInfo, Price) == 0x000004, "Member 'FDCAccountNameChangeShopInfo::Price' has a wrong offset!");
static_assert(offsetof(FDCAccountNameChangeShopInfo, ShopURL) == 0x000008, "Member 'FDCAccountNameChangeShopInfo::ShopURL' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCSpawnerItemData
// 0x00B0 (0x00B0 - 0x0000)
struct FDCSpawnerItemData final
{
public:
	TSoftObjectPtr<class UDCLootDropDataAsset>    ItemHolderLootDropId;                              // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCLootDropRateDataAsset> ItemHolderLootDropRateId;                          // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCMonsterDataAsset>     MonsterId;                                         // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDCPropsDataAsset>       PropsId;                                           // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnRate;                                         // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2285[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AItemHolderActorBase>       ItemHolderActorClassOverride;                      // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCSpawnerItemData) == 0x000008, "Wrong alignment on FDCSpawnerItemData");
static_assert(sizeof(FDCSpawnerItemData) == 0x0000B0, "Wrong size on FDCSpawnerItemData");
static_assert(offsetof(FDCSpawnerItemData, ItemHolderLootDropId) == 0x000000, "Member 'FDCSpawnerItemData::ItemHolderLootDropId' has a wrong offset!");
static_assert(offsetof(FDCSpawnerItemData, ItemHolderLootDropRateId) == 0x000028, "Member 'FDCSpawnerItemData::ItemHolderLootDropRateId' has a wrong offset!");
static_assert(offsetof(FDCSpawnerItemData, MonsterId) == 0x000050, "Member 'FDCSpawnerItemData::MonsterId' has a wrong offset!");
static_assert(offsetof(FDCSpawnerItemData, PropsId) == 0x000078, "Member 'FDCSpawnerItemData::PropsId' has a wrong offset!");
static_assert(offsetof(FDCSpawnerItemData, SpawnRate) == 0x0000A0, "Member 'FDCSpawnerItemData::SpawnRate' has a wrong offset!");
static_assert(offsetof(FDCSpawnerItemData, ItemHolderActorClassOverride) == 0x0000A8, "Member 'FDCSpawnerItemData::ItemHolderActorClassOverride' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCGameLiftSessionId
// 0x0000 (0x0010 - 0x0010)
struct FDCGameLiftSessionId final : public FDCStringIdBase
{
};
static_assert(alignof(FDCGameLiftSessionId) == 0x000008, "Wrong alignment on FDCGameLiftSessionId");
static_assert(sizeof(FDCGameLiftSessionId) == 0x000010, "Wrong size on FDCGameLiftSessionId");

// ScriptStruct DungeonCrawler.DCTrainingCharacterInfo
// 0x0098 (0x0098 - 0x0000)
struct FDCTrainingCharacterInfo final
{
public:
	class FString                                 CharacterId;                                       // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0010(0x0040)(Transient, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ClassAssetId;                                      // 0x0050(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCGender                                     Gender;                                            // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2286[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMaster;                                         // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLearn;                                         // 0x0069(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2287[0x6];                                     // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCPlayerCharacterDataAsset*            Data;                                              // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2288[0x20];                                    // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCTrainingCharacterInfo) == 0x000008, "Wrong alignment on FDCTrainingCharacterInfo");
static_assert(sizeof(FDCTrainingCharacterInfo) == 0x000098, "Wrong size on FDCTrainingCharacterInfo");
static_assert(offsetof(FDCTrainingCharacterInfo, CharacterId) == 0x000000, "Member 'FDCTrainingCharacterInfo::CharacterId' has a wrong offset!");
static_assert(offsetof(FDCTrainingCharacterInfo, Nickname) == 0x000010, "Member 'FDCTrainingCharacterInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FDCTrainingCharacterInfo, ClassAssetId) == 0x000050, "Member 'FDCTrainingCharacterInfo::ClassAssetId' has a wrong offset!");
static_assert(offsetof(FDCTrainingCharacterInfo, Gender) == 0x000060, "Member 'FDCTrainingCharacterInfo::Gender' has a wrong offset!");
static_assert(offsetof(FDCTrainingCharacterInfo, Level) == 0x000064, "Member 'FDCTrainingCharacterInfo::Level' has a wrong offset!");
static_assert(offsetof(FDCTrainingCharacterInfo, bIsMaster) == 0x000068, "Member 'FDCTrainingCharacterInfo::bIsMaster' has a wrong offset!");
static_assert(offsetof(FDCTrainingCharacterInfo, bHasLearn) == 0x000069, "Member 'FDCTrainingCharacterInfo::bHasLearn' has a wrong offset!");
static_assert(offsetof(FDCTrainingCharacterInfo, Data) == 0x000070, "Member 'FDCTrainingCharacterInfo::Data' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSetLootTarget
// 0x0110 (0x0128 - 0x0018)
struct FMsgSetLootTarget final : public FMsgBase
{
public:
	class UInventoryComponent*                    LootTargetComponent;                               // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemData>                      ContainingItemDataArray;                           // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSlotInfo>                      SlotInfoArray;                                     // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FHitResult                             LootTargetHitResult;                               // 0x0040(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSetLootTarget) == 0x000008, "Wrong alignment on FMsgSetLootTarget");
static_assert(sizeof(FMsgSetLootTarget) == 0x000128, "Wrong size on FMsgSetLootTarget");
static_assert(offsetof(FMsgSetLootTarget, LootTargetComponent) == 0x000018, "Member 'FMsgSetLootTarget::LootTargetComponent' has a wrong offset!");
static_assert(offsetof(FMsgSetLootTarget, ContainingItemDataArray) == 0x000020, "Member 'FMsgSetLootTarget::ContainingItemDataArray' has a wrong offset!");
static_assert(offsetof(FMsgSetLootTarget, SlotInfoArray) == 0x000030, "Member 'FMsgSetLootTarget::SlotInfoArray' has a wrong offset!");
static_assert(offsetof(FMsgSetLootTarget, LootTargetHitResult) == 0x000040, "Member 'FMsgSetLootTarget::LootTargetHitResult' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCClassTrainingInfo
// 0x0088 (0x0088 - 0x0000)
struct FDCClassTrainingInfo final
{
public:
	bool                                          bIsMaster;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCTrainingState                              TrainingState;                                     // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2289[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        MasterPlayerCharacterId;                           // 0x0004(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228A[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                ClassAbilityChoices;                               // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TMap<int32, struct FDCRewardInfo>             RewardChoiceMap;                                   // 0x0028(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FDCTrainingCharacterInfo>       TrainingCharacters;                                // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCClassTrainingInfo) == 0x000008, "Wrong alignment on FDCClassTrainingInfo");
static_assert(sizeof(FDCClassTrainingInfo) == 0x000088, "Wrong size on FDCClassTrainingInfo");
static_assert(offsetof(FDCClassTrainingInfo, bIsMaster) == 0x000000, "Member 'FDCClassTrainingInfo::bIsMaster' has a wrong offset!");
static_assert(offsetof(FDCClassTrainingInfo, TrainingState) == 0x000001, "Member 'FDCClassTrainingInfo::TrainingState' has a wrong offset!");
static_assert(offsetof(FDCClassTrainingInfo, MasterPlayerCharacterId) == 0x000004, "Member 'FDCClassTrainingInfo::MasterPlayerCharacterId' has a wrong offset!");
static_assert(offsetof(FDCClassTrainingInfo, ClassAbilityChoices) == 0x000018, "Member 'FDCClassTrainingInfo::ClassAbilityChoices' has a wrong offset!");
static_assert(offsetof(FDCClassTrainingInfo, RewardChoiceMap) == 0x000028, "Member 'FDCClassTrainingInfo::RewardChoiceMap' has a wrong offset!");
static_assert(offsetof(FDCClassTrainingInfo, TrainingCharacters) == 0x000078, "Member 'FDCClassTrainingInfo::TrainingCharacters' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCTrainingPointInfo
// 0x0010 (0x0010 - 0x0000)
struct FDCTrainingPointInfo final
{
public:
	int32                                         RewardPoint;                                       // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextRewardLevel;                                   // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LearningPoint;                                     // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextLearningLevel;                                 // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCTrainingPointInfo) == 0x000004, "Wrong alignment on FDCTrainingPointInfo");
static_assert(sizeof(FDCTrainingPointInfo) == 0x000010, "Wrong size on FDCTrainingPointInfo");
static_assert(offsetof(FDCTrainingPointInfo, RewardPoint) == 0x000000, "Member 'FDCTrainingPointInfo::RewardPoint' has a wrong offset!");
static_assert(offsetof(FDCTrainingPointInfo, NextRewardLevel) == 0x000004, "Member 'FDCTrainingPointInfo::NextRewardLevel' has a wrong offset!");
static_assert(offsetof(FDCTrainingPointInfo, LearningPoint) == 0x000008, "Member 'FDCTrainingPointInfo::LearningPoint' has a wrong offset!");
static_assert(offsetof(FDCTrainingPointInfo, NextLearningLevel) == 0x00000C, "Member 'FDCTrainingPointInfo::NextLearningLevel' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCTrainingOptionInfo
// 0x0040 (0x0040 - 0x0000)
struct FDCTrainingOptionInfo final
{
public:
	EDCTrainingState                              TrainingState;                                     // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228B[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCTrainingClassAbilityId              ClassAbilityId;                                    // 0x0004(0x0014)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardUniqueId;                                    // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228C[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDCRewardInfo                          RewardInfo;                                        // 0x0020(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCTrainingOptionInfo) == 0x000008, "Wrong alignment on FDCTrainingOptionInfo");
static_assert(sizeof(FDCTrainingOptionInfo) == 0x000040, "Wrong size on FDCTrainingOptionInfo");
static_assert(offsetof(FDCTrainingOptionInfo, TrainingState) == 0x000000, "Member 'FDCTrainingOptionInfo::TrainingState' has a wrong offset!");
static_assert(offsetof(FDCTrainingOptionInfo, ClassAbilityId) == 0x000004, "Member 'FDCTrainingOptionInfo::ClassAbilityId' has a wrong offset!");
static_assert(offsetof(FDCTrainingOptionInfo, RewardUniqueId) == 0x000018, "Member 'FDCTrainingOptionInfo::RewardUniqueId' has a wrong offset!");
static_assert(offsetof(FDCTrainingOptionInfo, RewardInfo) == 0x000020, "Member 'FDCTrainingOptionInfo::RewardInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgLootComponentNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgLootComponentNotify final : public FMsgBase
{
public:
	class ULootComponent*                         LootComponent;                                     // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgLootComponentNotify) == 0x000008, "Wrong alignment on FMsgLootComponentNotify");
static_assert(sizeof(FMsgLootComponentNotify) == 0x000020, "Wrong size on FMsgLootComponentNotify");
static_assert(offsetof(FMsgLootComponentNotify, LootComponent) == 0x000018, "Member 'FMsgLootComponentNotify::LootComponent' has a wrong offset!");

// ScriptStruct DungeonCrawler.TrainingItemSlotInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FTrainingItemSlotInfo final
{
public:
	uint8                                         Pad_228D[0x28];                                    // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrainingItemSlotInfo) == 0x000008, "Wrong alignment on FTrainingItemSlotInfo");
static_assert(sizeof(FTrainingItemSlotInfo) == 0x000028, "Wrong size on FTrainingItemSlotInfo");

// ScriptStruct DungeonCrawler.DesignDataTriumphLevelTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataTriumphLevelTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataTriumphLevel> TriumphLevel;                                      // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataTriumphLevelTableRow) == 0x000008, "Wrong alignment on FDesignDataTriumphLevelTableRow");
static_assert(sizeof(FDesignDataTriumphLevelTableRow) == 0x000058, "Wrong size on FDesignDataTriumphLevelTableRow");
static_assert(offsetof(FDesignDataTriumphLevelTableRow, TriumphLevel) == 0x000008, "Member 'FDesignDataTriumphLevelTableRow::TriumphLevel' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCFloorRuleDeathSwarmInfo
// 0x0130 (0x0130 - 0x0000)
struct FDCFloorRuleDeathSwarmInfo final
{
public:
	struct FDCFloorRuleDeathSwarmItemData         Data;                                              // 0x0000(0x0068)(Transient, NativeAccessSpecifierPrivate)
	struct FDeathSwarmCircle                      Area;                                              // 0x0068(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	TMap<class AFloorPortalBase*, class UDCFloorPortalDataAsset*> DisplayPortals;                                    // 0x0090(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class AFloorPortalBase*, class UDCFloorPortalDataAsset*> ShrinkPortals;                                     // 0x00E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FDCFloorRuleDeathSwarmInfo) == 0x000008, "Wrong alignment on FDCFloorRuleDeathSwarmInfo");
static_assert(sizeof(FDCFloorRuleDeathSwarmInfo) == 0x000130, "Wrong size on FDCFloorRuleDeathSwarmInfo");
static_assert(offsetof(FDCFloorRuleDeathSwarmInfo, Data) == 0x000000, "Member 'FDCFloorRuleDeathSwarmInfo::Data' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleDeathSwarmInfo, Area) == 0x000068, "Member 'FDCFloorRuleDeathSwarmInfo::Area' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleDeathSwarmInfo, DisplayPortals) == 0x000090, "Member 'FDCFloorRuleDeathSwarmInfo::DisplayPortals' has a wrong offset!");
static_assert(offsetof(FDCFloorRuleDeathSwarmInfo, ShrinkPortals) == 0x0000E0, "Member 'FDCFloorRuleDeathSwarmInfo::ShrinkPortals' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCHttpResHandler
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FDCHttpResHandler final
{
public:
	uint8                                         Pad_228E[0x28];                                    // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCHttpResHandler) == 0x000008, "Wrong alignment on FDCHttpResHandler");
static_assert(sizeof(FDCHttpResHandler) == 0x000028, "Wrong size on FDCHttpResHandler");

// ScriptStruct DungeonCrawler.DCDeathSwarmManager
// 0x0048 (0x0048 - 0x0000)
struct FDCDeathSwarmManager final
{
public:
	struct FDeathSwarmCircle                      RootArea;                                          // 0x0000(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FDCFloorRuleDeathSwarmInfo>     Rules;                                             // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UDCFloorRuleDeathSwarmDataAsset*        Data;                                              // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228F[0x8];                                     // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCDeathSwarmManager) == 0x000008, "Wrong alignment on FDCDeathSwarmManager");
static_assert(sizeof(FDCDeathSwarmManager) == 0x000048, "Wrong size on FDCDeathSwarmManager");
static_assert(offsetof(FDCDeathSwarmManager, RootArea) == 0x000000, "Member 'FDCDeathSwarmManager::RootArea' has a wrong offset!");
static_assert(offsetof(FDCDeathSwarmManager, Rules) == 0x000028, "Member 'FDCDeathSwarmManager::Rules' has a wrong offset!");
static_assert(offsetof(FDCDeathSwarmManager, Data) == 0x000038, "Member 'FDCDeathSwarmManager::Data' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataPlayerCharacter
// 0x0128 (0x0128 - 0x0000)
struct FDesignDataPlayerCharacter final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Dialog;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ClassInfo;                                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   CharacterTypes;                                    // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanUse;                                            // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDefault;                                         // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExperimental;                                    // 0x0082(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2290[0x5];                                     // 0x0083(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                BaseItems;                                         // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Skills;                                            // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Spells;                                            // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Musics;                                            // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                ShapeShifts;                                       // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Emotes;                                            // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Perks;                                             // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EDCEquipmentSlotIndex>                 DefaultHands;                                      // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataPlayerCharacter) == 0x000008, "Wrong alignment on FDesignDataPlayerCharacter");
static_assert(sizeof(FDesignDataPlayerCharacter) == 0x000128, "Wrong size on FDesignDataPlayerCharacter");
static_assert(offsetof(FDesignDataPlayerCharacter, Name) == 0x000000, "Member 'FDesignDataPlayerCharacter::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, Dialog) == 0x000018, "Member 'FDesignDataPlayerCharacter::Dialog' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, FlavorText) == 0x000028, "Member 'FDesignDataPlayerCharacter::FlavorText' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, ClassInfo) == 0x000040, "Member 'FDesignDataPlayerCharacter::ClassInfo' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, CharacterTypes) == 0x000050, "Member 'FDesignDataPlayerCharacter::CharacterTypes' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, ArtData) == 0x000060, "Member 'FDesignDataPlayerCharacter::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, SoundData) == 0x000070, "Member 'FDesignDataPlayerCharacter::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, CanUse) == 0x000080, "Member 'FDesignDataPlayerCharacter::CanUse' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, IsDefault) == 0x000081, "Member 'FDesignDataPlayerCharacter::IsDefault' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, IsExperimental) == 0x000082, "Member 'FDesignDataPlayerCharacter::IsExperimental' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, BaseItems) == 0x000088, "Member 'FDesignDataPlayerCharacter::BaseItems' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, Skills) == 0x000098, "Member 'FDesignDataPlayerCharacter::Skills' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, Spells) == 0x0000A8, "Member 'FDesignDataPlayerCharacter::Spells' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, Musics) == 0x0000B8, "Member 'FDesignDataPlayerCharacter::Musics' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, ShapeShifts) == 0x0000C8, "Member 'FDesignDataPlayerCharacter::ShapeShifts' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, Emotes) == 0x0000D8, "Member 'FDesignDataPlayerCharacter::Emotes' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, Abilities) == 0x0000E8, "Member 'FDesignDataPlayerCharacter::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, Effects) == 0x0000F8, "Member 'FDesignDataPlayerCharacter::Effects' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, Perks) == 0x000108, "Member 'FDesignDataPlayerCharacter::Perks' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacter, DefaultHands) == 0x000118, "Member 'FDesignDataPlayerCharacter::DefaultHands' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataAoe
// 0x0058 (0x0058 - 0x0000)
struct FDesignDataAoe final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataAoe) == 0x000008, "Wrong alignment on FDesignDataAoe");
static_assert(sizeof(FDesignDataAoe) == 0x000058, "Wrong size on FDesignDataAoe");
static_assert(offsetof(FDesignDataAoe, Name) == 0x000000, "Member 'FDesignDataAoe::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataAoe, ArtData) == 0x000018, "Member 'FDesignDataAoe::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataAoe, SoundData) == 0x000028, "Member 'FDesignDataAoe::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataAoe, Abilities) == 0x000038, "Member 'FDesignDataAoe::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataAoe, Effects) == 0x000048, "Member 'FDesignDataAoe::Effects' has a wrong offset!");

// ScriptStruct DungeonCrawler.ShapeShiftData
// 0x0020 (0x0020 - 0x0000)
struct FShapeShiftData final
{
public:
	struct FPrimaryAssetId                        ShapeShiftId;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ShapeShiftTag;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SequenceIndex;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShapeShiftData) == 0x000004, "Wrong alignment on FShapeShiftData");
static_assert(sizeof(FShapeShiftData) == 0x000020, "Wrong size on FShapeShiftData");
static_assert(offsetof(FShapeShiftData, ShapeShiftId) == 0x000000, "Member 'FShapeShiftData::ShapeShiftId' has a wrong offset!");
static_assert(offsetof(FShapeShiftData, ShapeShiftTag) == 0x000010, "Member 'FShapeShiftData::ShapeShiftTag' has a wrong offset!");
static_assert(offsetof(FShapeShiftData, SlotIndex) == 0x000018, "Member 'FShapeShiftData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FShapeShiftData, SequenceIndex) == 0x00001C, "Member 'FShapeShiftData::SequenceIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataProps
// 0x00B0 (0x00B0 - 0x0000)
struct FDesignDataProps final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           IdTag;                                             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GradeType;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        LootDropGroup;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APropsActorBase>            ActorClass;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractionMinCount;                               // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteractionMaxCount;                               // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                InteractionSettingDatas;                           // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                DestructibleTagQueryData;                          // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AdvPoint;                                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpPoint;                                          // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataProps) == 0x000008, "Wrong alignment on FDesignDataProps");
static_assert(sizeof(FDesignDataProps) == 0x0000B0, "Wrong size on FDesignDataProps");
static_assert(offsetof(FDesignDataProps, Name) == 0x000000, "Member 'FDesignDataProps::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, IdTag) == 0x000018, "Member 'FDesignDataProps::IdTag' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, GradeType) == 0x000020, "Member 'FDesignDataProps::GradeType' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, LootDropGroup) == 0x000028, "Member 'FDesignDataProps::LootDropGroup' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, ArtData) == 0x000038, "Member 'FDesignDataProps::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, SoundData) == 0x000048, "Member 'FDesignDataProps::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, ActorClass) == 0x000058, "Member 'FDesignDataProps::ActorClass' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, InteractionMinCount) == 0x000060, "Member 'FDesignDataProps::InteractionMinCount' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, InteractionMaxCount) == 0x000064, "Member 'FDesignDataProps::InteractionMaxCount' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, InteractionSettingDatas) == 0x000068, "Member 'FDesignDataProps::InteractionSettingDatas' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, DestructibleTagQueryData) == 0x000078, "Member 'FDesignDataProps::DestructibleTagQueryData' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, Abilities) == 0x000088, "Member 'FDesignDataProps::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, Effects) == 0x000098, "Member 'FDesignDataProps::Effects' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, AdvPoint) == 0x0000A8, "Member 'FDesignDataProps::AdvPoint' has a wrong offset!");
static_assert(offsetof(FDesignDataProps, ExpPoint) == 0x0000AC, "Member 'FDesignDataProps::ExpPoint' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataPropsInteract
// 0x00C0 (0x00C0 - 0x0000)
struct FDesignDataPropsInteract final
{
public:
	class FText                                   InteractionName;                                   // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   InteractionText;                                   // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        InteractData;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   InteractTypes;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConditionalDuration;                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InteractableTag;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TriggerTag;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AbilityTriggerTag;                                 // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DetectTagQueryData;                                // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        InteractTagQueryData;                              // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ConsumeTagQueryData;                               // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   BlockInteractionTags;                              // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkillCheckData;                                    // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataPropsInteract) == 0x000008, "Wrong alignment on FDesignDataPropsInteract");
static_assert(sizeof(FDesignDataPropsInteract) == 0x0000C0, "Wrong size on FDesignDataPropsInteract");
static_assert(offsetof(FDesignDataPropsInteract, InteractionName) == 0x000000, "Member 'FDesignDataPropsInteract::InteractionName' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, InteractionText) == 0x000018, "Member 'FDesignDataPropsInteract::InteractionText' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, InteractData) == 0x000030, "Member 'FDesignDataPropsInteract::InteractData' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, InteractTypes) == 0x000040, "Member 'FDesignDataPropsInteract::InteractTypes' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, Duration) == 0x000050, "Member 'FDesignDataPropsInteract::Duration' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, ConditionalDuration) == 0x000054, "Member 'FDesignDataPropsInteract::ConditionalDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, InteractableTag) == 0x000058, "Member 'FDesignDataPropsInteract::InteractableTag' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, TriggerTag) == 0x000060, "Member 'FDesignDataPropsInteract::TriggerTag' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, AbilityTriggerTag) == 0x000068, "Member 'FDesignDataPropsInteract::AbilityTriggerTag' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, DetectTagQueryData) == 0x000070, "Member 'FDesignDataPropsInteract::DetectTagQueryData' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, InteractTagQueryData) == 0x000080, "Member 'FDesignDataPropsInteract::InteractTagQueryData' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, ConsumeTagQueryData) == 0x000090, "Member 'FDesignDataPropsInteract::ConsumeTagQueryData' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, BlockInteractionTags) == 0x0000A0, "Member 'FDesignDataPropsInteract::BlockInteractionTags' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsInteract, SkillCheckData) == 0x0000B0, "Member 'FDesignDataPropsInteract::SkillCheckData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataItem
// 0x0198 (0x0198 - 0x0000)
struct FDesignDataItem final
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        OriginId;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2291[0x3];                                     // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SlotType;                                          // 0x004C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HandType;                                          // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2292[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   WeaponTypes;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ArmorType;                                         // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           UtilityType;                                       // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AccessoryType;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MiscType;                                          // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RarityType;                                        // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAmmoCount;                                      // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanDrop;                                           // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSaveIntoDatabase;                               // 0x00A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsForceTradeable;                                  // 0x00A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2293[0x1];                                     // 0x00A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        ArtData;                                           // 0x00A4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x00B4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ConsumeData;                                       // 0x00C4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2294[0x4];                                     // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AItemActor>                 ActorClass;                                        // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemHolderActorBase>       ItemHolderActorClass;                              // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryWidth;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryHeight;                                   // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WearingDelayTime;                                  // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2295[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                SelfAbilities;                                     // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                SelfEffects;                                       // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PrimaryProperty;                                   // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                SecondaryProperties;                               // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Requirement;                                       // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        BundleInfo;                                        // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ContainerData;                                     // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdvPoint;                                          // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpPoint;                                          // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GearScore;                                         // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2296[0x4];                                     // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataItem) == 0x000008, "Wrong alignment on FDesignDataItem");
static_assert(sizeof(FDesignDataItem) == 0x000198, "Wrong size on FDesignDataItem");
static_assert(offsetof(FDesignDataItem, IdTag) == 0x000000, "Member 'FDesignDataItem::IdTag' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, OriginId) == 0x000008, "Member 'FDesignDataItem::OriginId' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, Name) == 0x000018, "Member 'FDesignDataItem::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, FlavorText) == 0x000030, "Member 'FDesignDataItem::FlavorText' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, ItemType) == 0x000048, "Member 'FDesignDataItem::ItemType' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, SlotType) == 0x00004C, "Member 'FDesignDataItem::SlotType' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, HandType) == 0x000054, "Member 'FDesignDataItem::HandType' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, WeaponTypes) == 0x000060, "Member 'FDesignDataItem::WeaponTypes' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, ArmorType) == 0x000070, "Member 'FDesignDataItem::ArmorType' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, UtilityType) == 0x000078, "Member 'FDesignDataItem::UtilityType' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, AccessoryType) == 0x000080, "Member 'FDesignDataItem::AccessoryType' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, MiscType) == 0x000088, "Member 'FDesignDataItem::MiscType' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, RarityType) == 0x000090, "Member 'FDesignDataItem::RarityType' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, MaxCount) == 0x000098, "Member 'FDesignDataItem::MaxCount' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, MaxAmmoCount) == 0x00009C, "Member 'FDesignDataItem::MaxAmmoCount' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, CanDrop) == 0x0000A0, "Member 'FDesignDataItem::CanDrop' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, CanSaveIntoDatabase) == 0x0000A1, "Member 'FDesignDataItem::CanSaveIntoDatabase' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, IsForceTradeable) == 0x0000A2, "Member 'FDesignDataItem::IsForceTradeable' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, ArtData) == 0x0000A4, "Member 'FDesignDataItem::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, SoundData) == 0x0000B4, "Member 'FDesignDataItem::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, ConsumeData) == 0x0000C4, "Member 'FDesignDataItem::ConsumeData' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, ActorClass) == 0x0000D8, "Member 'FDesignDataItem::ActorClass' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, ItemHolderActorClass) == 0x0000E0, "Member 'FDesignDataItem::ItemHolderActorClass' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, InventoryWidth) == 0x0000E8, "Member 'FDesignDataItem::InventoryWidth' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, InventoryHeight) == 0x0000EC, "Member 'FDesignDataItem::InventoryHeight' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, WearingDelayTime) == 0x0000F0, "Member 'FDesignDataItem::WearingDelayTime' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, SelfAbilities) == 0x0000F8, "Member 'FDesignDataItem::SelfAbilities' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, SelfEffects) == 0x000108, "Member 'FDesignDataItem::SelfEffects' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, Abilities) == 0x000118, "Member 'FDesignDataItem::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, Effects) == 0x000128, "Member 'FDesignDataItem::Effects' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, PrimaryProperty) == 0x000138, "Member 'FDesignDataItem::PrimaryProperty' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, SecondaryProperties) == 0x000148, "Member 'FDesignDataItem::SecondaryProperties' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, Requirement) == 0x000158, "Member 'FDesignDataItem::Requirement' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, BundleInfo) == 0x000168, "Member 'FDesignDataItem::BundleInfo' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, ContainerData) == 0x000178, "Member 'FDesignDataItem::ContainerData' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, AdvPoint) == 0x000188, "Member 'FDesignDataItem::AdvPoint' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, ExpPoint) == 0x00018C, "Member 'FDesignDataItem::ExpPoint' has a wrong offset!");
static_assert(offsetof(FDesignDataItem, GearScore) == 0x000190, "Member 'FDesignDataItem::GearScore' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSkillRechargeRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgSkillRechargeRequest final : public FMsgBase
{
public:
	int32                                         RechargeAmount;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2297[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgSkillRechargeRequest) == 0x000008, "Wrong alignment on FMsgSkillRechargeRequest");
static_assert(sizeof(FMsgSkillRechargeRequest) == 0x000020, "Wrong size on FMsgSkillRechargeRequest");
static_assert(offsetof(FMsgSkillRechargeRequest, RechargeAmount) == 0x000018, "Member 'FMsgSkillRechargeRequest::RechargeAmount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCSoundDataContainer
// 0x0050 (0x0050 - 0x0000)
struct FDCSoundDataContainer final
{
public:
	TMap<EPhysicalSurface, class UAkSwitchValue*> AkSwitchBySurfaceType;                             // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCSoundDataContainer) == 0x000008, "Wrong alignment on FDCSoundDataContainer");
static_assert(sizeof(FDCSoundDataContainer) == 0x000050, "Wrong size on FDCSoundDataContainer");
static_assert(offsetof(FDCSoundDataContainer, AkSwitchBySurfaceType) == 0x000000, "Member 'FDCSoundDataContainer::AkSwitchBySurfaceType' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataItemRequirement
// 0x0058 (0x0058 - 0x0000)
struct FDesignDataItemRequirement final
{
public:
	TArray<struct FPrimaryAssetId>                ClassRequirements;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         StrengthRequirement;                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AgilityRequirement;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WillRequirement;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KnowledgeRequirement;                              // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResourcefulRequirement;                            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2298[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                PerkRequirements;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   PairWeaponRequirements;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                ExclusiveSkins;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemRequirement) == 0x000008, "Wrong alignment on FDesignDataItemRequirement");
static_assert(sizeof(FDesignDataItemRequirement) == 0x000058, "Wrong size on FDesignDataItemRequirement");
static_assert(offsetof(FDesignDataItemRequirement, ClassRequirements) == 0x000000, "Member 'FDesignDataItemRequirement::ClassRequirements' has a wrong offset!");
static_assert(offsetof(FDesignDataItemRequirement, StrengthRequirement) == 0x000010, "Member 'FDesignDataItemRequirement::StrengthRequirement' has a wrong offset!");
static_assert(offsetof(FDesignDataItemRequirement, AgilityRequirement) == 0x000014, "Member 'FDesignDataItemRequirement::AgilityRequirement' has a wrong offset!");
static_assert(offsetof(FDesignDataItemRequirement, WillRequirement) == 0x000018, "Member 'FDesignDataItemRequirement::WillRequirement' has a wrong offset!");
static_assert(offsetof(FDesignDataItemRequirement, KnowledgeRequirement) == 0x00001C, "Member 'FDesignDataItemRequirement::KnowledgeRequirement' has a wrong offset!");
static_assert(offsetof(FDesignDataItemRequirement, ResourcefulRequirement) == 0x000020, "Member 'FDesignDataItemRequirement::ResourcefulRequirement' has a wrong offset!");
static_assert(offsetof(FDesignDataItemRequirement, PerkRequirements) == 0x000028, "Member 'FDesignDataItemRequirement::PerkRequirements' has a wrong offset!");
static_assert(offsetof(FDesignDataItemRequirement, PairWeaponRequirements) == 0x000038, "Member 'FDesignDataItemRequirement::PairWeaponRequirements' has a wrong offset!");
static_assert(offsetof(FDesignDataItemRequirement, ExclusiveSkins) == 0x000048, "Member 'FDesignDataItemRequirement::ExclusiveSkins' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataItemContainer
// 0x0014 (0x0014 - 0x0000)
struct FDesignDataItemContainer final
{
public:
	struct FPrimaryAssetId                        ContentsItemId;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxContentsCount;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemContainer) == 0x000004, "Wrong alignment on FDesignDataItemContainer");
static_assert(sizeof(FDesignDataItemContainer) == 0x000014, "Wrong size on FDesignDataItemContainer");
static_assert(offsetof(FDesignDataItemContainer, ContentsItemId) == 0x000000, "Member 'FDesignDataItemContainer::ContentsItemId' has a wrong offset!");
static_assert(offsetof(FDesignDataItemContainer, MaxContentsCount) == 0x000010, "Member 'FDesignDataItemContainer::MaxContentsCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGASInstigatorDataResponse
// 0x0068 (0x0080 - 0x0018)
struct FMsgGASInstigatorDataResponse final : public FMsgBase
{
public:
	struct FInstigatorData                        InstigatorData;                                    // 0x0018(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGASInstigatorDataResponse) == 0x000008, "Wrong alignment on FMsgGASInstigatorDataResponse");
static_assert(sizeof(FMsgGASInstigatorDataResponse) == 0x000080, "Wrong size on FMsgGASInstigatorDataResponse");
static_assert(offsetof(FMsgGASInstigatorDataResponse, InstigatorData) == 0x000018, "Member 'FMsgGASInstigatorDataResponse::InstigatorData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGASActorStatusResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgGASActorStatusResponse final : public FMsgBase
{
public:
	TArray<struct FActorStatusData>               ActorStatusDatas;                                  // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGASActorStatusResponse) == 0x000008, "Wrong alignment on FMsgGASActorStatusResponse");
static_assert(sizeof(FMsgGASActorStatusResponse) == 0x000028, "Wrong size on FMsgGASActorStatusResponse");
static_assert(offsetof(FMsgGASActorStatusResponse, ActorStatusDatas) == 0x000018, "Member 'FMsgGASActorStatusResponse::ActorStatusDatas' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataSpawnerItem
// 0x0050 (0x0050 - 0x0000)
struct FDesignDataSpawnerItem final
{
public:
	struct FPrimaryAssetId                        ItemHolderLootDropId;                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ItemHolderLootDropRateId;                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        MonsterId;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PropsId;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnRate;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2299[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AItemHolderActorBase>       ItemHolderActorClassOverride;                      // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataSpawnerItem) == 0x000008, "Wrong alignment on FDesignDataSpawnerItem");
static_assert(sizeof(FDesignDataSpawnerItem) == 0x000050, "Wrong size on FDesignDataSpawnerItem");
static_assert(offsetof(FDesignDataSpawnerItem, ItemHolderLootDropId) == 0x000000, "Member 'FDesignDataSpawnerItem::ItemHolderLootDropId' has a wrong offset!");
static_assert(offsetof(FDesignDataSpawnerItem, ItemHolderLootDropRateId) == 0x000010, "Member 'FDesignDataSpawnerItem::ItemHolderLootDropRateId' has a wrong offset!");
static_assert(offsetof(FDesignDataSpawnerItem, MonsterId) == 0x000020, "Member 'FDesignDataSpawnerItem::MonsterId' has a wrong offset!");
static_assert(offsetof(FDesignDataSpawnerItem, PropsId) == 0x000030, "Member 'FDesignDataSpawnerItem::PropsId' has a wrong offset!");
static_assert(offsetof(FDesignDataSpawnerItem, SpawnRate) == 0x000040, "Member 'FDesignDataSpawnerItem::SpawnRate' has a wrong offset!");
static_assert(offsetof(FDesignDataSpawnerItem, ItemHolderActorClassOverride) == 0x000048, "Member 'FDesignDataSpawnerItem::ItemHolderActorClassOverride' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestChangePlayerCharacterClassRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgGameTestChangePlayerCharacterClassRequest final : public FMsgBase
{
public:
	EDCCharacterClass                             CharacterClass;                                    // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCGender                                     Gender;                                            // 0x0019(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229A[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGameTestChangePlayerCharacterClassRequest) == 0x000008, "Wrong alignment on FMsgGameTestChangePlayerCharacterClassRequest");
static_assert(sizeof(FMsgGameTestChangePlayerCharacterClassRequest) == 0x000020, "Wrong size on FMsgGameTestChangePlayerCharacterClassRequest");
static_assert(offsetof(FMsgGameTestChangePlayerCharacterClassRequest, CharacterClass) == 0x000018, "Member 'FMsgGameTestChangePlayerCharacterClassRequest::CharacterClass' has a wrong offset!");
static_assert(offsetof(FMsgGameTestChangePlayerCharacterClassRequest, Gender) == 0x000019, "Member 'FMsgGameTestChangePlayerCharacterClassRequest::Gender' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataSpawner
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataSpawner final
{
public:
	TArray<struct FDesignDataSpawnerItem>         SpawnerItemArray;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataSpawner) == 0x000008, "Wrong alignment on FDesignDataSpawner");
static_assert(sizeof(FDesignDataSpawner) == 0x000010, "Wrong size on FDesignDataSpawner");
static_assert(offsetof(FDesignDataSpawner, SpawnerItemArray) == 0x000000, "Member 'FDesignDataSpawner::SpawnerItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataSpell
// 0x00D8 (0x00D8 - 0x0000)
struct FDesignDataSpell final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Desc;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Classes;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CastingType;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SourceType;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CostType;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        CostEffect;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpellTier;                                         // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastingTime;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingDuration;                                // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingInterval;                                // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Range;                                             // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaRadius;                                        // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAreaInstall;                                     // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229B[0x3];                                     // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGameplayAbilityWorldReticle> ReticleActorClass;                                 // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMoving;                                         // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229C[0x3];                                     // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SpellTag;                                          // 0x008C(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0094(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x00A4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229D[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataSpell) == 0x000008, "Wrong alignment on FDesignDataSpell");
static_assert(sizeof(FDesignDataSpell) == 0x0000D8, "Wrong size on FDesignDataSpell");
static_assert(offsetof(FDesignDataSpell, Name) == 0x000000, "Member 'FDesignDataSpell::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, Desc) == 0x000018, "Member 'FDesignDataSpell::Desc' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, Classes) == 0x000028, "Member 'FDesignDataSpell::Classes' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, CastingType) == 0x000038, "Member 'FDesignDataSpell::CastingType' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, SourceType) == 0x000040, "Member 'FDesignDataSpell::SourceType' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, CostType) == 0x000048, "Member 'FDesignDataSpell::CostType' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, CostEffect) == 0x000050, "Member 'FDesignDataSpell::CostEffect' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, SpellTier) == 0x000060, "Member 'FDesignDataSpell::SpellTier' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, MaxCount) == 0x000064, "Member 'FDesignDataSpell::MaxCount' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, CastingTime) == 0x000068, "Member 'FDesignDataSpell::CastingTime' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, ChannelingDuration) == 0x00006C, "Member 'FDesignDataSpell::ChannelingDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, ChannelingInterval) == 0x000070, "Member 'FDesignDataSpell::ChannelingInterval' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, Range) == 0x000074, "Member 'FDesignDataSpell::Range' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, AreaRadius) == 0x000078, "Member 'FDesignDataSpell::AreaRadius' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, IsAreaInstall) == 0x00007C, "Member 'FDesignDataSpell::IsAreaInstall' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, ReticleActorClass) == 0x000080, "Member 'FDesignDataSpell::ReticleActorClass' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, UseMoving) == 0x000088, "Member 'FDesignDataSpell::UseMoving' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, SpellTag) == 0x00008C, "Member 'FDesignDataSpell::SpellTag' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, ArtData) == 0x000094, "Member 'FDesignDataSpell::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, SoundData) == 0x0000A4, "Member 'FDesignDataSpell::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, Abilities) == 0x0000B8, "Member 'FDesignDataSpell::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataSpell, Effects) == 0x0000C8, "Member 'FDesignDataSpell::Effects' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMusic
// 0x00C8 (0x00C8 - 0x0000)
struct FDesignDataMusic final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Desc;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Classes;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlayType;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SourceType;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TargetType;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MusicTier;                                         // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayTime;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingDuration;                                // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChannelingInterval;                                // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BadRange;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoodRange;                                         // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerfectRange;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MusicTag;                                          // 0x006C(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0074(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x0084(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PlayMusicData;                                     // 0x0094(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229E[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMusic) == 0x000008, "Wrong alignment on FDesignDataMusic");
static_assert(sizeof(FDesignDataMusic) == 0x0000C8, "Wrong size on FDesignDataMusic");
static_assert(offsetof(FDesignDataMusic, Name) == 0x000000, "Member 'FDesignDataMusic::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, Desc) == 0x000018, "Member 'FDesignDataMusic::Desc' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, Classes) == 0x000028, "Member 'FDesignDataMusic::Classes' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, PlayType) == 0x000038, "Member 'FDesignDataMusic::PlayType' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, SourceType) == 0x000040, "Member 'FDesignDataMusic::SourceType' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, TargetType) == 0x000048, "Member 'FDesignDataMusic::TargetType' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, MusicTier) == 0x000050, "Member 'FDesignDataMusic::MusicTier' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, PlayTime) == 0x000054, "Member 'FDesignDataMusic::PlayTime' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, ChannelingDuration) == 0x000058, "Member 'FDesignDataMusic::ChannelingDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, ChannelingInterval) == 0x00005C, "Member 'FDesignDataMusic::ChannelingInterval' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, BadRange) == 0x000060, "Member 'FDesignDataMusic::BadRange' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, GoodRange) == 0x000064, "Member 'FDesignDataMusic::GoodRange' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, PerfectRange) == 0x000068, "Member 'FDesignDataMusic::PerfectRange' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, MusicTag) == 0x00006C, "Member 'FDesignDataMusic::MusicTag' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, ArtData) == 0x000074, "Member 'FDesignDataMusic::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, SoundData) == 0x000084, "Member 'FDesignDataMusic::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, PlayMusicData) == 0x000094, "Member 'FDesignDataMusic::PlayMusicData' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, Abilities) == 0x0000A8, "Member 'FDesignDataMusic::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataMusic, Effects) == 0x0000B8, "Member 'FDesignDataMusic::Effects' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassLevelInfoResponse
// 0x0020 (0x0038 - 0x0018)
struct FMsgGameTestClassLevelInfoResponse final : public FMsgBase
{
public:
	int32                                         Level;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpBegin;                                          // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExpLimit;                                          // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardPoint;                                       // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextRewardLevel;                                   // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LearningPoint;                                     // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextLearningLevel;                                 // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassLevelInfoResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassLevelInfoResponse");
static_assert(sizeof(FMsgGameTestClassLevelInfoResponse) == 0x000038, "Wrong size on FMsgGameTestClassLevelInfoResponse");
static_assert(offsetof(FMsgGameTestClassLevelInfoResponse, Level) == 0x000018, "Member 'FMsgGameTestClassLevelInfoResponse::Level' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassLevelInfoResponse, Exp) == 0x00001C, "Member 'FMsgGameTestClassLevelInfoResponse::Exp' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassLevelInfoResponse, ExpBegin) == 0x000020, "Member 'FMsgGameTestClassLevelInfoResponse::ExpBegin' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassLevelInfoResponse, ExpLimit) == 0x000024, "Member 'FMsgGameTestClassLevelInfoResponse::ExpLimit' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassLevelInfoResponse, RewardPoint) == 0x000028, "Member 'FMsgGameTestClassLevelInfoResponse::RewardPoint' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassLevelInfoResponse, NextRewardLevel) == 0x00002C, "Member 'FMsgGameTestClassLevelInfoResponse::NextRewardLevel' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassLevelInfoResponse, LearningPoint) == 0x000030, "Member 'FMsgGameTestClassLevelInfoResponse::LearningPoint' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassLevelInfoResponse, NextLearningLevel) == 0x000034, "Member 'FMsgGameTestClassLevelInfoResponse::NextLearningLevel' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataShapeShift
// 0x00C8 (0x00C8 - 0x0000)
struct FDesignDataShapeShift final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        Desc;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Classes;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CastingTime;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadiusScale;                                // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHeightScale;                                // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TraceComplexOnMove;                                // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229F[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ShapeShiftTag;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ShapeShiftStartTriggerTag;                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   ShapeShiftedStateTags;                             // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SoundData;                                         // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ShapeShiftingAbility;                              // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Skills;                                            // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataShapeShift) == 0x000008, "Wrong alignment on FDesignDataShapeShift");
static_assert(sizeof(FDesignDataShapeShift) == 0x0000C8, "Wrong size on FDesignDataShapeShift");
static_assert(offsetof(FDesignDataShapeShift, Name) == 0x000000, "Member 'FDesignDataShapeShift::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, Desc) == 0x000018, "Member 'FDesignDataShapeShift::Desc' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, Classes) == 0x000028, "Member 'FDesignDataShapeShift::Classes' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, CastingTime) == 0x000038, "Member 'FDesignDataShapeShift::CastingTime' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, CapsuleRadiusScale) == 0x00003C, "Member 'FDesignDataShapeShift::CapsuleRadiusScale' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, CapsuleHeightScale) == 0x000040, "Member 'FDesignDataShapeShift::CapsuleHeightScale' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, TraceComplexOnMove) == 0x000044, "Member 'FDesignDataShapeShift::TraceComplexOnMove' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, ShapeShiftTag) == 0x000048, "Member 'FDesignDataShapeShift::ShapeShiftTag' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, ShapeShiftStartTriggerTag) == 0x000050, "Member 'FDesignDataShapeShift::ShapeShiftStartTriggerTag' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, ShapeShiftedStateTags) == 0x000058, "Member 'FDesignDataShapeShift::ShapeShiftedStateTags' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, ArtData) == 0x000068, "Member 'FDesignDataShapeShift::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, SoundData) == 0x000078, "Member 'FDesignDataShapeShift::SoundData' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, ShapeShiftingAbility) == 0x000088, "Member 'FDesignDataShapeShift::ShapeShiftingAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, Abilities) == 0x000098, "Member 'FDesignDataShapeShift::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, Effects) == 0x0000A8, "Member 'FDesignDataShapeShift::Effects' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShift, Skills) == 0x0000B8, "Member 'FDesignDataShapeShift::Skills' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataDesc
// 0x0068 (0x0068 - 0x0000)
struct FDesignDataDesc final
{
public:
	class FText                                   DescFormat;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 DescParam1;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DescParam2;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DescParam3;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DescParam4;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DescParam5;                                        // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataDesc) == 0x000008, "Wrong alignment on FDesignDataDesc");
static_assert(sizeof(FDesignDataDesc) == 0x000068, "Wrong size on FDesignDataDesc");
static_assert(offsetof(FDesignDataDesc, DescFormat) == 0x000000, "Member 'FDesignDataDesc::DescFormat' has a wrong offset!");
static_assert(offsetof(FDesignDataDesc, DescParam1) == 0x000018, "Member 'FDesignDataDesc::DescParam1' has a wrong offset!");
static_assert(offsetof(FDesignDataDesc, DescParam2) == 0x000028, "Member 'FDesignDataDesc::DescParam2' has a wrong offset!");
static_assert(offsetof(FDesignDataDesc, DescParam3) == 0x000038, "Member 'FDesignDataDesc::DescParam3' has a wrong offset!");
static_assert(offsetof(FDesignDataDesc, DescParam4) == 0x000048, "Member 'FDesignDataDesc::DescParam4' has a wrong offset!");
static_assert(offsetof(FDesignDataDesc, DescParam5) == 0x000058, "Member 'FDesignDataDesc::DescParam5' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMeleeAttack
// 0x0054 (0x0054 - 0x0000)
struct FDesignDataMeleeAttack final
{
public:
	float                                         DamageRatio;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitPlayRate;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitPlayRateDuration;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanStuckByHitBox;                                  // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A0[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterStuckPlayRate;                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterStuckPlayRateDuration;                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterStuckBlendOutTime;                        // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanStuckByShield;                                  // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A1[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeakShieldStuckPlayRate;                           // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeakShieldStuckPlayRateDuration;                   // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeakShieldStuckBlendOutTime;                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidShieldStuckPlayRate;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidShieldStuckPlayRateDuration;                    // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidShieldStuckBlendOutTime;                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeavyShieldStuckPlayRate;                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeavyShieldStuckPlayRateDuration;                  // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeavyShieldStuckBlendOutTime;                      // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanStuckByStaticObject;                            // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A2[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaticObjectStuckPlayRate;                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticObjectStuckPlayRateDuration;                 // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StaticObjectStuckBlendOutTime;                     // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMeleeAttack) == 0x000004, "Wrong alignment on FDesignDataMeleeAttack");
static_assert(sizeof(FDesignDataMeleeAttack) == 0x000054, "Wrong size on FDesignDataMeleeAttack");
static_assert(offsetof(FDesignDataMeleeAttack, DamageRatio) == 0x000000, "Member 'FDesignDataMeleeAttack::DamageRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, HitPlayRate) == 0x000004, "Member 'FDesignDataMeleeAttack::HitPlayRate' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, HitPlayRateDuration) == 0x000008, "Member 'FDesignDataMeleeAttack::HitPlayRateDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, CanStuckByHitBox) == 0x00000C, "Member 'FDesignDataMeleeAttack::CanStuckByHitBox' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, CharacterStuckPlayRate) == 0x000010, "Member 'FDesignDataMeleeAttack::CharacterStuckPlayRate' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, CharacterStuckPlayRateDuration) == 0x000014, "Member 'FDesignDataMeleeAttack::CharacterStuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, CharacterStuckBlendOutTime) == 0x000018, "Member 'FDesignDataMeleeAttack::CharacterStuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, CanStuckByShield) == 0x00001C, "Member 'FDesignDataMeleeAttack::CanStuckByShield' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, WeakShieldStuckPlayRate) == 0x000020, "Member 'FDesignDataMeleeAttack::WeakShieldStuckPlayRate' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, WeakShieldStuckPlayRateDuration) == 0x000024, "Member 'FDesignDataMeleeAttack::WeakShieldStuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, WeakShieldStuckBlendOutTime) == 0x000028, "Member 'FDesignDataMeleeAttack::WeakShieldStuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, MidShieldStuckPlayRate) == 0x00002C, "Member 'FDesignDataMeleeAttack::MidShieldStuckPlayRate' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, MidShieldStuckPlayRateDuration) == 0x000030, "Member 'FDesignDataMeleeAttack::MidShieldStuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, MidShieldStuckBlendOutTime) == 0x000034, "Member 'FDesignDataMeleeAttack::MidShieldStuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, HeavyShieldStuckPlayRate) == 0x000038, "Member 'FDesignDataMeleeAttack::HeavyShieldStuckPlayRate' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, HeavyShieldStuckPlayRateDuration) == 0x00003C, "Member 'FDesignDataMeleeAttack::HeavyShieldStuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, HeavyShieldStuckBlendOutTime) == 0x000040, "Member 'FDesignDataMeleeAttack::HeavyShieldStuckBlendOutTime' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, CanStuckByStaticObject) == 0x000044, "Member 'FDesignDataMeleeAttack::CanStuckByStaticObject' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, StaticObjectStuckPlayRate) == 0x000048, "Member 'FDesignDataMeleeAttack::StaticObjectStuckPlayRate' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, StaticObjectStuckPlayRateDuration) == 0x00004C, "Member 'FDesignDataMeleeAttack::StaticObjectStuckPlayRateDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataMeleeAttack, StaticObjectStuckBlendOutTime) == 0x000050, "Member 'FDesignDataMeleeAttack::StaticObjectStuckBlendOutTime' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSetEquippedWeaponsVisibility
// 0x0028 (0x0040 - 0x0018)
struct FMsgSetEquippedWeaponsVisibility final : public FMsgBase
{
public:
	struct FGameplayTagContainer                  IgnoreTypes;                                       // 0x0018(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsHide;                                           // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A3[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgSetEquippedWeaponsVisibility) == 0x000008, "Wrong alignment on FMsgSetEquippedWeaponsVisibility");
static_assert(sizeof(FMsgSetEquippedWeaponsVisibility) == 0x000040, "Wrong size on FMsgSetEquippedWeaponsVisibility");
static_assert(offsetof(FMsgSetEquippedWeaponsVisibility, IgnoreTypes) == 0x000018, "Member 'FMsgSetEquippedWeaponsVisibility::IgnoreTypes' has a wrong offset!");
static_assert(offsetof(FMsgSetEquippedWeaponsVisibility, bIsHide) == 0x000038, "Member 'FMsgSetEquippedWeaponsVisibility::bIsHide' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataFloorRuleDeathSwarmItem
// 0x0050 (0x0050 - 0x0000)
struct FDesignDataFloorRuleDeathSwarmItem final
{
public:
	float                                         DeathSwarmSize;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DeathSwarmAbilityTag;                              // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayPhaseDuration;                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                DisplayPhaseFloorPortalArray;                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ShrinkPhaseDuration;                               // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A4[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                ShrinkPhaseFloorPortalArray;                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          HideDeathSwarmTimer;                               // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A5[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        SoundData;                                         // 0x003C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A6[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataFloorRuleDeathSwarmItem) == 0x000008, "Wrong alignment on FDesignDataFloorRuleDeathSwarmItem");
static_assert(sizeof(FDesignDataFloorRuleDeathSwarmItem) == 0x000050, "Wrong size on FDesignDataFloorRuleDeathSwarmItem");
static_assert(offsetof(FDesignDataFloorRuleDeathSwarmItem, DeathSwarmSize) == 0x000000, "Member 'FDesignDataFloorRuleDeathSwarmItem::DeathSwarmSize' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleDeathSwarmItem, DeathSwarmAbilityTag) == 0x000004, "Member 'FDesignDataFloorRuleDeathSwarmItem::DeathSwarmAbilityTag' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleDeathSwarmItem, DisplayPhaseDuration) == 0x00000C, "Member 'FDesignDataFloorRuleDeathSwarmItem::DisplayPhaseDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleDeathSwarmItem, DisplayPhaseFloorPortalArray) == 0x000010, "Member 'FDesignDataFloorRuleDeathSwarmItem::DisplayPhaseFloorPortalArray' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleDeathSwarmItem, ShrinkPhaseDuration) == 0x000020, "Member 'FDesignDataFloorRuleDeathSwarmItem::ShrinkPhaseDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleDeathSwarmItem, ShrinkPhaseFloorPortalArray) == 0x000028, "Member 'FDesignDataFloorRuleDeathSwarmItem::ShrinkPhaseFloorPortalArray' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleDeathSwarmItem, HideDeathSwarmTimer) == 0x000038, "Member 'FDesignDataFloorRuleDeathSwarmItem::HideDeathSwarmTimer' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleDeathSwarmItem, SoundData) == 0x00003C, "Member 'FDesignDataFloorRuleDeathSwarmItem::SoundData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataFloorRuleDeathSwarm
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataFloorRuleDeathSwarm final
{
public:
	TArray<struct FDesignDataFloorRuleDeathSwarmItem> FloorRuleItemArray;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataFloorRuleDeathSwarm) == 0x000008, "Wrong alignment on FDesignDataFloorRuleDeathSwarm");
static_assert(sizeof(FDesignDataFloorRuleDeathSwarm) == 0x000010, "Wrong size on FDesignDataFloorRuleDeathSwarm");
static_assert(offsetof(FDesignDataFloorRuleDeathSwarm, FloorRuleItemArray) == 0x000000, "Member 'FDesignDataFloorRuleDeathSwarm::FloorRuleItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgEnableAddItemRequest
// 0x0018 (0x0030 - 0x0018)
struct FMsgEnableAddItemRequest final : public FMsgBase
{
public:
	int32                                         TargetInventoryId;                                 // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A7[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemData>                      AddItemDataArray;                                  // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgEnableAddItemRequest) == 0x000008, "Wrong alignment on FMsgEnableAddItemRequest");
static_assert(sizeof(FMsgEnableAddItemRequest) == 0x000030, "Wrong size on FMsgEnableAddItemRequest");
static_assert(offsetof(FMsgEnableAddItemRequest, TargetInventoryId) == 0x000018, "Member 'FMsgEnableAddItemRequest::TargetInventoryId' has a wrong offset!");
static_assert(offsetof(FMsgEnableAddItemRequest, AddItemDataArray) == 0x000020, "Member 'FMsgEnableAddItemRequest::AddItemDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataFloorRuleBlizzardItem
// 0x0038 (0x0038 - 0x0000)
struct FDesignDataFloorRuleBlizzardItem final
{
public:
	struct FGameplayTag                           BlizzardAbilityTag;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseDuration;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A8[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                PhaseFloorPortalArray;                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          HideBlizzardTimer;                                 // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A9[0x3];                                     // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        SoundData;                                         // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AA[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataFloorRuleBlizzardItem) == 0x000008, "Wrong alignment on FDesignDataFloorRuleBlizzardItem");
static_assert(sizeof(FDesignDataFloorRuleBlizzardItem) == 0x000038, "Wrong size on FDesignDataFloorRuleBlizzardItem");
static_assert(offsetof(FDesignDataFloorRuleBlizzardItem, BlizzardAbilityTag) == 0x000000, "Member 'FDesignDataFloorRuleBlizzardItem::BlizzardAbilityTag' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleBlizzardItem, PhaseDuration) == 0x000008, "Member 'FDesignDataFloorRuleBlizzardItem::PhaseDuration' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleBlizzardItem, PhaseFloorPortalArray) == 0x000010, "Member 'FDesignDataFloorRuleBlizzardItem::PhaseFloorPortalArray' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleBlizzardItem, HideBlizzardTimer) == 0x000020, "Member 'FDesignDataFloorRuleBlizzardItem::HideBlizzardTimer' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleBlizzardItem, SoundData) == 0x000024, "Member 'FDesignDataFloorRuleBlizzardItem::SoundData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataFloorRuleBlizzard
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataFloorRuleBlizzard final
{
public:
	TArray<struct FDesignDataFloorRuleBlizzardItem> FloorRuleItemArray;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataFloorRuleBlizzard) == 0x000008, "Wrong alignment on FDesignDataFloorRuleBlizzard");
static_assert(sizeof(FDesignDataFloorRuleBlizzard) == 0x000010, "Wrong size on FDesignDataFloorRuleBlizzard");
static_assert(offsetof(FDesignDataFloorRuleBlizzard, FloorRuleItemArray) == 0x000000, "Member 'FDesignDataFloorRuleBlizzard::FloorRuleItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataFloorPortal
// 0x000C (0x000C - 0x0000)
struct FDesignDataFloorPortal final
{
public:
	struct FGameplayTag                           PortalType;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortalScrollNum;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataFloorPortal) == 0x000004, "Wrong alignment on FDesignDataFloorPortal");
static_assert(sizeof(FDesignDataFloorPortal) == 0x00000C, "Wrong size on FDesignDataFloorPortal");
static_assert(offsetof(FDesignDataFloorPortal, PortalType) == 0x000000, "Member 'FDesignDataFloorPortal::PortalType' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorPortal, PortalScrollNum) == 0x000008, "Member 'FDesignDataFloorPortal::PortalScrollNum' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInventoryItemAmmoAddRequest
// 0x0018 (0x0030 - 0x0018)
struct FMsgInventoryItemAmmoAddRequest final : public FMsgBase
{
public:
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AB[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUniqueId;                                      // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AC[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgInventoryItemAmmoAddRequest) == 0x000008, "Wrong alignment on FMsgInventoryItemAmmoAddRequest");
static_assert(sizeof(FMsgInventoryItemAmmoAddRequest) == 0x000030, "Wrong size on FMsgInventoryItemAmmoAddRequest");
static_assert(offsetof(FMsgInventoryItemAmmoAddRequest, InventoryId) == 0x000018, "Member 'FMsgInventoryItemAmmoAddRequest::InventoryId' has a wrong offset!");
static_assert(offsetof(FMsgInventoryItemAmmoAddRequest, ItemUniqueId) == 0x000020, "Member 'FMsgInventoryItemAmmoAddRequest::ItemUniqueId' has a wrong offset!");
static_assert(offsetof(FMsgInventoryItemAmmoAddRequest, Count) == 0x000028, "Member 'FMsgInventoryItemAmmoAddRequest::Count' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMerchant
// 0x0050 (0x0050 - 0x0000)
struct FDesignDataMerchant final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   GreetingText;                                      // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EDCMerchantServiceType>                ServiceTypes;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMerchant) == 0x000008, "Wrong alignment on FDesignDataMerchant");
static_assert(sizeof(FDesignDataMerchant) == 0x000050, "Wrong size on FDesignDataMerchant");
static_assert(offsetof(FDesignDataMerchant, Name) == 0x000000, "Member 'FDesignDataMerchant::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataMerchant, GreetingText) == 0x000018, "Member 'FDesignDataMerchant::GreetingText' has a wrong offset!");
static_assert(offsetof(FDesignDataMerchant, ArtData) == 0x000030, "Member 'FDesignDataMerchant::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataMerchant, ServiceTypes) == 0x000040, "Member 'FDesignDataMerchant::ServiceTypes' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMerchantAffinity
// 0x0018 (0x0018 - 0x0000)
struct FDesignDataMerchantAffinity final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMerchantAffinity) == 0x000008, "Wrong alignment on FDesignDataMerchantAffinity");
static_assert(sizeof(FDesignDataMerchantAffinity) == 0x000018, "Wrong size on FDesignDataMerchantAffinity");
static_assert(offsetof(FDesignDataMerchantAffinity, Name) == 0x000000, "Member 'FDesignDataMerchantAffinity::Name' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataRecoveryAffinity
// 0x0001 (0x0001 - 0x0000)
struct FDesignDataRecoveryAffinity final
{
public:
	uint8                                         Pad_22AD[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataRecoveryAffinity) == 0x000001, "Wrong alignment on FDesignDataRecoveryAffinity");
static_assert(sizeof(FDesignDataRecoveryAffinity) == 0x000001, "Wrong size on FDesignDataRecoveryAffinity");

// ScriptStruct DungeonCrawler.DesignDataMerchantSchedule
// 0x0001 (0x0001 - 0x0000)
struct FDesignDataMerchantSchedule final
{
public:
	uint8                                         Pad_22AE[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataMerchantSchedule) == 0x000001, "Wrong alignment on FDesignDataMerchantSchedule");
static_assert(sizeof(FDesignDataMerchantSchedule) == 0x000001, "Wrong size on FDesignDataMerchantSchedule");

// ScriptStruct DungeonCrawler.MsgMoveItem
// 0x0120 (0x0138 - 0x0018)
struct FMsgMoveItem final : public FMsgBase
{
public:
	class AActor*                                 OldOwner;                                          // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              OldItemData;                                       // 0x0020(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
	class AActor*                                 NewOwner;                                          // 0x0120(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemData>                      NewItemDataArray;                                  // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgMoveItem) == 0x000008, "Wrong alignment on FMsgMoveItem");
static_assert(sizeof(FMsgMoveItem) == 0x000138, "Wrong size on FMsgMoveItem");
static_assert(offsetof(FMsgMoveItem, OldOwner) == 0x000018, "Member 'FMsgMoveItem::OldOwner' has a wrong offset!");
static_assert(offsetof(FMsgMoveItem, OldItemData) == 0x000020, "Member 'FMsgMoveItem::OldItemData' has a wrong offset!");
static_assert(offsetof(FMsgMoveItem, NewOwner) == 0x000120, "Member 'FMsgMoveItem::NewOwner' has a wrong offset!");
static_assert(offsetof(FMsgMoveItem, NewItemDataArray) == 0x000128, "Member 'FMsgMoveItem::NewItemDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataStockBuyItem
// 0x00B0 (0x00B0 - 0x0000)
struct FDesignDataStockBuyItem final
{
public:
	int64                                         UniqueID;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ConversationText;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   SaleCompleteText;                                  // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ItemId;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RequiredItemId_01;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount01;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RequiredItemId_02;                                 // 0x005C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount02;                                  // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RequiredItemId_03;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount03;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RequiredItemId_04;                                 // 0x0084(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount04;                                  // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RequiredItemId_05;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount05;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22AF[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataStockBuyItem) == 0x000008, "Wrong alignment on FDesignDataStockBuyItem");
static_assert(sizeof(FDesignDataStockBuyItem) == 0x0000B0, "Wrong size on FDesignDataStockBuyItem");
static_assert(offsetof(FDesignDataStockBuyItem, UniqueID) == 0x000000, "Member 'FDesignDataStockBuyItem::UniqueID' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, ConversationText) == 0x000008, "Member 'FDesignDataStockBuyItem::ConversationText' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, SaleCompleteText) == 0x000020, "Member 'FDesignDataStockBuyItem::SaleCompleteText' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, ItemId) == 0x000038, "Member 'FDesignDataStockBuyItem::ItemId' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, RequiredItemId_01) == 0x000048, "Member 'FDesignDataStockBuyItem::RequiredItemId_01' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, RequiredAmount01) == 0x000058, "Member 'FDesignDataStockBuyItem::RequiredAmount01' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, RequiredItemId_02) == 0x00005C, "Member 'FDesignDataStockBuyItem::RequiredItemId_02' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, RequiredAmount02) == 0x00006C, "Member 'FDesignDataStockBuyItem::RequiredAmount02' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, RequiredItemId_03) == 0x000070, "Member 'FDesignDataStockBuyItem::RequiredItemId_03' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, RequiredAmount03) == 0x000080, "Member 'FDesignDataStockBuyItem::RequiredAmount03' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, RequiredItemId_04) == 0x000084, "Member 'FDesignDataStockBuyItem::RequiredItemId_04' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, RequiredAmount04) == 0x000094, "Member 'FDesignDataStockBuyItem::RequiredAmount04' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, RequiredItemId_05) == 0x000098, "Member 'FDesignDataStockBuyItem::RequiredItemId_05' has a wrong offset!");
static_assert(offsetof(FDesignDataStockBuyItem, RequiredAmount05) == 0x0000A8, "Member 'FDesignDataStockBuyItem::RequiredAmount05' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataStockBuy
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataStockBuy final
{
public:
	TArray<struct FDesignDataStockBuyItem>        StockBuyItemArray;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataStockBuy) == 0x000008, "Wrong alignment on FDesignDataStockBuy");
static_assert(sizeof(FDesignDataStockBuy) == 0x000010, "Wrong size on FDesignDataStockBuy");
static_assert(offsetof(FDesignDataStockBuy, StockBuyItemArray) == 0x000000, "Member 'FDesignDataStockBuy::StockBuyItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataStockSellBackItem
// 0x0070 (0x0070 - 0x0000)
struct FDesignDataStockSellBackItem final
{
public:
	int64                                         UniqueID;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ConversationText;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ItemId;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReceivedItemId_01;                                 // 0x0034(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReceivedAmount01;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReceivedItemId_02;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReceivedAmount02;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReceivedItemId_03;                                 // 0x005C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReceivedAmount03;                                  // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataStockSellBackItem) == 0x000008, "Wrong alignment on FDesignDataStockSellBackItem");
static_assert(sizeof(FDesignDataStockSellBackItem) == 0x000070, "Wrong size on FDesignDataStockSellBackItem");
static_assert(offsetof(FDesignDataStockSellBackItem, UniqueID) == 0x000000, "Member 'FDesignDataStockSellBackItem::UniqueID' has a wrong offset!");
static_assert(offsetof(FDesignDataStockSellBackItem, ConversationText) == 0x000008, "Member 'FDesignDataStockSellBackItem::ConversationText' has a wrong offset!");
static_assert(offsetof(FDesignDataStockSellBackItem, ItemId) == 0x000020, "Member 'FDesignDataStockSellBackItem::ItemId' has a wrong offset!");
static_assert(offsetof(FDesignDataStockSellBackItem, ItemCount) == 0x000030, "Member 'FDesignDataStockSellBackItem::ItemCount' has a wrong offset!");
static_assert(offsetof(FDesignDataStockSellBackItem, ReceivedItemId_01) == 0x000034, "Member 'FDesignDataStockSellBackItem::ReceivedItemId_01' has a wrong offset!");
static_assert(offsetof(FDesignDataStockSellBackItem, ReceivedAmount01) == 0x000044, "Member 'FDesignDataStockSellBackItem::ReceivedAmount01' has a wrong offset!");
static_assert(offsetof(FDesignDataStockSellBackItem, ReceivedItemId_02) == 0x000048, "Member 'FDesignDataStockSellBackItem::ReceivedItemId_02' has a wrong offset!");
static_assert(offsetof(FDesignDataStockSellBackItem, ReceivedAmount02) == 0x000058, "Member 'FDesignDataStockSellBackItem::ReceivedAmount02' has a wrong offset!");
static_assert(offsetof(FDesignDataStockSellBackItem, ReceivedItemId_03) == 0x00005C, "Member 'FDesignDataStockSellBackItem::ReceivedItemId_03' has a wrong offset!");
static_assert(offsetof(FDesignDataStockSellBackItem, ReceivedAmount03) == 0x00006C, "Member 'FDesignDataStockSellBackItem::ReceivedAmount03' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataStockSellBack
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataStockSellBack final
{
public:
	TArray<struct FDesignDataStockSellBackItem>   StockSellBackItemArray;                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataStockSellBack) == 0x000008, "Wrong alignment on FDesignDataStockSellBack");
static_assert(sizeof(FDesignDataStockSellBack) == 0x000010, "Wrong size on FDesignDataStockSellBack");
static_assert(offsetof(FDesignDataStockSellBack, StockSellBackItemArray) == 0x000000, "Member 'FDesignDataStockSellBack::StockSellBackItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassShapeShiftSlotMoveResponse
// 0x0018 (0x0030 - 0x0018)
struct FMsgGameTestClassShapeShiftSlotMoveResponse final : public FMsgBase
{
public:
	int32                                         Result;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B0[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAccountDataShapeShift>         EquipShapeShiftList;                               // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassShapeShiftSlotMoveResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassShapeShiftSlotMoveResponse");
static_assert(sizeof(FMsgGameTestClassShapeShiftSlotMoveResponse) == 0x000030, "Wrong size on FMsgGameTestClassShapeShiftSlotMoveResponse");
static_assert(offsetof(FMsgGameTestClassShapeShiftSlotMoveResponse, Result) == 0x000018, "Member 'FMsgGameTestClassShapeShiftSlotMoveResponse::Result' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassShapeShiftSlotMoveResponse, EquipShapeShiftList) == 0x000020, "Member 'FMsgGameTestClassShapeShiftSlotMoveResponse::EquipShapeShiftList' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPlayerReturnToCharacterSelectRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgPlayerReturnToCharacterSelectRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgPlayerReturnToCharacterSelectRequest) == 0x000008, "Wrong alignment on FMsgPlayerReturnToCharacterSelectRequest");
static_assert(sizeof(FMsgPlayerReturnToCharacterSelectRequest) == 0x000018, "Wrong size on FMsgPlayerReturnToCharacterSelectRequest");

// ScriptStruct DungeonCrawler.DesignDataStockCraftItem
// 0x00B0 (0x00B0 - 0x0000)
struct FDesignDataStockCraftItem final
{
public:
	int64                                         UniqueID;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ConversationText;                                  // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CraftCompleteText;                                 // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ItemId;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RequiredItemId_01;                                 // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount01;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RequiredItemId_02;                                 // 0x005C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount02;                                  // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RequiredItemId_03;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount03;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RequiredItemId_04;                                 // 0x0084(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount04;                                  // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RequiredItemId_05;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAmount05;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B1[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataStockCraftItem) == 0x000008, "Wrong alignment on FDesignDataStockCraftItem");
static_assert(sizeof(FDesignDataStockCraftItem) == 0x0000B0, "Wrong size on FDesignDataStockCraftItem");
static_assert(offsetof(FDesignDataStockCraftItem, UniqueID) == 0x000000, "Member 'FDesignDataStockCraftItem::UniqueID' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, ConversationText) == 0x000008, "Member 'FDesignDataStockCraftItem::ConversationText' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, CraftCompleteText) == 0x000020, "Member 'FDesignDataStockCraftItem::CraftCompleteText' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, ItemId) == 0x000038, "Member 'FDesignDataStockCraftItem::ItemId' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, RequiredItemId_01) == 0x000048, "Member 'FDesignDataStockCraftItem::RequiredItemId_01' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, RequiredAmount01) == 0x000058, "Member 'FDesignDataStockCraftItem::RequiredAmount01' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, RequiredItemId_02) == 0x00005C, "Member 'FDesignDataStockCraftItem::RequiredItemId_02' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, RequiredAmount02) == 0x00006C, "Member 'FDesignDataStockCraftItem::RequiredAmount02' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, RequiredItemId_03) == 0x000070, "Member 'FDesignDataStockCraftItem::RequiredItemId_03' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, RequiredAmount03) == 0x000080, "Member 'FDesignDataStockCraftItem::RequiredAmount03' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, RequiredItemId_04) == 0x000084, "Member 'FDesignDataStockCraftItem::RequiredItemId_04' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, RequiredAmount04) == 0x000094, "Member 'FDesignDataStockCraftItem::RequiredAmount04' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, RequiredItemId_05) == 0x000098, "Member 'FDesignDataStockCraftItem::RequiredItemId_05' has a wrong offset!");
static_assert(offsetof(FDesignDataStockCraftItem, RequiredAmount05) == 0x0000A8, "Member 'FDesignDataStockCraftItem::RequiredAmount05' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataStockCraft
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataStockCraft final
{
public:
	TArray<struct FDesignDataStockCraftItem>      StockCraftItemArray;                               // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataStockCraft) == 0x000008, "Wrong alignment on FDesignDataStockCraft");
static_assert(sizeof(FDesignDataStockCraft) == 0x000010, "Wrong size on FDesignDataStockCraft");
static_assert(offsetof(FDesignDataStockCraft, StockCraftItemArray) == 0x000000, "Member 'FDesignDataStockCraft::StockCraftItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataBaseGear
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataBaseGear final
{
public:
	TArray<struct FDesignDataBaseGearItem>        BaseGearItemArray;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataBaseGear) == 0x000008, "Wrong alignment on FDesignDataBaseGear");
static_assert(sizeof(FDesignDataBaseGear) == 0x000010, "Wrong size on FDesignDataBaseGear");
static_assert(offsetof(FDesignDataBaseGear, BaseGearItemArray) == 0x000000, "Member 'FDesignDataBaseGear::BaseGearItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ObjectLinkResponeEvent
// 0x0060 (0x0060 - 0x0000)
struct FObjectLinkResponeEvent final
{
public:
	struct FGameplayTag                           SrcTypeTag;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FObjectLinkMetaData                    MetaData;                                          // 0x0008(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectLinkResponeEvent) == 0x000008, "Wrong alignment on FObjectLinkResponeEvent");
static_assert(sizeof(FObjectLinkResponeEvent) == 0x000060, "Wrong size on FObjectLinkResponeEvent");
static_assert(offsetof(FObjectLinkResponeEvent, SrcTypeTag) == 0x000000, "Member 'FObjectLinkResponeEvent::SrcTypeTag' has a wrong offset!");
static_assert(offsetof(FObjectLinkResponeEvent, MetaData) == 0x000008, "Member 'FObjectLinkResponeEvent::MetaData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgShowSystemMessage
// 0x0018 (0x0030 - 0x0018)
struct FMsgShowSystemMessage final : public FMsgBase
{
public:
	class FText                                   MessageToShow;                                     // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgShowSystemMessage) == 0x000008, "Wrong alignment on FMsgShowSystemMessage");
static_assert(sizeof(FMsgShowSystemMessage) == 0x000030, "Wrong size on FMsgShowSystemMessage");
static_assert(offsetof(FMsgShowSystemMessage, MessageToShow) == 0x000018, "Member 'FMsgShowSystemMessage::MessageToShow' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataConstant
// 0x0008 (0x0008 - 0x0000)
struct FDesignDataConstant final
{
public:
	float                                         FloatValue;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int32Value;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataConstant) == 0x000004, "Wrong alignment on FDesignDataConstant");
static_assert(sizeof(FDesignDataConstant) == 0x000008, "Wrong size on FDesignDataConstant");
static_assert(offsetof(FDesignDataConstant, FloatValue) == 0x000000, "Member 'FDesignDataConstant::FloatValue' has a wrong offset!");
static_assert(offsetof(FDesignDataConstant, Int32Value) == 0x000004, "Member 'FDesignDataConstant::Int32Value' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataEmote
// 0x0068 (0x0068 - 0x0000)
struct FDesignDataEmote final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   FlavorText;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EmoteTag;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Abilities;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Effects;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataEmote) == 0x000008, "Wrong alignment on FDesignDataEmote");
static_assert(sizeof(FDesignDataEmote) == 0x000068, "Wrong size on FDesignDataEmote");
static_assert(offsetof(FDesignDataEmote, Name) == 0x000000, "Member 'FDesignDataEmote::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataEmote, FlavorText) == 0x000018, "Member 'FDesignDataEmote::FlavorText' has a wrong offset!");
static_assert(offsetof(FDesignDataEmote, EmoteTag) == 0x000030, "Member 'FDesignDataEmote::EmoteTag' has a wrong offset!");
static_assert(offsetof(FDesignDataEmote, ArtData) == 0x000038, "Member 'FDesignDataEmote::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataEmote, Abilities) == 0x000048, "Member 'FDesignDataEmote::Abilities' has a wrong offset!");
static_assert(offsetof(FDesignDataEmote, Effects) == 0x000058, "Member 'FDesignDataEmote::Effects' has a wrong offset!");

// ScriptStruct DungeonCrawler.GameUserSettingVideoDisplay
// 0x0040 (0x0040 - 0x0000)
struct FGameUserSettingVideoDisplay final
{
public:
	int32                                         ShadowQuality;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectsQuality;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PostProcessQuality;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TextureQuality;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplayMode;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResolutionIndex;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameRateLimit;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameRateLimitMeta;                                // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GammaValue;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAntialiasMode                                AntiAliasingSuperResolution;                       // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B2[0x3];                                     // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RenderScale;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperResolutionModeTSR;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperResolutionModeDLSS;                           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperResolutionModeFSR;                            // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SuperResolutionModeXeSS;                           // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClothSimulation;                                  // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B3[0x3];                                     // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameUserSettingVideoDisplay) == 0x000004, "Wrong alignment on FGameUserSettingVideoDisplay");
static_assert(sizeof(FGameUserSettingVideoDisplay) == 0x000040, "Wrong size on FGameUserSettingVideoDisplay");
static_assert(offsetof(FGameUserSettingVideoDisplay, ShadowQuality) == 0x000000, "Member 'FGameUserSettingVideoDisplay::ShadowQuality' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, EffectsQuality) == 0x000004, "Member 'FGameUserSettingVideoDisplay::EffectsQuality' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, PostProcessQuality) == 0x000008, "Member 'FGameUserSettingVideoDisplay::PostProcessQuality' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, TextureQuality) == 0x00000C, "Member 'FGameUserSettingVideoDisplay::TextureQuality' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, DisplayMode) == 0x000010, "Member 'FGameUserSettingVideoDisplay::DisplayMode' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, ResolutionIndex) == 0x000014, "Member 'FGameUserSettingVideoDisplay::ResolutionIndex' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, FrameRateLimit) == 0x000018, "Member 'FGameUserSettingVideoDisplay::FrameRateLimit' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, FrameRateLimitMeta) == 0x00001C, "Member 'FGameUserSettingVideoDisplay::FrameRateLimitMeta' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, GammaValue) == 0x000020, "Member 'FGameUserSettingVideoDisplay::GammaValue' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, AntiAliasingSuperResolution) == 0x000024, "Member 'FGameUserSettingVideoDisplay::AntiAliasingSuperResolution' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, RenderScale) == 0x000028, "Member 'FGameUserSettingVideoDisplay::RenderScale' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, SuperResolutionModeTSR) == 0x00002C, "Member 'FGameUserSettingVideoDisplay::SuperResolutionModeTSR' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, SuperResolutionModeDLSS) == 0x000030, "Member 'FGameUserSettingVideoDisplay::SuperResolutionModeDLSS' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, SuperResolutionModeFSR) == 0x000034, "Member 'FGameUserSettingVideoDisplay::SuperResolutionModeFSR' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, SuperResolutionModeXeSS) == 0x000038, "Member 'FGameUserSettingVideoDisplay::SuperResolutionModeXeSS' has a wrong offset!");
static_assert(offsetof(FGameUserSettingVideoDisplay, bClothSimulation) == 0x00003C, "Member 'FGameUserSettingVideoDisplay::bClothSimulation' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgProjectileHitByTarget
// 0x0020 (0x0038 - 0x0018)
struct FMsgProjectileHitByTarget final : public FMsgBase
{
public:
	class AActor*                                 SourceActor;                                       // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0020(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgProjectileHitByTarget) == 0x000008, "Wrong alignment on FMsgProjectileHitByTarget");
static_assert(sizeof(FMsgProjectileHitByTarget) == 0x000038, "Wrong size on FMsgProjectileHitByTarget");
static_assert(offsetof(FMsgProjectileHitByTarget, SourceActor) == 0x000018, "Member 'FMsgProjectileHitByTarget::SourceActor' has a wrong offset!");
static_assert(offsetof(FMsgProjectileHitByTarget, HitLocation) == 0x000020, "Member 'FMsgProjectileHitByTarget::HitLocation' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataGameplayCueTagGroupItem
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataGameplayCueTagGroupItem final
{
public:
	struct FGameplayTag                           StateTag;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CueTag;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataGameplayCueTagGroupItem) == 0x000004, "Wrong alignment on FDesignDataGameplayCueTagGroupItem");
static_assert(sizeof(FDesignDataGameplayCueTagGroupItem) == 0x000010, "Wrong size on FDesignDataGameplayCueTagGroupItem");
static_assert(offsetof(FDesignDataGameplayCueTagGroupItem, StateTag) == 0x000000, "Member 'FDesignDataGameplayCueTagGroupItem::StateTag' has a wrong offset!");
static_assert(offsetof(FDesignDataGameplayCueTagGroupItem, CueTag) == 0x000008, "Member 'FDesignDataGameplayCueTagGroupItem::CueTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataGameplayCueTagGroup
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataGameplayCueTagGroup final
{
public:
	TArray<struct FDesignDataGameplayCueTagGroupItem> GameplayCueTagGroupItemArray;                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataGameplayCueTagGroup) == 0x000008, "Wrong alignment on FDesignDataGameplayCueTagGroup");
static_assert(sizeof(FDesignDataGameplayCueTagGroup) == 0x000010, "Wrong size on FDesignDataGameplayCueTagGroup");
static_assert(offsetof(FDesignDataGameplayCueTagGroup, GameplayCueTagGroupItemArray) == 0x000000, "Member 'FDesignDataGameplayCueTagGroup::GameplayCueTagGroupItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataAbilityRelationshipTagGroup
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataAbilityRelationshipTagGroup final
{
public:
	TArray<struct FDesignDataAbilityRelationshipTagGroupItem> AbilityRelationshipTagGroupItemArray;              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataAbilityRelationshipTagGroup) == 0x000008, "Wrong alignment on FDesignDataAbilityRelationshipTagGroup");
static_assert(sizeof(FDesignDataAbilityRelationshipTagGroup) == 0x000010, "Wrong size on FDesignDataAbilityRelationshipTagGroup");
static_assert(offsetof(FDesignDataAbilityRelationshipTagGroup, AbilityRelationshipTagGroupItemArray) == 0x000000, "Member 'FDesignDataAbilityRelationshipTagGroup::AbilityRelationshipTagGroupItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.AuraTargetCountData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FAuraTargetCountData final
{
public:
	uint8                                         Pad_22B4[0xC];                                     // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAuraTargetCountData) == 0x000004, "Wrong alignment on FAuraTargetCountData");
static_assert(sizeof(FAuraTargetCountData) == 0x00000C, "Wrong size on FAuraTargetCountData");

// ScriptStruct DungeonCrawler.ReligionRankRecordData
// 0x0090 (0x0090 - 0x0000)
struct FReligionRankRecordData final
{
public:
	struct FDCReligionRankEntryInfo               RankRecord;                                        // 0x0000(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0048(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsMine;                                           // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B5[0x7];                                     // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReligionRankRecordData) == 0x000008, "Wrong alignment on FReligionRankRecordData");
static_assert(sizeof(FReligionRankRecordData) == 0x000090, "Wrong size on FReligionRankRecordData");
static_assert(offsetof(FReligionRankRecordData, RankRecord) == 0x000000, "Member 'FReligionRankRecordData::RankRecord' has a wrong offset!");
static_assert(offsetof(FReligionRankRecordData, Nickname) == 0x000048, "Member 'FReligionRankRecordData::Nickname' has a wrong offset!");
static_assert(offsetof(FReligionRankRecordData, bIsMine) == 0x000088, "Member 'FReligionRankRecordData::bIsMine' has a wrong offset!");

// ScriptStruct DungeonCrawler.ReligionRankRecordWidgetHandleData
// 0x0090 (0x0090 - 0x0000)
struct FReligionRankRecordWidgetHandleData final
{
public:
	struct FReligionRankRecordData                ReligionRankRecordData;                            // 0x0000(0x0090)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReligionRankRecordWidgetHandleData) == 0x000008, "Wrong alignment on FReligionRankRecordWidgetHandleData");
static_assert(sizeof(FReligionRankRecordWidgetHandleData) == 0x000090, "Wrong size on FReligionRankRecordWidgetHandleData");
static_assert(offsetof(FReligionRankRecordWidgetHandleData, ReligionRankRecordData) == 0x000000, "Member 'FReligionRankRecordWidgetHandleData::ReligionRankRecordData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataDungeon
// 0x0078 (0x0078 - 0x0000)
struct FDesignDataDungeon final
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EGameType>                             GameTypes;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Floor;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        FloorRule;                                         // 0x0034(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B6[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UWorld>                  LevelAsset;                                        // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriumphExp;                                        // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B7[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataDungeon) == 0x000008, "Wrong alignment on FDesignDataDungeon");
static_assert(sizeof(FDesignDataDungeon) == 0x000078, "Wrong size on FDesignDataDungeon");
static_assert(offsetof(FDesignDataDungeon, IdTag) == 0x000000, "Member 'FDesignDataDungeon::IdTag' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeon, Name) == 0x000008, "Member 'FDesignDataDungeon::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeon, GameTypes) == 0x000020, "Member 'FDesignDataDungeon::GameTypes' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeon, Floor) == 0x000030, "Member 'FDesignDataDungeon::Floor' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeon, FloorRule) == 0x000034, "Member 'FDesignDataDungeon::FloorRule' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeon, LevelAsset) == 0x000048, "Member 'FDesignDataDungeon::LevelAsset' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeon, TriumphExp) == 0x000070, "Member 'FDesignDataDungeon::TriumphExp' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataDungeonType
// 0x0070 (0x0070 - 0x0000)
struct FDesignDataDungeonType final
{
public:
	struct FGameplayTag                           IdTag;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   GroupName;                                         // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ChapterName;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Desc;                                              // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B8[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataDungeonType) == 0x000008, "Wrong alignment on FDesignDataDungeonType");
static_assert(sizeof(FDesignDataDungeonType) == 0x000070, "Wrong size on FDesignDataDungeonType");
static_assert(offsetof(FDesignDataDungeonType, IdTag) == 0x000000, "Member 'FDesignDataDungeonType::IdTag' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeonType, Name) == 0x000008, "Member 'FDesignDataDungeonType::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeonType, GroupName) == 0x000020, "Member 'FDesignDataDungeonType::GroupName' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeonType, ChapterName) == 0x000038, "Member 'FDesignDataDungeonType::ChapterName' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeonType, Desc) == 0x000050, "Member 'FDesignDataDungeonType::Desc' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeonType, Order) == 0x000068, "Member 'FDesignDataDungeonType::Order' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataDungeonModule
// 0x0018 (0x0018 - 0x0000)
struct FDesignDataDungeonModule final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataDungeonModule) == 0x000008, "Wrong alignment on FDesignDataDungeonModule");
static_assert(sizeof(FDesignDataDungeonModule) == 0x000018, "Wrong size on FDesignDataDungeonModule");
static_assert(offsetof(FDesignDataDungeonModule, Name) == 0x000000, "Member 'FDesignDataDungeonModule::Name' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataShop
// 0x0058 (0x0058 - 0x0000)
struct FDesignDataShop final
{
public:
	struct FPrimaryAssetId                        StockData;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnSale;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22B9[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountPrice;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CashPrice;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountCashPrice;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BA[0x3];                                     // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCShopSalesChannelType                       SalesChannel;                                      // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BB[0x3];                                     // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ExclusiveSourceText;                               // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataShop) == 0x000008, "Wrong alignment on FDesignDataShop");
static_assert(sizeof(FDesignDataShop) == 0x000058, "Wrong size on FDesignDataShop");
static_assert(offsetof(FDesignDataShop, StockData) == 0x000000, "Member 'FDesignDataShop::StockData' has a wrong offset!");
static_assert(offsetof(FDesignDataShop, IsOnSale) == 0x000010, "Member 'FDesignDataShop::IsOnSale' has a wrong offset!");
static_assert(offsetof(FDesignDataShop, Price) == 0x000014, "Member 'FDesignDataShop::Price' has a wrong offset!");
static_assert(offsetof(FDesignDataShop, DiscountPrice) == 0x000018, "Member 'FDesignDataShop::DiscountPrice' has a wrong offset!");
static_assert(offsetof(FDesignDataShop, CashPrice) == 0x00001C, "Member 'FDesignDataShop::CashPrice' has a wrong offset!");
static_assert(offsetof(FDesignDataShop, DiscountCashPrice) == 0x000020, "Member 'FDesignDataShop::DiscountCashPrice' has a wrong offset!");
static_assert(offsetof(FDesignDataShop, IsNew) == 0x000024, "Member 'FDesignDataShop::IsNew' has a wrong offset!");
static_assert(offsetof(FDesignDataShop, SortOrder) == 0x000028, "Member 'FDesignDataShop::SortOrder' has a wrong offset!");
static_assert(offsetof(FDesignDataShop, SalesChannel) == 0x00002C, "Member 'FDesignDataShop::SalesChannel' has a wrong offset!");
static_assert(offsetof(FDesignDataShop, ExclusiveSourceText) == 0x000030, "Member 'FDesignDataShop::ExclusiveSourceText' has a wrong offset!");
static_assert(offsetof(FDesignDataShop, ArtData) == 0x000048, "Member 'FDesignDataShop::ArtData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameStateNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgGameStateNotify final : public FMsgBase
{
public:
	struct FGameStateData                         GameStateData;                                     // 0x0018(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameStateNotify) == 0x000008, "Wrong alignment on FMsgGameStateNotify");
static_assert(sizeof(FMsgGameStateNotify) == 0x000020, "Wrong size on FMsgGameStateNotify");
static_assert(offsetof(FMsgGameStateNotify, GameStateData) == 0x000018, "Member 'FMsgGameStateNotify::GameStateData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataItemSkinShop
// 0x0078 (0x0078 - 0x0000)
struct FDesignDataItemSkinShop final
{
public:
	TArray<struct FPrimaryAssetId>                StockDatas;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   PackageName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsOnSale;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BC[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountPrice;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CashPrice;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiscountCashPrice;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BD[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCShopSalesChannelType                       SalesChannel;                                      // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BE[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ExclusiveSourceText;                               // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCItemPreviewDataAsset*                PackagePreview;                                    // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemSkinShop) == 0x000008, "Wrong alignment on FDesignDataItemSkinShop");
static_assert(sizeof(FDesignDataItemSkinShop) == 0x000078, "Wrong size on FDesignDataItemSkinShop");
static_assert(offsetof(FDesignDataItemSkinShop, StockDatas) == 0x000000, "Member 'FDesignDataItemSkinShop::StockDatas' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, PackageName) == 0x000010, "Member 'FDesignDataItemSkinShop::PackageName' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, IsOnSale) == 0x000028, "Member 'FDesignDataItemSkinShop::IsOnSale' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, Price) == 0x00002C, "Member 'FDesignDataItemSkinShop::Price' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, DiscountPrice) == 0x000030, "Member 'FDesignDataItemSkinShop::DiscountPrice' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, CashPrice) == 0x000034, "Member 'FDesignDataItemSkinShop::CashPrice' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, DiscountCashPrice) == 0x000038, "Member 'FDesignDataItemSkinShop::DiscountCashPrice' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, IsNew) == 0x00003C, "Member 'FDesignDataItemSkinShop::IsNew' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, SortOrder) == 0x000040, "Member 'FDesignDataItemSkinShop::SortOrder' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, SalesChannel) == 0x000044, "Member 'FDesignDataItemSkinShop::SalesChannel' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, ExclusiveSourceText) == 0x000048, "Member 'FDesignDataItemSkinShop::ExclusiveSourceText' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, ArtData) == 0x000060, "Member 'FDesignDataItemSkinShop::ArtData' has a wrong offset!");
static_assert(offsetof(FDesignDataItemSkinShop, PackagePreview) == 0x000070, "Member 'FDesignDataItemSkinShop::PackagePreview' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataRedstonShardShop
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataRedstonShardShop final
{
public:
	struct FPrimaryAssetId                        ArtData;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataRedstonShardShop) == 0x000004, "Wrong alignment on FDesignDataRedstonShardShop");
static_assert(sizeof(FDesignDataRedstonShardShop) == 0x000010, "Wrong size on FDesignDataRedstonShardShop");
static_assert(offsetof(FDesignDataRedstonShardShop, ArtData) == 0x000000, "Member 'FDesignDataRedstonShardShop::ArtData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataChatRoom
// 0x0068 (0x0068 - 0x0000)
struct FDesignDataChatRoom final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChatRoomCategoryType                         ChatRoomCategoryType;                              // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22BF[0x3];                                     // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   AllowedItemLinkTypes;                              // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                AllowedItemLinkClassIds;                           // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                AdditionalAllowedItemLinkIdTagGroups;              // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   AllowedAllowedItemLinkDesc;                        // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataChatRoom) == 0x000008, "Wrong alignment on FDesignDataChatRoom");
static_assert(sizeof(FDesignDataChatRoom) == 0x000068, "Wrong size on FDesignDataChatRoom");
static_assert(offsetof(FDesignDataChatRoom, Name) == 0x000000, "Member 'FDesignDataChatRoom::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataChatRoom, Order) == 0x000018, "Member 'FDesignDataChatRoom::Order' has a wrong offset!");
static_assert(offsetof(FDesignDataChatRoom, ChatRoomCategoryType) == 0x00001C, "Member 'FDesignDataChatRoom::ChatRoomCategoryType' has a wrong offset!");
static_assert(offsetof(FDesignDataChatRoom, AllowedItemLinkTypes) == 0x000020, "Member 'FDesignDataChatRoom::AllowedItemLinkTypes' has a wrong offset!");
static_assert(offsetof(FDesignDataChatRoom, AllowedItemLinkClassIds) == 0x000030, "Member 'FDesignDataChatRoom::AllowedItemLinkClassIds' has a wrong offset!");
static_assert(offsetof(FDesignDataChatRoom, AdditionalAllowedItemLinkIdTagGroups) == 0x000040, "Member 'FDesignDataChatRoom::AdditionalAllowedItemLinkIdTagGroups' has a wrong offset!");
static_assert(offsetof(FDesignDataChatRoom, AllowedAllowedItemLinkDesc) == 0x000050, "Member 'FDesignDataChatRoom::AllowedAllowedItemLinkDesc' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLeaderboardRankAP
// 0x0008 (0x0008 - 0x0000)
struct FDesignDataLeaderboardRankAP final
{
public:
	EGameType                                     GameType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C0[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequiredTotalAP;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLeaderboardRankAP) == 0x000004, "Wrong alignment on FDesignDataLeaderboardRankAP");
static_assert(sizeof(FDesignDataLeaderboardRankAP) == 0x000008, "Wrong size on FDesignDataLeaderboardRankAP");
static_assert(offsetof(FDesignDataLeaderboardRankAP, GameType) == 0x000000, "Member 'FDesignDataLeaderboardRankAP::GameType' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardRankAP, RequiredTotalAP) == 0x000004, "Member 'FDesignDataLeaderboardRankAP::RequiredTotalAP' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameFloorLogNotify
// 0x0098 (0x00B0 - 0x0018)
struct FMsgGameFloorLogNotify final : public FMsgBase
{
public:
	struct FGameFloorLogData                      GameFloorLogData;                                  // 0x0018(0x0098)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameFloorLogNotify) == 0x000008, "Wrong alignment on FMsgGameFloorLogNotify");
static_assert(sizeof(FMsgGameFloorLogNotify) == 0x0000B0, "Wrong size on FMsgGameFloorLogNotify");
static_assert(offsetof(FMsgGameFloorLogNotify, GameFloorLogData) == 0x000018, "Member 'FMsgGameFloorLogNotify::GameFloorLogData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLeaderboardRankEF
// 0x0001 (0x0001 - 0x0000)
struct FDesignDataLeaderboardRankEF final
{
public:
	uint8                                         Pad_22C1[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataLeaderboardRankEF) == 0x000001, "Wrong alignment on FDesignDataLeaderboardRankEF");
static_assert(sizeof(FDesignDataLeaderboardRankEF) == 0x000001, "Wrong size on FDesignDataLeaderboardRankEF");

// ScriptStruct DungeonCrawler.DesignDataLeaderboardRankGroup
// 0x0060 (0x0060 - 0x0000)
struct FDesignDataLeaderboardRankGroup final
{
public:
	class FText                                   RankGroupName;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         APRating;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RankReward;                                        // 0x001C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RankReward2;                                       // 0x002C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RankReward3;                                       // 0x003C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        RankReward4;                                       // 0x004C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C2[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataLeaderboardRankGroup) == 0x000008, "Wrong alignment on FDesignDataLeaderboardRankGroup");
static_assert(sizeof(FDesignDataLeaderboardRankGroup) == 0x000060, "Wrong size on FDesignDataLeaderboardRankGroup");
static_assert(offsetof(FDesignDataLeaderboardRankGroup, RankGroupName) == 0x000000, "Member 'FDesignDataLeaderboardRankGroup::RankGroupName' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardRankGroup, APRating) == 0x000018, "Member 'FDesignDataLeaderboardRankGroup::APRating' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardRankGroup, RankReward) == 0x00001C, "Member 'FDesignDataLeaderboardRankGroup::RankReward' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardRankGroup, RankReward2) == 0x00002C, "Member 'FDesignDataLeaderboardRankGroup::RankReward2' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardRankGroup, RankReward3) == 0x00003C, "Member 'FDesignDataLeaderboardRankGroup::RankReward3' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardRankGroup, RankReward4) == 0x00004C, "Member 'FDesignDataLeaderboardRankGroup::RankReward4' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLeaderboardRank
// 0x0050 (0x0050 - 0x0000)
struct FDesignDataLeaderboardRank final
{
public:
	struct FPrimaryAssetId                        LeaderboardRankGroup;                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RankName;                                          // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         RankSubGrade;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C3[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                LeaderboardRankAPs;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                LeaderboardRankEFs;                                // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLeaderboardRank) == 0x000008, "Wrong alignment on FDesignDataLeaderboardRank");
static_assert(sizeof(FDesignDataLeaderboardRank) == 0x000050, "Wrong size on FDesignDataLeaderboardRank");
static_assert(offsetof(FDesignDataLeaderboardRank, LeaderboardRankGroup) == 0x000000, "Member 'FDesignDataLeaderboardRank::LeaderboardRankGroup' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardRank, RankName) == 0x000010, "Member 'FDesignDataLeaderboardRank::RankName' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardRank, RankSubGrade) == 0x000028, "Member 'FDesignDataLeaderboardRank::RankSubGrade' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardRank, LeaderboardRankAPs) == 0x000030, "Member 'FDesignDataLeaderboardRank::LeaderboardRankAPs' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardRank, LeaderboardRankEFs) == 0x000040, "Member 'FDesignDataLeaderboardRank::LeaderboardRankEFs' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLeaderboardContent
// 0x0060 (0x0060 - 0x0000)
struct FDesignDataLeaderboardContent final
{
public:
	class FText                                   ContentName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ContentDesc;                                       // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ContentScoreName;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ELeaderboardContentType                       ContentType;                                       // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C4[0x7];                                     // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                SlayerMonsterIds;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLeaderboardContent) == 0x000008, "Wrong alignment on FDesignDataLeaderboardContent");
static_assert(sizeof(FDesignDataLeaderboardContent) == 0x000060, "Wrong size on FDesignDataLeaderboardContent");
static_assert(offsetof(FDesignDataLeaderboardContent, ContentName) == 0x000000, "Member 'FDesignDataLeaderboardContent::ContentName' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardContent, ContentDesc) == 0x000018, "Member 'FDesignDataLeaderboardContent::ContentDesc' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardContent, ContentScoreName) == 0x000030, "Member 'FDesignDataLeaderboardContent::ContentScoreName' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardContent, ContentType) == 0x000048, "Member 'FDesignDataLeaderboardContent::ContentType' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardContent, SlayerMonsterIds) == 0x000050, "Member 'FDesignDataLeaderboardContent::SlayerMonsterIds' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGASAttributeNotify
// 0x0708 (0x0720 - 0x0018)
struct FMsgGASAttributeNotify final : public FMsgBase
{
public:
	class UDCAttributeSet*                        AttributeSet;                                      // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayAttribute                     Attribute;                                         // 0x0020(0x0038)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0058(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldValue;                                          // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0068(0x0420)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0488(0x0298)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGASAttributeNotify) == 0x000008, "Wrong alignment on FMsgGASAttributeNotify");
static_assert(sizeof(FMsgGASAttributeNotify) == 0x000720, "Wrong size on FMsgGASAttributeNotify");
static_assert(offsetof(FMsgGASAttributeNotify, AttributeSet) == 0x000018, "Member 'FMsgGASAttributeNotify::AttributeSet' has a wrong offset!");
static_assert(offsetof(FMsgGASAttributeNotify, Attribute) == 0x000020, "Member 'FMsgGASAttributeNotify::Attribute' has a wrong offset!");
static_assert(offsetof(FMsgGASAttributeNotify, NewValue) == 0x000058, "Member 'FMsgGASAttributeNotify::NewValue' has a wrong offset!");
static_assert(offsetof(FMsgGASAttributeNotify, OldValue) == 0x00005C, "Member 'FMsgGASAttributeNotify::OldValue' has a wrong offset!");
static_assert(offsetof(FMsgGASAttributeNotify, GameplayEffectClass) == 0x000060, "Member 'FMsgGASAttributeNotify::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FMsgGASAttributeNotify, EffectContext) == 0x000068, "Member 'FMsgGASAttributeNotify::EffectContext' has a wrong offset!");
static_assert(offsetof(FMsgGASAttributeNotify, EffectSpec) == 0x000488, "Member 'FMsgGASAttributeNotify::EffectSpec' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLeaderboardSheet
// 0x0018 (0x0018 - 0x0000)
struct FDesignDataLeaderboardSheet final
{
public:
	EGameType                                     GameType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C5[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                LeaderboardContents;                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLeaderboardSheet) == 0x000008, "Wrong alignment on FDesignDataLeaderboardSheet");
static_assert(sizeof(FDesignDataLeaderboardSheet) == 0x000018, "Wrong size on FDesignDataLeaderboardSheet");
static_assert(offsetof(FDesignDataLeaderboardSheet, GameType) == 0x000000, "Member 'FDesignDataLeaderboardSheet::GameType' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardSheet, LeaderboardContents) == 0x000008, "Member 'FDesignDataLeaderboardSheet::LeaderboardContents' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLeaderboard
// 0x0040 (0x0040 - 0x0000)
struct FDesignDataLeaderboard final
{
public:
	class FText                                   SeasonName;                                        // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                LeaderboardSheets;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                LeaderboardRanks;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LeaderBoardRankRewardIdx;                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLeaderboard) == 0x000008, "Wrong alignment on FDesignDataLeaderboard");
static_assert(sizeof(FDesignDataLeaderboard) == 0x000040, "Wrong size on FDesignDataLeaderboard");
static_assert(offsetof(FDesignDataLeaderboard, SeasonName) == 0x000000, "Member 'FDesignDataLeaderboard::SeasonName' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboard, LeaderboardSheets) == 0x000018, "Member 'FDesignDataLeaderboard::LeaderboardSheets' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboard, LeaderboardRanks) == 0x000028, "Member 'FDesignDataLeaderboard::LeaderboardRanks' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboard, LeaderBoardRankRewardIdx) == 0x000038, "Member 'FDesignDataLeaderboard::LeaderBoardRankRewardIdx' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboard, Order) == 0x00003C, "Member 'FDesignDataLeaderboard::Order' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataRewardItem
// 0x0030 (0x0030 - 0x0000)
struct FDesignDataRewardItem final
{
public:
	EDCRewardType                                 RewardType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C6[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RewardId;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardCount;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ArtData;                                           // 0x001C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C7[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataRewardItem) == 0x000008, "Wrong alignment on FDesignDataRewardItem");
static_assert(sizeof(FDesignDataRewardItem) == 0x000030, "Wrong size on FDesignDataRewardItem");
static_assert(offsetof(FDesignDataRewardItem, RewardType) == 0x000000, "Member 'FDesignDataRewardItem::RewardType' has a wrong offset!");
static_assert(offsetof(FDesignDataRewardItem, RewardId) == 0x000008, "Member 'FDesignDataRewardItem::RewardId' has a wrong offset!");
static_assert(offsetof(FDesignDataRewardItem, RewardCount) == 0x000018, "Member 'FDesignDataRewardItem::RewardCount' has a wrong offset!");
static_assert(offsetof(FDesignDataRewardItem, ArtData) == 0x00001C, "Member 'FDesignDataRewardItem::ArtData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGASActorDieNotify
// 0x06D0 (0x06E8 - 0x0018)
struct FMsgGASActorDieNotify final : public FMsgBase
{
public:
	bool                                          bRigid;                                            // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C8[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0028(0x0420)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0448(0x0298)(BlueprintVisible, NativeAccessSpecifierPublic)
	EDCKillReason                                 KillReason;                                        // 0x06E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C9[0x7];                                     // 0x06E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgGASActorDieNotify) == 0x000008, "Wrong alignment on FMsgGASActorDieNotify");
static_assert(sizeof(FMsgGASActorDieNotify) == 0x0006E8, "Wrong size on FMsgGASActorDieNotify");
static_assert(offsetof(FMsgGASActorDieNotify, bRigid) == 0x000018, "Member 'FMsgGASActorDieNotify::bRigid' has a wrong offset!");
static_assert(offsetof(FMsgGASActorDieNotify, GameplayEffectClass) == 0x000020, "Member 'FMsgGASActorDieNotify::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FMsgGASActorDieNotify, EffectContext) == 0x000028, "Member 'FMsgGASActorDieNotify::EffectContext' has a wrong offset!");
static_assert(offsetof(FMsgGASActorDieNotify, EffectSpec) == 0x000448, "Member 'FMsgGASActorDieNotify::EffectSpec' has a wrong offset!");
static_assert(offsetof(FMsgGASActorDieNotify, KillReason) == 0x0006E0, "Member 'FMsgGASActorDieNotify::KillReason' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataReward
// 0x0010 (0x0010 - 0x0000)
struct FDesignDataReward final
{
public:
	TArray<struct FDesignDataRewardItem>          RewardItemArray;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataReward) == 0x000008, "Wrong alignment on FDesignDataReward");
static_assert(sizeof(FDesignDataReward) == 0x000010, "Wrong size on FDesignDataReward");
static_assert(offsetof(FDesignDataReward, RewardItemArray) == 0x000000, "Member 'FDesignDataReward::RewardItemArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataQuestContentEscape
// 0x0020 (0x0020 - 0x0000)
struct FDesignDataQuestContentEscape final
{
public:
	int32                                         ContentCount;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CA[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   DungeonIdTags;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ConsecutiveEscape;                                 // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NoDamage;                                          // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCQuestHealthRequirementType                 HealthRequirementType;                             // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CB[0x1];                                     // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthRequirementRatio;                            // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataQuestContentEscape) == 0x000008, "Wrong alignment on FDesignDataQuestContentEscape");
static_assert(sizeof(FDesignDataQuestContentEscape) == 0x000020, "Wrong size on FDesignDataQuestContentEscape");
static_assert(offsetof(FDesignDataQuestContentEscape, ContentCount) == 0x000000, "Member 'FDesignDataQuestContentEscape::ContentCount' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentEscape, DungeonIdTags) == 0x000008, "Member 'FDesignDataQuestContentEscape::DungeonIdTags' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentEscape, ConsecutiveEscape) == 0x000018, "Member 'FDesignDataQuestContentEscape::ConsecutiveEscape' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentEscape, NoDamage) == 0x000019, "Member 'FDesignDataQuestContentEscape::NoDamage' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentEscape, HealthRequirementType) == 0x00001A, "Member 'FDesignDataQuestContentEscape::HealthRequirementType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentEscape, HealthRequirementRatio) == 0x00001C, "Member 'FDesignDataQuestContentEscape::HealthRequirementRatio' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataQuestContentKill
// 0x0040 (0x0040 - 0x0000)
struct FDesignDataQuestContentKill final
{
public:
	int32                                         ContentCount;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCQuestContentKillType                       KillType;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CC[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           KillTag;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GradeType;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   DungeonIdTags;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SingleSession;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustEscape;                                        // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCQuestHealthRequirementType                 HealthRequirementType;                             // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CD[0x1];                                     // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthRequirementRatio;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                TagQueryData;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataQuestContentKill) == 0x000008, "Wrong alignment on FDesignDataQuestContentKill");
static_assert(sizeof(FDesignDataQuestContentKill) == 0x000040, "Wrong size on FDesignDataQuestContentKill");
static_assert(offsetof(FDesignDataQuestContentKill, ContentCount) == 0x000000, "Member 'FDesignDataQuestContentKill::ContentCount' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentKill, KillType) == 0x000004, "Member 'FDesignDataQuestContentKill::KillType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentKill, KillTag) == 0x000008, "Member 'FDesignDataQuestContentKill::KillTag' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentKill, GradeType) == 0x000010, "Member 'FDesignDataQuestContentKill::GradeType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentKill, DungeonIdTags) == 0x000018, "Member 'FDesignDataQuestContentKill::DungeonIdTags' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentKill, SingleSession) == 0x000028, "Member 'FDesignDataQuestContentKill::SingleSession' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentKill, MustEscape) == 0x000029, "Member 'FDesignDataQuestContentKill::MustEscape' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentKill, HealthRequirementType) == 0x00002A, "Member 'FDesignDataQuestContentKill::HealthRequirementType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentKill, HealthRequirementRatio) == 0x00002C, "Member 'FDesignDataQuestContentKill::HealthRequirementRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentKill, TagQueryData) == 0x000030, "Member 'FDesignDataQuestContentKill::TagQueryData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataQuestContentExplore
// 0x0030 (0x0030 - 0x0000)
struct FDesignDataQuestContentExplore final
{
public:
	int32                                         ContentCount;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CE[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   DungeonIdTags;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ModuleId;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustEscape;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22CF[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataQuestContentExplore) == 0x000008, "Wrong alignment on FDesignDataQuestContentExplore");
static_assert(sizeof(FDesignDataQuestContentExplore) == 0x000030, "Wrong size on FDesignDataQuestContentExplore");
static_assert(offsetof(FDesignDataQuestContentExplore, ContentCount) == 0x000000, "Member 'FDesignDataQuestContentExplore::ContentCount' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentExplore, DungeonIdTags) == 0x000008, "Member 'FDesignDataQuestContentExplore::DungeonIdTags' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentExplore, ModuleId) == 0x000018, "Member 'FDesignDataQuestContentExplore::ModuleId' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentExplore, MustEscape) == 0x000028, "Member 'FDesignDataQuestContentExplore::MustEscape' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataQuestContentProps
// 0x0040 (0x0040 - 0x0000)
struct FDesignDataQuestContentProps final
{
public:
	EDCQuestContentPropsType                      PropsType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D0[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ContentCount;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PropsIdTag;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GradeType;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   DungeonIdTags;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SingleSession;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustEscape;                                        // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCQuestHealthRequirementType                 HealthRequirementType;                             // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D1[0x1];                                     // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthRequirementRatio;                            // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                TagQueryData;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataQuestContentProps) == 0x000008, "Wrong alignment on FDesignDataQuestContentProps");
static_assert(sizeof(FDesignDataQuestContentProps) == 0x000040, "Wrong size on FDesignDataQuestContentProps");
static_assert(offsetof(FDesignDataQuestContentProps, PropsType) == 0x000000, "Member 'FDesignDataQuestContentProps::PropsType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentProps, ContentCount) == 0x000004, "Member 'FDesignDataQuestContentProps::ContentCount' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentProps, PropsIdTag) == 0x000008, "Member 'FDesignDataQuestContentProps::PropsIdTag' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentProps, GradeType) == 0x000010, "Member 'FDesignDataQuestContentProps::GradeType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentProps, DungeonIdTags) == 0x000018, "Member 'FDesignDataQuestContentProps::DungeonIdTags' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentProps, SingleSession) == 0x000028, "Member 'FDesignDataQuestContentProps::SingleSession' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentProps, MustEscape) == 0x000029, "Member 'FDesignDataQuestContentProps::MustEscape' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentProps, HealthRequirementType) == 0x00002A, "Member 'FDesignDataQuestContentProps::HealthRequirementType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentProps, HealthRequirementRatio) == 0x00002C, "Member 'FDesignDataQuestContentProps::HealthRequirementRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentProps, TagQueryData) == 0x000030, "Member 'FDesignDataQuestContentProps::TagQueryData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataQuestContentUseItem
// 0x0048 (0x0048 - 0x0000)
struct FDesignDataQuestContentUseItem final
{
public:
	int32                                         ContentCount;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D2[0x3];                                     // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ItemIdTag;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TypeTag;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RarityType;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   DungeonIdTags;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SingleSession;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustEscape;                                        // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCQuestHealthRequirementType                 HealthRequirementType;                             // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D3[0x1];                                     // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HealthRequirementRatio;                            // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                TagQueryData;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataQuestContentUseItem) == 0x000008, "Wrong alignment on FDesignDataQuestContentUseItem");
static_assert(sizeof(FDesignDataQuestContentUseItem) == 0x000048, "Wrong size on FDesignDataQuestContentUseItem");
static_assert(offsetof(FDesignDataQuestContentUseItem, ContentCount) == 0x000000, "Member 'FDesignDataQuestContentUseItem::ContentCount' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentUseItem, ItemType) == 0x000004, "Member 'FDesignDataQuestContentUseItem::ItemType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentUseItem, ItemIdTag) == 0x000008, "Member 'FDesignDataQuestContentUseItem::ItemIdTag' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentUseItem, TypeTag) == 0x000010, "Member 'FDesignDataQuestContentUseItem::TypeTag' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentUseItem, RarityType) == 0x000018, "Member 'FDesignDataQuestContentUseItem::RarityType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentUseItem, DungeonIdTags) == 0x000020, "Member 'FDesignDataQuestContentUseItem::DungeonIdTags' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentUseItem, SingleSession) == 0x000030, "Member 'FDesignDataQuestContentUseItem::SingleSession' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentUseItem, MustEscape) == 0x000031, "Member 'FDesignDataQuestContentUseItem::MustEscape' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentUseItem, HealthRequirementType) == 0x000032, "Member 'FDesignDataQuestContentUseItem::HealthRequirementType' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentUseItem, HealthRequirementRatio) == 0x000034, "Member 'FDesignDataQuestContentUseItem::HealthRequirementRatio' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestContentUseItem, TagQueryData) == 0x000038, "Member 'FDesignDataQuestContentUseItem::TagQueryData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataQuest
// 0x0080 (0x0080 - 0x0000)
struct FDesignDataQuest final
{
public:
	struct FPrimaryAssetId                        RequiredQuest;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredLevel;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredAffinity;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        QuestReward;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   GreetingText;                                      // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CompleteText;                                      // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                QuestContents;                                     // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataQuest) == 0x000008, "Wrong alignment on FDesignDataQuest");
static_assert(sizeof(FDesignDataQuest) == 0x000080, "Wrong size on FDesignDataQuest");
static_assert(offsetof(FDesignDataQuest, RequiredQuest) == 0x000000, "Member 'FDesignDataQuest::RequiredQuest' has a wrong offset!");
static_assert(offsetof(FDesignDataQuest, RequiredLevel) == 0x000010, "Member 'FDesignDataQuest::RequiredLevel' has a wrong offset!");
static_assert(offsetof(FDesignDataQuest, RequiredAffinity) == 0x000014, "Member 'FDesignDataQuest::RequiredAffinity' has a wrong offset!");
static_assert(offsetof(FDesignDataQuest, QuestReward) == 0x000018, "Member 'FDesignDataQuest::QuestReward' has a wrong offset!");
static_assert(offsetof(FDesignDataQuest, TitleText) == 0x000028, "Member 'FDesignDataQuest::TitleText' has a wrong offset!");
static_assert(offsetof(FDesignDataQuest, GreetingText) == 0x000040, "Member 'FDesignDataQuest::GreetingText' has a wrong offset!");
static_assert(offsetof(FDesignDataQuest, CompleteText) == 0x000058, "Member 'FDesignDataQuest::CompleteText' has a wrong offset!");
static_assert(offsetof(FDesignDataQuest, QuestContents) == 0x000070, "Member 'FDesignDataQuest::QuestContents' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAddContainingItemResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgAddContainingItemResponse final : public FMsgBase
{
public:
	bool                                          bSuccess;                                          // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D4[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgAddContainingItemResponse) == 0x000008, "Wrong alignment on FMsgAddContainingItemResponse");
static_assert(sizeof(FMsgAddContainingItemResponse) == 0x000020, "Wrong size on FMsgAddContainingItemResponse");
static_assert(offsetof(FMsgAddContainingItemResponse, bSuccess) == 0x000018, "Member 'FMsgAddContainingItemResponse::bSuccess' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataQuestChapter
// 0x0028 (0x0028 - 0x0000)
struct FDesignDataQuestChapter final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                Quests;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataQuestChapter) == 0x000008, "Wrong alignment on FDesignDataQuestChapter");
static_assert(sizeof(FDesignDataQuestChapter) == 0x000028, "Wrong size on FDesignDataQuestChapter");
static_assert(offsetof(FDesignDataQuestChapter, Name) == 0x000000, "Member 'FDesignDataQuestChapter::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestChapter, Quests) == 0x000018, "Member 'FDesignDataQuestChapter::Quests' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataQuestSchedule
// 0x0001 (0x0001 - 0x0000)
struct FDesignDataQuestSchedule final
{
public:
	uint8                                         Pad_22D5[0x1];                                     // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDesignDataQuestSchedule) == 0x000001, "Wrong alignment on FDesignDataQuestSchedule");
static_assert(sizeof(FDesignDataQuestSchedule) == 0x000001, "Wrong size on FDesignDataQuestSchedule");

// ScriptStruct DungeonCrawler.DesignDataReligion
// 0x0060 (0x0068 - 0x0008)
struct FDesignDataReligion final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Desc;                                              // 0x0020(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         OfferingCost;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultReligion;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 OfferingLvCount;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataReligion) == 0x000008, "Wrong alignment on FDesignDataReligion");
static_assert(sizeof(FDesignDataReligion) == 0x000068, "Wrong size on FDesignDataReligion");
static_assert(offsetof(FDesignDataReligion, Name) == 0x000008, "Member 'FDesignDataReligion::Name' has a wrong offset!");
static_assert(offsetof(FDesignDataReligion, Desc) == 0x000020, "Member 'FDesignDataReligion::Desc' has a wrong offset!");
static_assert(offsetof(FDesignDataReligion, Subtitle) == 0x000038, "Member 'FDesignDataReligion::Subtitle' has a wrong offset!");
static_assert(offsetof(FDesignDataReligion, OfferingCost) == 0x000050, "Member 'FDesignDataReligion::OfferingCost' has a wrong offset!");
static_assert(offsetof(FDesignDataReligion, DefaultReligion) == 0x000054, "Member 'FDesignDataReligion::DefaultReligion' has a wrong offset!");
static_assert(offsetof(FDesignDataReligion, OfferingLvCount) == 0x000058, "Member 'FDesignDataReligion::OfferingLvCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataPlayerCharacterTableRow
// 0x0140 (0x0148 - 0x0008)
struct FDesignDataPlayerCharacterTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataPlayerCharacter> PlayerCharacter;                                   // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> PlayerCharacterAbility;                            // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> PlayerCharacterEffect;                             // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataBaseItem> PlayerCharacterBaseItem;                           // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataPlayerCharacterTableRow) == 0x000008, "Wrong alignment on FDesignDataPlayerCharacterTableRow");
static_assert(sizeof(FDesignDataPlayerCharacterTableRow) == 0x000148, "Wrong size on FDesignDataPlayerCharacterTableRow");
static_assert(offsetof(FDesignDataPlayerCharacterTableRow, PlayerCharacter) == 0x000008, "Member 'FDesignDataPlayerCharacterTableRow::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacterTableRow, PlayerCharacterAbility) == 0x000058, "Member 'FDesignDataPlayerCharacterTableRow::PlayerCharacterAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacterTableRow, PlayerCharacterEffect) == 0x0000A8, "Member 'FDesignDataPlayerCharacterTableRow::PlayerCharacterEffect' has a wrong offset!");
static_assert(offsetof(FDesignDataPlayerCharacterTableRow, PlayerCharacterBaseItem) == 0x0000F8, "Member 'FDesignDataPlayerCharacterTableRow::PlayerCharacterBaseItem' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMonsterTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataMonsterTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataMonster> Monster;                                           // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> MonsterAbility;                                    // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> MonsterEffect;                                     // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMonsterTableRow) == 0x000008, "Wrong alignment on FDesignDataMonsterTableRow");
static_assert(sizeof(FDesignDataMonsterTableRow) == 0x0000F8, "Wrong size on FDesignDataMonsterTableRow");
static_assert(offsetof(FDesignDataMonsterTableRow, Monster) == 0x000008, "Member 'FDesignDataMonsterTableRow::Monster' has a wrong offset!");
static_assert(offsetof(FDesignDataMonsterTableRow, MonsterAbility) == 0x000058, "Member 'FDesignDataMonsterTableRow::MonsterAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataMonsterTableRow, MonsterEffect) == 0x0000A8, "Member 'FDesignDataMonsterTableRow::MonsterEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataAoeTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataAoeTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataAoe> Aoe;                                               // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> AoeAbility;                                        // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> AoeEffect;                                         // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataAoeTableRow) == 0x000008, "Wrong alignment on FDesignDataAoeTableRow");
static_assert(sizeof(FDesignDataAoeTableRow) == 0x0000F8, "Wrong size on FDesignDataAoeTableRow");
static_assert(offsetof(FDesignDataAoeTableRow, Aoe) == 0x000008, "Member 'FDesignDataAoeTableRow::Aoe' has a wrong offset!");
static_assert(offsetof(FDesignDataAoeTableRow, AoeAbility) == 0x000058, "Member 'FDesignDataAoeTableRow::AoeAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataAoeTableRow, AoeEffect) == 0x0000A8, "Member 'FDesignDataAoeTableRow::AoeEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInventoryItemDataArrayRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgInventoryItemDataArrayRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgInventoryItemDataArrayRequest) == 0x000008, "Wrong alignment on FMsgInventoryItemDataArrayRequest");
static_assert(sizeof(FMsgInventoryItemDataArrayRequest) == 0x000018, "Wrong size on FMsgInventoryItemDataArrayRequest");

// ScriptStruct DungeonCrawler.DesignDataPropsTableRow
// 0x0190 (0x0198 - 0x0008)
struct FDesignDataPropsTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataProps> Props;                                             // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> PropsAbility;                                      // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> PropsEffect;                                       // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataPropsInteract> PropsInteract;                                     // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataPropsSkillCheck> PropsSkillCheck;                                   // 0x0148(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataPropsTableRow) == 0x000008, "Wrong alignment on FDesignDataPropsTableRow");
static_assert(sizeof(FDesignDataPropsTableRow) == 0x000198, "Wrong size on FDesignDataPropsTableRow");
static_assert(offsetof(FDesignDataPropsTableRow, Props) == 0x000008, "Member 'FDesignDataPropsTableRow::Props' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsTableRow, PropsAbility) == 0x000058, "Member 'FDesignDataPropsTableRow::PropsAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsTableRow, PropsEffect) == 0x0000A8, "Member 'FDesignDataPropsTableRow::PropsEffect' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsTableRow, PropsInteract) == 0x0000F8, "Member 'FDesignDataPropsTableRow::PropsInteract' has a wrong offset!");
static_assert(offsetof(FDesignDataPropsTableRow, PropsSkillCheck) == 0x000148, "Member 'FDesignDataPropsTableRow::PropsSkillCheck' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataItemTableRow
// 0x0230 (0x0238 - 0x0008)
struct FDesignDataItemTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataItem> Item;                                              // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> ItemAbility;                                       // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> ItemEffect;                                        // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataItemConsume> ItemConsume;                                       // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataItemRequirement> ItemRequirement;                                   // 0x0148(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataItemBundleInfo> ItemBundleInfo;                                    // 0x0198(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataItemContainer> ItemContainer;                                     // 0x01E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataItemTableRow) == 0x000008, "Wrong alignment on FDesignDataItemTableRow");
static_assert(sizeof(FDesignDataItemTableRow) == 0x000238, "Wrong size on FDesignDataItemTableRow");
static_assert(offsetof(FDesignDataItemTableRow, Item) == 0x000008, "Member 'FDesignDataItemTableRow::Item' has a wrong offset!");
static_assert(offsetof(FDesignDataItemTableRow, ItemAbility) == 0x000058, "Member 'FDesignDataItemTableRow::ItemAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataItemTableRow, ItemEffect) == 0x0000A8, "Member 'FDesignDataItemTableRow::ItemEffect' has a wrong offset!");
static_assert(offsetof(FDesignDataItemTableRow, ItemConsume) == 0x0000F8, "Member 'FDesignDataItemTableRow::ItemConsume' has a wrong offset!");
static_assert(offsetof(FDesignDataItemTableRow, ItemRequirement) == 0x000148, "Member 'FDesignDataItemTableRow::ItemRequirement' has a wrong offset!");
static_assert(offsetof(FDesignDataItemTableRow, ItemBundleInfo) == 0x000198, "Member 'FDesignDataItemTableRow::ItemBundleInfo' has a wrong offset!");
static_assert(offsetof(FDesignDataItemTableRow, ItemContainer) == 0x0001E8, "Member 'FDesignDataItemTableRow::ItemContainer' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataSpawnerTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataSpawnerTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataSpawner> Spawner;                                           // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataSpawnerTableRow) == 0x000008, "Wrong alignment on FDesignDataSpawnerTableRow");
static_assert(sizeof(FDesignDataSpawnerTableRow) == 0x000058, "Wrong size on FDesignDataSpawnerTableRow");
static_assert(offsetof(FDesignDataSpawnerTableRow, Spawner) == 0x000008, "Member 'FDesignDataSpawnerTableRow::Spawner' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMeleeAttackTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataMeleeAttackTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataMeleeAttack> MeleeAttack;                                       // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMeleeAttackTableRow) == 0x000008, "Wrong alignment on FDesignDataMeleeAttackTableRow");
static_assert(sizeof(FDesignDataMeleeAttackTableRow) == 0x000058, "Wrong size on FDesignDataMeleeAttackTableRow");
static_assert(offsetof(FDesignDataMeleeAttackTableRow, MeleeAttack) == 0x000008, "Member 'FDesignDataMeleeAttackTableRow::MeleeAttack' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCDungeonRecoveryItemInfo
// 0x0188 (0x0188 - 0x0000)
struct FDCDungeonRecoveryItemInfo final
{
public:
	int64                                         UniqueID;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCItemInfo                            ItemInfo;                                          // 0x0008(0x0168)(BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCDungeonRecoveryPriceInfo>    PriceInfoArray;                                    // 0x0170(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDateTime                              ExpiredDateTime;                                   // 0x0180(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCDungeonRecoveryItemInfo) == 0x000008, "Wrong alignment on FDCDungeonRecoveryItemInfo");
static_assert(sizeof(FDCDungeonRecoveryItemInfo) == 0x000188, "Wrong size on FDCDungeonRecoveryItemInfo");
static_assert(offsetof(FDCDungeonRecoveryItemInfo, UniqueID) == 0x000000, "Member 'FDCDungeonRecoveryItemInfo::UniqueID' has a wrong offset!");
static_assert(offsetof(FDCDungeonRecoveryItemInfo, ItemInfo) == 0x000008, "Member 'FDCDungeonRecoveryItemInfo::ItemInfo' has a wrong offset!");
static_assert(offsetof(FDCDungeonRecoveryItemInfo, PriceInfoArray) == 0x000170, "Member 'FDCDungeonRecoveryItemInfo::PriceInfoArray' has a wrong offset!");
static_assert(offsetof(FDCDungeonRecoveryItemInfo, ExpiredDateTime) == 0x000180, "Member 'FDCDungeonRecoveryItemInfo::ExpiredDateTime' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataSkillTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataSkillTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataSkill> Skill;                                             // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> SkillAbility;                                      // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> SkillEffect;                                       // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataSkillTableRow) == 0x000008, "Wrong alignment on FDesignDataSkillTableRow");
static_assert(sizeof(FDesignDataSkillTableRow) == 0x0000F8, "Wrong size on FDesignDataSkillTableRow");
static_assert(offsetof(FDesignDataSkillTableRow, Skill) == 0x000008, "Member 'FDesignDataSkillTableRow::Skill' has a wrong offset!");
static_assert(offsetof(FDesignDataSkillTableRow, SkillAbility) == 0x000058, "Member 'FDesignDataSkillTableRow::SkillAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataSkillTableRow, SkillEffect) == 0x0000A8, "Member 'FDesignDataSkillTableRow::SkillEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataSpellTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataSpellTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataSpell> Spell;                                             // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> SpellAbility;                                      // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> SpellEffect;                                       // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataSpellTableRow) == 0x000008, "Wrong alignment on FDesignDataSpellTableRow");
static_assert(sizeof(FDesignDataSpellTableRow) == 0x0000F8, "Wrong size on FDesignDataSpellTableRow");
static_assert(offsetof(FDesignDataSpellTableRow, Spell) == 0x000008, "Member 'FDesignDataSpellTableRow::Spell' has a wrong offset!");
static_assert(offsetof(FDesignDataSpellTableRow, SpellAbility) == 0x000058, "Member 'FDesignDataSpellTableRow::SpellAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataSpellTableRow, SpellEffect) == 0x0000A8, "Member 'FDesignDataSpellTableRow::SpellEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataShapeShiftTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataShapeShiftTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataShapeShift> ShapeShift;                                        // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> ShapeShiftAbility;                                 // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> ShapeShiftEffect;                                  // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataShapeShiftTableRow) == 0x000008, "Wrong alignment on FDesignDataShapeShiftTableRow");
static_assert(sizeof(FDesignDataShapeShiftTableRow) == 0x0000F8, "Wrong size on FDesignDataShapeShiftTableRow");
static_assert(offsetof(FDesignDataShapeShiftTableRow, ShapeShift) == 0x000008, "Member 'FDesignDataShapeShiftTableRow::ShapeShift' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShiftTableRow, ShapeShiftAbility) == 0x000058, "Member 'FDesignDataShapeShiftTableRow::ShapeShiftAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataShapeShiftTableRow, ShapeShiftEffect) == 0x0000A8, "Member 'FDesignDataShapeShiftTableRow::ShapeShiftEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMusicTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataMusicTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataMusic> Music;                                             // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> MusicAbility;                                      // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> MusicEffect;                                       // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMusicTableRow) == 0x000008, "Wrong alignment on FDesignDataMusicTableRow");
static_assert(sizeof(FDesignDataMusicTableRow) == 0x0000F8, "Wrong size on FDesignDataMusicTableRow");
static_assert(offsetof(FDesignDataMusicTableRow, Music) == 0x000008, "Member 'FDesignDataMusicTableRow::Music' has a wrong offset!");
static_assert(offsetof(FDesignDataMusicTableRow, MusicAbility) == 0x000058, "Member 'FDesignDataMusicTableRow::MusicAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataMusicTableRow, MusicEffect) == 0x0000A8, "Member 'FDesignDataMusicTableRow::MusicEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataMerchantTableRow
// 0x0280 (0x0288 - 0x0008)
struct FDesignDataMerchantTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataMerchant> Merchant;                                          // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataMerchantAffinity> MerchantAffinity;                                  // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataRecoveryAffinity> RecoveryAffinity;                                  // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataMerchantSchedule> MerchantSchedule;                                  // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataStockBuy> StockBuy;                                          // 0x0148(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataStockSellBack> StockSellBack;                                     // 0x0198(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataStockCraft> StockCraft;                                        // 0x01E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataBaseGear> BaseGear;                                          // 0x0238(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataMerchantTableRow) == 0x000008, "Wrong alignment on FDesignDataMerchantTableRow");
static_assert(sizeof(FDesignDataMerchantTableRow) == 0x000288, "Wrong size on FDesignDataMerchantTableRow");
static_assert(offsetof(FDesignDataMerchantTableRow, Merchant) == 0x000008, "Member 'FDesignDataMerchantTableRow::Merchant' has a wrong offset!");
static_assert(offsetof(FDesignDataMerchantTableRow, MerchantAffinity) == 0x000058, "Member 'FDesignDataMerchantTableRow::MerchantAffinity' has a wrong offset!");
static_assert(offsetof(FDesignDataMerchantTableRow, RecoveryAffinity) == 0x0000A8, "Member 'FDesignDataMerchantTableRow::RecoveryAffinity' has a wrong offset!");
static_assert(offsetof(FDesignDataMerchantTableRow, MerchantSchedule) == 0x0000F8, "Member 'FDesignDataMerchantTableRow::MerchantSchedule' has a wrong offset!");
static_assert(offsetof(FDesignDataMerchantTableRow, StockBuy) == 0x000148, "Member 'FDesignDataMerchantTableRow::StockBuy' has a wrong offset!");
static_assert(offsetof(FDesignDataMerchantTableRow, StockSellBack) == 0x000198, "Member 'FDesignDataMerchantTableRow::StockSellBack' has a wrong offset!");
static_assert(offsetof(FDesignDataMerchantTableRow, StockCraft) == 0x0001E8, "Member 'FDesignDataMerchantTableRow::StockCraft' has a wrong offset!");
static_assert(offsetof(FDesignDataMerchantTableRow, BaseGear) == 0x000238, "Member 'FDesignDataMerchantTableRow::BaseGear' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataFloorRuleTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataFloorRuleTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataFloorRuleDeathSwarm> FloorRuleDeathSwarm;                               // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataFloorRuleBlizzard> FloorRuleBlizzard;                                 // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataFloorPortal> FloorPortal;                                       // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataFloorRuleTableRow) == 0x000008, "Wrong alignment on FDesignDataFloorRuleTableRow");
static_assert(sizeof(FDesignDataFloorRuleTableRow) == 0x0000F8, "Wrong size on FDesignDataFloorRuleTableRow");
static_assert(offsetof(FDesignDataFloorRuleTableRow, FloorRuleDeathSwarm) == 0x000008, "Member 'FDesignDataFloorRuleTableRow::FloorRuleDeathSwarm' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleTableRow, FloorRuleBlizzard) == 0x000058, "Member 'FDesignDataFloorRuleTableRow::FloorRuleBlizzard' has a wrong offset!");
static_assert(offsetof(FDesignDataFloorRuleTableRow, FloorPortal) == 0x0000A8, "Member 'FDesignDataFloorRuleTableRow::FloorPortal' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataConstantTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataConstantTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataConstant> Constant;                                          // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataConstantTableRow) == 0x000008, "Wrong alignment on FDesignDataConstantTableRow");
static_assert(sizeof(FDesignDataConstantTableRow) == 0x000058, "Wrong size on FDesignDataConstantTableRow");
static_assert(offsetof(FDesignDataConstantTableRow, Constant) == 0x000008, "Member 'FDesignDataConstantTableRow::Constant' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataEmoteTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataEmoteTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataEmote> Emote;                                             // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayAbility> EmoteAbility;                                      // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayEffect> EmoteEffect;                                       // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataEmoteTableRow) == 0x000008, "Wrong alignment on FDesignDataEmoteTableRow");
static_assert(sizeof(FDesignDataEmoteTableRow) == 0x0000F8, "Wrong size on FDesignDataEmoteTableRow");
static_assert(offsetof(FDesignDataEmoteTableRow, Emote) == 0x000008, "Member 'FDesignDataEmoteTableRow::Emote' has a wrong offset!");
static_assert(offsetof(FDesignDataEmoteTableRow, EmoteAbility) == 0x000058, "Member 'FDesignDataEmoteTableRow::EmoteAbility' has a wrong offset!");
static_assert(offsetof(FDesignDataEmoteTableRow, EmoteEffect) == 0x0000A8, "Member 'FDesignDataEmoteTableRow::EmoteEffect' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataGameplayCueTagGroupTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataGameplayCueTagGroupTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataGameplayCueTagGroup> GameplayCueTagGroup;                               // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataGameplayCueTagGroupTableRow) == 0x000008, "Wrong alignment on FDesignDataGameplayCueTagGroupTableRow");
static_assert(sizeof(FDesignDataGameplayCueTagGroupTableRow) == 0x000058, "Wrong size on FDesignDataGameplayCueTagGroupTableRow");
static_assert(offsetof(FDesignDataGameplayCueTagGroupTableRow, GameplayCueTagGroup) == 0x000008, "Member 'FDesignDataGameplayCueTagGroupTableRow::GameplayCueTagGroup' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgCurrentEquippedItemActorsRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgCurrentEquippedItemActorsRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgCurrentEquippedItemActorsRequest) == 0x000008, "Wrong alignment on FMsgCurrentEquippedItemActorsRequest");
static_assert(sizeof(FMsgCurrentEquippedItemActorsRequest) == 0x000018, "Wrong size on FMsgCurrentEquippedItemActorsRequest");

// ScriptStruct DungeonCrawler.DesignDataAbilityRelationshipTagGroupTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataAbilityRelationshipTagGroupTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataAbilityRelationshipTagGroup> AbilityRelationshipTagGroup;                       // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataAbilityRelationshipTagGroupTableRow) == 0x000008, "Wrong alignment on FDesignDataAbilityRelationshipTagGroupTableRow");
static_assert(sizeof(FDesignDataAbilityRelationshipTagGroupTableRow) == 0x000058, "Wrong size on FDesignDataAbilityRelationshipTagGroupTableRow");
static_assert(offsetof(FDesignDataAbilityRelationshipTagGroupTableRow, AbilityRelationshipTagGroup) == 0x000008, "Member 'FDesignDataAbilityRelationshipTagGroupTableRow::AbilityRelationshipTagGroup' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataDungeonTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataDungeonTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataDungeon> Dungeon;                                           // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataDungeonType> DungeonType;                                       // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataDungeonModule> DungeonModule;                                     // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataDungeonTableRow) == 0x000008, "Wrong alignment on FDesignDataDungeonTableRow");
static_assert(sizeof(FDesignDataDungeonTableRow) == 0x0000F8, "Wrong size on FDesignDataDungeonTableRow");
static_assert(offsetof(FDesignDataDungeonTableRow, Dungeon) == 0x000008, "Member 'FDesignDataDungeonTableRow::Dungeon' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeonTableRow, DungeonType) == 0x000058, "Member 'FDesignDataDungeonTableRow::DungeonType' has a wrong offset!");
static_assert(offsetof(FDesignDataDungeonTableRow, DungeonModule) == 0x0000A8, "Member 'FDesignDataDungeonTableRow::DungeonModule' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataShopTableRow
// 0x0230 (0x0238 - 0x0008)
struct FDesignDataShopTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataShop> ShopCharacterSkin;                                 // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataItemSkinShop> ShopItemSkin;                                      // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataShop> ShopEmote;                                         // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataShop> ShopLobbyEmote;                                    // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataShop> ShopActionSkin;                                    // 0x0148(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataShop> ShopClassPackage;                                  // 0x0198(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataRedstonShardShop> ShopRedstoneShard;                                 // 0x01E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataShopTableRow) == 0x000008, "Wrong alignment on FDesignDataShopTableRow");
static_assert(sizeof(FDesignDataShopTableRow) == 0x000238, "Wrong size on FDesignDataShopTableRow");
static_assert(offsetof(FDesignDataShopTableRow, ShopCharacterSkin) == 0x000008, "Member 'FDesignDataShopTableRow::ShopCharacterSkin' has a wrong offset!");
static_assert(offsetof(FDesignDataShopTableRow, ShopItemSkin) == 0x000058, "Member 'FDesignDataShopTableRow::ShopItemSkin' has a wrong offset!");
static_assert(offsetof(FDesignDataShopTableRow, ShopEmote) == 0x0000A8, "Member 'FDesignDataShopTableRow::ShopEmote' has a wrong offset!");
static_assert(offsetof(FDesignDataShopTableRow, ShopLobbyEmote) == 0x0000F8, "Member 'FDesignDataShopTableRow::ShopLobbyEmote' has a wrong offset!");
static_assert(offsetof(FDesignDataShopTableRow, ShopActionSkin) == 0x000148, "Member 'FDesignDataShopTableRow::ShopActionSkin' has a wrong offset!");
static_assert(offsetof(FDesignDataShopTableRow, ShopClassPackage) == 0x000198, "Member 'FDesignDataShopTableRow::ShopClassPackage' has a wrong offset!");
static_assert(offsetof(FDesignDataShopTableRow, ShopRedstoneShard) == 0x0001E8, "Member 'FDesignDataShopTableRow::ShopRedstoneShard' has a wrong offset!");

// ScriptStruct DungeonCrawler.CallData
// 0x0018 (0x0018 - 0x0000)
struct FCallData final
{
public:
	uint32                                        Type;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D6[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 Data;                                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCallData) == 0x000008, "Wrong alignment on FCallData");
static_assert(sizeof(FCallData) == 0x000018, "Wrong size on FCallData");
static_assert(offsetof(FCallData, Type) == 0x000000, "Member 'FCallData::Type' has a wrong offset!");
static_assert(offsetof(FCallData, Data) == 0x000008, "Member 'FCallData::Data' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataChatTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataChatTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataChatRoom> ChatRoom;                                          // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataChatTableRow) == 0x000008, "Wrong alignment on FDesignDataChatTableRow");
static_assert(sizeof(FDesignDataChatTableRow) == 0x000058, "Wrong size on FDesignDataChatTableRow");
static_assert(offsetof(FDesignDataChatTableRow, ChatRoom) == 0x000008, "Member 'FDesignDataChatTableRow::ChatRoom' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataLeaderboardTableRow
// 0x0280 (0x0288 - 0x0008)
struct FDesignDataLeaderboardTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataLeaderboard> Leaderboard;                                       // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataLeaderboardSheet> LeaderboardSheet;                                  // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataLeaderboardContent> LeaderboardContent;                                // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataLeaderboardRank> LeaderboardRank;                                   // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataLeaderboardRankGroup> LeaderboardRankGroup;                              // 0x0148(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataLeaderboardRankAP> LeaderboardRankAP;                                 // 0x0198(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataLeaderboardRankEF> LeaderboardRankEF;                                 // 0x01E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataReward> LeaderboardRankReward;                             // 0x0238(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataLeaderboardTableRow) == 0x000008, "Wrong alignment on FDesignDataLeaderboardTableRow");
static_assert(sizeof(FDesignDataLeaderboardTableRow) == 0x000288, "Wrong size on FDesignDataLeaderboardTableRow");
static_assert(offsetof(FDesignDataLeaderboardTableRow, Leaderboard) == 0x000008, "Member 'FDesignDataLeaderboardTableRow::Leaderboard' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardTableRow, LeaderboardSheet) == 0x000058, "Member 'FDesignDataLeaderboardTableRow::LeaderboardSheet' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardTableRow, LeaderboardContent) == 0x0000A8, "Member 'FDesignDataLeaderboardTableRow::LeaderboardContent' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardTableRow, LeaderboardRank) == 0x0000F8, "Member 'FDesignDataLeaderboardTableRow::LeaderboardRank' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardTableRow, LeaderboardRankGroup) == 0x000148, "Member 'FDesignDataLeaderboardTableRow::LeaderboardRankGroup' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardTableRow, LeaderboardRankAP) == 0x000198, "Member 'FDesignDataLeaderboardTableRow::LeaderboardRankAP' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardTableRow, LeaderboardRankEF) == 0x0001E8, "Member 'FDesignDataLeaderboardTableRow::LeaderboardRankEF' has a wrong offset!");
static_assert(offsetof(FDesignDataLeaderboardTableRow, LeaderboardRankReward) == 0x000238, "Member 'FDesignDataLeaderboardTableRow::LeaderboardRankReward' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataGEModifierTableRow
// 0x0050 (0x0058 - 0x0008)
struct FDesignDataGEModifierTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataGEModifier> GEModifier;                                        // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataGEModifierTableRow) == 0x000008, "Wrong alignment on FDesignDataGEModifierTableRow");
static_assert(sizeof(FDesignDataGEModifierTableRow) == 0x000058, "Wrong size on FDesignDataGEModifierTableRow");
static_assert(offsetof(FDesignDataGEModifierTableRow, GEModifier) == 0x000008, "Member 'FDesignDataGEModifierTableRow::GEModifier' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataQuestTableRow
// 0x0320 (0x0328 - 0x0008)
struct FDesignDataQuestTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataQuestChapter> QuestChapter;                                      // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataQuestSchedule> QuestSchedule;                                     // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataQuest> Quest;                                             // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataReward> QuestReward;                                       // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataQuestContentEscape> QuestContentEscape;                                // 0x0148(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataQuestContentKill> QuestContentKill;                                  // 0x0198(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataQuestContentFetch> QuestContentFetch;                                 // 0x01E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataQuestContentExplore> QuestContentExplore;                               // 0x0238(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataQuestContentProps> QuestContentProps;                                 // 0x0288(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataQuestContentUseItem> QuestContentUseItem;                               // 0x02D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataQuestTableRow) == 0x000008, "Wrong alignment on FDesignDataQuestTableRow");
static_assert(sizeof(FDesignDataQuestTableRow) == 0x000328, "Wrong size on FDesignDataQuestTableRow");
static_assert(offsetof(FDesignDataQuestTableRow, QuestChapter) == 0x000008, "Member 'FDesignDataQuestTableRow::QuestChapter' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestTableRow, QuestSchedule) == 0x000058, "Member 'FDesignDataQuestTableRow::QuestSchedule' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestTableRow, Quest) == 0x0000A8, "Member 'FDesignDataQuestTableRow::Quest' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestTableRow, QuestReward) == 0x0000F8, "Member 'FDesignDataQuestTableRow::QuestReward' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestTableRow, QuestContentEscape) == 0x000148, "Member 'FDesignDataQuestTableRow::QuestContentEscape' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestTableRow, QuestContentKill) == 0x000198, "Member 'FDesignDataQuestTableRow::QuestContentKill' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestTableRow, QuestContentFetch) == 0x0001E8, "Member 'FDesignDataQuestTableRow::QuestContentFetch' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestTableRow, QuestContentExplore) == 0x000238, "Member 'FDesignDataQuestTableRow::QuestContentExplore' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestTableRow, QuestContentProps) == 0x000288, "Member 'FDesignDataQuestTableRow::QuestContentProps' has a wrong offset!");
static_assert(offsetof(FDesignDataQuestTableRow, QuestContentUseItem) == 0x0002D8, "Member 'FDesignDataQuestTableRow::QuestContentUseItem' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGiveAbility
// 0x0008 (0x0020 - 0x0018)
struct FMsgGiveAbility final : public FMsgBase
{
public:
	class AActor*                                 TargetActor;                                       // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGiveAbility) == 0x000008, "Wrong alignment on FMsgGiveAbility");
static_assert(sizeof(FMsgGiveAbility) == 0x000020, "Wrong size on FMsgGiveAbility");
static_assert(offsetof(FMsgGiveAbility, TargetActor) == 0x000018, "Member 'FMsgGiveAbility::TargetActor' has a wrong offset!");

// ScriptStruct DungeonCrawler.DesignDataReligionTableRow
// 0x00F0 (0x00F8 - 0x0008)
struct FDesignDataReligionTableRow final : public FTableRowBase
{
public:
	TMap<struct FPrimaryAssetId, struct FDesignDataReligion> Religion;                                          // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataReligionBlessing> ReligionBlessing;                                  // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, struct FDesignDataReligionSeason> ReligionSeason;                                    // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDesignDataReligionTableRow) == 0x000008, "Wrong alignment on FDesignDataReligionTableRow");
static_assert(sizeof(FDesignDataReligionTableRow) == 0x0000F8, "Wrong size on FDesignDataReligionTableRow");
static_assert(offsetof(FDesignDataReligionTableRow, Religion) == 0x000008, "Member 'FDesignDataReligionTableRow::Religion' has a wrong offset!");
static_assert(offsetof(FDesignDataReligionTableRow, ReligionBlessing) == 0x000058, "Member 'FDesignDataReligionTableRow::ReligionBlessing' has a wrong offset!");
static_assert(offsetof(FDesignDataReligionTableRow, ReligionSeason) == 0x0000A8, "Member 'FDesignDataReligionTableRow::ReligionSeason' has a wrong offset!");

// ScriptStruct DungeonCrawler.DevMsgGm
// 0x0020 (0x0038 - 0x0018)
struct FDevMsgGm final : public FMsgBase
{
public:
	class FString                                 Cmd;                                               // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccountId;                                         // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevMsgGm) == 0x000008, "Wrong alignment on FDevMsgGm");
static_assert(sizeof(FDevMsgGm) == 0x000038, "Wrong size on FDevMsgGm");
static_assert(offsetof(FDevMsgGm, Cmd) == 0x000018, "Member 'FDevMsgGm::Cmd' has a wrong offset!");
static_assert(offsetof(FDevMsgGm, AccountId) == 0x000028, "Member 'FDevMsgGm::AccountId' has a wrong offset!");

// ScriptStruct DungeonCrawler.DevMsgUIToggle
// 0x0000 (0x0018 - 0x0018)
struct FDevMsgUIToggle final : public FMsgBase
{
};
static_assert(alignof(FDevMsgUIToggle) == 0x000008, "Wrong alignment on FDevMsgUIToggle");
static_assert(sizeof(FDevMsgUIToggle) == 0x000018, "Wrong size on FDevMsgUIToggle");

// ScriptStruct DungeonCrawler.DungeonRotationTimerData
// 0x000C (0x000C - 0x0000)
struct FDungeonRotationTimerData final
{
public:
	int32                                         Hours;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minutes;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seconds;                                           // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDungeonRotationTimerData) == 0x000004, "Wrong alignment on FDungeonRotationTimerData");
static_assert(sizeof(FDungeonRotationTimerData) == 0x00000C, "Wrong size on FDungeonRotationTimerData");
static_assert(offsetof(FDungeonRotationTimerData, Hours) == 0x000000, "Member 'FDungeonRotationTimerData::Hours' has a wrong offset!");
static_assert(offsetof(FDungeonRotationTimerData, Minutes) == 0x000004, "Member 'FDungeonRotationTimerData::Minutes' has a wrong offset!");
static_assert(offsetof(FDungeonRotationTimerData, Seconds) == 0x000008, "Member 'FDungeonRotationTimerData::Seconds' has a wrong offset!");

// ScriptStruct DungeonCrawler.DungeonSelectButtonWidgetHandleData
// 0x0020 (0x0020 - 0x0000)
struct FDungeonSelectButtonWidgetHandleData final
{
public:
	EMatchMode                                    MatchMode;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     GameType;                                          // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D7[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDungeonRotationTimerData              DungeonRotationTimerData;                          // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bMatching;                                         // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D8[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDungeonRotationItemInfo               DungeonRotationItemInfo;                           // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDungeonSelectButtonWidgetHandleData) == 0x000004, "Wrong alignment on FDungeonSelectButtonWidgetHandleData");
static_assert(sizeof(FDungeonSelectButtonWidgetHandleData) == 0x000020, "Wrong size on FDungeonSelectButtonWidgetHandleData");
static_assert(offsetof(FDungeonSelectButtonWidgetHandleData, MatchMode) == 0x000000, "Member 'FDungeonSelectButtonWidgetHandleData::MatchMode' has a wrong offset!");
static_assert(offsetof(FDungeonSelectButtonWidgetHandleData, GameType) == 0x000001, "Member 'FDungeonSelectButtonWidgetHandleData::GameType' has a wrong offset!");
static_assert(offsetof(FDungeonSelectButtonWidgetHandleData, DungeonRotationTimerData) == 0x000004, "Member 'FDungeonSelectButtonWidgetHandleData::DungeonRotationTimerData' has a wrong offset!");
static_assert(offsetof(FDungeonSelectButtonWidgetHandleData, bMatching) == 0x000010, "Member 'FDungeonSelectButtonWidgetHandleData::bMatching' has a wrong offset!");
static_assert(offsetof(FDungeonSelectButtonWidgetHandleData, DungeonRotationItemInfo) == 0x000014, "Member 'FDungeonSelectButtonWidgetHandleData::DungeonRotationItemInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgChangedItemRequirementFulfillmentStatus
// 0x0008 (0x0020 - 0x0018)
struct FMsgChangedItemRequirementFulfillmentStatus final : public FMsgBase
{
public:
	bool                                          bFulfilled;                                        // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D9[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgChangedItemRequirementFulfillmentStatus) == 0x000008, "Wrong alignment on FMsgChangedItemRequirementFulfillmentStatus");
static_assert(sizeof(FMsgChangedItemRequirementFulfillmentStatus) == 0x000020, "Wrong size on FMsgChangedItemRequirementFulfillmentStatus");
static_assert(offsetof(FMsgChangedItemRequirementFulfillmentStatus, bFulfilled) == 0x000018, "Member 'FMsgChangedItemRequirementFulfillmentStatus::bFulfilled' has a wrong offset!");

// ScriptStruct DungeonCrawler.DungeonSelectWidgetHandleData
// 0x0014 (0x0014 - 0x0000)
struct FDungeonSelectWidgetHandleData final
{
public:
	EMatchMode                                    MatchMode;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22DA[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDungeonRotationTimerData              DungeonRotationTimerData;                          // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EGameType                                     GameType;                                          // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22DB[0x3];                                     // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDungeonSelectWidgetHandleData) == 0x000004, "Wrong alignment on FDungeonSelectWidgetHandleData");
static_assert(sizeof(FDungeonSelectWidgetHandleData) == 0x000014, "Wrong size on FDungeonSelectWidgetHandleData");
static_assert(offsetof(FDungeonSelectWidgetHandleData, MatchMode) == 0x000000, "Member 'FDungeonSelectWidgetHandleData::MatchMode' has a wrong offset!");
static_assert(offsetof(FDungeonSelectWidgetHandleData, DungeonRotationTimerData) == 0x000004, "Member 'FDungeonSelectWidgetHandleData::DungeonRotationTimerData' has a wrong offset!");
static_assert(offsetof(FDungeonSelectWidgetHandleData, GameType) == 0x000010, "Member 'FDungeonSelectWidgetHandleData::GameType' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCEmoteSlotInfo
// 0x0014 (0x0014 - 0x0000)
struct FDCEmoteSlotInfo final
{
public:
	struct FPrimaryAssetId                        EmoteId;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCEmoteSlotInfo) == 0x000004, "Wrong alignment on FDCEmoteSlotInfo");
static_assert(sizeof(FDCEmoteSlotInfo) == 0x000014, "Wrong size on FDCEmoteSlotInfo");
static_assert(offsetof(FDCEmoteSlotInfo, EmoteId) == 0x000000, "Member 'FDCEmoteSlotInfo::EmoteId' has a wrong offset!");
static_assert(offsetof(FDCEmoteSlotInfo, SlotIndex) == 0x000010, "Member 'FDCEmoteSlotInfo::SlotIndex' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCQuickSlotData
// 0x0008 (0x0008 - 0x0000)
struct FDCQuickSlotData final
{
public:
	EEquipmentQuickSlotType                       Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22DC[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCQuickSlotData) == 0x000004, "Wrong alignment on FDCQuickSlotData");
static_assert(sizeof(FDCQuickSlotData) == 0x000008, "Wrong size on FDCQuickSlotData");
static_assert(offsetof(FDCQuickSlotData, Type) == 0x000000, "Member 'FDCQuickSlotData::Type' has a wrong offset!");
static_assert(offsetof(FDCQuickSlotData, Index) == 0x000004, "Member 'FDCQuickSlotData::Index' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInteractStart
// 0x0010 (0x0028 - 0x0018)
struct FMsgInteractStart final : public FMsgBase
{
public:
	class AActor*                                 Interacter;                                        // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CurrentStateTag;                                   // 0x0020(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgInteractStart) == 0x000008, "Wrong alignment on FMsgInteractStart");
static_assert(sizeof(FMsgInteractStart) == 0x000028, "Wrong size on FMsgInteractStart");
static_assert(offsetof(FMsgInteractStart, Interacter) == 0x000018, "Member 'FMsgInteractStart::Interacter' has a wrong offset!");
static_assert(offsetof(FMsgInteractStart, CurrentStateTag) == 0x000020, "Member 'FMsgInteractStart::CurrentStateTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSampleRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgSampleRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgSampleRequest) == 0x000008, "Wrong alignment on FMsgSampleRequest");
static_assert(sizeof(FMsgSampleRequest) == 0x000018, "Wrong size on FMsgSampleRequest");

// ScriptStruct DungeonCrawler.MsgSampleResponse
// 0x0000 (0x0018 - 0x0018)
struct FMsgSampleResponse final : public FMsgBase
{
};
static_assert(alignof(FMsgSampleResponse) == 0x000008, "Wrong alignment on FMsgSampleResponse");
static_assert(sizeof(FMsgSampleResponse) == 0x000018, "Wrong size on FMsgSampleResponse");

// ScriptStruct DungeonCrawler.PlayerInfo
// 0x0020 (0x0020 - 0x0000)
struct FPlayerInfo final
{
public:
	int32                                         TotalCount;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LobbyCount;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DungeonCount;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22DD[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInvitePartyUserSlot>           InvitePartyUserSlotArray;                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInfo) == 0x000008, "Wrong alignment on FPlayerInfo");
static_assert(sizeof(FPlayerInfo) == 0x000020, "Wrong size on FPlayerInfo");
static_assert(offsetof(FPlayerInfo, TotalCount) == 0x000000, "Member 'FPlayerInfo::TotalCount' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, LobbyCount) == 0x000004, "Member 'FPlayerInfo::LobbyCount' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, DungeonCount) == 0x000008, "Member 'FPlayerInfo::DungeonCount' has a wrong offset!");
static_assert(offsetof(FPlayerInfo, InvitePartyUserSlotArray) == 0x000010, "Member 'FPlayerInfo::InvitePartyUserSlotArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInteractFailed
// 0x0010 (0x0028 - 0x0018)
struct FMsgInteractFailed final : public FMsgBase
{
public:
	class AActor*                                 Interacter;                                        // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0020(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgInteractFailed) == 0x000008, "Wrong alignment on FMsgInteractFailed");
static_assert(sizeof(FMsgInteractFailed) == 0x000028, "Wrong size on FMsgInteractFailed");
static_assert(offsetof(FMsgInteractFailed, Interacter) == 0x000018, "Member 'FMsgInteractFailed::Interacter' has a wrong offset!");
static_assert(offsetof(FMsgInteractFailed, EventTag) == 0x000020, "Member 'FMsgInteractFailed::EventTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.FunctionTrigger
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FFunctionTrigger final
{
public:
	uint8                                         Pad_22DE[0x70];                                    // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFunctionTrigger) == 0x000008, "Wrong alignment on FFunctionTrigger");
static_assert(sizeof(FFunctionTrigger) == 0x000070, "Wrong size on FFunctionTrigger");

// ScriptStruct DungeonCrawler.GameActorStatusSlotWidgetData
// 0x0020 (0x0020 - 0x0000)
struct FGameActorStatusSlotWidgetData final
{
public:
	struct FActorStatusData                       ActorStatusData;                                   // 0x0000(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameActorStatusSlotWidgetData) == 0x000008, "Wrong alignment on FGameActorStatusSlotWidgetData");
static_assert(sizeof(FGameActorStatusSlotWidgetData) == 0x000020, "Wrong size on FGameActorStatusSlotWidgetData");
static_assert(offsetof(FGameActorStatusSlotWidgetData, ActorStatusData) == 0x000000, "Member 'FGameActorStatusSlotWidgetData::ActorStatusData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCReservedPartyMember
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FDCReservedPartyMember final
{
public:
	uint8                                         Pad_22DF[0x58];                                    // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCReservedPartyMember) == 0x000008, "Wrong alignment on FDCReservedPartyMember");
static_assert(sizeof(FDCReservedPartyMember) == 0x000058, "Wrong size on FDCReservedPartyMember");

// ScriptStruct DungeonCrawler.DCGameEnterUser
// 0x0088 (0x0088 - 0x0000)
struct FDCGameEnterUser final
{
public:
	struct FNickname                              Nickname;                                          // 0x0000(0x0040)(Transient, NativeAccessSpecifierPublic)
	class FString                                 CharacterClassStr;                                 // 0x0040(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCCharacterId                         CharacterId;                                       // 0x0050(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCGender                                     Gender;                                            // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E0[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Level;                                             // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCPartyId                             PartyId;                                           // 0x0068(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDCReservedPartyMember>         ReservedPartyMembers;                              // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCGameEnterUser) == 0x000008, "Wrong alignment on FDCGameEnterUser");
static_assert(sizeof(FDCGameEnterUser) == 0x000088, "Wrong size on FDCGameEnterUser");
static_assert(offsetof(FDCGameEnterUser, Nickname) == 0x000000, "Member 'FDCGameEnterUser::Nickname' has a wrong offset!");
static_assert(offsetof(FDCGameEnterUser, CharacterClassStr) == 0x000040, "Member 'FDCGameEnterUser::CharacterClassStr' has a wrong offset!");
static_assert(offsetof(FDCGameEnterUser, CharacterId) == 0x000050, "Member 'FDCGameEnterUser::CharacterId' has a wrong offset!");
static_assert(offsetof(FDCGameEnterUser, Gender) == 0x000060, "Member 'FDCGameEnterUser::Gender' has a wrong offset!");
static_assert(offsetof(FDCGameEnterUser, Level) == 0x000064, "Member 'FDCGameEnterUser::Level' has a wrong offset!");
static_assert(offsetof(FDCGameEnterUser, PartyId) == 0x000068, "Member 'FDCGameEnterUser::PartyId' has a wrong offset!");
static_assert(offsetof(FDCGameEnterUser, ReservedPartyMembers) == 0x000078, "Member 'FDCGameEnterUser::ReservedPartyMembers' has a wrong offset!");

// ScriptStruct DungeonCrawler.SkillCheckData
// 0x001C (0x001C - 0x0000)
struct FSkillCheckData final
{
public:
	struct FGameplayTag                           SkillCheckType;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SucceedSectionStartTime;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SucceedSectionEndTime;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectSucceedSectionStartTime;                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerfectSucceedSectionEndTime;                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillCheckData) == 0x000004, "Wrong alignment on FSkillCheckData");
static_assert(sizeof(FSkillCheckData) == 0x00001C, "Wrong size on FSkillCheckData");
static_assert(offsetof(FSkillCheckData, SkillCheckType) == 0x000000, "Member 'FSkillCheckData::SkillCheckType' has a wrong offset!");
static_assert(offsetof(FSkillCheckData, Duration) == 0x000008, "Member 'FSkillCheckData::Duration' has a wrong offset!");
static_assert(offsetof(FSkillCheckData, SucceedSectionStartTime) == 0x00000C, "Member 'FSkillCheckData::SucceedSectionStartTime' has a wrong offset!");
static_assert(offsetof(FSkillCheckData, SucceedSectionEndTime) == 0x000010, "Member 'FSkillCheckData::SucceedSectionEndTime' has a wrong offset!");
static_assert(offsetof(FSkillCheckData, PerfectSucceedSectionStartTime) == 0x000014, "Member 'FSkillCheckData::PerfectSucceedSectionStartTime' has a wrong offset!");
static_assert(offsetof(FSkillCheckData, PerfectSucceedSectionEndTime) == 0x000018, "Member 'FSkillCheckData::PerfectSucceedSectionEndTime' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInteractSkillCheckStart
// 0x0020 (0x0038 - 0x0018)
struct FMsgInteractSkillCheckStart final : public FMsgBase
{
public:
	struct FSkillCheckData                        SkillCheckData;                                    // 0x0018(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E1[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgInteractSkillCheckStart) == 0x000008, "Wrong alignment on FMsgInteractSkillCheckStart");
static_assert(sizeof(FMsgInteractSkillCheckStart) == 0x000038, "Wrong size on FMsgInteractSkillCheckStart");
static_assert(offsetof(FMsgInteractSkillCheckStart, SkillCheckData) == 0x000018, "Member 'FMsgInteractSkillCheckStart::SkillCheckData' has a wrong offset!");

// ScriptStruct DungeonCrawler.InteractTargetData
// 0x0020 (0x0020 - 0x0000)
struct FInteractTargetData final
{
public:
	class FText                                   InteractTargetName;                                // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RarityType;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractTargetData) == 0x000008, "Wrong alignment on FInteractTargetData");
static_assert(sizeof(FInteractTargetData) == 0x000020, "Wrong size on FInteractTargetData");
static_assert(offsetof(FInteractTargetData, InteractTargetName) == 0x000000, "Member 'FInteractTargetData::InteractTargetName' has a wrong offset!");
static_assert(offsetof(FInteractTargetData, RarityType) == 0x000018, "Member 'FInteractTargetData::RarityType' has a wrong offset!");

// ScriptStruct DungeonCrawler.InteractionData
// 0x00B8 (0x00B8 - 0x0000)
struct FInteractionData final
{
public:
	class FText                                   InteractionName;                                   // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   InteractionText;                                   // 0x0018(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UInteractData*                          InteractDataAsset;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConditionalDuration;                               // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InteractTypes;                                     // 0x0040(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TriggerTag;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AbilityTriggerTag;                                 // 0x0068(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTagQueryData*                          DetectTagQueryData;                                // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTagQueryData*                          InteractTagQueryData;                              // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTagQueryData*                          ConsumeTagQueryData;                               // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  BlockInteractionTags;                              // 0x0088(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SkillCheckDataId;                                  // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionData) == 0x000008, "Wrong alignment on FInteractionData");
static_assert(sizeof(FInteractionData) == 0x0000B8, "Wrong size on FInteractionData");
static_assert(offsetof(FInteractionData, InteractionName) == 0x000000, "Member 'FInteractionData::InteractionName' has a wrong offset!");
static_assert(offsetof(FInteractionData, InteractionText) == 0x000018, "Member 'FInteractionData::InteractionText' has a wrong offset!");
static_assert(offsetof(FInteractionData, InteractDataAsset) == 0x000030, "Member 'FInteractionData::InteractDataAsset' has a wrong offset!");
static_assert(offsetof(FInteractionData, Duration) == 0x000038, "Member 'FInteractionData::Duration' has a wrong offset!");
static_assert(offsetof(FInteractionData, ConditionalDuration) == 0x00003C, "Member 'FInteractionData::ConditionalDuration' has a wrong offset!");
static_assert(offsetof(FInteractionData, InteractTypes) == 0x000040, "Member 'FInteractionData::InteractTypes' has a wrong offset!");
static_assert(offsetof(FInteractionData, TriggerTag) == 0x000060, "Member 'FInteractionData::TriggerTag' has a wrong offset!");
static_assert(offsetof(FInteractionData, AbilityTriggerTag) == 0x000068, "Member 'FInteractionData::AbilityTriggerTag' has a wrong offset!");
static_assert(offsetof(FInteractionData, DetectTagQueryData) == 0x000070, "Member 'FInteractionData::DetectTagQueryData' has a wrong offset!");
static_assert(offsetof(FInteractionData, InteractTagQueryData) == 0x000078, "Member 'FInteractionData::InteractTagQueryData' has a wrong offset!");
static_assert(offsetof(FInteractionData, ConsumeTagQueryData) == 0x000080, "Member 'FInteractionData::ConsumeTagQueryData' has a wrong offset!");
static_assert(offsetof(FInteractionData, BlockInteractionTags) == 0x000088, "Member 'FInteractionData::BlockInteractionTags' has a wrong offset!");
static_assert(offsetof(FInteractionData, SkillCheckDataId) == 0x0000A8, "Member 'FInteractionData::SkillCheckDataId' has a wrong offset!");

// ScriptStruct DungeonCrawler.GameInteractionDescriptionWidgetData
// 0x0078 (0x0078 - 0x0000)
struct FGameInteractionDescriptionWidgetData final
{
public:
	struct FInteractTargetData                    InteractTargetData;                                // 0x0000(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FInteractionData> InteractableDataByStateMap;                        // 0x0020(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ECommonInputType                              InputType;                                         // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E2[0x7];                                     // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameInteractionDescriptionWidgetData) == 0x000008, "Wrong alignment on FGameInteractionDescriptionWidgetData");
static_assert(sizeof(FGameInteractionDescriptionWidgetData) == 0x000078, "Wrong size on FGameInteractionDescriptionWidgetData");
static_assert(offsetof(FGameInteractionDescriptionWidgetData, InteractTargetData) == 0x000000, "Member 'FGameInteractionDescriptionWidgetData::InteractTargetData' has a wrong offset!");
static_assert(offsetof(FGameInteractionDescriptionWidgetData, InteractableDataByStateMap) == 0x000020, "Member 'FGameInteractionDescriptionWidgetData::InteractableDataByStateMap' has a wrong offset!");
static_assert(offsetof(FGameInteractionDescriptionWidgetData, InputType) == 0x000070, "Member 'FGameInteractionDescriptionWidgetData::InputType' has a wrong offset!");

// ScriptStruct DungeonCrawler.KeyboardInputBinding
// 0x0070 (0x0070 - 0x0000)
struct FKeyboardInputBinding final
{
public:
	struct FEnhancedActionKeyMapping              InputMapping;                                      // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E3[0x20];                                    // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyboardInputBinding) == 0x000008, "Wrong alignment on FKeyboardInputBinding");
static_assert(sizeof(FKeyboardInputBinding) == 0x000070, "Wrong size on FKeyboardInputBinding");
static_assert(offsetof(FKeyboardInputBinding, InputMapping) == 0x000000, "Member 'FKeyboardInputBinding::InputMapping' has a wrong offset!");

// ScriptStruct DungeonCrawler.InteractionSucceedData
// 0x0018 (0x0018 - 0x0000)
struct FInteractionSucceedData final
{
public:
	struct FGameplayTag                           StateTag;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCAccountId                           AccountId;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionSucceedData) == 0x000008, "Wrong alignment on FInteractionSucceedData");
static_assert(sizeof(FInteractionSucceedData) == 0x000018, "Wrong size on FInteractionSucceedData");
static_assert(offsetof(FInteractionSucceedData, StateTag) == 0x000000, "Member 'FInteractionSucceedData::StateTag' has a wrong offset!");
static_assert(offsetof(FInteractionSucceedData, AccountId) == 0x000008, "Member 'FInteractionSucceedData::AccountId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MiniMapDeathSwarmData
// 0x0038 (0x0038 - 0x0000)
struct FMiniMapDeathSwarmData final
{
public:
	EFloorRulePhase                               FloorRulePhase;                                    // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E4[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LerpRatio;                                         // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PosLerpFrom;                                       // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeLerpFrom;                                      // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E5[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              PosLerpTo;                                         // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeLerpTo;                                        // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E6[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMiniMapDeathSwarmData) == 0x000008, "Wrong alignment on FMiniMapDeathSwarmData");
static_assert(sizeof(FMiniMapDeathSwarmData) == 0x000038, "Wrong size on FMiniMapDeathSwarmData");
static_assert(offsetof(FMiniMapDeathSwarmData, FloorRulePhase) == 0x000000, "Member 'FMiniMapDeathSwarmData::FloorRulePhase' has a wrong offset!");
static_assert(offsetof(FMiniMapDeathSwarmData, LerpRatio) == 0x000004, "Member 'FMiniMapDeathSwarmData::LerpRatio' has a wrong offset!");
static_assert(offsetof(FMiniMapDeathSwarmData, PosLerpFrom) == 0x000008, "Member 'FMiniMapDeathSwarmData::PosLerpFrom' has a wrong offset!");
static_assert(offsetof(FMiniMapDeathSwarmData, SizeLerpFrom) == 0x000018, "Member 'FMiniMapDeathSwarmData::SizeLerpFrom' has a wrong offset!");
static_assert(offsetof(FMiniMapDeathSwarmData, PosLerpTo) == 0x000020, "Member 'FMiniMapDeathSwarmData::PosLerpTo' has a wrong offset!");
static_assert(offsetof(FMiniMapDeathSwarmData, SizeLerpTo) == 0x000030, "Member 'FMiniMapDeathSwarmData::SizeLerpTo' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameAISet
// 0x0008 (0x0020 - 0x0018)
struct FMsgGameAISet final : public FMsgBase
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameAISet) == 0x000008, "Wrong alignment on FMsgGameAISet");
static_assert(sizeof(FMsgGameAISet) == 0x000020, "Wrong size on FMsgGameAISet");
static_assert(offsetof(FMsgGameAISet, BehaviorTree) == 0x000018, "Member 'FMsgGameAISet::BehaviorTree' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameAnnounceNotify
// 0x0090 (0x00A8 - 0x0018)
struct FMsgGameAnnounceNotify final : public FMsgBase
{
public:
	struct FGameAnnounceData                      GameAnnounceData;                                  // 0x0018(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameAnnounceNotify) == 0x000008, "Wrong alignment on FMsgGameAnnounceNotify");
static_assert(sizeof(FMsgGameAnnounceNotify) == 0x0000A8, "Wrong size on FMsgGameAnnounceNotify");
static_assert(offsetof(FMsgGameAnnounceNotify, GameAnnounceData) == 0x000018, "Member 'FMsgGameAnnounceNotify::GameAnnounceData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameKillLogNotify
// 0x0118 (0x0130 - 0x0018)
struct FMsgGameKillLogNotify final : public FMsgBase
{
public:
	struct FGameKillLogData                       GameKillLogData;                                   // 0x0018(0x0118)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameKillLogNotify) == 0x000008, "Wrong alignment on FMsgGameKillLogNotify");
static_assert(sizeof(FMsgGameKillLogNotify) == 0x000130, "Wrong size on FMsgGameKillLogNotify");
static_assert(offsetof(FMsgGameKillLogNotify, GameKillLogData) == 0x000018, "Member 'FMsgGameKillLogNotify::GameKillLogData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGASAttributeSetRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgGASAttributeSetRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgGASAttributeSetRequest) == 0x000008, "Wrong alignment on FMsgGASAttributeSetRequest");
static_assert(sizeof(FMsgGASAttributeSetRequest) == 0x000018, "Wrong size on FMsgGASAttributeSetRequest");

// ScriptStruct DungeonCrawler.MsgGASGameplayTagContainerResponse
// 0x0020 (0x0038 - 0x0018)
struct FMsgGASGameplayTagContainerResponse final : public FMsgBase
{
public:
	struct FGameplayTagContainer                  GameplayTagContainer;                              // 0x0018(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGASGameplayTagContainerResponse) == 0x000008, "Wrong alignment on FMsgGASGameplayTagContainerResponse");
static_assert(sizeof(FMsgGASGameplayTagContainerResponse) == 0x000038, "Wrong size on FMsgGASGameplayTagContainerResponse");
static_assert(offsetof(FMsgGASGameplayTagContainerResponse, GameplayTagContainer) == 0x000018, "Member 'FMsgGASGameplayTagContainerResponse::GameplayTagContainer' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGASImpactEnduranceExhaustedNotify
// 0x06C8 (0x06E0 - 0x0018)
struct FMsgGASImpactEnduranceExhaustedNotify final : public FMsgBase
{
public:
	float                                         ExhaustedTime;                                     // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E7[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GameplayEffectClass;                               // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameplayEffectContext               EffectContext;                                     // 0x0028(0x0420)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    EffectSpec;                                        // 0x0448(0x0298)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGASImpactEnduranceExhaustedNotify) == 0x000008, "Wrong alignment on FMsgGASImpactEnduranceExhaustedNotify");
static_assert(sizeof(FMsgGASImpactEnduranceExhaustedNotify) == 0x0006E0, "Wrong size on FMsgGASImpactEnduranceExhaustedNotify");
static_assert(offsetof(FMsgGASImpactEnduranceExhaustedNotify, ExhaustedTime) == 0x000018, "Member 'FMsgGASImpactEnduranceExhaustedNotify::ExhaustedTime' has a wrong offset!");
static_assert(offsetof(FMsgGASImpactEnduranceExhaustedNotify, GameplayEffectClass) == 0x000020, "Member 'FMsgGASImpactEnduranceExhaustedNotify::GameplayEffectClass' has a wrong offset!");
static_assert(offsetof(FMsgGASImpactEnduranceExhaustedNotify, EffectContext) == 0x000028, "Member 'FMsgGASImpactEnduranceExhaustedNotify::EffectContext' has a wrong offset!");
static_assert(offsetof(FMsgGASImpactEnduranceExhaustedNotify, EffectSpec) == 0x000448, "Member 'FMsgGASImpactEnduranceExhaustedNotify::EffectSpec' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGASEffectCauserDataResponse
// 0x0018 (0x0030 - 0x0018)
struct FMsgGASEffectCauserDataResponse final : public FMsgBase
{
public:
	struct FEffectCauserData                      EffectCauserData;                                  // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGASEffectCauserDataResponse) == 0x000008, "Wrong alignment on FMsgGASEffectCauserDataResponse");
static_assert(sizeof(FMsgGASEffectCauserDataResponse) == 0x000030, "Wrong size on FMsgGASEffectCauserDataResponse");
static_assert(offsetof(FMsgGASEffectCauserDataResponse, EffectCauserData) == 0x000018, "Member 'FMsgGASEffectCauserDataResponse::EffectCauserData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCGameTestClassTrainingInfo
// 0x0058 (0x0058 - 0x0000)
struct FDCGameTestClassTrainingInfo final
{
public:
	bool                                          bIsMaster;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCTrainingState                              TrainingState;                                     // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E8[0x2];                                     // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPrimaryAssetId                        MasterPlayerCharacterId;                           // 0x0004(0x0010)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22E9[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                ClassAbilityChoices;                               // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 RewardChoiceUniqueIds;                             // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FDCRewardInfo>                  RewardChoiceInfos;                                 // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FDCTrainingCharacterInfo>       TrainingCharacters;                                // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCGameTestClassTrainingInfo) == 0x000008, "Wrong alignment on FDCGameTestClassTrainingInfo");
static_assert(sizeof(FDCGameTestClassTrainingInfo) == 0x000058, "Wrong size on FDCGameTestClassTrainingInfo");
static_assert(offsetof(FDCGameTestClassTrainingInfo, bIsMaster) == 0x000000, "Member 'FDCGameTestClassTrainingInfo::bIsMaster' has a wrong offset!");
static_assert(offsetof(FDCGameTestClassTrainingInfo, TrainingState) == 0x000001, "Member 'FDCGameTestClassTrainingInfo::TrainingState' has a wrong offset!");
static_assert(offsetof(FDCGameTestClassTrainingInfo, MasterPlayerCharacterId) == 0x000004, "Member 'FDCGameTestClassTrainingInfo::MasterPlayerCharacterId' has a wrong offset!");
static_assert(offsetof(FDCGameTestClassTrainingInfo, ClassAbilityChoices) == 0x000018, "Member 'FDCGameTestClassTrainingInfo::ClassAbilityChoices' has a wrong offset!");
static_assert(offsetof(FDCGameTestClassTrainingInfo, RewardChoiceUniqueIds) == 0x000028, "Member 'FDCGameTestClassTrainingInfo::RewardChoiceUniqueIds' has a wrong offset!");
static_assert(offsetof(FDCGameTestClassTrainingInfo, RewardChoiceInfos) == 0x000038, "Member 'FDCGameTestClassTrainingInfo::RewardChoiceInfos' has a wrong offset!");
static_assert(offsetof(FDCGameTestClassTrainingInfo, TrainingCharacters) == 0x000048, "Member 'FDCGameTestClassTrainingInfo::TrainingCharacters' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassPerkListResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgGameTestClassPerkListResponse final : public FMsgBase
{
public:
	TArray<struct FAccountDataPerk>               Perks;                                             // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassPerkListResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassPerkListResponse");
static_assert(sizeof(FMsgGameTestClassPerkListResponse) == 0x000028, "Wrong size on FMsgGameTestClassPerkListResponse");
static_assert(offsetof(FMsgGameTestClassPerkListResponse, Perks) == 0x000018, "Member 'FMsgGameTestClassPerkListResponse::Perks' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassSpellListResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgGameTestClassSpellListResponse final : public FMsgBase
{
public:
	TArray<struct FAccountDataSpell>              Spells;                                            // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassSpellListResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassSpellListResponse");
static_assert(sizeof(FMsgGameTestClassSpellListResponse) == 0x000028, "Wrong size on FMsgGameTestClassSpellListResponse");
static_assert(offsetof(FMsgGameTestClassSpellListResponse, Spells) == 0x000018, "Member 'FMsgGameTestClassSpellListResponse::Spells' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassSpellSequenceChangeResponse
// 0x0018 (0x0030 - 0x0018)
struct FMsgGameTestClassSpellSequenceChangeResponse final : public FMsgBase
{
public:
	int32                                         Result;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22EA[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAccountDataSpell>              EquipSpellList;                                    // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassSpellSequenceChangeResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassSpellSequenceChangeResponse");
static_assert(sizeof(FMsgGameTestClassSpellSequenceChangeResponse) == 0x000030, "Wrong size on FMsgGameTestClassSpellSequenceChangeResponse");
static_assert(offsetof(FMsgGameTestClassSpellSequenceChangeResponse, Result) == 0x000018, "Member 'FMsgGameTestClassSpellSequenceChangeResponse::Result' has a wrong offset!");
static_assert(offsetof(FMsgGameTestClassSpellSequenceChangeResponse, EquipSpellList) == 0x000020, "Member 'FMsgGameTestClassSpellSequenceChangeResponse::EquipSpellList' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgGameTestClassShapeShiftListResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgGameTestClassShapeShiftListResponse final : public FMsgBase
{
public:
	TArray<struct FAccountDataShapeShift>         ShapeShifts;                                       // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgGameTestClassShapeShiftListResponse) == 0x000008, "Wrong alignment on FMsgGameTestClassShapeShiftListResponse");
static_assert(sizeof(FMsgGameTestClassShapeShiftListResponse) == 0x000028, "Wrong size on FMsgGameTestClassShapeShiftListResponse");
static_assert(offsetof(FMsgGameTestClassShapeShiftListResponse, ShapeShifts) == 0x000018, "Member 'FMsgGameTestClassShapeShiftListResponse::ShapeShifts' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCServerPolicyInfo
// 0x0001 (0x0001 - 0x0000)
struct FDCServerPolicyInfo final
{
public:
	bool                                          bGmEnabled;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCServerPolicyInfo) == 0x000001, "Wrong alignment on FDCServerPolicyInfo");
static_assert(sizeof(FDCServerPolicyInfo) == 0x000001, "Wrong size on FDCServerPolicyInfo");
static_assert(offsetof(FDCServerPolicyInfo, bGmEnabled) == 0x000000, "Member 'FDCServerPolicyInfo::bGmEnabled' has a wrong offset!");

// ScriptStruct DungeonCrawler.ObjectLinkEventContext
// 0x00A8 (0x00A8 - 0x0000)
struct FObjectLinkEventContext final
{
public:
	struct FGameplayTagQuery                      EventStateTagQuery;                                // 0x0000(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      OwnerStateTagQuery;                                // 0x0048(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0090(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FObjectLinkEventMethod>         Methods;                                           // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectLinkEventContext) == 0x000008, "Wrong alignment on FObjectLinkEventContext");
static_assert(sizeof(FObjectLinkEventContext) == 0x0000A8, "Wrong size on FObjectLinkEventContext");
static_assert(offsetof(FObjectLinkEventContext, EventStateTagQuery) == 0x000000, "Member 'FObjectLinkEventContext::EventStateTagQuery' has a wrong offset!");
static_assert(offsetof(FObjectLinkEventContext, OwnerStateTagQuery) == 0x000048, "Member 'FObjectLinkEventContext::OwnerStateTagQuery' has a wrong offset!");
static_assert(offsetof(FObjectLinkEventContext, EventTag) == 0x000090, "Member 'FObjectLinkEventContext::EventTag' has a wrong offset!");
static_assert(offsetof(FObjectLinkEventContext, Methods) == 0x000098, "Member 'FObjectLinkEventContext::Methods' has a wrong offset!");

// ScriptStruct DungeonCrawler.GameUserSettingAudios
// 0x0030 (0x0030 - 0x0000)
struct FGameUserSettingAudios final
{
public:
	float                                         TotalVolume;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectVolume;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicVolume;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBackgroundVolume;                                // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoipInit;                                         // 0x000D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoipEnable;                                       // 0x000E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoipGlobal;                                       // 0x000F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoipSendAlways;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22EB[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VoipInputVolume;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoipOutputVolume;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22EC[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameUserSettingAudiosVoipPartyMember> VoipPartyMemberSettingArray;                       // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameUserSettingAudios) == 0x000008, "Wrong alignment on FGameUserSettingAudios");
static_assert(sizeof(FGameUserSettingAudios) == 0x000030, "Wrong size on FGameUserSettingAudios");
static_assert(offsetof(FGameUserSettingAudios, TotalVolume) == 0x000000, "Member 'FGameUserSettingAudios::TotalVolume' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudios, EffectVolume) == 0x000004, "Member 'FGameUserSettingAudios::EffectVolume' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudios, MusicVolume) == 0x000008, "Member 'FGameUserSettingAudios::MusicVolume' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudios, IsBackgroundVolume) == 0x00000C, "Member 'FGameUserSettingAudios::IsBackgroundVolume' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudios, bVoipInit) == 0x00000D, "Member 'FGameUserSettingAudios::bVoipInit' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudios, bVoipEnable) == 0x00000E, "Member 'FGameUserSettingAudios::bVoipEnable' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudios, bVoipGlobal) == 0x00000F, "Member 'FGameUserSettingAudios::bVoipGlobal' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudios, bVoipSendAlways) == 0x000010, "Member 'FGameUserSettingAudios::bVoipSendAlways' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudios, VoipInputVolume) == 0x000014, "Member 'FGameUserSettingAudios::VoipInputVolume' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudios, VoipOutputVolume) == 0x000018, "Member 'FGameUserSettingAudios::VoipOutputVolume' has a wrong offset!");
static_assert(offsetof(FGameUserSettingAudios, VoipPartyMemberSettingArray) == 0x000020, "Member 'FGameUserSettingAudios::VoipPartyMemberSettingArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemConsumeRandomEffectData
// 0x0010 (0x0010 - 0x0000)
struct FItemConsumeRandomEffectData final
{
public:
	class UDCGameplayEffectDataAsset*             EffectDataAsset;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandomRate;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22ED[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemConsumeRandomEffectData) == 0x000008, "Wrong alignment on FItemConsumeRandomEffectData");
static_assert(sizeof(FItemConsumeRandomEffectData) == 0x000010, "Wrong size on FItemConsumeRandomEffectData");
static_assert(offsetof(FItemConsumeRandomEffectData, EffectDataAsset) == 0x000000, "Member 'FItemConsumeRandomEffectData::EffectDataAsset' has a wrong offset!");
static_assert(offsetof(FItemConsumeRandomEffectData, RandomRate) == 0x000008, "Member 'FItemConsumeRandomEffectData::RandomRate' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInteractStarted
// 0x0010 (0x0028 - 0x0018)
struct FMsgInteractStarted final : public FMsgBase
{
public:
	class AActor*                                 Interacter;                                        // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           EventTag;                                          // 0x0020(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgInteractStarted) == 0x000008, "Wrong alignment on FMsgInteractStarted");
static_assert(sizeof(FMsgInteractStarted) == 0x000028, "Wrong size on FMsgInteractStarted");
static_assert(offsetof(FMsgInteractStarted, Interacter) == 0x000018, "Member 'FMsgInteractStarted::Interacter' has a wrong offset!");
static_assert(offsetof(FMsgInteractStarted, EventTag) == 0x000020, "Member 'FMsgInteractStarted::EventTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInteractEnd
// 0x0108 (0x0120 - 0x0018)
struct FMsgInteractEnd final : public FMsgBase
{
public:
	class AActor*                                 Interacter;                                        // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSucceed;                                        // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22EE[0x3];                                     // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           EventTag;                                          // 0x0024(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           StateTag;                                          // 0x002C(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22EF[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0038(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgInteractEnd) == 0x000008, "Wrong alignment on FMsgInteractEnd");
static_assert(sizeof(FMsgInteractEnd) == 0x000120, "Wrong size on FMsgInteractEnd");
static_assert(offsetof(FMsgInteractEnd, Interacter) == 0x000018, "Member 'FMsgInteractEnd::Interacter' has a wrong offset!");
static_assert(offsetof(FMsgInteractEnd, bIsSucceed) == 0x000020, "Member 'FMsgInteractEnd::bIsSucceed' has a wrong offset!");
static_assert(offsetof(FMsgInteractEnd, EventTag) == 0x000024, "Member 'FMsgInteractEnd::EventTag' has a wrong offset!");
static_assert(offsetof(FMsgInteractEnd, StateTag) == 0x00002C, "Member 'FMsgInteractEnd::StateTag' has a wrong offset!");
static_assert(offsetof(FMsgInteractEnd, HitResult) == 0x000038, "Member 'FMsgInteractEnd::HitResult' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInteractLost
// 0x0008 (0x0020 - 0x0018)
struct FMsgInteractLost final : public FMsgBase
{
public:
	class AActor*                                 Interacter;                                        // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgInteractLost) == 0x000008, "Wrong alignment on FMsgInteractLost");
static_assert(sizeof(FMsgInteractLost) == 0x000020, "Wrong size on FMsgInteractLost");
static_assert(offsetof(FMsgInteractLost, Interacter) == 0x000018, "Member 'FMsgInteractLost::Interacter' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInteractDataSet
// 0x0070 (0x0088 - 0x0018)
struct FMsgInteractDataSet final : public FMsgBase
{
public:
	struct FInteractTargetData                    InteractTargetData;                                // 0x0018(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FInteractionData> InteractableDataByStateMap;                        // 0x0038(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgInteractDataSet) == 0x000008, "Wrong alignment on FMsgInteractDataSet");
static_assert(sizeof(FMsgInteractDataSet) == 0x000088, "Wrong size on FMsgInteractDataSet");
static_assert(offsetof(FMsgInteractDataSet, InteractTargetData) == 0x000018, "Member 'FMsgInteractDataSet::InteractTargetData' has a wrong offset!");
static_assert(offsetof(FMsgInteractDataSet, InteractableDataByStateMap) == 0x000038, "Member 'FMsgInteractDataSet::InteractableDataByStateMap' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInteractSkillCheckEnd
// 0x0008 (0x0020 - 0x0018)
struct FMsgInteractSkillCheckEnd final : public FMsgBase
{
public:
	ESkillCheckResult                             Result;                                            // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F0[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgInteractSkillCheckEnd) == 0x000008, "Wrong alignment on FMsgInteractSkillCheckEnd");
static_assert(sizeof(FMsgInteractSkillCheckEnd) == 0x000020, "Wrong size on FMsgInteractSkillCheckEnd");
static_assert(offsetof(FMsgInteractSkillCheckEnd, Result) == 0x000018, "Member 'FMsgInteractSkillCheckEnd::Result' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgRemoveContainingItemResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgRemoveContainingItemResponse final : public FMsgBase
{
public:
	bool                                          bSuccess;                                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F1[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgRemoveContainingItemResponse) == 0x000008, "Wrong alignment on FMsgRemoveContainingItemResponse");
static_assert(sizeof(FMsgRemoveContainingItemResponse) == 0x000020, "Wrong size on FMsgRemoveContainingItemResponse");
static_assert(offsetof(FMsgRemoveContainingItemResponse, bSuccess) == 0x000018, "Member 'FMsgRemoveContainingItemResponse::bSuccess' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgReduceItemContentsCountRequest
// 0x0018 (0x0030 - 0x0018)
struct FMsgReduceItemContentsCountRequest final : public FMsgBase
{
public:
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F2[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUniqueId;                                      // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReduceContentsCount;                               // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F3[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgReduceItemContentsCountRequest) == 0x000008, "Wrong alignment on FMsgReduceItemContentsCountRequest");
static_assert(sizeof(FMsgReduceItemContentsCountRequest) == 0x000030, "Wrong size on FMsgReduceItemContentsCountRequest");
static_assert(offsetof(FMsgReduceItemContentsCountRequest, InventoryId) == 0x000018, "Member 'FMsgReduceItemContentsCountRequest::InventoryId' has a wrong offset!");
static_assert(offsetof(FMsgReduceItemContentsCountRequest, ItemUniqueId) == 0x000020, "Member 'FMsgReduceItemContentsCountRequest::ItemUniqueId' has a wrong offset!");
static_assert(offsetof(FMsgReduceItemContentsCountRequest, ReduceContentsCount) == 0x000028, "Member 'FMsgReduceItemContentsCountRequest::ReduceContentsCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgReduceItemContentsCountResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgReduceItemContentsCountResponse final : public FMsgBase
{
public:
	bool                                          bSucceed;                                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F4[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgReduceItemContentsCountResponse) == 0x000008, "Wrong alignment on FMsgReduceItemContentsCountResponse");
static_assert(sizeof(FMsgReduceItemContentsCountResponse) == 0x000020, "Wrong size on FMsgReduceItemContentsCountResponse");
static_assert(offsetof(FMsgReduceItemContentsCountResponse, bSucceed) == 0x000018, "Member 'FMsgReduceItemContentsCountResponse::bSucceed' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAddSheathItemActor
// 0x0008 (0x0020 - 0x0018)
struct FMsgAddSheathItemActor final : public FMsgBase
{
public:
	class AItemActor*                             SheathItemActor;                                   // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAddSheathItemActor) == 0x000008, "Wrong alignment on FMsgAddSheathItemActor");
static_assert(sizeof(FMsgAddSheathItemActor) == 0x000020, "Wrong size on FMsgAddSheathItemActor");
static_assert(offsetof(FMsgAddSheathItemActor, SheathItemActor) == 0x000018, "Member 'FMsgAddSheathItemActor::SheathItemActor' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgItemDataNotify
// 0x0208 (0x0220 - 0x0018)
struct FMsgItemDataNotify final : public FMsgBase
{
public:
	class UInventoryComponent*                    InventoryComponent;                                // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemData                              OldItemData;                                       // 0x0020(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FItemData                              NewItemData;                                       // 0x0120(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgItemDataNotify) == 0x000008, "Wrong alignment on FMsgItemDataNotify");
static_assert(sizeof(FMsgItemDataNotify) == 0x000220, "Wrong size on FMsgItemDataNotify");
static_assert(offsetof(FMsgItemDataNotify, InventoryComponent) == 0x000018, "Member 'FMsgItemDataNotify::InventoryComponent' has a wrong offset!");
static_assert(offsetof(FMsgItemDataNotify, OldItemData) == 0x000020, "Member 'FMsgItemDataNotify::OldItemData' has a wrong offset!");
static_assert(offsetof(FMsgItemDataNotify, NewItemData) == 0x000120, "Member 'FMsgItemDataNotify::NewItemData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgEnableSwapItemRequest
// 0x0118 (0x0130 - 0x0018)
struct FMsgEnableSwapItemRequest final : public FMsgBase
{
public:
	int32                                         TargetInventoryId;                                 // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F5[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemData                              RemoveItemData;                                    // 0x0020(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FItemData>                      AddItemDataArray;                                  // 0x0120(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgEnableSwapItemRequest) == 0x000008, "Wrong alignment on FMsgEnableSwapItemRequest");
static_assert(sizeof(FMsgEnableSwapItemRequest) == 0x000130, "Wrong size on FMsgEnableSwapItemRequest");
static_assert(offsetof(FMsgEnableSwapItemRequest, TargetInventoryId) == 0x000018, "Member 'FMsgEnableSwapItemRequest::TargetInventoryId' has a wrong offset!");
static_assert(offsetof(FMsgEnableSwapItemRequest, RemoveItemData) == 0x000020, "Member 'FMsgEnableSwapItemRequest::RemoveItemData' has a wrong offset!");
static_assert(offsetof(FMsgEnableSwapItemRequest, AddItemDataArray) == 0x000120, "Member 'FMsgEnableSwapItemRequest::AddItemDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgInventoryItemAmmoReduceRequest
// 0x0018 (0x0030 - 0x0018)
struct FMsgInventoryItemAmmoReduceRequest final : public FMsgBase
{
public:
	int32                                         InventoryId;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F6[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ItemUniqueId;                                      // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F7[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgInventoryItemAmmoReduceRequest) == 0x000008, "Wrong alignment on FMsgInventoryItemAmmoReduceRequest");
static_assert(sizeof(FMsgInventoryItemAmmoReduceRequest) == 0x000030, "Wrong size on FMsgInventoryItemAmmoReduceRequest");
static_assert(offsetof(FMsgInventoryItemAmmoReduceRequest, InventoryId) == 0x000018, "Member 'FMsgInventoryItemAmmoReduceRequest::InventoryId' has a wrong offset!");
static_assert(offsetof(FMsgInventoryItemAmmoReduceRequest, ItemUniqueId) == 0x000020, "Member 'FMsgInventoryItemAmmoReduceRequest::ItemUniqueId' has a wrong offset!");
static_assert(offsetof(FMsgInventoryItemAmmoReduceRequest, Count) == 0x000028, "Member 'FMsgInventoryItemAmmoReduceRequest::Count' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSucceedWidgetMoveItem
// 0x0010 (0x0028 - 0x0018)
struct FMsgSucceedWidgetMoveItem final : public FMsgBase
{
public:
	TArray<struct FItemData>                      ItemDataArray;                                     // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSucceedWidgetMoveItem) == 0x000008, "Wrong alignment on FMsgSucceedWidgetMoveItem");
static_assert(sizeof(FMsgSucceedWidgetMoveItem) == 0x000028, "Wrong size on FMsgSucceedWidgetMoveItem");
static_assert(offsetof(FMsgSucceedWidgetMoveItem, ItemDataArray) == 0x000018, "Member 'FMsgSucceedWidgetMoveItem::ItemDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgItemIdNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgItemIdNotify final : public FMsgBase
{
public:
	struct FDCItemId                              ItemId;                                            // 0x0018(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCInventoryId                                Inventory;                                         // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F8[0x3];                                     // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index;                                             // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgItemIdNotify) == 0x000008, "Wrong alignment on FMsgItemIdNotify");
static_assert(sizeof(FMsgItemIdNotify) == 0x000028, "Wrong size on FMsgItemIdNotify");
static_assert(offsetof(FMsgItemIdNotify, ItemId) == 0x000018, "Member 'FMsgItemIdNotify::ItemId' has a wrong offset!");
static_assert(offsetof(FMsgItemIdNotify, Inventory) == 0x000020, "Member 'FMsgItemIdNotify::Inventory' has a wrong offset!");
static_assert(offsetof(FMsgItemIdNotify, Index) == 0x000024, "Member 'FMsgItemIdNotify::Index' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgAddToInventory
// 0x0018 (0x0030 - 0x0018)
struct FMsgAddToInventory final : public FMsgBase
{
public:
	class AActor*                                 Owner;                                             // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEquipped;                                         // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22F9[0x3];                                     // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InventoryId;                                       // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventorySlotId;                                   // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FA[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgAddToInventory) == 0x000008, "Wrong alignment on FMsgAddToInventory");
static_assert(sizeof(FMsgAddToInventory) == 0x000030, "Wrong size on FMsgAddToInventory");
static_assert(offsetof(FMsgAddToInventory, Owner) == 0x000018, "Member 'FMsgAddToInventory::Owner' has a wrong offset!");
static_assert(offsetof(FMsgAddToInventory, bEquipped) == 0x000020, "Member 'FMsgAddToInventory::bEquipped' has a wrong offset!");
static_assert(offsetof(FMsgAddToInventory, InventoryId) == 0x000024, "Member 'FMsgAddToInventory::InventoryId' has a wrong offset!");
static_assert(offsetof(FMsgAddToInventory, InventorySlotId) == 0x000028, "Member 'FMsgAddToInventory::InventorySlotId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgEquip
// 0x0000 (0x0018 - 0x0018)
struct FMsgEquip final : public FMsgBase
{
};
static_assert(alignof(FMsgEquip) == 0x000008, "Wrong alignment on FMsgEquip");
static_assert(sizeof(FMsgEquip) == 0x000018, "Wrong size on FMsgEquip");

// ScriptStruct DungeonCrawler.MsgRemoveAbility
// 0x0008 (0x0020 - 0x0018)
struct FMsgRemoveAbility final : public FMsgBase
{
public:
	class AActor*                                 TargetActor;                                       // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgRemoveAbility) == 0x000008, "Wrong alignment on FMsgRemoveAbility");
static_assert(sizeof(FMsgRemoveAbility) == 0x000020, "Wrong size on FMsgRemoveAbility");
static_assert(offsetof(FMsgRemoveAbility, TargetActor) == 0x000018, "Member 'FMsgRemoveAbility::TargetActor' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgItemDataUpdateNotify
// 0x0100 (0x0118 - 0x0018)
struct FMsgItemDataUpdateNotify final : public FMsgBase
{
public:
	struct FItemData                              ItemData;                                          // 0x0018(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgItemDataUpdateNotify) == 0x000008, "Wrong alignment on FMsgItemDataUpdateNotify");
static_assert(sizeof(FMsgItemDataUpdateNotify) == 0x000118, "Wrong size on FMsgItemDataUpdateNotify");
static_assert(offsetof(FMsgItemDataUpdateNotify, ItemData) == 0x000018, "Member 'FMsgItemDataUpdateNotify::ItemData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgChangedItemArtData
// 0x0010 (0x0028 - 0x0018)
struct FMsgChangedItemArtData final : public FMsgBase
{
public:
	class UItem*                                  Item;                                              // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArtDataItem*                           NewItemArtData;                                    // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgChangedItemArtData) == 0x000008, "Wrong alignment on FMsgChangedItemArtData");
static_assert(sizeof(FMsgChangedItemArtData) == 0x000028, "Wrong size on FMsgChangedItemArtData");
static_assert(offsetof(FMsgChangedItemArtData, Item) == 0x000018, "Member 'FMsgChangedItemArtData::Item' has a wrong offset!");
static_assert(offsetof(FMsgChangedItemArtData, NewItemArtData) == 0x000020, "Member 'FMsgChangedItemArtData::NewItemArtData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgItemWearingStart
// 0x0128 (0x0140 - 0x0018)
struct FMsgItemWearingStart final : public FMsgBase
{
public:
	struct FItemData                              WearingItemData;                                   // 0x0018(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  WearingActor;                                      // 0x0118(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0120(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FB[0x4];                                     // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0128(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgItemWearingStart) == 0x000008, "Wrong alignment on FMsgItemWearingStart");
static_assert(sizeof(FMsgItemWearingStart) == 0x000140, "Wrong size on FMsgItemWearingStart");
static_assert(offsetof(FMsgItemWearingStart, WearingItemData) == 0x000018, "Member 'FMsgItemWearingStart::WearingItemData' has a wrong offset!");
static_assert(offsetof(FMsgItemWearingStart, WearingActor) == 0x000118, "Member 'FMsgItemWearingStart::WearingActor' has a wrong offset!");
static_assert(offsetof(FMsgItemWearingStart, Duration) == 0x000120, "Member 'FMsgItemWearingStart::Duration' has a wrong offset!");
static_assert(offsetof(FMsgItemWearingStart, Description) == 0x000128, "Member 'FMsgItemWearingStart::Description' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgItemWearingEnd
// 0x0008 (0x0020 - 0x0018)
struct FMsgItemWearingEnd final : public FMsgBase
{
public:
	bool                                          bIsSucceed;                                        // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FC[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgItemWearingEnd) == 0x000008, "Wrong alignment on FMsgItemWearingEnd");
static_assert(sizeof(FMsgItemWearingEnd) == 0x000020, "Wrong size on FMsgItemWearingEnd");
static_assert(offsetof(FMsgItemWearingEnd, bIsSucceed) == 0x000018, "Member 'FMsgItemWearingEnd::bIsSucceed' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemRandomGenerateData
// 0x00A0 (0x00A0 - 0x0000)
struct FItemRandomGenerateData final
{
public:
	EItemRandomGenerateType                       GenerateType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FD[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDCLootDropDataAsset*                   LootDropData;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDCLootDropRateDataAsset*               LootDropRateData;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EItemType>                             GenerateItemTypeArray;                             // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ItemRarityTags;                                    // 0x0028(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         GenerateCount;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FE[0x54];                                    // 0x004C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemRandomGenerateData) == 0x000008, "Wrong alignment on FItemRandomGenerateData");
static_assert(sizeof(FItemRandomGenerateData) == 0x0000A0, "Wrong size on FItemRandomGenerateData");
static_assert(offsetof(FItemRandomGenerateData, GenerateType) == 0x000000, "Member 'FItemRandomGenerateData::GenerateType' has a wrong offset!");
static_assert(offsetof(FItemRandomGenerateData, LootDropData) == 0x000008, "Member 'FItemRandomGenerateData::LootDropData' has a wrong offset!");
static_assert(offsetof(FItemRandomGenerateData, LootDropRateData) == 0x000010, "Member 'FItemRandomGenerateData::LootDropRateData' has a wrong offset!");
static_assert(offsetof(FItemRandomGenerateData, GenerateItemTypeArray) == 0x000018, "Member 'FItemRandomGenerateData::GenerateItemTypeArray' has a wrong offset!");
static_assert(offsetof(FItemRandomGenerateData, ItemRarityTags) == 0x000028, "Member 'FItemRandomGenerateData::ItemRarityTags' has a wrong offset!");
static_assert(offsetof(FItemRandomGenerateData, GenerateCount) == 0x000048, "Member 'FItemRandomGenerateData::GenerateCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemTooltipWidgetData
// 0x0100 (0x0100 - 0x0000)
struct FItemTooltipWidgetData final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTooltipWidgetData) == 0x000008, "Wrong alignment on FItemTooltipWidgetData");
static_assert(sizeof(FItemTooltipWidgetData) == 0x000100, "Wrong size on FItemTooltipWidgetData");
static_assert(offsetof(FItemTooltipWidgetData, ItemData) == 0x000000, "Member 'FItemTooltipWidgetData::ItemData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemInventorySize
// 0x0008 (0x0008 - 0x0000)
struct FItemInventorySize final
{
public:
	int32                                         Width;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemInventorySize) == 0x000004, "Wrong alignment on FItemInventorySize");
static_assert(sizeof(FItemInventorySize) == 0x000008, "Wrong size on FItemInventorySize");
static_assert(offsetof(FItemInventorySize, Width) == 0x000000, "Member 'FItemInventorySize::Width' has a wrong offset!");
static_assert(offsetof(FItemInventorySize, Height) == 0x000004, "Member 'FItemInventorySize::Height' has a wrong offset!");

// ScriptStruct DungeonCrawler.ItemWidgetData
// 0x0100 (0x0100 - 0x0000)
struct FItemWidgetData final
{
public:
	struct FItemData                              ItemData;                                          // 0x0000(0x0100)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemWidgetData) == 0x000008, "Wrong alignment on FItemWidgetData");
static_assert(sizeof(FItemWidgetData) == 0x000100, "Wrong size on FItemWidgetData");
static_assert(offsetof(FItemWidgetData, ItemData) == 0x000000, "Member 'FItemWidgetData::ItemData' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardRankRecordMineData
// 0x0080 (0x0080 - 0x0000)
struct FLeaderboardRankRecordMineData final
{
public:
	int32                                         PlayGameCount;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BatchGameCount;                                    // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRankRecord                            RankRecord;                                        // 0x0008(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         LeaderboardScoreFractionalDigits;                  // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22FF[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeaderboardRankRecordMineData) == 0x000008, "Wrong alignment on FLeaderboardRankRecordMineData");
static_assert(sizeof(FLeaderboardRankRecordMineData) == 0x000080, "Wrong size on FLeaderboardRankRecordMineData");
static_assert(offsetof(FLeaderboardRankRecordMineData, PlayGameCount) == 0x000000, "Member 'FLeaderboardRankRecordMineData::PlayGameCount' has a wrong offset!");
static_assert(offsetof(FLeaderboardRankRecordMineData, BatchGameCount) == 0x000004, "Member 'FLeaderboardRankRecordMineData::BatchGameCount' has a wrong offset!");
static_assert(offsetof(FLeaderboardRankRecordMineData, RankRecord) == 0x000008, "Member 'FLeaderboardRankRecordMineData::RankRecord' has a wrong offset!");
static_assert(offsetof(FLeaderboardRankRecordMineData, LeaderboardScoreFractionalDigits) == 0x000078, "Member 'FLeaderboardRankRecordMineData::LeaderboardScoreFractionalDigits' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardRankRecordMineWidgetHandleData
// 0x0080 (0x0080 - 0x0000)
struct FLeaderboardRankRecordMineWidgetHandleData final
{
public:
	struct FLeaderboardRankRecordMineData         LeaderboardRankRecordMineData;                     // 0x0000(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeaderboardRankRecordMineWidgetHandleData) == 0x000008, "Wrong alignment on FLeaderboardRankRecordMineWidgetHandleData");
static_assert(sizeof(FLeaderboardRankRecordMineWidgetHandleData) == 0x000080, "Wrong size on FLeaderboardRankRecordMineWidgetHandleData");
static_assert(offsetof(FLeaderboardRankRecordMineWidgetHandleData, LeaderboardRankRecordMineData) == 0x000000, "Member 'FLeaderboardRankRecordMineWidgetHandleData::LeaderboardRankRecordMineData' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCLoginResult
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FDCLoginResult final
{
public:
	EServiceConnectFailType                       FailureType;                                       // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2300[0x27];                                    // 0x0001(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCLoginResult) == 0x000008, "Wrong alignment on FDCLoginResult");
static_assert(sizeof(FDCLoginResult) == 0x000028, "Wrong size on FDCLoginResult");
static_assert(offsetof(FDCLoginResult, FailureType) == 0x000000, "Member 'FDCLoginResult::FailureType' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgRemoveLootTarget
// 0x0018 (0x0030 - 0x0018)
struct FMsgRemoveLootTarget final : public FMsgBase
{
public:
	class UInventoryComponent*                    LootTargetComponent;                               // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemData>                      ContainingItemDataArray;                           // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgRemoveLootTarget) == 0x000008, "Wrong alignment on FMsgRemoveLootTarget");
static_assert(sizeof(FMsgRemoveLootTarget) == 0x000030, "Wrong size on FMsgRemoveLootTarget");
static_assert(offsetof(FMsgRemoveLootTarget, LootTargetComponent) == 0x000018, "Member 'FMsgRemoveLootTarget::LootTargetComponent' has a wrong offset!");
static_assert(offsetof(FMsgRemoveLootTarget, ContainingItemDataArray) == 0x000020, "Member 'FMsgRemoveLootTarget::ContainingItemDataArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgClearLootingTargets
// 0x0000 (0x0018 - 0x0018)
struct FMsgClearLootingTargets final : public FMsgBase
{
};
static_assert(alignof(FMsgClearLootingTargets) == 0x000008, "Wrong alignment on FMsgClearLootingTargets");
static_assert(sizeof(FMsgClearLootingTargets) == 0x000018, "Wrong size on FMsgClearLootingTargets");

// ScriptStruct DungeonCrawler.MsgAddLooter
// 0x00F0 (0x0108 - 0x0018)
struct FMsgAddLooter final : public FMsgBase
{
public:
	class AActor*                                 Looter;                                            // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0020(0x00E8)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgAddLooter) == 0x000008, "Wrong alignment on FMsgAddLooter");
static_assert(sizeof(FMsgAddLooter) == 0x000108, "Wrong size on FMsgAddLooter");
static_assert(offsetof(FMsgAddLooter, Looter) == 0x000018, "Member 'FMsgAddLooter::Looter' has a wrong offset!");
static_assert(offsetof(FMsgAddLooter, HitResult) == 0x000020, "Member 'FMsgAddLooter::HitResult' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgRemoveLooter
// 0x0008 (0x0020 - 0x0018)
struct FMsgRemoveLooter final : public FMsgBase
{
public:
	class AActor*                                 Looter;                                            // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgRemoveLooter) == 0x000008, "Wrong alignment on FMsgRemoveLooter");
static_assert(sizeof(FMsgRemoveLooter) == 0x000020, "Wrong size on FMsgRemoveLooter");
static_assert(offsetof(FMsgRemoveLooter, Looter) == 0x000018, "Member 'FMsgRemoveLooter::Looter' has a wrong offset!");

// ScriptStruct DungeonCrawler.StockCraftTradeItemInfo
// 0x0010 (0x0010 - 0x0000)
struct FStockCraftTradeItemInfo final
{
public:
	int64                                         ItemUniqueId;                                      // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemContentsCount;                                 // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStockCraftTradeItemInfo) == 0x000008, "Wrong alignment on FStockCraftTradeItemInfo");
static_assert(sizeof(FStockCraftTradeItemInfo) == 0x000010, "Wrong size on FStockCraftTradeItemInfo");
static_assert(offsetof(FStockCraftTradeItemInfo, ItemUniqueId) == 0x000000, "Member 'FStockCraftTradeItemInfo::ItemUniqueId' has a wrong offset!");
static_assert(offsetof(FStockCraftTradeItemInfo, ItemCount) == 0x000008, "Member 'FStockCraftTradeItemInfo::ItemCount' has a wrong offset!");
static_assert(offsetof(FStockCraftTradeItemInfo, ItemContentsCount) == 0x00000C, "Member 'FStockCraftTradeItemInfo::ItemContentsCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCMindwipeInfo
// 0x0018 (0x0018 - 0x0000)
struct FDCMindwipeInfo final
{
public:
	struct FTimespan                              ResetInterval;                                     // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ResetDateTime;                                     // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanMindwipe;                                      // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2301[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCMindwipeInfo) == 0x000008, "Wrong alignment on FDCMindwipeInfo");
static_assert(sizeof(FDCMindwipeInfo) == 0x000018, "Wrong size on FDCMindwipeInfo");
static_assert(offsetof(FDCMindwipeInfo, ResetInterval) == 0x000000, "Member 'FDCMindwipeInfo::ResetInterval' has a wrong offset!");
static_assert(offsetof(FDCMindwipeInfo, ResetDateTime) == 0x000008, "Member 'FDCMindwipeInfo::ResetDateTime' has a wrong offset!");
static_assert(offsetof(FDCMindwipeInfo, bCanMindwipe) == 0x000010, "Member 'FDCMindwipeInfo::bCanMindwipe' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardRankAPInfo
// 0x0010 (0x0010 - 0x0000)
struct FLeaderboardRankAPInfo final
{
public:
	class UDCLeaderboardRankAPDataAsset*          LeaderboardRankAPData;                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredTotalAP;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2302[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeaderboardRankAPInfo) == 0x000008, "Wrong alignment on FLeaderboardRankAPInfo");
static_assert(sizeof(FLeaderboardRankAPInfo) == 0x000010, "Wrong size on FLeaderboardRankAPInfo");
static_assert(offsetof(FLeaderboardRankAPInfo, LeaderboardRankAPData) == 0x000000, "Member 'FLeaderboardRankAPInfo::LeaderboardRankAPData' has a wrong offset!");
static_assert(offsetof(FLeaderboardRankAPInfo, RequiredTotalAP) == 0x000008, "Member 'FLeaderboardRankAPInfo::RequiredTotalAP' has a wrong offset!");

// ScriptStruct DungeonCrawler.LeaderboardRankEFInfo
// 0x0010 (0x0010 - 0x0000)
struct FLeaderboardRankEFInfo final
{
public:
	class UDCLeaderboardRankEFDataAsset*          LeaderboardRankEFData;                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EntranceFee;                                       // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2303[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeaderboardRankEFInfo) == 0x000008, "Wrong alignment on FLeaderboardRankEFInfo");
static_assert(sizeof(FLeaderboardRankEFInfo) == 0x000010, "Wrong size on FLeaderboardRankEFInfo");
static_assert(offsetof(FLeaderboardRankEFInfo, LeaderboardRankEFData) == 0x000000, "Member 'FLeaderboardRankEFInfo::LeaderboardRankEFData' has a wrong offset!");
static_assert(offsetof(FLeaderboardRankEFInfo, EntranceFee) == 0x000008, "Member 'FLeaderboardRankEFInfo::EntranceFee' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgMonsterAIStart
// 0x0000 (0x0018 - 0x0018)
struct FMsgMonsterAIStart final : public FMsgBase
{
};
static_assert(alignof(FMsgMonsterAIStart) == 0x000008, "Wrong alignment on FMsgMonsterAIStart");
static_assert(sizeof(FMsgMonsterAIStart) == 0x000018, "Wrong size on FMsgMonsterAIStart");

// ScriptStruct DungeonCrawler.MsgMonsterIdRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgMonsterIdRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgMonsterIdRequest) == 0x000008, "Wrong alignment on FMsgMonsterIdRequest");
static_assert(sizeof(FMsgMonsterIdRequest) == 0x000018, "Wrong size on FMsgMonsterIdRequest");

// ScriptStruct DungeonCrawler.MsgGameplaytagNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgGameplaytagNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgGameplaytagNotify) == 0x000008, "Wrong alignment on FMsgGameplaytagNotify");
static_assert(sizeof(FMsgGameplaytagNotify) == 0x000018, "Wrong size on FMsgGameplaytagNotify");

// ScriptStruct DungeonCrawler.MsgMusicPlayStart
// 0x0030 (0x0048 - 0x0018)
struct FMsgMusicPlayStart final : public FMsgBase
{
public:
	float                                         Duration;                                          // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JudgementThreshold;                                // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastSpeed;                                         // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2304[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0028(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UPlayMusicData*                         PlayMusicData;                                     // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgMusicPlayStart) == 0x000008, "Wrong alignment on FMsgMusicPlayStart");
static_assert(sizeof(FMsgMusicPlayStart) == 0x000048, "Wrong size on FMsgMusicPlayStart");
static_assert(offsetof(FMsgMusicPlayStart, Duration) == 0x000018, "Member 'FMsgMusicPlayStart::Duration' has a wrong offset!");
static_assert(offsetof(FMsgMusicPlayStart, JudgementThreshold) == 0x00001C, "Member 'FMsgMusicPlayStart::JudgementThreshold' has a wrong offset!");
static_assert(offsetof(FMsgMusicPlayStart, CastSpeed) == 0x000020, "Member 'FMsgMusicPlayStart::CastSpeed' has a wrong offset!");
static_assert(offsetof(FMsgMusicPlayStart, Description) == 0x000028, "Member 'FMsgMusicPlayStart::Description' has a wrong offset!");
static_assert(offsetof(FMsgMusicPlayStart, PlayMusicData) == 0x000040, "Member 'FMsgMusicPlayStart::PlayMusicData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgMusicChannelingEnd
// 0x0000 (0x0018 - 0x0018)
struct FMsgMusicChannelingEnd final : public FMsgBase
{
};
static_assert(alignof(FMsgMusicChannelingEnd) == 0x000008, "Wrong alignment on FMsgMusicChannelingEnd");
static_assert(sizeof(FMsgMusicChannelingEnd) == 0x000018, "Wrong size on FMsgMusicChannelingEnd");

// ScriptStruct DungeonCrawler.MsgMusicJudgeNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgMusicJudgeNotify final : public FMsgBase
{
public:
	EMusicPlaySectionJudgement                    Judge;                                             // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2305[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElapsedTime;                                       // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PastSectionRatio;                                  // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextSectionRatio;                                  // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgMusicJudgeNotify) == 0x000008, "Wrong alignment on FMsgMusicJudgeNotify");
static_assert(sizeof(FMsgMusicJudgeNotify) == 0x000028, "Wrong size on FMsgMusicJudgeNotify");
static_assert(offsetof(FMsgMusicJudgeNotify, Judge) == 0x000018, "Member 'FMsgMusicJudgeNotify::Judge' has a wrong offset!");
static_assert(offsetof(FMsgMusicJudgeNotify, ElapsedTime) == 0x00001C, "Member 'FMsgMusicJudgeNotify::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FMsgMusicJudgeNotify, PastSectionRatio) == 0x000020, "Member 'FMsgMusicJudgeNotify::PastSectionRatio' has a wrong offset!");
static_assert(offsetof(FMsgMusicJudgeNotify, NextSectionRatio) == 0x000024, "Member 'FMsgMusicJudgeNotify::NextSectionRatio' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgMusicDataUpdateNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgMusicDataUpdateNotify final : public FMsgBase
{
public:
	struct FMusicData                             MusicData;                                         // 0x0018(0x0024)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2306[0x4];                                     // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgMusicDataUpdateNotify) == 0x000008, "Wrong alignment on FMsgMusicDataUpdateNotify");
static_assert(sizeof(FMsgMusicDataUpdateNotify) == 0x000040, "Wrong size on FMsgMusicDataUpdateNotify");
static_assert(offsetof(FMsgMusicDataUpdateNotify, MusicData) == 0x000018, "Member 'FMsgMusicDataUpdateNotify::MusicData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPartyDataRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgPartyDataRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgPartyDataRequest) == 0x000008, "Wrong alignment on FMsgPartyDataRequest");
static_assert(sizeof(FMsgPartyDataRequest) == 0x000018, "Wrong size on FMsgPartyDataRequest");

// ScriptStruct DungeonCrawler.MsgPartyDataResponse
// 0x0050 (0x0068 - 0x0018)
struct FMsgPartyDataResponse final : public FMsgBase
{
public:
	TMap<class FString, struct FPartyData>        PartyDataMap;                                      // 0x0018(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPartyDataResponse) == 0x000008, "Wrong alignment on FMsgPartyDataResponse");
static_assert(sizeof(FMsgPartyDataResponse) == 0x000068, "Wrong size on FMsgPartyDataResponse");
static_assert(offsetof(FMsgPartyDataResponse, PartyDataMap) == 0x000018, "Member 'FMsgPartyDataResponse::PartyDataMap' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPartyLinkRequest
// 0x0010 (0x0028 - 0x0018)
struct FMsgPartyLinkRequest final : public FMsgBase
{
public:
	class FString                                 PartyId;                                           // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPartyLinkRequest) == 0x000008, "Wrong alignment on FMsgPartyLinkRequest");
static_assert(sizeof(FMsgPartyLinkRequest) == 0x000028, "Wrong size on FMsgPartyLinkRequest");
static_assert(offsetof(FMsgPartyLinkRequest, PartyId) == 0x000018, "Member 'FMsgPartyLinkRequest::PartyId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPartyLinkResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgPartyLinkResponse final : public FMsgBase
{
public:
	class UPartySession*                          PartySession;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPartyLinkResponse) == 0x000008, "Wrong alignment on FMsgPartyLinkResponse");
static_assert(sizeof(FMsgPartyLinkResponse) == 0x000020, "Wrong size on FMsgPartyLinkResponse");
static_assert(offsetof(FMsgPartyLinkResponse, PartySession) == 0x000018, "Member 'FMsgPartyLinkResponse::PartySession' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPartySessionNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgPartySessionNotify final : public FMsgBase
{
public:
	class UPartySession*                          PartySession;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPartySessionNotify) == 0x000008, "Wrong alignment on FMsgPartySessionNotify");
static_assert(sizeof(FMsgPartySessionNotify) == 0x000020, "Wrong size on FMsgPartySessionNotify");
static_assert(offsetof(FMsgPartySessionNotify, PartySession) == 0x000018, "Member 'FMsgPartySessionNotify::PartySession' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPartyLinkAllPartyDataNotify
// 0x0040 (0x0058 - 0x0018)
struct FMsgPartyLinkAllPartyDataNotify final : public FMsgBase
{
public:
	struct FPartyData                             PartyData;                                         // 0x0018(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPartyData                             OldPartyData;                                      // 0x0038(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPartyLinkAllPartyDataNotify) == 0x000008, "Wrong alignment on FMsgPartyLinkAllPartyDataNotify");
static_assert(sizeof(FMsgPartyLinkAllPartyDataNotify) == 0x000058, "Wrong size on FMsgPartyLinkAllPartyDataNotify");
static_assert(offsetof(FMsgPartyLinkAllPartyDataNotify, PartyData) == 0x000018, "Member 'FMsgPartyLinkAllPartyDataNotify::PartyData' has a wrong offset!");
static_assert(offsetof(FMsgPartyLinkAllPartyDataNotify, OldPartyData) == 0x000038, "Member 'FMsgPartyLinkAllPartyDataNotify::OldPartyData' has a wrong offset!");

// ScriptStruct DungeonCrawler.PerkWidgetData
// 0x0030 (0x0030 - 0x0000)
struct FPerkWidgetData final
{
public:
	class FText                                   PerkName;                                          // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   PerkDescription;                                   // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkWidgetData) == 0x000008, "Wrong alignment on FPerkWidgetData");
static_assert(sizeof(FPerkWidgetData) == 0x000030, "Wrong size on FPerkWidgetData");
static_assert(offsetof(FPerkWidgetData, PerkName) == 0x000000, "Member 'FPerkWidgetData::PerkName' has a wrong offset!");
static_assert(offsetof(FPerkWidgetData, PerkDescription) == 0x000018, "Member 'FPerkWidgetData::PerkDescription' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPlayerLogoutNotify
// 0x0090 (0x00A8 - 0x0018)
struct FMsgPlayerLogoutNotify final : public FMsgBase
{
public:
	struct FAccountDataReplication                AccountDataReplication;                            // 0x0018(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPlayerLogoutNotify) == 0x000008, "Wrong alignment on FMsgPlayerLogoutNotify");
static_assert(sizeof(FMsgPlayerLogoutNotify) == 0x0000A8, "Wrong size on FMsgPlayerLogoutNotify");
static_assert(offsetof(FMsgPlayerLogoutNotify, AccountDataReplication) == 0x000018, "Member 'FMsgPlayerLogoutNotify::AccountDataReplication' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgCharacterResurrectionResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgCharacterResurrectionResponse final : public FMsgBase
{
public:
	class ADCCharacterBase*                       DCCharacterBase;                                   // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgCharacterResurrectionResponse) == 0x000008, "Wrong alignment on FMsgCharacterResurrectionResponse");
static_assert(sizeof(FMsgCharacterResurrectionResponse) == 0x000020, "Wrong size on FMsgCharacterResurrectionResponse");
static_assert(offsetof(FMsgCharacterResurrectionResponse, DCCharacterBase) == 0x000018, "Member 'FMsgCharacterResurrectionResponse::DCCharacterBase' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPlayerRestartNotify
// 0x0090 (0x00A8 - 0x0018)
struct FMsgPlayerRestartNotify final : public FMsgBase
{
public:
	struct FAccountDataReplication                AccountDataReplication;                            // 0x0018(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPlayerRestartNotify) == 0x000008, "Wrong alignment on FMsgPlayerRestartNotify");
static_assert(sizeof(FMsgPlayerRestartNotify) == 0x0000A8, "Wrong size on FMsgPlayerRestartNotify");
static_assert(offsetof(FMsgPlayerRestartNotify, AccountDataReplication) == 0x000018, "Member 'FMsgPlayerRestartNotify::AccountDataReplication' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCPlayMusicDataContainer
// 0x0018 (0x0018 - 0x0000)
struct FDCPlayMusicDataContainer final
{
public:
	class UAkSwitchValue*                         AkSwitch;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MontageSectionName;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SectionPlayTime;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2307[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCPlayMusicDataContainer) == 0x000008, "Wrong alignment on FDCPlayMusicDataContainer");
static_assert(sizeof(FDCPlayMusicDataContainer) == 0x000018, "Wrong size on FDCPlayMusicDataContainer");
static_assert(offsetof(FDCPlayMusicDataContainer, AkSwitch) == 0x000000, "Member 'FDCPlayMusicDataContainer::AkSwitch' has a wrong offset!");
static_assert(offsetof(FDCPlayMusicDataContainer, MontageSectionName) == 0x000008, "Member 'FDCPlayMusicDataContainer::MontageSectionName' has a wrong offset!");
static_assert(offsetof(FDCPlayMusicDataContainer, SectionPlayTime) == 0x000010, "Member 'FDCPlayMusicDataContainer::SectionPlayTime' has a wrong offset!");

// ScriptStruct DungeonCrawler.DungeonSelectParam
// 0x0030 (0x0030 - 0x0000)
struct FDungeonSelectParam final
{
public:
	int32                                         HighRollerFee;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighRollerMinLevel;                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoblinHighRollerFee;                               // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoblinHighRollerMinLevel;                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RuinsHighRollerFee;                                // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RuinsHighRollerMinLevel;                           // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArenaMinLevel;                                     // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2308[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              FeatureLockRemainTime;                             // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocked;                                         // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2309[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDungeonSelectParam) == 0x000008, "Wrong alignment on FDungeonSelectParam");
static_assert(sizeof(FDungeonSelectParam) == 0x000030, "Wrong size on FDungeonSelectParam");
static_assert(offsetof(FDungeonSelectParam, HighRollerFee) == 0x000000, "Member 'FDungeonSelectParam::HighRollerFee' has a wrong offset!");
static_assert(offsetof(FDungeonSelectParam, HighRollerMinLevel) == 0x000004, "Member 'FDungeonSelectParam::HighRollerMinLevel' has a wrong offset!");
static_assert(offsetof(FDungeonSelectParam, GoblinHighRollerFee) == 0x000008, "Member 'FDungeonSelectParam::GoblinHighRollerFee' has a wrong offset!");
static_assert(offsetof(FDungeonSelectParam, GoblinHighRollerMinLevel) == 0x00000C, "Member 'FDungeonSelectParam::GoblinHighRollerMinLevel' has a wrong offset!");
static_assert(offsetof(FDungeonSelectParam, RuinsHighRollerFee) == 0x000010, "Member 'FDungeonSelectParam::RuinsHighRollerFee' has a wrong offset!");
static_assert(offsetof(FDungeonSelectParam, RuinsHighRollerMinLevel) == 0x000014, "Member 'FDungeonSelectParam::RuinsHighRollerMinLevel' has a wrong offset!");
static_assert(offsetof(FDungeonSelectParam, ArenaMinLevel) == 0x000018, "Member 'FDungeonSelectParam::ArenaMinLevel' has a wrong offset!");
static_assert(offsetof(FDungeonSelectParam, FeatureLockRemainTime) == 0x000020, "Member 'FDungeonSelectParam::FeatureLockRemainTime' has a wrong offset!");
static_assert(offsetof(FDungeonSelectParam, bIsLocked) == 0x000028, "Member 'FDungeonSelectParam::bIsLocked' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPropsFloorPortalScrollNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgPropsFloorPortalScrollNotify final : public FMsgBase
{
public:
	bool                                          bActive;                                           // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230A[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgPropsFloorPortalScrollNotify) == 0x000008, "Wrong alignment on FMsgPropsFloorPortalScrollNotify");
static_assert(sizeof(FMsgPropsFloorPortalScrollNotify) == 0x000020, "Wrong size on FMsgPropsFloorPortalScrollNotify");
static_assert(offsetof(FMsgPropsFloorPortalScrollNotify, bActive) == 0x000018, "Member 'FMsgPropsFloorPortalScrollNotify::bActive' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCFloorMatchmakingPartyMember
// 0x0058 (0x0058 - 0x0000)
struct FDCFloorMatchmakingPartyMember final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNickname                              Nickname;                                          // 0x0010(0x0040)(Transient, NativeAccessSpecifierPublic)
	EDCCharacterClass                             CharacterClass;                                    // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDCGender                                     Gender;                                            // 0x0051(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230B[0x2];                                     // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Level;                                             // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCFloorMatchmakingPartyMember) == 0x000008, "Wrong alignment on FDCFloorMatchmakingPartyMember");
static_assert(sizeof(FDCFloorMatchmakingPartyMember) == 0x000058, "Wrong size on FDCFloorMatchmakingPartyMember");
static_assert(offsetof(FDCFloorMatchmakingPartyMember, AccountId) == 0x000000, "Member 'FDCFloorMatchmakingPartyMember::AccountId' has a wrong offset!");
static_assert(offsetof(FDCFloorMatchmakingPartyMember, Nickname) == 0x000010, "Member 'FDCFloorMatchmakingPartyMember::Nickname' has a wrong offset!");
static_assert(offsetof(FDCFloorMatchmakingPartyMember, CharacterClass) == 0x000050, "Member 'FDCFloorMatchmakingPartyMember::CharacterClass' has a wrong offset!");
static_assert(offsetof(FDCFloorMatchmakingPartyMember, Gender) == 0x000051, "Member 'FDCFloorMatchmakingPartyMember::Gender' has a wrong offset!");
static_assert(offsetof(FDCFloorMatchmakingPartyMember, Level) == 0x000054, "Member 'FDCFloorMatchmakingPartyMember::Level' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCFloorMatchmakingUserResult
// 0x0030 (0x0030 - 0x0000)
struct FDCFloorMatchmakingUserResult final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDCGameLiftSessionId                   SessionId;                                         // 0x0010(0x0010)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Address;                                           // 0x0020(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDCFloorMatchmakingUserResult) == 0x000008, "Wrong alignment on FDCFloorMatchmakingUserResult");
static_assert(sizeof(FDCFloorMatchmakingUserResult) == 0x000030, "Wrong size on FDCFloorMatchmakingUserResult");
static_assert(offsetof(FDCFloorMatchmakingUserResult, AccountId) == 0x000000, "Member 'FDCFloorMatchmakingUserResult::AccountId' has a wrong offset!");
static_assert(offsetof(FDCFloorMatchmakingUserResult, SessionId) == 0x000010, "Member 'FDCFloorMatchmakingUserResult::SessionId' has a wrong offset!");
static_assert(offsetof(FDCFloorMatchmakingUserResult, Address) == 0x000020, "Member 'FDCFloorMatchmakingUserResult::Address' has a wrong offset!");

// ScriptStruct DungeonCrawler.ServerMsgReConnectGameInfoRequest
// 0x0108 (0x0120 - 0x0018)
struct FServerMsgReConnectGameInfoRequest final : public FMsgBase
{
public:
	struct FAccountData                           AccountData;                                       // 0x0018(0x0108)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerMsgReConnectGameInfoRequest) == 0x000008, "Wrong alignment on FServerMsgReConnectGameInfoRequest");
static_assert(sizeof(FServerMsgReConnectGameInfoRequest) == 0x000120, "Wrong size on FServerMsgReConnectGameInfoRequest");
static_assert(offsetof(FServerMsgReConnectGameInfoRequest, AccountData) == 0x000018, "Member 'FServerMsgReConnectGameInfoRequest::AccountData' has a wrong offset!");

// ScriptStruct DungeonCrawler.ServerMsgReConnectGameInfoResponse
// 0x0110 (0x0128 - 0x0018)
struct FServerMsgReConnectGameInfoResponse final : public FMsgBase
{
public:
	struct FAccountData                           AccountData;                                       // 0x0018(0x0108)(NativeAccessSpecifierPublic)
	bool                                          IsSuccess;                                         // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230C[0x7];                                     // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FServerMsgReConnectGameInfoResponse) == 0x000008, "Wrong alignment on FServerMsgReConnectGameInfoResponse");
static_assert(sizeof(FServerMsgReConnectGameInfoResponse) == 0x000128, "Wrong size on FServerMsgReConnectGameInfoResponse");
static_assert(offsetof(FServerMsgReConnectGameInfoResponse, AccountData) == 0x000018, "Member 'FServerMsgReConnectGameInfoResponse::AccountData' has a wrong offset!");
static_assert(offsetof(FServerMsgReConnectGameInfoResponse, IsSuccess) == 0x000120, "Member 'FServerMsgReConnectGameInfoResponse::IsSuccess' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSkillIdArrayNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgSkillIdArrayNotify final : public FMsgBase
{
public:
	TArray<struct FPrimaryAssetId>                SkillIdArray;                                      // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSkillIdArrayNotify) == 0x000008, "Wrong alignment on FMsgSkillIdArrayNotify");
static_assert(sizeof(FMsgSkillIdArrayNotify) == 0x000028, "Wrong size on FMsgSkillIdArrayNotify");
static_assert(offsetof(FMsgSkillIdArrayNotify, SkillIdArray) == 0x000018, "Member 'FMsgSkillIdArrayNotify::SkillIdArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSkillDataUpdateNotify
// 0x0038 (0x0050 - 0x0018)
struct FMsgSkillDataUpdateNotify final : public FMsgBase
{
public:
	ESkillIndex                                   SlotIndex;                                         // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230D[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkillData                             SkillData;                                         // 0x001C(0x0030)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_230E[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgSkillDataUpdateNotify) == 0x000008, "Wrong alignment on FMsgSkillDataUpdateNotify");
static_assert(sizeof(FMsgSkillDataUpdateNotify) == 0x000050, "Wrong size on FMsgSkillDataUpdateNotify");
static_assert(offsetof(FMsgSkillDataUpdateNotify, SlotIndex) == 0x000018, "Member 'FMsgSkillDataUpdateNotify::SlotIndex' has a wrong offset!");
static_assert(offsetof(FMsgSkillDataUpdateNotify, SkillData) == 0x00001C, "Member 'FMsgSkillDataUpdateNotify::SkillData' has a wrong offset!");

// ScriptStruct DungeonCrawler.SkillCooldownData
// 0x0008 (0x0008 - 0x0000)
struct FSkillCooldownData final
{
public:
	float                                         RemainDuration;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillCooldownData) == 0x000004, "Wrong alignment on FSkillCooldownData");
static_assert(sizeof(FSkillCooldownData) == 0x000008, "Wrong size on FSkillCooldownData");
static_assert(offsetof(FSkillCooldownData, RemainDuration) == 0x000000, "Member 'FSkillCooldownData::RemainDuration' has a wrong offset!");
static_assert(offsetof(FSkillCooldownData, MaxDuration) == 0x000004, "Member 'FSkillCooldownData::MaxDuration' has a wrong offset!");

// ScriptStruct DungeonCrawler.SkillWidgetData
// 0x0030 (0x0030 - 0x0000)
struct FSkillWidgetData final
{
public:
	class FText                                   SkillName;                                         // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   SkillDescription;                                  // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillWidgetData) == 0x000008, "Wrong alignment on FSkillWidgetData");
static_assert(sizeof(FSkillWidgetData) == 0x000030, "Wrong size on FSkillWidgetData");
static_assert(offsetof(FSkillWidgetData, SkillName) == 0x000000, "Member 'FSkillWidgetData::SkillName' has a wrong offset!");
static_assert(offsetof(FSkillWidgetData, SkillDescription) == 0x000018, "Member 'FSkillWidgetData::SkillDescription' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSoundEvent
// 0x0010 (0x0028 - 0x0018)
struct FMsgSoundEvent final : public FMsgBase
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0018(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DefaultAkEvent;                                    // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSoundEvent) == 0x000008, "Wrong alignment on FMsgSoundEvent");
static_assert(sizeof(FMsgSoundEvent) == 0x000028, "Wrong size on FMsgSoundEvent");
static_assert(offsetof(FMsgSoundEvent, EventTag) == 0x000018, "Member 'FMsgSoundEvent::EventTag' has a wrong offset!");
static_assert(offsetof(FMsgSoundEvent, DefaultAkEvent) == 0x000020, "Member 'FMsgSoundEvent::DefaultAkEvent' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSoundVolumeEnter
// 0x0040 (0x0058 - 0x0018)
struct FMsgSoundVolumeEnter final : public FMsgBase
{
public:
	struct FAkAudioVolumeInfo                     AkVolumeInfo;                                      // 0x0018(0x0040)(BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSoundVolumeEnter) == 0x000008, "Wrong alignment on FMsgSoundVolumeEnter");
static_assert(sizeof(FMsgSoundVolumeEnter) == 0x000058, "Wrong size on FMsgSoundVolumeEnter");
static_assert(offsetof(FMsgSoundVolumeEnter, AkVolumeInfo) == 0x000018, "Member 'FMsgSoundVolumeEnter::AkVolumeInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.DCItemSoundInfo
// 0x0178 (0x0178 - 0x0000)
struct FDCItemSoundInfo final
{
public:
	struct FDCItemInfo                            ItemInfo;                                          // 0x0000(0x0168)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SoundTag;                                          // 0x0168(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldSound;                                       // 0x0170(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230F[0x7];                                     // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDCItemSoundInfo) == 0x000008, "Wrong alignment on FDCItemSoundInfo");
static_assert(sizeof(FDCItemSoundInfo) == 0x000178, "Wrong size on FDCItemSoundInfo");
static_assert(offsetof(FDCItemSoundInfo, ItemInfo) == 0x000000, "Member 'FDCItemSoundInfo::ItemInfo' has a wrong offset!");
static_assert(offsetof(FDCItemSoundInfo, SoundTag) == 0x000168, "Member 'FDCItemSoundInfo::SoundTag' has a wrong offset!");
static_assert(offsetof(FDCItemSoundInfo, bWorldSound) == 0x000170, "Member 'FDCItemSoundInfo::bWorldSound' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSpellSetCurrentSpellData
// 0x0040 (0x0058 - 0x0018)
struct FMsgSpellSetCurrentSpellData final : public FMsgBase
{
public:
	struct FSpellData                             SpellData;                                         // 0x0018(0x0040)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSpellSetCurrentSpellData) == 0x000008, "Wrong alignment on FMsgSpellSetCurrentSpellData");
static_assert(sizeof(FMsgSpellSetCurrentSpellData) == 0x000058, "Wrong size on FMsgSpellSetCurrentSpellData");
static_assert(offsetof(FMsgSpellSetCurrentSpellData, SpellData) == 0x000018, "Member 'FMsgSpellSetCurrentSpellData::SpellData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSpellRecharge
// 0x0008 (0x0020 - 0x0018)
struct FMsgSpellRecharge final : public FMsgBase
{
public:
	int32                                         RechargeAmount;                                    // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2310[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgSpellRecharge) == 0x000008, "Wrong alignment on FMsgSpellRecharge");
static_assert(sizeof(FMsgSpellRecharge) == 0x000020, "Wrong size on FMsgSpellRecharge");
static_assert(offsetof(FMsgSpellRecharge, RechargeAmount) == 0x000018, "Member 'FMsgSpellRecharge::RechargeAmount' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSpellDataUpdateNotify
// 0x0040 (0x0058 - 0x0018)
struct FMsgSpellDataUpdateNotify final : public FMsgBase
{
public:
	struct FSpellData                             SpellData;                                         // 0x0018(0x0040)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSpellDataUpdateNotify) == 0x000008, "Wrong alignment on FMsgSpellDataUpdateNotify");
static_assert(sizeof(FMsgSpellDataUpdateNotify) == 0x000058, "Wrong size on FMsgSpellDataUpdateNotify");
static_assert(offsetof(FMsgSpellDataUpdateNotify, SpellData) == 0x000018, "Member 'FMsgSpellDataUpdateNotify::SpellData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSpellCastEnd
// 0x0000 (0x0018 - 0x0018)
struct FMsgSpellCastEnd final : public FMsgBase
{
};
static_assert(alignof(FMsgSpellCastEnd) == 0x000008, "Wrong alignment on FMsgSpellCastEnd");
static_assert(sizeof(FMsgSpellCastEnd) == 0x000018, "Wrong size on FMsgSpellCastEnd");

// ScriptStruct DungeonCrawler.MsgSpellChannelingStart
// 0x0020 (0x0038 - 0x0018)
struct FMsgSpellChannelingStart final : public FMsgBase
{
public:
	float                                         Duration;                                          // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2311[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0020(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgSpellChannelingStart) == 0x000008, "Wrong alignment on FMsgSpellChannelingStart");
static_assert(sizeof(FMsgSpellChannelingStart) == 0x000038, "Wrong size on FMsgSpellChannelingStart");
static_assert(offsetof(FMsgSpellChannelingStart, Duration) == 0x000018, "Member 'FMsgSpellChannelingStart::Duration' has a wrong offset!");
static_assert(offsetof(FMsgSpellChannelingStart, Description) == 0x000020, "Member 'FMsgSpellChannelingStart::Description' has a wrong offset!");

// ScriptStruct DungeonCrawler.TimerWidgetData
// 0x0010 (0x0010 - 0x0000)
struct FTimerWidgetData final
{
public:
	int32                                         LeftHour;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftMinute;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftSecond;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimerWidgetData) == 0x000004, "Wrong alignment on FTimerWidgetData");
static_assert(sizeof(FTimerWidgetData) == 0x000010, "Wrong size on FTimerWidgetData");
static_assert(offsetof(FTimerWidgetData, LeftHour) == 0x000000, "Member 'FTimerWidgetData::LeftHour' has a wrong offset!");
static_assert(offsetof(FTimerWidgetData, LeftMinute) == 0x000004, "Member 'FTimerWidgetData::LeftMinute' has a wrong offset!");
static_assert(offsetof(FTimerWidgetData, LeftSecond) == 0x000008, "Member 'FTimerWidgetData::LeftSecond' has a wrong offset!");
static_assert(offsetof(FTimerWidgetData, Progress) == 0x00000C, "Member 'FTimerWidgetData::Progress' has a wrong offset!");

// ScriptStruct DungeonCrawler.VoipAkComponentData
// 0x0004 (0x0004 - 0x0000)
struct FVoipAkComponentData final
{
public:
	uint8                                         Pad_2312[0x4];                                     // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVoipAkComponentData) == 0x000001, "Wrong alignment on FVoipAkComponentData");
static_assert(sizeof(FVoipAkComponentData) == 0x000004, "Wrong size on FVoipAkComponentData");

// ScriptStruct DungeonCrawler.VoipUserWidgetData
// 0x0040 (0x0040 - 0x0000)
struct FVoipUserWidgetData final
{
public:
	struct FDCAccountId                           AccountId;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVoipUserData                          VoipUserData;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVoipPartyData                         VoipPartyData;                                     // 0x0018(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bVoipForceParty;                                   // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2313[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVoipUserWidgetData) == 0x000008, "Wrong alignment on FVoipUserWidgetData");
static_assert(sizeof(FVoipUserWidgetData) == 0x000040, "Wrong size on FVoipUserWidgetData");
static_assert(offsetof(FVoipUserWidgetData, AccountId) == 0x000000, "Member 'FVoipUserWidgetData::AccountId' has a wrong offset!");
static_assert(offsetof(FVoipUserWidgetData, VoipUserData) == 0x000010, "Member 'FVoipUserWidgetData::VoipUserData' has a wrong offset!");
static_assert(offsetof(FVoipUserWidgetData, VoipPartyData) == 0x000018, "Member 'FVoipUserWidgetData::VoipPartyData' has a wrong offset!");
static_assert(offsetof(FVoipUserWidgetData, bVoipForceParty) == 0x000038, "Member 'FVoipUserWidgetData::bVoipForceParty' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetCharacterSelectGroupToggleRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetCharacterSelectGroupToggleRequest final : public FMsgBase
{
public:
	EWidgetCharacterSelectGroupType               WidgetCharacterSelectGroupType;                    // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2314[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetCharacterSelectGroupToggleRequest) == 0x000008, "Wrong alignment on FMsgWidgetCharacterSelectGroupToggleRequest");
static_assert(sizeof(FMsgWidgetCharacterSelectGroupToggleRequest) == 0x000020, "Wrong size on FMsgWidgetCharacterSelectGroupToggleRequest");
static_assert(offsetof(FMsgWidgetCharacterSelectGroupToggleRequest, WidgetCharacterSelectGroupType) == 0x000018, "Member 'FMsgWidgetCharacterSelectGroupToggleRequest::WidgetCharacterSelectGroupType' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetDeleteCharacterNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetDeleteCharacterNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2315[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetDeleteCharacterNotify) == 0x000008, "Wrong alignment on FMsgWidgetDeleteCharacterNotify");
static_assert(sizeof(FMsgWidgetDeleteCharacterNotify) == 0x000020, "Wrong size on FMsgWidgetDeleteCharacterNotify");

// ScriptStruct DungeonCrawler.MsgWidgetRequestCharacterListNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetRequestCharacterListNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2316[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetRequestCharacterListNotify) == 0x000008, "Wrong alignment on FMsgWidgetRequestCharacterListNotify");
static_assert(sizeof(FMsgWidgetRequestCharacterListNotify) == 0x000020, "Wrong size on FMsgWidgetRequestCharacterListNotify");

// ScriptStruct DungeonCrawler.MsgWidgetCreateCharacterErrorMessageNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetCreateCharacterErrorMessageNotify final : public FMsgBase
{
public:
	class FText                                   CreateCharacterErrorMessage;                       // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetCreateCharacterErrorMessageNotify) == 0x000008, "Wrong alignment on FMsgWidgetCreateCharacterErrorMessageNotify");
static_assert(sizeof(FMsgWidgetCreateCharacterErrorMessageNotify) == 0x000030, "Wrong size on FMsgWidgetCreateCharacterErrorMessageNotify");
static_assert(offsetof(FMsgWidgetCreateCharacterErrorMessageNotify, CreateCharacterErrorMessage) == 0x000018, "Member 'FMsgWidgetCreateCharacterErrorMessageNotify::CreateCharacterErrorMessage' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetGameGroupHideUIbyNonCoexistWidgetRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetGameGroupHideUIbyNonCoexistWidgetRequest final : public FMsgBase
{
public:
	EWidgetGameGroupType                          WidgetGameGroupType;                               // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2317[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetGameGroupHideUIbyNonCoexistWidgetRequest) == 0x000008, "Wrong alignment on FMsgWidgetGameGroupHideUIbyNonCoexistWidgetRequest");
static_assert(sizeof(FMsgWidgetGameGroupHideUIbyNonCoexistWidgetRequest) == 0x000020, "Wrong size on FMsgWidgetGameGroupHideUIbyNonCoexistWidgetRequest");
static_assert(offsetof(FMsgWidgetGameGroupHideUIbyNonCoexistWidgetRequest, WidgetGameGroupType) == 0x000018, "Member 'FMsgWidgetGameGroupHideUIbyNonCoexistWidgetRequest::WidgetGameGroupType' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetGameGroupVisibilityRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetGameGroupVisibilityRequest final : public FMsgBase
{
public:
	EWidgetGameGroupType                          WidgetGameGroupType;                               // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              NewVisibility;                                     // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2318[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetGameGroupVisibilityRequest) == 0x000008, "Wrong alignment on FMsgWidgetGameGroupVisibilityRequest");
static_assert(sizeof(FMsgWidgetGameGroupVisibilityRequest) == 0x000020, "Wrong size on FMsgWidgetGameGroupVisibilityRequest");
static_assert(offsetof(FMsgWidgetGameGroupVisibilityRequest, WidgetGameGroupType) == 0x000018, "Member 'FMsgWidgetGameGroupVisibilityRequest::WidgetGameGroupType' has a wrong offset!");
static_assert(offsetof(FMsgWidgetGameGroupVisibilityRequest, NewVisibility) == 0x000019, "Member 'FMsgWidgetGameGroupVisibilityRequest::NewVisibility' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetHitDirectionInfoNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetHitDirectionInfoNotify final : public FMsgBase
{
public:
	struct FVector                                HitDirection;                                      // 0x0018(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetHitDirectionInfoNotify) == 0x000008, "Wrong alignment on FMsgWidgetHitDirectionInfoNotify");
static_assert(sizeof(FMsgWidgetHitDirectionInfoNotify) == 0x000030, "Wrong size on FMsgWidgetHitDirectionInfoNotify");
static_assert(offsetof(FMsgWidgetHitDirectionInfoNotify, HitDirection) == 0x000018, "Member 'FMsgWidgetHitDirectionInfoNotify::HitDirection' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetHitDirectionRecoveryHealingNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetHitDirectionRecoveryHealingNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetHitDirectionRecoveryHealingNotify) == 0x000008, "Wrong alignment on FMsgWidgetHitDirectionRecoveryHealingNotify");
static_assert(sizeof(FMsgWidgetHitDirectionRecoveryHealingNotify) == 0x000018, "Wrong size on FMsgWidgetHitDirectionRecoveryHealingNotify");

// ScriptStruct DungeonCrawler.MsgWidgetChangeCrossHairEachWeaponNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgWidgetChangeCrossHairEachWeaponNotify final : public FMsgBase
{
public:
	TArray<struct FGameplayTag>                   WeaponTypeTags;                                    // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemUtilityTag;                                    // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemSlotTypeTag;                                   // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAttackEnable;                                    // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2319[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetChangeCrossHairEachWeaponNotify) == 0x000008, "Wrong alignment on FMsgWidgetChangeCrossHairEachWeaponNotify");
static_assert(sizeof(FMsgWidgetChangeCrossHairEachWeaponNotify) == 0x000040, "Wrong size on FMsgWidgetChangeCrossHairEachWeaponNotify");
static_assert(offsetof(FMsgWidgetChangeCrossHairEachWeaponNotify, WeaponTypeTags) == 0x000018, "Member 'FMsgWidgetChangeCrossHairEachWeaponNotify::WeaponTypeTags' has a wrong offset!");
static_assert(offsetof(FMsgWidgetChangeCrossHairEachWeaponNotify, ItemUtilityTag) == 0x000028, "Member 'FMsgWidgetChangeCrossHairEachWeaponNotify::ItemUtilityTag' has a wrong offset!");
static_assert(offsetof(FMsgWidgetChangeCrossHairEachWeaponNotify, ItemSlotTypeTag) == 0x000030, "Member 'FMsgWidgetChangeCrossHairEachWeaponNotify::ItemSlotTypeTag' has a wrong offset!");
static_assert(offsetof(FMsgWidgetChangeCrossHairEachWeaponNotify, IsAttackEnable) == 0x000038, "Member 'FMsgWidgetChangeCrossHairEachWeaponNotify::IsAttackEnable' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetChangeCrossHairInfoNotify
// 0x0020 (0x0038 - 0x0018)
struct FMsgWidgetChangeCrossHairInfoNotify final : public FMsgBase
{
public:
	TArray<struct FGameplayTag>                   WeaponTypeTags;                                    // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ChangeAngle;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnPinPoint;                                        // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231A[0x3];                                     // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateTime;                                        // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231B[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetChangeCrossHairInfoNotify) == 0x000008, "Wrong alignment on FMsgWidgetChangeCrossHairInfoNotify");
static_assert(sizeof(FMsgWidgetChangeCrossHairInfoNotify) == 0x000038, "Wrong size on FMsgWidgetChangeCrossHairInfoNotify");
static_assert(offsetof(FMsgWidgetChangeCrossHairInfoNotify, WeaponTypeTags) == 0x000018, "Member 'FMsgWidgetChangeCrossHairInfoNotify::WeaponTypeTags' has a wrong offset!");
static_assert(offsetof(FMsgWidgetChangeCrossHairInfoNotify, ChangeAngle) == 0x000028, "Member 'FMsgWidgetChangeCrossHairInfoNotify::ChangeAngle' has a wrong offset!");
static_assert(offsetof(FMsgWidgetChangeCrossHairInfoNotify, OnPinPoint) == 0x00002C, "Member 'FMsgWidgetChangeCrossHairInfoNotify::OnPinPoint' has a wrong offset!");
static_assert(offsetof(FMsgWidgetChangeCrossHairInfoNotify, RotateTime) == 0x000030, "Member 'FMsgWidgetChangeCrossHairInfoNotify::RotateTime' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetPlayPullingCrossHairNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetPlayPullingCrossHairNotify final : public FMsgBase
{
public:
	uint8                                         Pad_231C[0x8];                                     // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetPlayPullingCrossHairNotify) == 0x000008, "Wrong alignment on FMsgWidgetPlayPullingCrossHairNotify");
static_assert(sizeof(FMsgWidgetPlayPullingCrossHairNotify) == 0x000020, "Wrong size on FMsgWidgetPlayPullingCrossHairNotify");

// ScriptStruct DungeonCrawler.MsgWidgetSkillCooldownStartWidgetNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetSkillCooldownStartWidgetNotify final : public FMsgBase
{
public:
	struct FGameplayTag                           SkillTag;                                          // 0x0018(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainDuration;                                    // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetSkillCooldownStartWidgetNotify) == 0x000008, "Wrong alignment on FMsgWidgetSkillCooldownStartWidgetNotify");
static_assert(sizeof(FMsgWidgetSkillCooldownStartWidgetNotify) == 0x000028, "Wrong size on FMsgWidgetSkillCooldownStartWidgetNotify");
static_assert(offsetof(FMsgWidgetSkillCooldownStartWidgetNotify, SkillTag) == 0x000018, "Member 'FMsgWidgetSkillCooldownStartWidgetNotify::SkillTag' has a wrong offset!");
static_assert(offsetof(FMsgWidgetSkillCooldownStartWidgetNotify, RemainDuration) == 0x000020, "Member 'FMsgWidgetSkillCooldownStartWidgetNotify::RemainDuration' has a wrong offset!");
static_assert(offsetof(FMsgWidgetSkillCooldownStartWidgetNotify, MaxDuration) == 0x000024, "Member 'FMsgWidgetSkillCooldownStartWidgetNotify::MaxDuration' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetSkillCooldownEndWidgetNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetSkillCooldownEndWidgetNotify final : public FMsgBase
{
public:
	struct FGameplayTag                           SkillSlotKeyTag;                                   // 0x0018(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkillTag;                                          // 0x0020(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetSkillCooldownEndWidgetNotify) == 0x000008, "Wrong alignment on FMsgWidgetSkillCooldownEndWidgetNotify");
static_assert(sizeof(FMsgWidgetSkillCooldownEndWidgetNotify) == 0x000028, "Wrong size on FMsgWidgetSkillCooldownEndWidgetNotify");
static_assert(offsetof(FMsgWidgetSkillCooldownEndWidgetNotify, SkillSlotKeyTag) == 0x000018, "Member 'FMsgWidgetSkillCooldownEndWidgetNotify::SkillSlotKeyTag' has a wrong offset!");
static_assert(offsetof(FMsgWidgetSkillCooldownEndWidgetNotify, SkillTag) == 0x000020, "Member 'FMsgWidgetSkillCooldownEndWidgetNotify::SkillTag' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetSkillCooldownClearWidgetNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetSkillCooldownClearWidgetNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetSkillCooldownClearWidgetNotify) == 0x000008, "Wrong alignment on FMsgWidgetSkillCooldownClearWidgetNotify");
static_assert(sizeof(FMsgWidgetSkillCooldownClearWidgetNotify) == 0x000018, "Wrong size on FMsgWidgetSkillCooldownClearWidgetNotify");

// ScriptStruct DungeonCrawler.MsgWidgetShowVideoDisplayApplyAlarmWndNotity
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetShowVideoDisplayApplyAlarmWndNotity final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetShowVideoDisplayApplyAlarmWndNotity) == 0x000008, "Wrong alignment on FMsgWidgetShowVideoDisplayApplyAlarmWndNotity");
static_assert(sizeof(FMsgWidgetShowVideoDisplayApplyAlarmWndNotity) == 0x000018, "Wrong size on FMsgWidgetShowVideoDisplayApplyAlarmWndNotity");

// ScriptStruct DungeonCrawler.MsgWidgetOptionVideoDisplayApplyedNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetOptionVideoDisplayApplyedNotify final : public FMsgBase
{
public:
	bool                                          IsApplyed;                                         // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231D[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetOptionVideoDisplayApplyedNotify) == 0x000008, "Wrong alignment on FMsgWidgetOptionVideoDisplayApplyedNotify");
static_assert(sizeof(FMsgWidgetOptionVideoDisplayApplyedNotify) == 0x000020, "Wrong size on FMsgWidgetOptionVideoDisplayApplyedNotify");
static_assert(offsetof(FMsgWidgetOptionVideoDisplayApplyedNotify, IsApplyed) == 0x000018, "Member 'FMsgWidgetOptionVideoDisplayApplyedNotify::IsApplyed' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetLobbyGroupHideUIbyNonCoexistWidgetRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetRequest final : public FMsgBase
{
public:
	EWidgetLobbyGroupType                         WidgetLobbyGroupType;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231E[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LobbyGroupWidgetPriority;                          // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetRequest) == 0x000008, "Wrong alignment on FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetRequest");
static_assert(sizeof(FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetRequest) == 0x000020, "Wrong size on FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetRequest");
static_assert(offsetof(FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetRequest, WidgetLobbyGroupType) == 0x000018, "Member 'FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetRequest::WidgetLobbyGroupType' has a wrong offset!");
static_assert(offsetof(FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetRequest, LobbyGroupWidgetPriority) == 0x00001C, "Member 'FMsgWidgetLobbyGroupHideUIbyNonCoexistWidgetRequest::LobbyGroupWidgetPriority' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetLobbyGroupToggleRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetLobbyGroupToggleRequest final : public FMsgBase
{
public:
	EWidgetLobbyGroupType                         WidgetLobbyGroupType;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231F[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetLobbyGroupToggleRequest) == 0x000008, "Wrong alignment on FMsgWidgetLobbyGroupToggleRequest");
static_assert(sizeof(FMsgWidgetLobbyGroupToggleRequest) == 0x000020, "Wrong size on FMsgWidgetLobbyGroupToggleRequest");
static_assert(offsetof(FMsgWidgetLobbyGroupToggleRequest, WidgetLobbyGroupType) == 0x000018, "Member 'FMsgWidgetLobbyGroupToggleRequest::WidgetLobbyGroupType' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetLobbyGroupVisibilityRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetLobbyGroupVisibilityRequest final : public FMsgBase
{
public:
	EWidgetLobbyGroupType                         WidgetLobbyGroupType;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              NewVisibility;                                     // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForce;                                          // 0x001A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2320[0x5];                                     // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetLobbyGroupVisibilityRequest) == 0x000008, "Wrong alignment on FMsgWidgetLobbyGroupVisibilityRequest");
static_assert(sizeof(FMsgWidgetLobbyGroupVisibilityRequest) == 0x000020, "Wrong size on FMsgWidgetLobbyGroupVisibilityRequest");
static_assert(offsetof(FMsgWidgetLobbyGroupVisibilityRequest, WidgetLobbyGroupType) == 0x000018, "Member 'FMsgWidgetLobbyGroupVisibilityRequest::WidgetLobbyGroupType' has a wrong offset!");
static_assert(offsetof(FMsgWidgetLobbyGroupVisibilityRequest, NewVisibility) == 0x000019, "Member 'FMsgWidgetLobbyGroupVisibilityRequest::NewVisibility' has a wrong offset!");
static_assert(offsetof(FMsgWidgetLobbyGroupVisibilityRequest, bIsForce) == 0x00001A, "Member 'FMsgWidgetLobbyGroupVisibilityRequest::bIsForce' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetLobbyGroupToggleNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetLobbyGroupToggleNotify final : public FMsgBase
{
public:
	EWidgetLobbyGroupType                         WidgetLobbyGroupType;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              NewVisibility;                                     // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2321[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetLobbyGroupToggleNotify) == 0x000008, "Wrong alignment on FMsgWidgetLobbyGroupToggleNotify");
static_assert(sizeof(FMsgWidgetLobbyGroupToggleNotify) == 0x000020, "Wrong size on FMsgWidgetLobbyGroupToggleNotify");
static_assert(offsetof(FMsgWidgetLobbyGroupToggleNotify, WidgetLobbyGroupType) == 0x000018, "Member 'FMsgWidgetLobbyGroupToggleNotify::WidgetLobbyGroupType' has a wrong offset!");
static_assert(offsetof(FMsgWidgetLobbyGroupToggleNotify, NewVisibility) == 0x000019, "Member 'FMsgWidgetLobbyGroupToggleNotify::NewVisibility' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetLobbyGroupHideResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetLobbyGroupHideResponse final : public FMsgBase
{
public:
	EWidgetLobbyGroupType                         WidgetLobbyGroupType;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanHide;                                          // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2322[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetLobbyGroupHideResponse) == 0x000008, "Wrong alignment on FMsgWidgetLobbyGroupHideResponse");
static_assert(sizeof(FMsgWidgetLobbyGroupHideResponse) == 0x000020, "Wrong size on FMsgWidgetLobbyGroupHideResponse");
static_assert(offsetof(FMsgWidgetLobbyGroupHideResponse, WidgetLobbyGroupType) == 0x000018, "Member 'FMsgWidgetLobbyGroupHideResponse::WidgetLobbyGroupType' has a wrong offset!");
static_assert(offsetof(FMsgWidgetLobbyGroupHideResponse, bCanHide) == 0x000019, "Member 'FMsgWidgetLobbyGroupHideResponse::bCanHide' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetLobbyTabSelectRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetLobbyTabSelectRequest final : public FMsgBase
{
public:
	EDCWidgetLobbyTabType                         LobbyTabType;                                      // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2323[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetLobbyTabSelectRequest) == 0x000008, "Wrong alignment on FMsgWidgetLobbyTabSelectRequest");
static_assert(sizeof(FMsgWidgetLobbyTabSelectRequest) == 0x000020, "Wrong size on FMsgWidgetLobbyTabSelectRequest");
static_assert(offsetof(FMsgWidgetLobbyTabSelectRequest, LobbyTabType) == 0x000018, "Member 'FMsgWidgetLobbyTabSelectRequest::LobbyTabType' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassGroupHideUIbyNonCoexistWidgetRequest
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetClassGroupHideUIbyNonCoexistWidgetRequest final : public FMsgBase
{
public:
	EWidgetClassGroupType                         WidgetClassGroupType;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2324[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassGroupHideUIbyNonCoexistWidgetRequest) == 0x000008, "Wrong alignment on FMsgWidgetClassGroupHideUIbyNonCoexistWidgetRequest");
static_assert(sizeof(FMsgWidgetClassGroupHideUIbyNonCoexistWidgetRequest) == 0x000020, "Wrong size on FMsgWidgetClassGroupHideUIbyNonCoexistWidgetRequest");
static_assert(offsetof(FMsgWidgetClassGroupHideUIbyNonCoexistWidgetRequest, WidgetClassGroupType) == 0x000018, "Member 'FMsgWidgetClassGroupHideUIbyNonCoexistWidgetRequest::WidgetClassGroupType' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassGroupToggleNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetClassGroupToggleNotify final : public FMsgBase
{
public:
	EWidgetClassGroupType                         WidgetClassGroupType;                              // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              NewVisibility;                                     // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2325[0x6];                                     // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassGroupToggleNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassGroupToggleNotify");
static_assert(sizeof(FMsgWidgetClassGroupToggleNotify) == 0x000020, "Wrong size on FMsgWidgetClassGroupToggleNotify");
static_assert(offsetof(FMsgWidgetClassGroupToggleNotify, WidgetClassGroupType) == 0x000018, "Member 'FMsgWidgetClassGroupToggleNotify::WidgetClassGroupType' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassGroupToggleNotify, NewVisibility) == 0x000019, "Member 'FMsgWidgetClassGroupToggleNotify::NewVisibility' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetPlayerInventoryTabActiveNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetPlayerInventoryTabActiveNotify final : public FMsgBase
{
public:
	EWidgetPlayerInventoryTabType                 WidgetPlayerInventoryTabType;                      // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2326[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetPlayerInventoryTabActiveNotify) == 0x000008, "Wrong alignment on FMsgWidgetPlayerInventoryTabActiveNotify");
static_assert(sizeof(FMsgWidgetPlayerInventoryTabActiveNotify) == 0x000020, "Wrong size on FMsgWidgetPlayerInventoryTabActiveNotify");
static_assert(offsetof(FMsgWidgetPlayerInventoryTabActiveNotify, WidgetPlayerInventoryTabType) == 0x000018, "Member 'FMsgWidgetPlayerInventoryTabActiveNotify::WidgetPlayerInventoryTabType' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetLeaderboardBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetLeaderboardBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetLeaderboardBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetLeaderboardBeginNotify");
static_assert(sizeof(FMsgWidgetLeaderboardBeginNotify) == 0x000018, "Wrong size on FMsgWidgetLeaderboardBeginNotify");

// ScriptStruct DungeonCrawler.MsgWidgetLobbyPopupSWidgetNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetLobbyPopupSWidgetNotify final : public FMsgBase
{
public:
	class FText                                   DescText;                                          // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetLobbyPopupSWidgetNotify) == 0x000008, "Wrong alignment on FMsgWidgetLobbyPopupSWidgetNotify");
static_assert(sizeof(FMsgWidgetLobbyPopupSWidgetNotify) == 0x000030, "Wrong size on FMsgWidgetLobbyPopupSWidgetNotify");
static_assert(offsetof(FMsgWidgetLobbyPopupSWidgetNotify, DescText) == 0x000018, "Member 'FMsgWidgetLobbyPopupSWidgetNotify::DescText' has a wrong offset!");

// ScriptStruct DungeonCrawler.WidgetPartyCharacterVisibleBody
// 0x0002 (0x0002 - 0x0000)
struct FWidgetPartyCharacterVisibleBody final
{
public:
	EWidgetPartyUserLocate                        WidgetPartyUserLocate;                             // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Visible;                                           // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWidgetPartyCharacterVisibleBody) == 0x000001, "Wrong alignment on FWidgetPartyCharacterVisibleBody");
static_assert(sizeof(FWidgetPartyCharacterVisibleBody) == 0x000002, "Wrong size on FWidgetPartyCharacterVisibleBody");
static_assert(offsetof(FWidgetPartyCharacterVisibleBody, WidgetPartyUserLocate) == 0x000000, "Member 'FWidgetPartyCharacterVisibleBody::WidgetPartyUserLocate' has a wrong offset!");
static_assert(offsetof(FWidgetPartyCharacterVisibleBody, Visible) == 0x000001, "Member 'FWidgetPartyCharacterVisibleBody::Visible' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPartyMemberEnter
// 0x00C8 (0x00E0 - 0x0018)
struct FMsgPartyMemberEnter final : public FMsgBase
{
public:
	EWidgetPartyUserLocate                        WidgetLocate;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2327[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayPartyUserInfo                     UserInfo;                                          // 0x0020(0x00C0)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgPartyMemberEnter) == 0x000008, "Wrong alignment on FMsgPartyMemberEnter");
static_assert(sizeof(FMsgPartyMemberEnter) == 0x0000E0, "Wrong size on FMsgPartyMemberEnter");
static_assert(offsetof(FMsgPartyMemberEnter, WidgetLocate) == 0x000018, "Member 'FMsgPartyMemberEnter::WidgetLocate' has a wrong offset!");
static_assert(offsetof(FMsgPartyMemberEnter, UserInfo) == 0x000020, "Member 'FMsgPartyMemberEnter::UserInfo' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPartyMemberLeave
// 0x0008 (0x0020 - 0x0018)
struct FMsgPartyMemberLeave final : public FMsgBase
{
public:
	EWidgetPartyUserLocate                        WidgetLocate;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2328[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgPartyMemberLeave) == 0x000008, "Wrong alignment on FMsgPartyMemberLeave");
static_assert(sizeof(FMsgPartyMemberLeave) == 0x000020, "Wrong size on FMsgPartyMemberLeave");
static_assert(offsetof(FMsgPartyMemberLeave, WidgetLocate) == 0x000018, "Member 'FMsgPartyMemberLeave::WidgetLocate' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPlayPartyReadyStateChangedNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgPlayPartyReadyStateChangedNotify final : public FMsgBase
{
public:
	EWidgetPartyUserLocate                        WidgetPartyUserLocate;                             // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeader;                                           // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReady;                                            // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2329[0x5];                                     // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgPlayPartyReadyStateChangedNotify) == 0x000008, "Wrong alignment on FMsgPlayPartyReadyStateChangedNotify");
static_assert(sizeof(FMsgPlayPartyReadyStateChangedNotify) == 0x000020, "Wrong size on FMsgPlayPartyReadyStateChangedNotify");
static_assert(offsetof(FMsgPlayPartyReadyStateChangedNotify, WidgetPartyUserLocate) == 0x000018, "Member 'FMsgPlayPartyReadyStateChangedNotify::WidgetPartyUserLocate' has a wrong offset!");
static_assert(offsetof(FMsgPlayPartyReadyStateChangedNotify, bLeader) == 0x000019, "Member 'FMsgPlayPartyReadyStateChangedNotify::bLeader' has a wrong offset!");
static_assert(offsetof(FMsgPlayPartyReadyStateChangedNotify, bReady) == 0x00001A, "Member 'FMsgPlayPartyReadyStateChangedNotify::bReady' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPlayMatchingStateChangedNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgPlayMatchingStateChangedNotify final : public FMsgBase
{
public:
	bool                                          bMatching;                                         // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232A[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgPlayMatchingStateChangedNotify) == 0x000008, "Wrong alignment on FMsgPlayMatchingStateChangedNotify");
static_assert(sizeof(FMsgPlayMatchingStateChangedNotify) == 0x000020, "Wrong size on FMsgPlayMatchingStateChangedNotify");
static_assert(offsetof(FMsgPlayMatchingStateChangedNotify, bMatching) == 0x000018, "Member 'FMsgPlayMatchingStateChangedNotify::bMatching' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetPlayBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetPlayBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetPlayBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetPlayBeginNotify");
static_assert(sizeof(FMsgWidgetPlayBeginNotify) == 0x000018, "Wrong size on FMsgWidgetPlayBeginNotify");

// ScriptStruct DungeonCrawler.MsgWidgetCustomizeBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetCustomizeBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetCustomizeBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetCustomizeBeginNotify");
static_assert(sizeof(FMsgWidgetCustomizeBeginNotify) == 0x000018, "Wrong size on FMsgWidgetCustomizeBeginNotify");

// ScriptStruct DungeonCrawler.MsgWidgetAddItemOnDealTableSuccessNotify
// 0x0100 (0x0118 - 0x0018)
struct FMsgWidgetAddItemOnDealTableSuccessNotify final : public FMsgBase
{
public:
	struct FItemData                              ItemData;                                          // 0x0018(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetAddItemOnDealTableSuccessNotify) == 0x000008, "Wrong alignment on FMsgWidgetAddItemOnDealTableSuccessNotify");
static_assert(sizeof(FMsgWidgetAddItemOnDealTableSuccessNotify) == 0x000118, "Wrong size on FMsgWidgetAddItemOnDealTableSuccessNotify");
static_assert(offsetof(FMsgWidgetAddItemOnDealTableSuccessNotify, ItemData) == 0x000018, "Member 'FMsgWidgetAddItemOnDealTableSuccessNotify::ItemData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetRemoveItemFromDealTable
// 0x0100 (0x0118 - 0x0018)
struct FMsgWidgetRemoveItemFromDealTable final : public FMsgBase
{
public:
	struct FItemData                              ItemData;                                          // 0x0018(0x0100)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetRemoveItemFromDealTable) == 0x000008, "Wrong alignment on FMsgWidgetRemoveItemFromDealTable");
static_assert(sizeof(FMsgWidgetRemoveItemFromDealTable) == 0x000118, "Wrong size on FMsgWidgetRemoveItemFromDealTable");
static_assert(offsetof(FMsgWidgetRemoveItemFromDealTable, ItemData) == 0x000018, "Member 'FMsgWidgetRemoveItemFromDealTable::ItemData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradeChannelChatRequest
// 0x00A8 (0x00C0 - 0x0018)
struct FMsgWidgetTradeChannelChatRequest final : public FMsgBase
{
public:
	EChatType                                     ChatType;                                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232B[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChatTargetAccountId;                               // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChatTargetCharacterId;                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChatData                              ChatData;                                          // 0x0040(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetTradeChannelChatRequest) == 0x000008, "Wrong alignment on FMsgWidgetTradeChannelChatRequest");
static_assert(sizeof(FMsgWidgetTradeChannelChatRequest) == 0x0000C0, "Wrong size on FMsgWidgetTradeChannelChatRequest");
static_assert(offsetof(FMsgWidgetTradeChannelChatRequest, ChatType) == 0x000018, "Member 'FMsgWidgetTradeChannelChatRequest::ChatType' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradeChannelChatRequest, ChatTargetAccountId) == 0x000020, "Member 'FMsgWidgetTradeChannelChatRequest::ChatTargetAccountId' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradeChannelChatRequest, ChatTargetCharacterId) == 0x000030, "Member 'FMsgWidgetTradeChannelChatRequest::ChatTargetCharacterId' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradeChannelChatRequest, ChatData) == 0x000040, "Member 'FMsgWidgetTradeChannelChatRequest::ChatData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradeChannelChatResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetTradeChannelChatResponse final : public FMsgBase
{
public:
	EMsgWidgetChatResult                          Result;                                            // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232C[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              TimeLeft;                                          // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetTradeChannelChatResponse) == 0x000008, "Wrong alignment on FMsgWidgetTradeChannelChatResponse");
static_assert(sizeof(FMsgWidgetTradeChannelChatResponse) == 0x000028, "Wrong size on FMsgWidgetTradeChannelChatResponse");
static_assert(offsetof(FMsgWidgetTradeChannelChatResponse, Result) == 0x000018, "Member 'FMsgWidgetTradeChannelChatResponse::Result' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradeChannelChatResponse, TimeLeft) == 0x000020, "Member 'FMsgWidgetTradeChannelChatResponse::TimeLeft' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradingChatResponse
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetTradingChatResponse final : public FMsgBase
{
public:
	EMsgWidgetChatResult                          Result;                                            // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232D[0x7];                                     // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              TimeLeft;                                          // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetTradingChatResponse) == 0x000008, "Wrong alignment on FMsgWidgetTradingChatResponse");
static_assert(sizeof(FMsgWidgetTradingChatResponse) == 0x000028, "Wrong size on FMsgWidgetTradingChatResponse");
static_assert(offsetof(FMsgWidgetTradingChatResponse, Result) == 0x000018, "Member 'FMsgWidgetTradingChatResponse::Result' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradingChatResponse, TimeLeft) == 0x000020, "Member 'FMsgWidgetTradingChatResponse::TimeLeft' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetTradingChatNotify
// 0x0090 (0x00A8 - 0x0018)
struct FMsgWidgetTradingChatNotify final : public FMsgBase
{
public:
	uint8                                         Pad_232E[0x90];                                    // 0x0018(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetTradingChatNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradingChatNotify");
static_assert(sizeof(FMsgWidgetTradingChatNotify) == 0x0000A8, "Wrong size on FMsgWidgetTradingChatNotify");

// ScriptStruct DungeonCrawler.MsgWidgetTradeSubscriptionButtonClicked
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetTradeSubscriptionButtonClicked final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetTradeSubscriptionButtonClicked) == 0x000008, "Wrong alignment on FMsgWidgetTradeSubscriptionButtonClicked");
static_assert(sizeof(FMsgWidgetTradeSubscriptionButtonClicked) == 0x000018, "Wrong size on FMsgWidgetTradeSubscriptionButtonClicked");

// ScriptStruct DungeonCrawler.MsgWidgetTradeSubscriptionSuccessNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetTradeSubscriptionSuccessNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetTradeSubscriptionSuccessNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeSubscriptionSuccessNotify");
static_assert(sizeof(FMsgWidgetTradeSubscriptionSuccessNotify) == 0x000018, "Wrong size on FMsgWidgetTradeSubscriptionSuccessNotify");

// ScriptStruct DungeonCrawler.MsgWidgetTradeChatUserListAddNotify
// 0x0020 (0x0038 - 0x0018)
struct FMsgWidgetTradeChatUserListAddNotify final : public FMsgBase
{
public:
	bool                                          bIsStart;                                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232F[0x17];                                    // 0x0019(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsFinish;                                         // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2330[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetTradeChatUserListAddNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeChatUserListAddNotify");
static_assert(sizeof(FMsgWidgetTradeChatUserListAddNotify) == 0x000038, "Wrong size on FMsgWidgetTradeChatUserListAddNotify");
static_assert(offsetof(FMsgWidgetTradeChatUserListAddNotify, bIsStart) == 0x000018, "Member 'FMsgWidgetTradeChatUserListAddNotify::bIsStart' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradeChatUserListAddNotify, bIsFinish) == 0x000030, "Member 'FMsgWidgetTradeChatUserListAddNotify::bIsFinish' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassTopMenuBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassTopMenuBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassTopMenuBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassTopMenuBeginNotify");
static_assert(sizeof(FMsgWidgetClassTopMenuBeginNotify) == 0x000018, "Wrong size on FMsgWidgetClassTopMenuBeginNotify");

// ScriptStruct DungeonCrawler.MsgWidgetTradeBeginNotify
// 0x0038 (0x0050 - 0x0018)
struct FMsgWidgetTradeBeginNotify final : public FMsgBase
{
public:
	class FText                                   MyNickName;                                        // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   TargetNickname;                                    // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         TradeFee;                                          // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResetDuration;                                     // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetTradeBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetTradeBeginNotify");
static_assert(sizeof(FMsgWidgetTradeBeginNotify) == 0x000050, "Wrong size on FMsgWidgetTradeBeginNotify");
static_assert(offsetof(FMsgWidgetTradeBeginNotify, MyNickName) == 0x000018, "Member 'FMsgWidgetTradeBeginNotify::MyNickName' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradeBeginNotify, TargetNickname) == 0x000030, "Member 'FMsgWidgetTradeBeginNotify::TargetNickname' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradeBeginNotify, TradeFee) == 0x000048, "Member 'FMsgWidgetTradeBeginNotify::TradeFee' has a wrong offset!");
static_assert(offsetof(FMsgWidgetTradeBeginNotify, ResetDuration) == 0x00004C, "Member 'FMsgWidgetTradeBeginNotify::ResetDuration' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassBeginNotify");
static_assert(sizeof(FMsgWidgetClassBeginNotify) == 0x000018, "Wrong size on FMsgWidgetClassBeginNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassSlotUnLockLevelNotify
// 0x0020 (0x0038 - 0x0018)
struct FMsgWidgetClassSlotUnLockLevelNotify final : public FMsgBase
{
public:
	TArray<int32>                                 IndexArray;                                        // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 UnLockLevelArray;                                  // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassSlotUnLockLevelNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSlotUnLockLevelNotify");
static_assert(sizeof(FMsgWidgetClassSlotUnLockLevelNotify) == 0x000038, "Wrong size on FMsgWidgetClassSlotUnLockLevelNotify");
static_assert(offsetof(FMsgWidgetClassSlotUnLockLevelNotify, IndexArray) == 0x000018, "Member 'FMsgWidgetClassSlotUnLockLevelNotify::IndexArray' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassSlotUnLockLevelNotify, UnLockLevelArray) == 0x000028, "Member 'FMsgWidgetClassSlotUnLockLevelNotify::UnLockLevelArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassEquipNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassEquipNotify final : public FMsgBase
{
public:
	uint8                                         Pad_2331[0x10];                                    // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassEquipNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassEquipNotify");
static_assert(sizeof(FMsgWidgetClassEquipNotify) == 0x000028, "Wrong size on FMsgWidgetClassEquipNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassSkillBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassSkillBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassSkillBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSkillBeginNotify");
static_assert(sizeof(FMsgWidgetClassSkillBeginNotify) == 0x000018, "Wrong size on FMsgWidgetClassSkillBeginNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassSkillListNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassSkillListNotify final : public FMsgBase
{
public:
	TArray<struct FDataSkill>                     SkillIdArray;                                      // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassSkillListNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSkillListNotify");
static_assert(sizeof(FMsgWidgetClassSkillListNotify) == 0x000028, "Wrong size on FMsgWidgetClassSkillListNotify");
static_assert(offsetof(FMsgWidgetClassSkillListNotify, SkillIdArray) == 0x000018, "Member 'FMsgWidgetClassSkillListNotify::SkillIdArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassSpellUnequippedListNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassSpellUnequippedListNotify final : public FMsgBase
{
public:
	TArray<struct FSpellData>                     SpellArray;                                        // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassSpellUnequippedListNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSpellUnequippedListNotify");
static_assert(sizeof(FMsgWidgetClassSpellUnequippedListNotify) == 0x000028, "Wrong size on FMsgWidgetClassSpellUnequippedListNotify");
static_assert(offsetof(FMsgWidgetClassSpellUnequippedListNotify, SpellArray) == 0x000018, "Member 'FMsgWidgetClassSpellUnequippedListNotify::SpellArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassMusicBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassMusicBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassMusicBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassMusicBeginNotify");
static_assert(sizeof(FMsgWidgetClassMusicBeginNotify) == 0x000018, "Wrong size on FMsgWidgetClassMusicBeginNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassMusicUnequippedListNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassMusicUnequippedListNotify final : public FMsgBase
{
public:
	TArray<struct FMusicData>                     MusicArray;                                        // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassMusicUnequippedListNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassMusicUnequippedListNotify");
static_assert(sizeof(FMsgWidgetClassMusicUnequippedListNotify) == 0x000028, "Wrong size on FMsgWidgetClassMusicUnequippedListNotify");
static_assert(offsetof(FMsgWidgetClassMusicUnequippedListNotify, MusicArray) == 0x000018, "Member 'FMsgWidgetClassMusicUnequippedListNotify::MusicArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassShapeShiftEquippedListNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassShapeShiftEquippedListNotify final : public FMsgBase
{
public:
	TArray<struct FShapeShiftData>                ShapeShiftArray;                                   // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassShapeShiftEquippedListNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassShapeShiftEquippedListNotify");
static_assert(sizeof(FMsgWidgetClassShapeShiftEquippedListNotify) == 0x000028, "Wrong size on FMsgWidgetClassShapeShiftEquippedListNotify");
static_assert(offsetof(FMsgWidgetClassShapeShiftEquippedListNotify, ShapeShiftArray) == 0x000018, "Member 'FMsgWidgetClassShapeShiftEquippedListNotify::ShapeShiftArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassShapeShiftUnequippedListNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassShapeShiftUnequippedListNotify final : public FMsgBase
{
public:
	TArray<struct FShapeShiftData>                ShapeShiftArray;                                   // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassShapeShiftUnequippedListNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassShapeShiftUnequippedListNotify");
static_assert(sizeof(FMsgWidgetClassShapeShiftUnequippedListNotify) == 0x000028, "Wrong size on FMsgWidgetClassShapeShiftUnequippedListNotify");
static_assert(offsetof(FMsgWidgetClassShapeShiftUnequippedListNotify, ShapeShiftArray) == 0x000018, "Member 'FMsgWidgetClassShapeShiftUnequippedListNotify::ShapeShiftArray' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassItemMoveResponseNotify
// 0x0048 (0x0060 - 0x0018)
struct FMsgWidgetClassItemMoveResponseNotify final : public FMsgBase
{
public:
	int32                                         Result;                                            // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2332[0x44];                                    // 0x001C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassItemMoveResponseNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassItemMoveResponseNotify");
static_assert(sizeof(FMsgWidgetClassItemMoveResponseNotify) == 0x000060, "Wrong size on FMsgWidgetClassItemMoveResponseNotify");
static_assert(offsetof(FMsgWidgetClassItemMoveResponseNotify, Result) == 0x000018, "Member 'FMsgWidgetClassItemMoveResponseNotify::Result' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassSpellSlotMoveRequestNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassSpellSlotMoveRequestNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SpellId;                                           // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2333[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassSpellSlotMoveRequestNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSpellSlotMoveRequestNotify");
static_assert(sizeof(FMsgWidgetClassSpellSlotMoveRequestNotify) == 0x000030, "Wrong size on FMsgWidgetClassSpellSlotMoveRequestNotify");
static_assert(offsetof(FMsgWidgetClassSpellSlotMoveRequestNotify, Index) == 0x000018, "Member 'FMsgWidgetClassSpellSlotMoveRequestNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassSpellSlotMoveRequestNotify, SpellId) == 0x00001C, "Member 'FMsgWidgetClassSpellSlotMoveRequestNotify::SpellId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassSpellSequenceChangeRequestNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassSpellSequenceChangeRequestNotify final : public FMsgBase
{
public:
	int32                                         SequenceIndex;                                     // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SpellId;                                           // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2334[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassSpellSequenceChangeRequestNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSpellSequenceChangeRequestNotify");
static_assert(sizeof(FMsgWidgetClassSpellSequenceChangeRequestNotify) == 0x000030, "Wrong size on FMsgWidgetClassSpellSequenceChangeRequestNotify");
static_assert(offsetof(FMsgWidgetClassSpellSequenceChangeRequestNotify, SequenceIndex) == 0x000018, "Member 'FMsgWidgetClassSpellSequenceChangeRequestNotify::SequenceIndex' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassSpellSequenceChangeRequestNotify, SpellId) == 0x00001C, "Member 'FMsgWidgetClassSpellSequenceChangeRequestNotify::SpellId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassShapeShiftSlotMoveRequestNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassShapeShiftSlotMoveRequestNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ShapeShiftId;                                      // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2335[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassShapeShiftSlotMoveRequestNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassShapeShiftSlotMoveRequestNotify");
static_assert(sizeof(FMsgWidgetClassShapeShiftSlotMoveRequestNotify) == 0x000030, "Wrong size on FMsgWidgetClassShapeShiftSlotMoveRequestNotify");
static_assert(offsetof(FMsgWidgetClassShapeShiftSlotMoveRequestNotify, Index) == 0x000018, "Member 'FMsgWidgetClassShapeShiftSlotMoveRequestNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassShapeShiftSlotMoveRequestNotify, ShapeShiftId) == 0x00001C, "Member 'FMsgWidgetClassShapeShiftSlotMoveRequestNotify::ShapeShiftId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassUnEquipmentTypeChangeNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetClassUnEquipmentTypeChangeNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2336[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassUnEquipmentTypeChangeNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassUnEquipmentTypeChangeNotify");
static_assert(sizeof(FMsgWidgetClassUnEquipmentTypeChangeNotify) == 0x000020, "Wrong size on FMsgWidgetClassUnEquipmentTypeChangeNotify");
static_assert(offsetof(FMsgWidgetClassUnEquipmentTypeChangeNotify, Index) == 0x000018, "Member 'FMsgWidgetClassUnEquipmentTypeChangeNotify::Index' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassAddEquipPerkNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassAddEquipPerkNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PerkId;                                            // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2337[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassAddEquipPerkNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassAddEquipPerkNotify");
static_assert(sizeof(FMsgWidgetClassAddEquipPerkNotify) == 0x000030, "Wrong size on FMsgWidgetClassAddEquipPerkNotify");
static_assert(offsetof(FMsgWidgetClassAddEquipPerkNotify, Index) == 0x000018, "Member 'FMsgWidgetClassAddEquipPerkNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassAddEquipPerkNotify, PerkId) == 0x00001C, "Member 'FMsgWidgetClassAddEquipPerkNotify::PerkId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassRemoveEquipPerkNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassRemoveEquipPerkNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PerkId;                                            // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2338[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassRemoveEquipPerkNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassRemoveEquipPerkNotify");
static_assert(sizeof(FMsgWidgetClassRemoveEquipPerkNotify) == 0x000030, "Wrong size on FMsgWidgetClassRemoveEquipPerkNotify");
static_assert(offsetof(FMsgWidgetClassRemoveEquipPerkNotify, Index) == 0x000018, "Member 'FMsgWidgetClassRemoveEquipPerkNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassRemoveEquipPerkNotify, PerkId) == 0x00001C, "Member 'FMsgWidgetClassRemoveEquipPerkNotify::PerkId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassRemoveUnEquipPerkNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassRemoveUnEquipPerkNotify final : public FMsgBase
{
public:
	struct FPrimaryAssetId                        PerkId;                                            // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassRemoveUnEquipPerkNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassRemoveUnEquipPerkNotify");
static_assert(sizeof(FMsgWidgetClassRemoveUnEquipPerkNotify) == 0x000028, "Wrong size on FMsgWidgetClassRemoveUnEquipPerkNotify");
static_assert(offsetof(FMsgWidgetClassRemoveUnEquipPerkNotify, PerkId) == 0x000018, "Member 'FMsgWidgetClassRemoveUnEquipPerkNotify::PerkId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassRemoveUnEquipSkillNotify
// 0x0010 (0x0028 - 0x0018)
struct FMsgWidgetClassRemoveUnEquipSkillNotify final : public FMsgBase
{
public:
	struct FPrimaryAssetId                        SkillId;                                           // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassRemoveUnEquipSkillNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassRemoveUnEquipSkillNotify");
static_assert(sizeof(FMsgWidgetClassRemoveUnEquipSkillNotify) == 0x000028, "Wrong size on FMsgWidgetClassRemoveUnEquipSkillNotify");
static_assert(offsetof(FMsgWidgetClassRemoveUnEquipSkillNotify, SkillId) == 0x000018, "Member 'FMsgWidgetClassRemoveUnEquipSkillNotify::SkillId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassPerkEventNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassPerkEventNotify final : public FMsgBase
{
public:
	int32                                         Move;                                              // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        PerkId;                                            // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassPerkEventNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassPerkEventNotify");
static_assert(sizeof(FMsgWidgetClassPerkEventNotify) == 0x000030, "Wrong size on FMsgWidgetClassPerkEventNotify");
static_assert(offsetof(FMsgWidgetClassPerkEventNotify, Move) == 0x000018, "Member 'FMsgWidgetClassPerkEventNotify::Move' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassPerkEventNotify, Index) == 0x00001C, "Member 'FMsgWidgetClassPerkEventNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassPerkEventNotify, PerkId) == 0x000020, "Member 'FMsgWidgetClassPerkEventNotify::PerkId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassPerkSwapEventNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgWidgetClassPerkSwapEventNotify final : public FMsgBase
{
public:
	int32                                         SrcIndex;                                          // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SrcPerkId;                                         // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DstIndex;                                          // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DstPerkId;                                         // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassPerkSwapEventNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassPerkSwapEventNotify");
static_assert(sizeof(FMsgWidgetClassPerkSwapEventNotify) == 0x000040, "Wrong size on FMsgWidgetClassPerkSwapEventNotify");
static_assert(offsetof(FMsgWidgetClassPerkSwapEventNotify, SrcIndex) == 0x000018, "Member 'FMsgWidgetClassPerkSwapEventNotify::SrcIndex' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassPerkSwapEventNotify, SrcPerkId) == 0x00001C, "Member 'FMsgWidgetClassPerkSwapEventNotify::SrcPerkId' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassPerkSwapEventNotify, DstIndex) == 0x00002C, "Member 'FMsgWidgetClassPerkSwapEventNotify::DstIndex' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassPerkSwapEventNotify, DstPerkId) == 0x000030, "Member 'FMsgWidgetClassPerkSwapEventNotify::DstPerkId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassSkillSwapEventNotify
// 0x0028 (0x0040 - 0x0018)
struct FMsgWidgetClassSkillSwapEventNotify final : public FMsgBase
{
public:
	int32                                         SrcIndex;                                          // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        SrcSkillId;                                        // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DstIndex;                                          // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        DstSkillId;                                        // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetClassSkillSwapEventNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSkillSwapEventNotify");
static_assert(sizeof(FMsgWidgetClassSkillSwapEventNotify) == 0x000040, "Wrong size on FMsgWidgetClassSkillSwapEventNotify");
static_assert(offsetof(FMsgWidgetClassSkillSwapEventNotify, SrcIndex) == 0x000018, "Member 'FMsgWidgetClassSkillSwapEventNotify::SrcIndex' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassSkillSwapEventNotify, SrcSkillId) == 0x00001C, "Member 'FMsgWidgetClassSkillSwapEventNotify::SrcSkillId' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassSkillSwapEventNotify, DstIndex) == 0x00002C, "Member 'FMsgWidgetClassSkillSwapEventNotify::DstIndex' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassSkillSwapEventNotify, DstSkillId) == 0x000030, "Member 'FMsgWidgetClassSkillSwapEventNotify::DstSkillId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassMusicEquipNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassMusicEquipNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        MusicId;                                           // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2339[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassMusicEquipNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassMusicEquipNotify");
static_assert(sizeof(FMsgWidgetClassMusicEquipNotify) == 0x000030, "Wrong size on FMsgWidgetClassMusicEquipNotify");
static_assert(offsetof(FMsgWidgetClassMusicEquipNotify, Index) == 0x000018, "Member 'FMsgWidgetClassMusicEquipNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassMusicEquipNotify, MusicId) == 0x00001C, "Member 'FMsgWidgetClassMusicEquipNotify::MusicId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassShapeShiftEquipNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetClassShapeShiftEquipNotify final : public FMsgBase
{
public:
	int32                                         Index;                                             // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ShapeShiftId;                                      // 0x001C(0x0010)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233A[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassShapeShiftEquipNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassShapeShiftEquipNotify");
static_assert(sizeof(FMsgWidgetClassShapeShiftEquipNotify) == 0x000030, "Wrong size on FMsgWidgetClassShapeShiftEquipNotify");
static_assert(offsetof(FMsgWidgetClassShapeShiftEquipNotify, Index) == 0x000018, "Member 'FMsgWidgetClassShapeShiftEquipNotify::Index' has a wrong offset!");
static_assert(offsetof(FMsgWidgetClassShapeShiftEquipNotify, ShapeShiftId) == 0x00001C, "Member 'FMsgWidgetClassShapeShiftEquipNotify::ShapeShiftId' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassUnEquipmentClearSelectedItemNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassUnEquipmentClearSelectedItemNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassUnEquipmentClearSelectedItemNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassUnEquipmentClearSelectedItemNotify");
static_assert(sizeof(FMsgWidgetClassUnEquipmentClearSelectedItemNotify) == 0x000018, "Wrong size on FMsgWidgetClassUnEquipmentClearSelectedItemNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassEquipablePerkEmptySlotsMarkNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify final : public FMsgBase
{
public:
	bool                                          bMark;                                             // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233B[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify");
static_assert(sizeof(FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify) == 0x000020, "Wrong size on FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify");
static_assert(offsetof(FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify, bMark) == 0x000018, "Member 'FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify::bMark' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetClassSpellShowEquippableSlotNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassSpellShowEquippableSlotNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassSpellShowEquippableSlotNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSpellShowEquippableSlotNotify");
static_assert(sizeof(FMsgWidgetClassSpellShowEquippableSlotNotify) == 0x000018, "Wrong size on FMsgWidgetClassSpellShowEquippableSlotNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassSpellHideEquippableSlotNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassSpellHideEquippableSlotNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassSpellHideEquippableSlotNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassSpellHideEquippableSlotNotify");
static_assert(sizeof(FMsgWidgetClassSpellHideEquippableSlotNotify) == 0x000018, "Wrong size on FMsgWidgetClassSpellHideEquippableSlotNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassMusicShowEquippableSlotNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassMusicShowEquippableSlotNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassMusicShowEquippableSlotNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassMusicShowEquippableSlotNotify");
static_assert(sizeof(FMsgWidgetClassMusicShowEquippableSlotNotify) == 0x000018, "Wrong size on FMsgWidgetClassMusicShowEquippableSlotNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassShapeShiftShowEquippableSlotNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassShapeShiftShowEquippableSlotNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassShapeShiftShowEquippableSlotNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassShapeShiftShowEquippableSlotNotify");
static_assert(sizeof(FMsgWidgetClassShapeShiftShowEquippableSlotNotify) == 0x000018, "Wrong size on FMsgWidgetClassShapeShiftShowEquippableSlotNotify");

// ScriptStruct DungeonCrawler.MsgWidgetClassShapeShiftHideEquippableSlotNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetClassShapeShiftHideEquippableSlotNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetClassShapeShiftHideEquippableSlotNotify) == 0x000008, "Wrong alignment on FMsgWidgetClassShapeShiftHideEquippableSlotNotify");
static_assert(sizeof(FMsgWidgetClassShapeShiftHideEquippableSlotNotify) == 0x000018, "Wrong size on FMsgWidgetClassShapeShiftHideEquippableSlotNotify");

// ScriptStruct DungeonCrawler.MsgWidgetSelectRegionButtonNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetSelectRegionButtonNotify final : public FMsgBase
{
public:
	int32                                         Region;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233C[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetSelectRegionButtonNotify) == 0x000008, "Wrong alignment on FMsgWidgetSelectRegionButtonNotify");
static_assert(sizeof(FMsgWidgetSelectRegionButtonNotify) == 0x000020, "Wrong size on FMsgWidgetSelectRegionButtonNotify");
static_assert(offsetof(FMsgWidgetSelectRegionButtonNotify, Region) == 0x000018, "Member 'FMsgWidgetSelectRegionButtonNotify::Region' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetMailBoxNewAlarmNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetMailBoxNewAlarmNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetMailBoxNewAlarmNotify) == 0x000008, "Wrong alignment on FMsgWidgetMailBoxNewAlarmNotify");
static_assert(sizeof(FMsgWidgetMailBoxNewAlarmNotify) == 0x000018, "Wrong size on FMsgWidgetMailBoxNewAlarmNotify");

// ScriptStruct DungeonCrawler.MsgWidgetKarmaReportInfoNotify
// 0x0020 (0x0038 - 0x0018)
struct FMsgWidgetKarmaReportInfoNotify final : public FMsgBase
{
public:
	TArray<struct FKarmaMatchInfo>                MatchInfoArray;                                    // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CurrentTicketCount;                                // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollectionStepCount;                               // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCollectionCount;                                // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTicketCount;                                    // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetKarmaReportInfoNotify) == 0x000008, "Wrong alignment on FMsgWidgetKarmaReportInfoNotify");
static_assert(sizeof(FMsgWidgetKarmaReportInfoNotify) == 0x000038, "Wrong size on FMsgWidgetKarmaReportInfoNotify");
static_assert(offsetof(FMsgWidgetKarmaReportInfoNotify, MatchInfoArray) == 0x000018, "Member 'FMsgWidgetKarmaReportInfoNotify::MatchInfoArray' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportInfoNotify, CurrentTicketCount) == 0x000028, "Member 'FMsgWidgetKarmaReportInfoNotify::CurrentTicketCount' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportInfoNotify, CollectionStepCount) == 0x00002C, "Member 'FMsgWidgetKarmaReportInfoNotify::CollectionStepCount' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportInfoNotify, MaxCollectionCount) == 0x000030, "Member 'FMsgWidgetKarmaReportInfoNotify::MaxCollectionCount' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportInfoNotify, MaxTicketCount) == 0x000034, "Member 'FMsgWidgetKarmaReportInfoNotify::MaxTicketCount' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetQuestLogBeginNotify
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetQuestLogBeginNotify final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetQuestLogBeginNotify) == 0x000008, "Wrong alignment on FMsgWidgetQuestLogBeginNotify");
static_assert(sizeof(FMsgWidgetQuestLogBeginNotify) == 0x000018, "Wrong size on FMsgWidgetQuestLogBeginNotify");

// ScriptStruct DungeonCrawler.MsgWidgetKarmaReportActionRequest
// 0x0030 (0x0048 - 0x0018)
struct FMsgWidgetKarmaReportActionRequest final : public FMsgBase
{
public:
	int32                                         MatchIdx;                                          // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233D[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccountId;                                         // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterId;                                       // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Action;                                            // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233E[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetKarmaReportActionRequest) == 0x000008, "Wrong alignment on FMsgWidgetKarmaReportActionRequest");
static_assert(sizeof(FMsgWidgetKarmaReportActionRequest) == 0x000048, "Wrong size on FMsgWidgetKarmaReportActionRequest");
static_assert(offsetof(FMsgWidgetKarmaReportActionRequest, MatchIdx) == 0x000018, "Member 'FMsgWidgetKarmaReportActionRequest::MatchIdx' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportActionRequest, AccountId) == 0x000020, "Member 'FMsgWidgetKarmaReportActionRequest::AccountId' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportActionRequest, CharacterId) == 0x000030, "Member 'FMsgWidgetKarmaReportActionRequest::CharacterId' has a wrong offset!");
static_assert(offsetof(FMsgWidgetKarmaReportActionRequest, Action) == 0x000040, "Member 'FMsgWidgetKarmaReportActionRequest::Action' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetFriendItemRecoveryNotify
// 0x0018 (0x0030 - 0x0018)
struct FMsgWidgetFriendItemRecoveryNotify final : public FMsgBase
{
public:
	TArray<struct FAccountDataItem>               FriendRecoveryItems;                               // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsItemReceivedUser;                               // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233F[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetFriendItemRecoveryNotify) == 0x000008, "Wrong alignment on FMsgWidgetFriendItemRecoveryNotify");
static_assert(sizeof(FMsgWidgetFriendItemRecoveryNotify) == 0x000030, "Wrong size on FMsgWidgetFriendItemRecoveryNotify");
static_assert(offsetof(FMsgWidgetFriendItemRecoveryNotify, FriendRecoveryItems) == 0x000018, "Member 'FMsgWidgetFriendItemRecoveryNotify::FriendRecoveryItems' has a wrong offset!");
static_assert(offsetof(FMsgWidgetFriendItemRecoveryNotify, bIsItemReceivedUser) == 0x000028, "Member 'FMsgWidgetFriendItemRecoveryNotify::bIsItemReceivedUser' has a wrong offset!");

// ScriptStruct DungeonCrawler.PlayPartyUserInfoData
// 0x0010 (0x0010 - 0x0000)
struct FPlayPartyUserInfoData final
{
public:
	TArray<struct FPlayPartyUserInfo>             PlayPartyData;                                     // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayPartyUserInfoData) == 0x000008, "Wrong alignment on FPlayPartyUserInfoData");
static_assert(sizeof(FPlayPartyUserInfoData) == 0x000010, "Wrong size on FPlayPartyUserInfoData");
static_assert(offsetof(FPlayPartyUserInfoData, PlayPartyData) == 0x000000, "Member 'FPlayPartyUserInfoData::PlayPartyData' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgSystemMessageNotify
// 0x0020 (0x0038 - 0x0018)
struct FMsgSystemMessageNotify final : public FMsgBase
{
public:
	class FText                                   OutputMessage;                                     // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2340[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgSystemMessageNotify) == 0x000008, "Wrong alignment on FMsgSystemMessageNotify");
static_assert(sizeof(FMsgSystemMessageNotify) == 0x000038, "Wrong size on FMsgSystemMessageNotify");
static_assert(offsetof(FMsgSystemMessageNotify, OutputMessage) == 0x000018, "Member 'FMsgSystemMessageNotify::OutputMessage' has a wrong offset!");
static_assert(offsetof(FMsgSystemMessageNotify, Duration) == 0x000030, "Member 'FMsgSystemMessageNotify::Duration' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgPopupBaseNotify
// 0x0008 (0x0040 - 0x0038)
struct FMsgPopupBaseNotify final : public FMsgPopup
{
public:
	uint8                                         Pad_2341[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgPopupBaseNotify) == 0x000008, "Wrong alignment on FMsgPopupBaseNotify");
static_assert(sizeof(FMsgPopupBaseNotify) == 0x000040, "Wrong size on FMsgPopupBaseNotify");

// ScriptStruct DungeonCrawler.MsgWidgetPopupMessageNotify
// 0x0000 (0x0038 - 0x0038)
struct FMsgWidgetPopupMessageNotify final : public FMsgPopup
{
};
static_assert(alignof(FMsgWidgetPopupMessageNotify) == 0x000008, "Wrong alignment on FMsgWidgetPopupMessageNotify");
static_assert(sizeof(FMsgWidgetPopupMessageNotify) == 0x000038, "Wrong size on FMsgWidgetPopupMessageNotify");

// ScriptStruct DungeonCrawler.MsgWidgetPopupMessageRequest
// 0x0000 (0x0038 - 0x0038)
struct FMsgWidgetPopupMessageRequest final : public FMsgPopup
{
};
static_assert(alignof(FMsgWidgetPopupMessageRequest) == 0x000008, "Wrong alignment on FMsgWidgetPopupMessageRequest");
static_assert(sizeof(FMsgWidgetPopupMessageRequest) == 0x000038, "Wrong size on FMsgWidgetPopupMessageRequest");

// ScriptStruct DungeonCrawler.MsgWidgetPopupCloseRequest
// 0x0000 (0x0018 - 0x0018)
struct FMsgWidgetPopupCloseRequest final : public FMsgBase
{
};
static_assert(alignof(FMsgWidgetPopupCloseRequest) == 0x000008, "Wrong alignment on FMsgWidgetPopupCloseRequest");
static_assert(sizeof(FMsgWidgetPopupCloseRequest) == 0x000018, "Wrong size on FMsgWidgetPopupCloseRequest");

// ScriptStruct DungeonCrawler.MsgWidgetPopupCloseResponse
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetPopupCloseResponse final : public FMsgBase
{
public:
	bool                                          bSucceedClose;                                     // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2342[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetPopupCloseResponse) == 0x000008, "Wrong alignment on FMsgWidgetPopupCloseResponse");
static_assert(sizeof(FMsgWidgetPopupCloseResponse) == 0x000020, "Wrong size on FMsgWidgetPopupCloseResponse");
static_assert(offsetof(FMsgWidgetPopupCloseResponse, bSucceedClose) == 0x000018, "Member 'FMsgWidgetPopupCloseResponse::bSucceedClose' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetProgressBarStart
// 0x0020 (0x0038 - 0x0018)
struct FMsgWidgetProgressBarStart final : public FMsgBase
{
public:
	class FText                                   Description;                                       // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDuration;                                     // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMsgWidgetProgressBarStart) == 0x000008, "Wrong alignment on FMsgWidgetProgressBarStart");
static_assert(sizeof(FMsgWidgetProgressBarStart) == 0x000038, "Wrong size on FMsgWidgetProgressBarStart");
static_assert(offsetof(FMsgWidgetProgressBarStart, Description) == 0x000018, "Member 'FMsgWidgetProgressBarStart::Description' has a wrong offset!");
static_assert(offsetof(FMsgWidgetProgressBarStart, Duration) == 0x000030, "Member 'FMsgWidgetProgressBarStart::Duration' has a wrong offset!");
static_assert(offsetof(FMsgWidgetProgressBarStart, StartDuration) == 0x000034, "Member 'FMsgWidgetProgressBarStart::StartDuration' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetProgressBarResume
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetProgressBarResume final : public FMsgBase
{
public:
	float                                         AdditionalElapsedTimeRatio;                        // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2343[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetProgressBarResume) == 0x000008, "Wrong alignment on FMsgWidgetProgressBarResume");
static_assert(sizeof(FMsgWidgetProgressBarResume) == 0x000020, "Wrong size on FMsgWidgetProgressBarResume");
static_assert(offsetof(FMsgWidgetProgressBarResume, AdditionalElapsedTimeRatio) == 0x000018, "Member 'FMsgWidgetProgressBarResume::AdditionalElapsedTimeRatio' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetProgressBarEnd
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetProgressBarEnd final : public FMsgBase
{
public:
	bool                                          bIsSucceed;                                        // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2344[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetProgressBarEnd) == 0x000008, "Wrong alignment on FMsgWidgetProgressBarEnd");
static_assert(sizeof(FMsgWidgetProgressBarEnd) == 0x000020, "Wrong size on FMsgWidgetProgressBarEnd");
static_assert(offsetof(FMsgWidgetProgressBarEnd, bIsSucceed) == 0x000018, "Member 'FMsgWidgetProgressBarEnd::bIsSucceed' has a wrong offset!");

// ScriptStruct DungeonCrawler.MsgWidgetContextOptionSelectedNotify
// 0x0008 (0x0020 - 0x0018)
struct FMsgWidgetContextOptionSelectedNotify final : public FMsgBase
{
public:
	EContextOptionType                            ContextOptionType;                                 // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2345[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMsgWidgetContextOptionSelectedNotify) == 0x000008, "Wrong alignment on FMsgWidgetContextOptionSelectedNotify");
static_assert(sizeof(FMsgWidgetContextOptionSelectedNotify) == 0x000020, "Wrong size on FMsgWidgetContextOptionSelectedNotify");
static_assert(offsetof(FMsgWidgetContextOptionSelectedNotify, ContextOptionType) == 0x000018, "Member 'FMsgWidgetContextOptionSelectedNotify::ContextOptionType' has a wrong offset!");

}

