#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DungeonCrawler

#include "Basic.hpp"

#include "DungeonCrawler_classes.hpp"
#include "DungeonCrawler_parameters.hpp"


namespace SDK
{

// Function DungeonCrawler.AccountLink.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccountLink::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountLink", "BroadcastMsgBlueprint");

	Params::AccountLink_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountLink.TerminateBase
// (Native, Public)

void UAccountLink::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountLink", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountLink.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccountLink::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountLink", "UnbindMsg");

	Params::AccountLink_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountLink.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccountLink::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountLink", "UnbindMsgAll");

	Params::AccountLink_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountLinkAll.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccountLinkAll::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountLinkAll", "BroadcastMsgBlueprint");

	Params::AccountLinkAll_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountLinkAll.TerminateBase
// (Native, Public)

void UAccountLinkAll::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountLinkAll", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountLinkAll.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccountLinkAll::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountLinkAll", "UnbindMsg");

	Params::AccountLinkAll_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountLinkAll.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccountLinkAll::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountLinkAll", "UnbindMsgAll");

	Params::AccountLinkAll_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountSession.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccountSession::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountSession", "BroadcastMsgBlueprint");

	Params::AccountSession_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountSession.TerminateBase
// (Native, Public)

void UAccountSession::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountSession", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountSession.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccountSession::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountSession", "UnbindMsg");

	Params::AccountSession_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AccountSession.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccountSession::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccountSession", "UnbindMsgAll");

	Params::AccountSession_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBase.BindMsgOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBindMsgNode*                     InMsgDynamicDelegate                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCWidgetBase::BindMsgOwner(class UScriptStruct* InMsgType, class UBindMsgNode* InMsgDynamicDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCWidgetBase", "BindMsgOwner");

	Params::DCWidgetBase_BindMsgOwner Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InMsgDynamicDelegate = InMsgDynamicDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCWidgetBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCWidgetBase", "BroadcastMsgBlueprint");

	Params::DCWidgetBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBase.GetOwningBaseInterfaceBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBaseInterface>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class IBaseInterface> UDCWidgetBase::GetOwningBaseInterfaceBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCWidgetBase", "GetOwningBaseInterfaceBlueprint");

	Params::DCWidgetBase_GetOwningBaseInterfaceBlueprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBase.IsSpectating
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCWidgetBase::IsSpectating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCWidgetBase", "IsSpectating");

	Params::DCWidgetBase_IsSpectating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBase.TerminateBase
// (Native, Public)

void UDCWidgetBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCWidgetBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCWidgetBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCWidgetBase", "UnbindMsg");

	Params::DCWidgetBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCWidgetBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCWidgetBase", "UnbindMsgAll");

	Params::DCWidgetBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBase.UnbindMsgAllOwner
// (Final, Native, Public, BlueprintCallable)

void UDCWidgetBase::UnbindMsgAllOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCWidgetBase", "UnbindMsgAllOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBase.UnbindMsgOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCWidgetBase::UnbindMsgOwner(class UScriptStruct* InMsgType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCWidgetBase", "UnbindMsgOwner");

	Params::DCWidgetBase_UnbindMsgOwner Parms{};

	Parms.InMsgType = InMsgType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTradeInventoryWidget.OnTradeEnd
// (Final, Native, Private)

void UDCTradeInventoryWidget::OnTradeEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradeInventoryWidget", "OnTradeEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryBase.OnRep_Indexes
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<int32>                           OldIndexes                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCInventoryBase::OnRep_Indexes(const TArray<int32>& OldIndexes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryBase", "OnRep_Indexes");

	Params::DCInventoryBase_OnRep_Indexes Parms{};

	Parms.OldIndexes = std::move(OldIndexes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryBase.OnRep_Version
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FDCInventoryVersion              OldVersion                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCInventoryBase::OnRep_Version(const struct FDCInventoryVersion& OldVersion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryBase", "OnRep_Version");

	Params::DCInventoryBase_OnRep_Version Parms{};

	Parms.OldVersion = std::move(OldVersion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCBoxInventory.OnRep_BoxSize
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// struct FIntPoint                        OldBoxSize                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCBoxInventory::OnRep_BoxSize(const struct FIntPoint& OldBoxSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCBoxInventory", "OnRep_BoxSize");

	Params::DCBoxInventory_OnRep_BoxSize Parms{};

	Parms.OldBoxSize = std::move(OldBoxSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.GetQualityLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameMenuOptionsVideosSlotWidget::GetQualityLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideosSlotWidget", "GetQualityLevel");

	Params::GameMenuOptionsVideosSlotWidget_GetQualityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnEpicButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideosSlotWidget::OnEpicButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideosSlotWidget", "OnEpicButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnExtraButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideosSlotWidget::OnExtraButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideosSlotWidget", "OnExtraButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnHighButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideosSlotWidget::OnHighButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideosSlotWidget", "OnHighButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnLowButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideosSlotWidget::OnLowButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideosSlotWidget", "OnLowButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnMediumButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideosSlotWidget::OnMediumButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideosSlotWidget", "OnMediumButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnQualityLevel
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsVideosSlotWidget::OnQualityLevel(const int32& NewValue, const int32& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideosSlotWidget", "OnQualityLevel");

	Params::GameMenuOptionsVideosSlotWidget_OnQualityLevel Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.SetQualityLevel
// (Final, Native, Public)
// Parameters:
// int32                                   InQualityLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsVideosSlotWidget::SetQualityLevel(int32 InQualityLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideosSlotWidget", "SetQualityLevel");

	Params::GameMenuOptionsVideosSlotWidget_SetQualityLevel Parms{};

	Parms.InQualityLevel = InQualityLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.SetTitle
// (Final, Native, Public)
// Parameters:
// class FText                             InTitle                                                (Parm, NativeAccessSpecifierPublic)

void UGameMenuOptionsVideosSlotWidget::SetTitle(const class FText& InTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideosSlotWidget", "SetTitle");

	Params::GameMenuOptionsVideosSlotWidget_SetTitle Parms{};

	Parms.InTitle = std::move(InTitle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ArenaSelectSlotWidget.OnArenaButtonClicked
// (Final, Native, Protected)

void UArenaSelectSlotWidget::OnArenaButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArenaSelectSlotWidget", "OnArenaButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ArenaSelectSlotWidget.OnGameUserSettingControlsChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameUserSettingControls         InGameUserSettingControls                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameUserSettingControls         InOldGameUserSettingControls                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArenaSelectSlotWidget::OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArenaSelectSlotWidget", "OnGameUserSettingControlsChanged");

	Params::ArenaSelectSlotWidget_OnGameUserSettingControlsChanged Parms{};

	Parms.InGameUserSettingControls = std::move(InGameUserSettingControls);
	Parms.InOldGameUserSettingControls = std::move(InOldGameUserSettingControls);
	Parms.bInForce = bInForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ArenaSelectSlotWidget.UpdateArenaSelectSlot
// (Event, Protected, BlueprintEvent)

void UArenaSelectSlotWidget::UpdateArenaSelectSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArenaSelectSlotWidget", "UpdateArenaSelectSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ArenaSelectSlotWidget.CanJoin
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UArenaSelectSlotWidget::CanJoin() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArenaSelectSlotWidget", "CanJoin");

	Params::ArenaSelectSlotWidget_CanJoin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ArenaSelectSlotWidget.GetBeginTime
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UArenaSelectSlotWidget::GetBeginTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArenaSelectSlotWidget", "GetBeginTime");

	Params::ArenaSelectSlotWidget_GetBeginTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ArenaSelectSlotWidget.GetEndTime
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UArenaSelectSlotWidget::GetEndTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArenaSelectSlotWidget", "GetEndTime");

	Params::ArenaSelectSlotWidget_GetEndTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameModeAIControllerBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameModeAIControllerBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameModeAIControllerBase", "BroadcastMsgBlueprint");

	Params::DCGameModeAIControllerBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameModeAIControllerBase.ReceivePreInitializeComponents
// (Event, Protected, BlueprintEvent)

void ADCGameModeAIControllerBase::ReceivePreInitializeComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameModeAIControllerBase", "ReceivePreInitializeComponents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCGameModeAIControllerBase.TerminateBase
// (Native, Public)

void ADCGameModeAIControllerBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameModeAIControllerBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameModeAIControllerBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameModeAIControllerBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameModeAIControllerBase", "UnbindMsg");

	Params::DCGameModeAIControllerBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameModeAIControllerBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameModeAIControllerBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameModeAIControllerBase", "UnbindMsgAll");

	Params::DCGameModeAIControllerBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::AddGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "AddGameplayCue");

	Params::DCGameplayAbilityBase_AddGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueLocal
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "AddGameplayCueLocal");

	Params::DCGameplayAbilityBase_AddGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueLocalWithParams
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Params_0                                               (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::AddGameplayCueLocalWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "AddGameplayCueLocalWithParams");

	Params::DCGameplayAbilityBase_AddGameplayCueLocalWithParams Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueWithParams
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Params_0                                               (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::AddGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "AddGameplayCueWithParams");

	Params::DCGameplayAbilityBase_AddGameplayCueWithParams Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainer
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ContainerTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   OverrideGameplayLevel                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCountToApply                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsApplyTargetSelf                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UDCGameplayAbilityBase::ApplyEffectContainer(const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData, int32 OverrideGameplayLevel, int32 InCountToApply, bool bIsApplyTargetSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "ApplyEffectContainer");

	Params::DCGameplayAbilityBase_ApplyEffectContainer Parms{};

	Parms.ContainerTag = std::move(ContainerTag);
	Parms.EventData = std::move(EventData);
	Parms.OverrideGameplayLevel = OverrideGameplayLevel;
	Parms.InCountToApply = InCountToApply;
	Parms.bIsApplyTargetSelf = bIsApplyTargetSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainerSpec
// (Native, Public, HasOutParams)
// Parameters:
// struct FDCGameplayEffectContainerSpec   ContainerSpec                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InCountToApply                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsApplyTargetSelf                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UDCGameplayAbilityBase::ApplyEffectContainerSpec(const struct FDCGameplayEffectContainerSpec& ContainerSpec, int32 InCountToApply, bool bIsApplyTargetSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "ApplyEffectContainerSpec");

	Params::DCGameplayAbilityBase_ApplyEffectContainerSpec Parms{};

	Parms.ContainerSpec = std::move(ContainerSpec);
	Parms.InCountToApply = InCountToApply;
	Parms.bIsApplyTargetSelf = bIsApplyTargetSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainerSpecArray
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FDCGameplayEffectContainerSpec>OutContainerSpecArray                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ContainerTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UDCGameplayAbilityBase::ApplyEffectContainerSpecArray(TArray<struct FDCGameplayEffectContainerSpec>& OutContainerSpecArray, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "ApplyEffectContainerSpecArray");

	Params::DCGameplayAbilityBase_ApplyEffectContainerSpecArray Parms{};

	Parms.OutContainerSpecArray = std::move(OutContainerSpecArray);
	Parms.ContainerTag = std::move(ContainerTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutContainerSpecArray = std::move(Parms.OutContainerSpecArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayAbilityBase.ApplyMovementModifier
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     EventTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::ApplyMovementModifier(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "ApplyMovementModifier");

	Params::DCGameplayAbilityBase_ApplyMovementModifier Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.ApplyPremadeSpecArray
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ContainerTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UDCGameplayAbilityBase::ApplyPremadeSpecArray(const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "ApplyPremadeSpecArray");

	Params::DCGameplayAbilityBase_ApplyPremadeSpecArray Parms{};

	Parms.ContainerTag = std::move(ContainerTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayAbilityBase.CopyPremadeSpecArray
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::CopyPremadeSpecArray(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "CopyPremadeSpecArray");

	Params::DCGameplayAbilityBase_CopyPremadeSpecArray Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "ExecuteGameplayCue");

	Params::DCGameplayAbilityBase_ExecuteGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueLocal
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "ExecuteGameplayCueLocal");

	Params::DCGameplayAbilityBase_ExecuteGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueLocalWithParams
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Params_0                                               (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::ExecuteGameplayCueLocalWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "ExecuteGameplayCueLocalWithParams");

	Params::DCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueWithParams
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           Params_0                                               (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::ExecuteGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "ExecuteGameplayCueWithParams");

	Params::DCGameplayAbilityBase_ExecuteGameplayCueWithParams Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.GetEffectAssetTagsInEffectContainerArray
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InContainerTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UDCGameplayAbilityBase::GetEffectAssetTagsInEffectContainerArray(const struct FGameplayTag& InContainerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "GetEffectAssetTagsInEffectContainerArray");

	Params::DCGameplayAbilityBase_GetEffectAssetTagsInEffectContainerArray Parms{};

	Parms.InContainerTag = std::move(InContainerTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayAbilityBase.GetGameplayTriggerTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UDCGameplayAbilityBase::GetGameplayTriggerTag(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "GetGameplayTriggerTag");

	Params::DCGameplayAbilityBase_GetGameplayTriggerTag Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayAbilityBase.GetSetByCallerValueInEffectContainerArray
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ContainerTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     SetByCallerDataTag                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCGameplayAbilityBase::GetSetByCallerValueInEffectContainerArray(const struct FGameplayTag& ContainerTag, const struct FGameplayTag& SetByCallerDataTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "GetSetByCallerValueInEffectContainerArray");

	Params::DCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray Parms{};

	Parms.ContainerTag = std::move(ContainerTag);
	Parms.SetByCallerDataTag = std::move(SetByCallerDataTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerPremadeSpec
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ContainerTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   OverrideGameplayLevel                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::MakeEffectContainerPremadeSpec(class AActor* InActor, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData, int32 OverrideGameplayLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "MakeEffectContainerPremadeSpec");

	Params::DCGameplayAbilityBase_MakeEffectContainerPremadeSpec Parms{};

	Parms.InActor = InActor;
	Parms.ContainerTag = std::move(ContainerTag);
	Parms.EventData = std::move(EventData);
	Parms.OverrideGameplayLevel = OverrideGameplayLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerSpec
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FDCGameplayEffectContainerSpec>OutContainerSpecArray                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ContainerTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   OverrideGameplayLevel                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::MakeEffectContainerSpec(TArray<struct FDCGameplayEffectContainerSpec>* OutContainerSpecArray, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData, int32 OverrideGameplayLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "MakeEffectContainerSpec");

	Params::DCGameplayAbilityBase_MakeEffectContainerSpec Parms{};

	Parms.ContainerTag = std::move(ContainerTag);
	Parms.EventData = std::move(EventData);
	Parms.OverrideGameplayLevel = OverrideGameplayLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutContainerSpecArray != nullptr)
		*OutContainerSpecArray = std::move(Parms.OutContainerSpecArray);
}


// Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerSpecFromContainer
// (Native, Public, HasOutParams)
// Parameters:
// TArray<struct FDCGameplayEffectContainerSpec>OutContainerSpecArray                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDCGameplayEffectContainer       Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   OverrideGameplayLevel                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::MakeEffectContainerSpecFromContainer(TArray<struct FDCGameplayEffectContainerSpec>& OutContainerSpecArray, const struct FDCGameplayEffectContainer& Container, const struct FGameplayEventData& EventData, int32 OverrideGameplayLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "MakeEffectContainerSpecFromContainer");

	Params::DCGameplayAbilityBase_MakeEffectContainerSpecFromContainer Parms{};

	Parms.OutContainerSpecArray = std::move(OutContainerSpecArray);
	Parms.Container = std::move(Container);
	Parms.EventData = std::move(EventData);
	Parms.OverrideGameplayLevel = OverrideGameplayLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutContainerSpecArray = std::move(Parms.OutContainerSpecArray);
}


// Function DungeonCrawler.DCGameplayAbilityBase.RemoveAllAppliedMovementModifiers
// (Native, Protected, BlueprintCallable)

void UDCGameplayAbilityBase::RemoveAllAppliedMovementModifiers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "RemoveAllAppliedMovementModifiers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.RemoveGameplayCue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::RemoveGameplayCue(const struct FGameplayTag& GameplayCueTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "RemoveGameplayCue");

	Params::DCGameplayAbilityBase_RemoveGameplayCue Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.RemoveGameplayCueLocal
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "RemoveGameplayCueLocal");

	Params::DCGameplayAbilityBase_RemoveGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.RemoveMovementModifier
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     EventTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameplayAbilityBase::RemoveMovementModifier(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "RemoveMovementModifier");

	Params::DCGameplayAbilityBase_RemoveMovementModifier Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayAbilityBase.HasMovementModifier
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     EventTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDCGameplayAbilityBase::HasMovementModifier(const struct FGameplayTag& EventTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "HasMovementModifier");

	Params::DCGameplayAbilityBase_HasMovementModifier Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayAbilityBase.IsMovementModifierApplied
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     EventTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDCGameplayAbilityBase::IsMovementModifierApplied(const struct FGameplayTag& EventTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayAbilityBase", "IsMovementModifierApplied");

	Params::DCGameplayAbilityBase_IsMovementModifierApplied Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_Interact.EventReceived
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_Interact::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "EventReceived");

	Params::GA_Interact_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.IsValidData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGA_Interact::IsValidData(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "IsValidData");

	Params::GA_Interact_IsValidData Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_Interact.OnAimDirectionChange
// (Native, Protected)

void UGA_Interact::OnAimDirectionChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnAimDirectionChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnCancelled
// (Final, Native, Protected)

void UGA_Interact::OnCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnCancelled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnDetectUnableInteraction
// (Final, Native, Protected)

void UGA_Interact::OnDetectUnableInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnDetectUnableInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnEndSync
// (Final, Native, Protected)

void UGA_Interact::OnEndSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnEndSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnFinish
// (Final, Native, Protected)

void UGA_Interact::OnFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnInteractBlockTagAdded
// (Final, Native, Protected)

void UGA_Interact::OnInteractBlockTagAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnInteractBlockTagAdded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnPause
// (Final, Native, Protected)

void UGA_Interact::OnPause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnPause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnResume
// (Final, Native, Protected)

void UGA_Interact::OnResume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnResume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnSkillCheck
// (Final, Native, Protected)

void UGA_Interact::OnSkillCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnSkillCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnSkillCheckFailed
// (Final, Native, Protected)

void UGA_Interact::OnSkillCheckFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnSkillCheckFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnSkillCheckFinished
// (Final, Native, Protected)
// Parameters:
// ESkillCheckResult                       Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_Interact::OnSkillCheckFinished(ESkillCheckResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnSkillCheckFinished");

	Params::GA_Interact_OnSkillCheckFinished Parms{};

	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnSkillCheckPerfectSucceed
// (Final, Native, Protected)

void UGA_Interact::OnSkillCheckPerfectSucceed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnSkillCheckPerfectSucceed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnSkillCheckSucceed
// (Final, Native, Protected)

void UGA_Interact::OnSkillCheckSucceed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnSkillCheckSucceed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnStartDelayFinished
// (Final, Native, Protected)

void UGA_Interact::OnStartDelayFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnStartDelayFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnStartSync
// (Final, Native, Protected)

void UGA_Interact::OnStartSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnStartSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Interact.OnVelocityChange
// (Final, Native, Protected)

void UGA_Interact::OnVelocityChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Interact", "OnVelocityChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCExpressmanComponent.OnRep_TargetExpressmanData
// (Final, Native, Private)

void UDCExpressmanComponent::OnRep_TargetExpressmanData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCExpressmanComponent", "OnRep_TargetExpressmanData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCExpressmanComponent.ShowSystemMessage_Client
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class FText                             InMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCExpressmanComponent::ShowSystemMessage_Client(const class FText& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCExpressmanComponent", "ShowSystemMessage_Client");

	Params::DCExpressmanComponent_ShowSystemMessage_Client Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCActorBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorBase", "BroadcastMsgBlueprint");

	Params::DCActorBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorBase.HasActorBegunPlayBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCActorBase::HasActorBegunPlayBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorBase", "HasActorBegunPlayBlueprint");

	Params::DCActorBase_HasActorBegunPlayBlueprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCActorBase.ReceivePreInitializeComponents
// (Event, Protected, BlueprintEvent)

void ADCActorBase::ReceivePreInitializeComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorBase", "ReceivePreInitializeComponents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCActorBase.TerminateBase
// (Native, Public)

void ADCActorBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCActorBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorBase", "UnbindMsg");

	Params::DCActorBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCActorBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorBase", "UnbindMsgAll");

	Params::DCActorBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInteractableActorBase.InteractFailed
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCInteractableActorBase::InteractFailed(class AActor* Interacter, const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInteractableActorBase", "InteractFailed");

	Params::DCInteractableActorBase_InteractFailed Parms{};

	Parms.Interacter = Interacter;
	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInteractableActorBase.InteractFound
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InteractPart                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCInteractableActorBase::InteractFound(class AActor* Interacter, class UPrimitiveComponent* InteractPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInteractableActorBase", "InteractFound");

	Params::DCInteractableActorBase_InteractFound Parms{};

	Parms.Interacter = Interacter;
	Parms.InteractPart = InteractPart;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCInteractableActorBase.InteractLost
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCInteractableActorBase::InteractLost(class AActor* Interacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInteractableActorBase", "InteractLost");

	Params::DCInteractableActorBase_InteractLost Parms{};

	Parms.Interacter = Interacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCInteractableActorBase.InteractStarted
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCInteractableActorBase::InteractStarted(class AActor* Interacter, const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInteractableActorBase", "InteractStarted");

	Params::DCInteractableActorBase_InteractStarted Parms{};

	Parms.Interacter = Interacter;
	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInteractableActorBase.InteractSucceed
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     StateTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     TriggerTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADCInteractableActorBase::InteractSucceed(class AActor* Interacter, const struct FGameplayTag& StateTag, const struct FGameplayTag& TriggerTag, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInteractableActorBase", "InteractSucceed");

	Params::DCInteractableActorBase_InteractSucceed Parms{};

	Parms.Interacter = Interacter;
	Parms.StateTag = std::move(StateTag);
	Parms.TriggerTag = std::move(TriggerTag);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PropsActorBase.CheckQuestUseItem
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemData                        ItemData                                               (Parm, NativeAccessSpecifierPublic)

void APropsActorBase::CheckQuestUseItem(class AActor* Interacter, const struct FItemData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "CheckQuestUseItem");

	Params::PropsActorBase_CheckQuestUseItem Parms{};

	Parms.Interacter = Interacter;
	Parms.ItemData = std::move(ItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PropsActorBase.FinishLooting
// (Final, Native, Public, BlueprintCallable)

void APropsActorBase::FinishLooting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "FinishLooting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PropsActorBase.GameplayTagUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropsActorBase::GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "GameplayTagUpdated");

	Params::PropsActorBase_GameplayTagUpdated Parms{};

	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InCount = InCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PropsActorBase.GetDesignDataAssetProps
// (Final, Native, Public)
// Parameters:
// const class UDesignDataAssetProps*      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDesignDataAssetProps* APropsActorBase::GetDesignDataAssetProps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "GetDesignDataAssetProps");

	Params::PropsActorBase_GetDesignDataAssetProps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.PropsActorBase.GetDesignDataProps
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FDesignDataProps           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDesignDataProps APropsActorBase::GetDesignDataProps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "GetDesignDataProps");

	Params::PropsActorBase_GetDesignDataProps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.PropsActorBase.GetPropsId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FPrimaryAssetId            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FPrimaryAssetId APropsActorBase::GetPropsId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "GetPropsId");

	Params::PropsActorBase_GetPropsId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.PropsActorBase.IsNetLoadOnClient
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 APropsActorBase::IsNetLoadOnClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "IsNetLoadOnClient");

	Params::PropsActorBase_IsNetLoadOnClient Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.PropsActorBase.OnImpactEnduranceExhausted
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ExhaustedTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      GameplayEffectClass                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APropsActorBase::OnImpactEnduranceExhausted(float ExhaustedTime, TSubclassOf<class UGameplayEffect> GameplayEffectClass, const struct FDCGameplayEffectContext& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "OnImpactEnduranceExhausted");

	Params::PropsActorBase_OnImpactEnduranceExhausted Parms{};

	Parms.ExhaustedTime = ExhaustedTime;
	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PropsActorBase.SetPropsId
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InPropsId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropsActorBase::SetPropsId(const struct FPrimaryAssetId& InPropsId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "SetPropsId");

	Params::PropsActorBase_SetPropsId Parms{};

	Parms.InPropsId = std::move(InPropsId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PropsActorBase.SetSoundData
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FPrimaryAssetId                  InSoundDataId                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropsActorBase::SetSoundData(const struct FPrimaryAssetId& InSoundDataId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "SetSoundData");

	Params::PropsActorBase_SetSoundData Parms{};

	Parms.InSoundDataId = std::move(InSoundDataId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PropsActorBase.StartLooting
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCPlayerCharacterBase*           Looter                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APropsActorBase::StartLooting(class ADCPlayerCharacterBase* Looter, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "StartLooting");

	Params::PropsActorBase_StartLooting Parms{};

	Parms.Looter = Looter;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PropsActorBase.UndoUsed
// (Final, Native, Protected, BlueprintCallable)

void APropsActorBase::UndoUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "UndoUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PropsActorBase.UpdateInteractDepthValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   DepthValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropsActorBase::UpdateInteractDepthValue(int32 DepthValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropsActorBase", "UpdateInteractDepthValue");

	Params::PropsActorBase_UpdateInteractDepthValue Parms{};

	Parms.DepthValue = DepthValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.FloorPortalScrollBase.ClosePortalScroll
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADCPlayerCharacterBase*           Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFloorPortalScrollBase::ClosePortalScroll(class ADCPlayerCharacterBase* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FloorPortalScrollBase", "ClosePortalScroll");

	Params::FloorPortalScrollBase_ClosePortalScroll Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LobbyUserSlotBase.SetNicknameBlueprint
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FNickname                        InNickName                                             (Parm, NativeAccessSpecifierPublic)

void ULobbyUserSlotBase::SetNicknameBlueprint(const struct FNickname& InNickName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyUserSlotBase", "SetNicknameBlueprint");

	Params::LobbyUserSlotBase_SetNicknameBlueprint Parms{};

	Parms.InNickName = std::move(InNickName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCChannelPlayerListEntryWidget.OnRightClicked
// (Native, Protected)

void UDCChannelPlayerListEntryWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCChannelPlayerListEntryWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.BindMsgOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBindMsgNode*                     InMsgDynamicDelegate                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonActivatableWidgetBase::BindMsgOwner(class UScriptStruct* InMsgType, class UBindMsgNode* InMsgDynamicDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "BindMsgOwner");

	Params::DCCommonActivatableWidgetBase_BindMsgOwner Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InMsgDynamicDelegate = InMsgDynamicDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonActivatableWidgetBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "BroadcastMsgBlueprint");

	Params::DCCommonActivatableWidgetBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.DisableVirtualCursor
// (Final, Native, Public, BlueprintCallable)

void UDCCommonActivatableWidgetBase::DisableVirtualCursor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "DisableVirtualCursor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.EnableVirtualCursor
// (Final, Native, Public, BlueprintCallable)

void UDCCommonActivatableWidgetBase::EnableVirtualCursor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "EnableVirtualCursor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.GetOwningBaseInterfaceBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBaseInterface>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class IBaseInterface> UDCCommonActivatableWidgetBase::GetOwningBaseInterfaceBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "GetOwningBaseInterfaceBlueprint");

	Params::DCCommonActivatableWidgetBase_GetOwningBaseInterfaceBlueprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.IsSpectating
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCCommonActivatableWidgetBase::IsSpectating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "IsSpectating");

	Params::DCCommonActivatableWidgetBase_IsSpectating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.TerminateBase
// (Native, Public)

void UDCCommonActivatableWidgetBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonActivatableWidgetBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "UnbindMsg");

	Params::DCCommonActivatableWidgetBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonActivatableWidgetBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "UnbindMsgAll");

	Params::DCCommonActivatableWidgetBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.UnbindMsgAllOwner
// (Final, Native, Public, BlueprintCallable)

void UDCCommonActivatableWidgetBase::UnbindMsgAllOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "UnbindMsgAllOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonActivatableWidgetBase.UnbindMsgOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonActivatableWidgetBase::UnbindMsgOwner(class UScriptStruct* InMsgType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonActivatableWidgetBase", "UnbindMsgOwner");

	Params::DCCommonActivatableWidgetBase_UnbindMsgOwner Parms{};

	Parms.InMsgType = InMsgType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameGroupWidgetBase.OnGroupWidgetVisibilityChanged
// (Final, Native, Private)
// Parameters:
// ESlateVisibility                        NewVisibility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameGroupWidgetBase::OnGroupWidgetVisibilityChanged(ESlateVisibility NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameGroupWidgetBase", "OnGroupWidgetVisibilityChanged");

	Params::GameGroupWidgetBase_OnGroupWidgetVisibilityChanged Parms{};

	Parms.NewVisibility = NewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameGroupWidgetBase.OnHidden
// (Native, Event, Protected, BlueprintEvent)

void UGameGroupWidgetBase::OnHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameGroupWidgetBase", "OnHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameGroupWidgetBase.OnVisible
// (Native, Event, Protected, BlueprintEvent)

void UGameGroupWidgetBase::OnVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameGroupWidgetBase", "OnVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMusicSelectGroupWidget.OnCurrentMusicSlotChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UGameMusicSlotWidget*             InSelectedSlot                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMusicSelectGroupWidget::OnCurrentMusicSlotChanged(class UGameMusicSlotWidget* InSelectedSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicSelectGroupWidget", "OnCurrentMusicSlotChanged");

	Params::GameMusicSelectGroupWidget_OnCurrentMusicSlotChanged Parms{};

	Parms.InSelectedSlot = InSelectedSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMusicSelectGroupWidget.OnMusicSelectClose
// (Event, Protected, BlueprintEvent)

void UGameMusicSelectGroupWidget::OnMusicSelectClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicSelectGroupWidget", "OnMusicSelectClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMusicSelectGroupWidget.OnMusicSelectPopup
// (Event, Protected, BlueprintEvent)

void UGameMusicSelectGroupWidget::OnMusicSelectPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicSelectGroupWidget", "OnMusicSelectPopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMusicSelectGroupWidget.OnSelectedMusicIndexChanged
// (Final, Native, Protected, BlueprintCallable)

void UGameMusicSelectGroupWidget::OnSelectedMusicIndexChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicSelectGroupWidget", "OnSelectedMusicIndexChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentInventoryComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "BroadcastMsgBlueprint");

	Params::EquipmentInventoryComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.GetCurrentHoldingItemData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FItemData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FItemData UEquipmentInventoryComponent::GetCurrentHoldingItemData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "GetCurrentHoldingItemData");

	Params::EquipmentInventoryComponent_GetCurrentHoldingItemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.EquipmentInventoryComponent.HideEquippedItemActorsInGame
// (Final, Native, Public)
// Parameters:
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentInventoryComponent::HideEquippedItemActorsInGame(bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "HideEquippedItemActorsInGame");

	Params::EquipmentInventoryComponent_HideEquippedItemActorsInGame Parms{};

	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.OnQuickSlotApplied
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UEquipmentInventoryComponent::OnQuickSlotApplied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "OnQuickSlotApplied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.OnRep_EquipAnimData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCEquipAnimData                 OldEquipAnimData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEquipmentInventoryComponent::OnRep_EquipAnimData(const struct FDCEquipAnimData& OldEquipAnimData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "OnRep_EquipAnimData");

	Params::EquipmentInventoryComponent_OnRep_EquipAnimData Parms{};

	Parms.OldEquipAnimData = std::move(OldEquipAnimData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.OnRep_EquippedItemActors
// (Final, Native, Private)
// Parameters:
// TArray<class AItemActor*>               OldEquippedItemActors                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEquipmentInventoryComponent::OnRep_EquippedItemActors(const TArray<class AItemActor*>& OldEquippedItemActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "OnRep_EquippedItemActors");

	Params::EquipmentInventoryComponent_OnRep_EquippedItemActors Parms{};

	Parms.OldEquippedItemActors = std::move(OldEquippedItemActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.OnRep_InventoryData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCEquipmentInventoryData        OldInventoryData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEquipmentInventoryComponent::OnRep_InventoryData(const struct FDCEquipmentInventoryData& OldInventoryData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "OnRep_InventoryData");

	Params::EquipmentInventoryComponent_OnRep_InventoryData Parms{};

	Parms.OldInventoryData = std::move(OldInventoryData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.OnRep_QuickSlotData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCQuickSlotData                 OldQuickSlotData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UEquipmentInventoryComponent::OnRep_QuickSlotData(const struct FDCQuickSlotData& OldQuickSlotData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "OnRep_QuickSlotData");

	Params::EquipmentInventoryComponent_OnRep_QuickSlotData Parms{};

	Parms.OldQuickSlotData = std::move(OldQuickSlotData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.OnRep_SheathItemActors
// (Final, Native, Private)
// Parameters:
// TArray<class AItemActor*>               OldSheathItemActors                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEquipmentInventoryComponent::OnRep_SheathItemActors(const TArray<class AItemActor*>& OldSheathItemActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "OnRep_SheathItemActors");

	Params::EquipmentInventoryComponent_OnRep_SheathItemActors Parms{};

	Parms.OldSheathItemActors = std::move(OldSheathItemActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.TerminateBase
// (Native, Public)

void UEquipmentInventoryComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentInventoryComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "UnbindMsg");

	Params::EquipmentInventoryComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentInventoryComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "UnbindMsgAll");

	Params::EquipmentInventoryComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.ClientReqChangeQuickSlot
// (Net, NetReliable, Native, Event, Public, NetClient, Const)
// Parameters:
// EEquipmentQuickSlotType                 QuickSlotType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipCondition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentInventoryComponent::ClientReqChangeQuickSlot(EEquipmentQuickSlotType QuickSlotType, bool bSkipCondition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "ClientReqChangeQuickSlot");

	Params::EquipmentInventoryComponent_ClientReqChangeQuickSlot Parms{};

	Parms.QuickSlotType = QuickSlotType;
	Parms.bSkipCondition = bSkipCondition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentInventoryComponent.GetCurrentActiveSlotType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentQuickSlotType                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEquipmentQuickSlotType UEquipmentInventoryComponent::GetCurrentActiveSlotType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "GetCurrentActiveSlotType");

	Params::EquipmentInventoryComponent_GetCurrentActiveSlotType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.EquipmentInventoryComponent.GetItemsBySlotType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ItemSlotType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UItem*>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UItem*> UEquipmentInventoryComponent::GetItemsBySlotType(const struct FGameplayTag& ItemSlotType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInventoryComponent", "GetItemsBySlotType");

	Params::EquipmentInventoryComponent_GetItemsBySlotType Parms{};

	Parms.ItemSlotType = std::move(ItemSlotType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDungeonResultGroupWidget.OnDungeonResultGroupVisibilityChanged
// (Final, Native, Private)
// Parameters:
// ESlateVisibility                        NewVisibility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCDungeonResultGroupWidget::OnDungeonResultGroupVisibilityChanged(ESlateVisibility NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultGroupWidget", "OnDungeonResultGroupVisibilityChanged");

	Params::DCDungeonResultGroupWidget_OnDungeonResultGroupVisibilityChanged Parms{};

	Parms.NewVisibility = NewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemInstallBase.EventReceived
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ItemInstallBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemInstallBase", "EventReceived");

	Params::GA_ItemInstallBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemInstallBase.OnAimDirectionChange
// (Final, Native, Private)

void UGA_ItemInstallBase::OnAimDirectionChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemInstallBase", "OnAimDirectionChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemInstallBase.OnDistanceChanged
// (Final, Native, Private)

void UGA_ItemInstallBase::OnDistanceChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemInstallBase", "OnDistanceChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemInstallBase.OnFinishConsume
// (Final, Native, Private)

void UGA_ItemInstallBase::OnFinishConsume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemInstallBase", "OnFinishConsume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemInstallBase.OnNetSync
// (Final, Native, Private)

void UGA_ItemInstallBase::OnNetSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemInstallBase", "OnNetSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemInstallBase.OnVelocityChange
// (Final, Native, Private)

void UGA_ItemInstallBase::OnVelocityChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemInstallBase", "OnVelocityChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_LobbyEmoteBase.OnCancelled
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_LobbyEmoteBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_LobbyEmoteBase", "OnCancelled");

	Params::GA_LobbyEmoteBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_LobbyEmoteBase.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_LobbyEmoteBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_LobbyEmoteBase", "OnCompleted");

	Params::GA_LobbyEmoteBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_LobbyEmoteBase.ReceivedEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_LobbyEmoteBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_LobbyEmoteBase", "ReceivedEvent");

	Params::GA_LobbyEmoteBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.BindMsgOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBindMsgNode*                     InMsgDynamicDelegate                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonButtonBase::BindMsgOwner(class UScriptStruct* InMsgType, class UBindMsgNode* InMsgDynamicDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "BindMsgOwner");

	Params::DCCommonButtonBase_BindMsgOwner Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InMsgDynamicDelegate = InMsgDynamicDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonButtonBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "BroadcastMsgBlueprint");

	Params::DCCommonButtonBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.GetOwningBaseInterfaceBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBaseInterface>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class IBaseInterface> UDCCommonButtonBase::GetOwningBaseInterfaceBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "GetOwningBaseInterfaceBlueprint");

	Params::DCCommonButtonBase_GetOwningBaseInterfaceBlueprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCommonButtonBase.GetTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCCommonButtonBase::GetTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "GetTooltipWidget");

	Params::DCCommonButtonBase_GetTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCommonButtonBase.OnCommonButtonClicked
// (Final, Native, Private)

void UDCCommonButtonBase::OnCommonButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "OnCommonButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.PlayClickSound
// (Final, Native, Private)

void UDCCommonButtonBase::PlayClickSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "PlayClickSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.SetBlockClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsBlocked                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonButtonBase::SetBlockClick(bool bInIsBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "SetBlockClick");

	Params::DCCommonButtonBase_SetBlockClick Parms{};

	Parms.bInIsBlocked = bInIsBlocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.SetButtonText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InButtonText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCCommonButtonBase::SetButtonText(const class FText& InButtonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "SetButtonText");

	Params::DCCommonButtonBase_SetButtonText Parms{};

	Parms.InButtonText = std::move(InButtonText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.TerminateBase
// (Native, Public)

void UDCCommonButtonBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonButtonBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "UnbindMsg");

	Params::DCCommonButtonBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonButtonBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "UnbindMsgAll");

	Params::DCCommonButtonBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.UnbindMsgAllOwner
// (Final, Native, Public, BlueprintCallable)

void UDCCommonButtonBase::UnbindMsgAllOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "UnbindMsgAllOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonBase.UnbindMsgOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommonButtonBase::UnbindMsgOwner(class UScriptStruct* InMsgType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonBase", "UnbindMsgOwner");

	Params::DCCommonButtonBase_UnbindMsgOwner Parms{};

	Parms.InMsgType = InMsgType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameAmmoWidget.OnEquipItemActorsEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class AItemActor*>               ItemActors                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGameAmmoWidget::OnEquipItemActorsEvent(const TArray<class AItemActor*>& ItemActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameAmmoWidget", "OnEquipItemActorsEvent");

	Params::GameAmmoWidget_OnEquipItemActorsEvent Parms{};

	Parms.ItemActors = std::move(ItemActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterInventoryWidget.GetTitle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCCharacterInventoryWidget::GetTitle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterInventoryWidget", "GetTitle");

	Params::DCCharacterInventoryWidget_GetTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterInventoryWidget.GetTitleColor
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UDCCharacterInventoryWidget::GetTitleColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterInventoryWidget", "GetTitleColor");

	Params::DCCharacterInventoryWidget_GetTitleColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_PickUp.OnPickedUp
// (Final, Native, Private)
// Parameters:
// class AActor*                           ItemHolderToPickUp                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldDestroy                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PickUp::OnPickedUp(class AActor* ItemHolderToPickUp, bool bShouldDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PickUp", "OnPickedUp");

	Params::GA_PickUp_OnPickedUp Parms{};

	Parms.ItemHolderToPickUp = ItemHolderToPickUp;
	Parms.bShouldDestroy = bShouldDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PickUp.OnStartSync
// (Final, Native, Private)

void UGA_PickUp::OnStartSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PickUp", "OnStartSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemHolderActorBase.InitItemHolderActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FItemData                        InItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AItemHolderActorBase::InitItemHolderActor(const struct FItemData& InItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemHolderActorBase", "InitItemHolderActor");

	Params::ItemHolderActorBase_InitItemHolderActor Parms{};

	Parms.InItemData = std::move(InItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemHolderActorBase.OnRep_ArtDataItem
// (Native, Protected)
// Parameters:
// class UArtDataItem*                     OldArtDataItem                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemHolderActorBase::OnRep_ArtDataItem(class UArtDataItem* OldArtDataItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemHolderActorBase", "OnRep_ArtDataItem");

	Params::ItemHolderActorBase_OnRep_ArtDataItem Parms{};

	Parms.OldArtDataItem = OldArtDataItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemHolderActorBase.OnRep_ItemInfo
// (Native, Protected, HasOutParams)
// Parameters:
// struct FDCItemInfo                      OldItemInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemHolderActorBase::OnRep_ItemInfo(const struct FDCItemInfo& OldItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemHolderActorBase", "OnRep_ItemInfo");

	Params::ItemHolderActorBase_OnRep_ItemInfo Parms{};

	Parms.OldItemInfo = std::move(OldItemInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemHolderActorBase.OverrideItemArtData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UArtDataItem*                     NewItemArtData                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemHolderActorBase::OverrideItemArtData(class UArtDataItem* NewItemArtData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemHolderActorBase", "OverrideItemArtData");

	Params::ItemHolderActorBase_OverrideItemArtData Parms{};

	Parms.NewItemArtData = NewItemArtData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemHolderActorBase.SetItemId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InItemId                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemHolderActorBase::SetItemId(const struct FPrimaryAssetId& InItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemHolderActorBase", "SetItemId");

	Params::ItemHolderActorBase_SetItemId Parms{};

	Parms.InItemId = std::move(InItemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemHolderActorBase.GetItemId
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId AItemHolderActorBase::GetItemId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemHolderActorBase", "GetItemId");

	Params::ItemHolderActorBase_GetItemId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitGenericGameplayTagEvent.WaitGenericGameplayTagEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOptionalExternalTarget                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitGenericGameplayTagEvent*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitGenericGameplayTagEvent* UDCAT_WaitGenericGameplayTagEvent::WaitGenericGameplayTagEvent(class UGameplayAbility* OwningAbility, class AActor* InOptionalExternalTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitGenericGameplayTagEvent", "WaitGenericGameplayTagEvent");

	Params::DCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InOptionalExternalTarget = InOptionalExternalTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCQuestLogDealTableWidget.OnButtonAccept
// (Final, Native, Private)

void UDCQuestLogDealTableWidget::OnButtonAccept()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogDealTableWidget", "OnButtonAccept");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCQuestLogDealTableWidget.OnButtonComplete
// (Final, Native, Private)

void UDCQuestLogDealTableWidget::OnButtonComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogDealTableWidget", "OnButtonComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCQuestLogDealTableWidget.OnButtonItemDeliver
// (Final, Native, Private)

void UDCQuestLogDealTableWidget::OnButtonItemDeliver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogDealTableWidget", "OnButtonItemDeliver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCQuestLogDealTableWidget.OnMatchStateChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsMatching                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCQuestLogDealTableWidget::OnMatchStateChange(bool bIsMatching)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogDealTableWidget", "OnMatchStateChange");

	Params::DCQuestLogDealTableWidget_OnMatchStateChange Parms{};

	Parms.bIsMatching = bIsMatching;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCQuestLogDealTableWidget.OnQuestInfoUpdated
// (Event, Protected, BlueprintEvent)

void UDCQuestLogDealTableWidget::OnQuestInfoUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogDealTableWidget", "OnQuestInfoUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCQuestLogDealTableWidget.GetQuestState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCQuestState                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCQuestState UDCQuestLogDealTableWidget::GetQuestState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogDealTableWidget", "GetQuestState");

	Params::DCQuestLogDealTableWidget_GetQuestState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.KarmaReportWidgetBase.OnFMsgWidgetKarmaReportActionResponseBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetKarmaReportActionResponseInMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UKarmaReportWidgetBase::OnFMsgWidgetKarmaReportActionResponseBlueprint(const struct FMsgWidgetKarmaReportActionResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KarmaReportWidgetBase", "OnFMsgWidgetKarmaReportActionResponseBlueprint");

	Params::KarmaReportWidgetBase_OnFMsgWidgetKarmaReportActionResponseBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.KarmaReportWidgetBase.OnFMsgWidgetKarmaReportInfoNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetKarmaReportInfoNotify  InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UKarmaReportWidgetBase::OnFMsgWidgetKarmaReportInfoNotifyBlueprint(const struct FMsgWidgetKarmaReportInfoNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KarmaReportWidgetBase", "OnFMsgWidgetKarmaReportInfoNotifyBlueprint");

	Params::KarmaReportWidgetBase_OnFMsgWidgetKarmaReportInfoNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.KarmaReportWidgetBase.OnUpdateFame
// (Final, Native, Protected, BlueprintCallable)

void UKarmaReportWidgetBase::OnUpdateFame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KarmaReportWidgetBase", "OnUpdateFame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.AddPlayerMappableConfigByTag
// (BlueprintCosmetic, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InputConfigTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FModifyContextOptions            Options                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDCEnhancedInputLocalPlayerSubsystem::AddPlayerMappableConfigByTag(const struct FGameplayTag& InputConfigTag, const struct FModifyContextOptions& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEnhancedInputLocalPlayerSubsystem", "AddPlayerMappableConfigByTag");

	Params::DCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag Parms{};

	Parms.InputConfigTag = std::move(InputConfigTag);
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.RemovePlayerMappableConfigByTag
// (BlueprintCosmetic, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InputConfigTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FModifyContextOptions            Options                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDCEnhancedInputLocalPlayerSubsystem::RemovePlayerMappableConfigByTag(const struct FGameplayTag& InputConfigTag, const struct FModifyContextOptions& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEnhancedInputLocalPlayerSubsystem", "RemovePlayerMappableConfigByTag");

	Params::DCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag Parms{};

	Parms.InputConfigTag = std::move(InputConfigTag);
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.GetInputConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ConfigTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDCInputConfig*             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDCInputConfig* UDCEnhancedInputLocalPlayerSubsystem::GetInputConfig(const struct FGameplayTag& ConfigTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEnhancedInputLocalPlayerSubsystem", "GetInputConfig");

	Params::DCEnhancedInputLocalPlayerSubsystem_GetInputConfig Parms{};

	Parms.ConfigTag = std::move(ConfigTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.GetPlayerMappableInputConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ConfigTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UPlayerMappableInputConfig* ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UPlayerMappableInputConfig* UDCEnhancedInputLocalPlayerSubsystem::GetPlayerMappableInputConfig(const struct FGameplayTag& ConfigTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEnhancedInputLocalPlayerSubsystem", "GetPlayerMappableInputConfig");

	Params::DCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig Parms{};

	Parms.ConfigTag = std::move(ConfigTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskAttributeChanged.ListenForAttributeChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskAttributeChanged*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskAttributeChanged", "ListenForAttributeChange");

	Params::AsyncTaskAttributeChanged_ListenForAttributeChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskAttributeChanged.ListenForAttributesChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayAttribute>       Attributes                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UAsyncTaskAttributeChanged*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributesChange(class UAbilitySystemComponent* AbilitySystemComponent, const TArray<struct FGameplayAttribute>& Attributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskAttributeChanged", "ListenForAttributesChange");

	Params::AsyncTaskAttributeChanged_ListenForAttributesChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Attributes = std::move(Attributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskAttributeChanged.EndTask
// (Final, Native, Public, BlueprintCallable)

void UAsyncTaskAttributeChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskAttributeChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AsyncTaskCooldownChanged.ListenForCooldownChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            CooldownTags                                           (Parm, NativeAccessSpecifierPublic)
// bool                                    UseServerCooldown                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskCooldownChanged*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskCooldownChanged* UAsyncTaskCooldownChanged::ListenForCooldownChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTagContainer& CooldownTags, bool UseServerCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskCooldownChanged", "ListenForCooldownChange");

	Params::AsyncTaskCooldownChanged_ListenForCooldownChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.CooldownTags = std::move(CooldownTags);
	Parms.UseServerCooldown = UseServerCooldown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskCooldownChanged.EndTask
// (Final, Native, Public, BlueprintCallable)

void UAsyncTaskCooldownChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskCooldownChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AsyncTaskEffectInhibitionChanged.ListenForGameplayInhibitionChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskEffectInhibitionChanged*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskEffectInhibitionChanged* UAsyncTaskEffectInhibitionChanged::ListenForGameplayInhibitionChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskEffectInhibitionChanged", "ListenForGameplayInhibitionChange");

	Params::AsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.EffectGameplayTag = std::move(EffectGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskEffectInhibitionChanged.EndTask
// (Final, Native, Public, BlueprintCallable)

void UAsyncTaskEffectInhibitionChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskEffectInhibitionChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayerCharacterCaptureActor.GetCharacterMeshAnimInstance
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* APlayerCharacterCaptureActor::GetCharacterMeshAnimInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterCaptureActor", "GetCharacterMeshAnimInstance");

	Params::PlayerCharacterCaptureActor_GetCharacterMeshAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.PlayerCharacterCaptureActor.OnItemEquipped
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UAnimationAsset*                  ItemStandIdle                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ItemHandType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ItemSlotType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacterCaptureActor::OnItemEquipped(const class UAnimationAsset* ItemStandIdle, const struct FGameplayTag& ItemHandType, const struct FGameplayTag& ItemSlotType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterCaptureActor", "OnItemEquipped");

	Params::PlayerCharacterCaptureActor_OnItemEquipped Parms{};

	Parms.ItemStandIdle = ItemStandIdle;
	Parms.ItemHandType = std::move(ItemHandType);
	Parms.ItemSlotType = std::move(ItemSlotType);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayerCharacterCaptureActor.ResetMeshRotation
// (Final, Native, Protected, BlueprintCallable)

void APlayerCharacterCaptureActor::ResetMeshRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterCaptureActor", "ResetMeshRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayerCharacterCaptureActor.SetMeshRotation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InYaw                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacterCaptureActor::SetMeshRotation(float InYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterCaptureActor", "SetMeshRotation");

	Params::PlayerCharacterCaptureActor_SetMeshRotation Parms{};

	Parms.InYaw = InYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayerCharacterCaptureActor.SetMeshRotationSpeedMultiplier
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacterCaptureActor::SetMeshRotationSpeedMultiplier(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterCaptureActor", "SetMeshRotationSpeedMultiplier");

	Params::PlayerCharacterCaptureActor_SetMeshRotationSpeedMultiplier Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayerCharacterCaptureActor.SetStartRotateLocation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InStartPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacterCaptureActor::SetStartRotateLocation(float InStartPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterCaptureActor", "SetStartRotateLocation");

	Params::PlayerCharacterCaptureActor_SetStartRotateLocation Parms{};

	Parms.InStartPosition = InStartPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayerCharacterCaptureActor.GetRenderTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTextureRenderTarget2D*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2D* APlayerCharacterCaptureActor::GetRenderTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterCaptureActor", "GetRenderTarget");

	Params::PlayerCharacterCaptureActor_GetRenderTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WindforceToActor.WindforceToActor
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCPlayerCharacterBase*           TargetCharcter                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WindVector                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WindforceToActor*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WindforceToActor* UDCAT_WindforceToActor::WindforceToActor(class UGameplayAbility* OwningAbility, class ADCPlayerCharacterBase* TargetCharcter, const struct FVector& WindVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WindforceToActor", "WindforceToActor");

	Params::DCAT_WindforceToActor_WindforceToActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetCharcter = TargetCharcter;
	Parms.WindVector = std::move(WindVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskEffectStackChanged.ListenForGameplayEffectStackChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskEffectStackChanged*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskEffectStackChanged* UAsyncTaskEffectStackChanged::ListenForGameplayEffectStackChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskEffectStackChanged", "ListenForGameplayEffectStackChange");

	Params::AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.EffectGameplayTag = std::move(EffectGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskEffectStackChanged.EndTask
// (Final, Native, Public, BlueprintCallable)

void UAsyncTaskEffectStackChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskEffectStackChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     WithTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     WithoutTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeTriggeredAbilities                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskWaitGAActivated*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskWaitGAActivated* UAsyncTaskWaitGAActivated::WaitForAbilityActivate(class AActor* TargetActor, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, bool IncludeTriggeredAbilities, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskWaitGAActivated", "WaitForAbilityActivate");

	Params::AsyncTaskWaitGAActivated_WaitForAbilityActivate Parms{};

	Parms.TargetActor = TargetActor;
	Parms.WithTag = std::move(WithTag);
	Parms.WithoutTag = std::move(WithoutTag);
	Parms.IncludeTriggeredAbilities = IncludeTriggeredAbilities;
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivate_Query
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagQuery                Query                                                  (Parm, NativeAccessSpecifierPublic)
// bool                                    IncludeTriggeredAbilities                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskWaitGAActivated*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskWaitGAActivated* UAsyncTaskWaitGAActivated::WaitForAbilityActivate_Query(class AActor* TargetActor, const struct FGameplayTagQuery& Query, bool IncludeTriggeredAbilities, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskWaitGAActivated", "WaitForAbilityActivate_Query");

	Params::AsyncTaskWaitGAActivated_WaitForAbilityActivate_Query Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Query = std::move(Query);
	Parms.IncludeTriggeredAbilities = IncludeTriggeredAbilities;
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivateWithTagRequirements
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         TagRequirements                                        (Parm, NativeAccessSpecifierPublic)
// bool                                    IncludeTriggeredAbilities                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskWaitGAActivated*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskWaitGAActivated* UAsyncTaskWaitGAActivated::WaitForAbilityActivateWithTagRequirements(class AActor* TargetActor, const struct FGameplayTagRequirements& TagRequirements, bool IncludeTriggeredAbilities, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskWaitGAActivated", "WaitForAbilityActivateWithTagRequirements");

	Params::AsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TagRequirements = std::move(TagRequirements);
	Parms.IncludeTriggeredAbilities = IncludeTriggeredAbilities;
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskWaitGAActivated.OnAbilityActivate
// (Final, Native, Protected)
// Parameters:
// class UGameplayAbility*                 ActivatedAbility                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncTaskWaitGAActivated::OnAbilityActivate(class UGameplayAbility* ActivatedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskWaitGAActivated", "OnAbilityActivate");

	Params::AsyncTaskWaitGAActivated_OnAbilityActivate Parms{};

	Parms.ActivatedAbility = ActivatedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEnd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     WithTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     WithoutTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskWaitGAEnded*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskWaitGAEnded* UAsyncTaskWaitGAEnded::WaitForAbilityEnd(class AActor* TargetActor, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskWaitGAEnded", "WaitForAbilityEnd");

	Params::AsyncTaskWaitGAEnded_WaitForAbilityEnd Parms{};

	Parms.TargetActor = TargetActor;
	Parms.WithTag = std::move(WithTag);
	Parms.WithoutTag = std::move(WithoutTag);
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEnd_Query
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagQuery                Query                                                  (Parm, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskWaitGAEnded*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskWaitGAEnded* UAsyncTaskWaitGAEnded::WaitForAbilityEnd_Query(class AActor* TargetActor, const struct FGameplayTagQuery& Query, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskWaitGAEnded", "WaitForAbilityEnd_Query");

	Params::AsyncTaskWaitGAEnded_WaitForAbilityEnd_Query Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Query = std::move(Query);
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEndWithTagRequirements
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         TagRequirements                                        (Parm, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskWaitGAEnded*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskWaitGAEnded* UAsyncTaskWaitGAEnded::WaitForAbilityEndWithTagRequirements(class AActor* TargetActor, const struct FGameplayTagRequirements& TagRequirements, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskWaitGAEnded", "WaitForAbilityEndWithTagRequirements");

	Params::AsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TagRequirements = std::move(TagRequirements);
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AsyncTaskWaitGAEnded.OnAbilityEnded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FAbilityEndedData                AbilityEndedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAsyncTaskWaitGAEnded::OnAbilityEnded(const struct FAbilityEndedData& AbilityEndedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskWaitGAEnded", "OnAbilityEnded");

	Params::AsyncTaskWaitGAEnded_OnAbilityEnded Parms{};

	Parms.AbilityEndedData = std::move(AbilityEndedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AsyncTaskWaitGameplayEvent.WaitGameplayEventToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyTriggerOnce                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyMatchExact                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskWaitGameplayEvent*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskWaitGameplayEvent* UAsyncTaskWaitGameplayEvent::WaitGameplayEventToActor(class AActor* TargetActor, const struct FGameplayTag& EventTag, bool OnlyTriggerOnce, bool OnlyMatchExact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskWaitGameplayEvent", "WaitGameplayEventToActor");

	Params::AsyncTaskWaitGameplayEvent_WaitGameplayEventToActor Parms{};

	Parms.TargetActor = TargetActor;
	Parms.EventTag = std::move(EventTag);
	Parms.OnlyTriggerOnce = OnlyTriggerOnce;
	Parms.OnlyMatchExact = OnlyMatchExact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DungeonCrawler.AsyncTaskWaitGameplayEvent.EventReceivedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FGameplayEventData               Payload                                                (Parm, NativeAccessSpecifierPublic)

void UAsyncTaskWaitGameplayEvent::EventReceivedDelegate__DelegateSignature(const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskWaitGameplayEvent", "EventReceivedDelegate__DelegateSignature");

	Params::AsyncTaskWaitGameplayEvent_EventReceivedDelegate__DelegateSignature Parms{};

	Parms.Payload = std::move(Payload);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ItemWidget.OnCanEquipByRequirementsChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    bCanEquip                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EItemRequirementType>            RequirementsNotMatched                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UItemWidget::OnCanEquipByRequirementsChanged(bool bCanEquip, const TArray<EItemRequirementType>& RequirementsNotMatched)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemWidget", "OnCanEquipByRequirementsChanged");

	Params::ItemWidget_OnCanEquipByRequirementsChanged Parms{};

	Parms.bCanEquip = bCanEquip;
	Parms.RequirementsNotMatched = std::move(RequirementsNotMatched);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ItemWidget.OnItemData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FItemData                        NewItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FItemData                        OldItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemWidget::OnItemData(const struct FItemData& NewItemData, const struct FItemData& OldItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemWidget", "OnItemData");

	Params::ItemWidget_OnItemData Parms{};

	Parms.NewItemData = std::move(NewItemData);
	Parms.OldItemData = std::move(OldItemData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ItemWidget.SetItemData
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FItemData                        NewItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemWidget::SetItemData(const struct FItemData& NewItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemWidget", "SetItemData");

	Params::ItemWidget_SetItemData Parms{};

	Parms.NewItemData = std::move(NewItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemWidget.SetItemIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTexture2D*                       ItemIconTexture                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemInventorySize               ItemInventorySize                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UItemWidget::SetItemIcon(class UTexture2D* ItemIconTexture, const struct FItemInventorySize& ItemInventorySize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemWidget", "SetItemIcon");

	Params::ItemWidget_SetItemIcon Parms{};

	Parms.ItemIconTexture = ItemIconTexture;
	Parms.ItemInventorySize = std::move(ItemInventorySize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemWidget.SetItemOwnerActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InItemOwnedActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemWidget::SetItemOwnerActor(class AActor* InItemOwnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemWidget", "SetItemOwnerActor");

	Params::ItemWidget_SetItemOwnerActor Parms{};

	Parms.InItemOwnedActor = InItemOwnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemWidget.GetItemData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FItemData UItemWidget::GetItemData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemWidget", "GetItemData");

	Params::ItemWidget_GetItemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ItemWidget.GetItemIconImage
// (Final, Native, Public, Const)
// Parameters:
// class UImage*                           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UImage* UItemWidget::GetItemIconImage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemWidget", "GetItemIconImage");

	Params::ItemWidget_GetItemIconImage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ControllableItemWidget.DropAllItem
// (Final, Native, Protected)

void UControllableItemWidget::DropAllItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllableItemWidget", "DropAllItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ControllableItemWidget.DropOneItem
// (Final, Native, Protected)

void UControllableItemWidget::DropOneItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllableItemWidget", "DropOneItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ControllableItemWidget.OnLeftMouseButtonDoubleClick
// (Native, Protected, BlueprintCallable)
// Parameters:
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UControllableItemWidget::OnLeftMouseButtonDoubleClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllableItemWidget", "OnLeftMouseButtonDoubleClick");

	Params::ControllableItemWidget_OnLeftMouseButtonDoubleClick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ControllableItemWidget.OnLeftMouseButtonDown
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGeometry                        MyGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInventoryItemLinkButtonPressed                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UControllableItemWidget::OnLeftMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent, bool bInventoryItemLinkButtonPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllableItemWidget", "OnLeftMouseButtonDown");

	Params::ControllableItemWidget_OnLeftMouseButtonDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);
	Parms.bInventoryItemLinkButtonPressed = bInventoryItemLinkButtonPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ControllableItemWidget.OnRightMouseButtonDown
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGeometry                        MyGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInventoryDropButtonPressed                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInventorySplitButtonPressed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UControllableItemWidget::OnRightMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent, bool bInventoryDropButtonPressed, bool bInventorySplitButtonPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllableItemWidget", "OnRightMouseButtonDown");

	Params::ControllableItemWidget_OnRightMouseButtonDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);
	Parms.bInventoryDropButtonPressed = bInventoryDropButtonPressed;
	Parms.bInventorySplitButtonPressed = bInventorySplitButtonPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ControllableItemWidget.QuickMoveItem
// (Final, Native, Protected)

void UControllableItemWidget::QuickMoveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllableItemWidget", "QuickMoveItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AttackInputManagerComponent.EventReceived
// (Final, Native, Protected)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UAttackInputManagerComponent::EventReceived(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackInputManagerComponent", "EventReceived");

	Params::AttackInputManagerComponent_EventReceived Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AttackInputManagerComponent.GetCurrentTriggerTag
// (Final, Native, Public)
// Parameters:
// struct FGameplayTag                     TriggerTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UAttackInputManagerComponent::GetCurrentTriggerTag(const struct FGameplayTag& TriggerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackInputManagerComponent", "GetCurrentTriggerTag");

	Params::AttackInputManagerComponent_GetCurrentTriggerTag Parms{};

	Parms.TriggerTag = std::move(TriggerTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.AttackInputManagerComponent.HandleAttackInput
// (Final, Native, Public)
// Parameters:
// struct FGameplayTag                     InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttackInputManagerComponent::HandleAttackInput(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackInputManagerComponent", "HandleAttackInput");

	Params::AttackInputManagerComponent_HandleAttackInput Parms{};

	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AttackInputManagerComponent.OnAbilityActivate
// (Final, Native, Private)
// Parameters:
// class UGameplayAbility*                 ActivatedAbility                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttackInputManagerComponent::OnAbilityActivate(class UGameplayAbility* ActivatedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackInputManagerComponent", "OnAbilityActivate");

	Params::AttackInputManagerComponent_OnAbilityActivate Parms{};

	Parms.ActivatedAbility = ActivatedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AttackInputManagerComponent.OnAbilityEnded
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FAbilityEndedData                AbilityEndedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAttackInputManagerComponent::OnAbilityEnded(const struct FAbilityEndedData& AbilityEndedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackInputManagerComponent", "OnAbilityEnded");

	Params::AttackInputManagerComponent_OnAbilityEnded Parms{};

	Parms.AbilityEndedData = std::move(AbilityEndedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.AttackInputManagerComponent.SetAttackEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bIsAttackEnabled                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAttackInputManagerComponent::SetAttackEnabled(bool bIsAttackEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackInputManagerComponent", "SetAttackEnabled");

	Params::AttackInputManagerComponent_SetAttackEnabled Parms{};

	Parms.bIsAttackEnabled = bIsAttackEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCArenaWidget.ShowRoundResult
// (Event, Protected, BlueprintEvent)

void UDCArenaWidget::ShowRoundResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "ShowRoundResult");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCArenaWidget.ShowRoundStart
// (Event, Protected, BlueprintEvent)

void UDCArenaWidget::ShowRoundStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "ShowRoundStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCArenaWidget.GetCurrentPhase
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameStateType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameStateType UDCArenaWidget::GetCurrentPhase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "GetCurrentPhase");

	Params::DCArenaWidget_GetCurrentPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCArenaWidget.GetNumMaxPlayers
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCArenaWidget::GetNumMaxPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "GetNumMaxPlayers");

	Params::DCArenaWidget_GetNumMaxPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCArenaWidget.GetNumPlayers
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCArenaWidget::GetNumPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "GetNumPlayers");

	Params::DCArenaWidget_GetNumPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCArenaWidget.GetRemainIntermissionTime
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UDCArenaWidget::GetRemainIntermissionTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "GetRemainIntermissionTime");

	Params::DCArenaWidget_GetRemainIntermissionTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCArenaWidget.GetRemainRoundTime
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UDCArenaWidget::GetRemainRoundTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "GetRemainRoundTime");

	Params::DCArenaWidget_GetRemainRoundTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCArenaWidget.GetRemainWelcomeTime
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UDCArenaWidget::GetRemainWelcomeTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "GetRemainWelcomeTime");

	Params::DCArenaWidget_GetRemainWelcomeTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCArenaWidget.GetRoundTime
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UDCArenaWidget::GetRoundTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "GetRoundTime");

	Params::DCArenaWidget_GetRoundTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCArenaWidget.IsDrawLastRound
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCArenaWidget::IsDrawLastRound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "IsDrawLastRound");

	Params::DCArenaWidget_IsDrawLastRound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCArenaWidget.IsWinLastRound
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCArenaWidget::IsWinLastRound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaWidget", "IsWinLastRound");

	Params::DCArenaWidget_IsWinLastRound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ReceivedInvitationSlotWidget.OnRightClicked
// (Native, Protected)

void UReceivedInvitationSlotWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReceivedInvitationSlotWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameModeBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameModeBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameModeBase", "BroadcastMsgBlueprint");

	Params::DCGameModeBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameModeBase.TerminateBase
// (Native, Public)

void ADCGameModeBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameModeBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameModeBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameModeBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameModeBase", "UnbindMsg");

	Params::DCGameModeBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameModeBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameModeBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameModeBase", "UnbindMsgAll");

	Params::DCGameModeBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDungeonGameMode.OnFloorRuleData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameFloorRuleData               InFloorRuleData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCDungeonGameMode::OnFloorRuleData(const struct FGameFloorRuleData& InFloorRuleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonGameMode", "OnFloorRuleData");

	Params::DCDungeonGameMode_OnFloorRuleData Parms{};

	Parms.InFloorRuleData = std::move(InFloorRuleData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDungeonGameMode.OnFloorRuleFinished
// (Final, Native, Private)

void ADCDungeonGameMode::OnFloorRuleFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonGameMode", "OnFloorRuleFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDungeonGameMode.RegisterPoolingObject
// (Final, Native, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCDungeonGameMode::RegisterPoolingObject(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonGameMode", "RegisterPoolingObject");

	Params::DCDungeonGameMode_RegisterPoolingObject Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitDistChangeFromLocation.WaitDistanceChange
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaximumDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitDistChangeFromLocation* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitDistChangeFromLocation* UDCAT_WaitDistChangeFromLocation::WaitDistanceChange(class UGameplayAbility* OwningAbility, const struct FVector& TargetLocation, float MaximumDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitDistChangeFromLocation", "WaitDistanceChange");

	Params::DCAT_WaitDistChangeFromLocation_WaitDistanceChange Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.MaximumDistance = MaximumDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.BlizzardBase.OnBlizzardIndex
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABlizzardBase::OnBlizzardIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlizzardBase", "OnBlizzardIndex");

	Params::BlizzardBase_OnBlizzardIndex Parms{};

	Parms.InIndex = InIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.BlizzardBase.OnNewPlayerCharacterRegistered
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADCCharacterBase*                 InRegisteredCharacter                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABlizzardBase::OnNewPlayerCharacterRegistered(class ADCCharacterBase* InRegisteredCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlizzardBase", "OnNewPlayerCharacterRegistered");

	Params::BlizzardBase_OnNewPlayerCharacterRegistered Parms{};

	Parms.InRegisteredCharacter = InRegisteredCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.BlizzardBase.OnRep_GameBlizzardData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameBlizzardData                InOldGameBlizzardData                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ABlizzardBase::OnRep_GameBlizzardData(const struct FGameBlizzardData& InOldGameBlizzardData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlizzardBase", "OnRep_GameBlizzardData");

	Params::BlizzardBase_OnRep_GameBlizzardData Parms{};

	Parms.InOldGameBlizzardData = std::move(InOldGameBlizzardData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.BlizzardBase.OnRep_GameFloorRuleData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameFloorRuleData               InOldGameFloorRuleData                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ABlizzardBase::OnRep_GameFloorRuleData(const struct FGameFloorRuleData& InOldGameFloorRuleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlizzardBase", "OnRep_GameFloorRuleData");

	Params::BlizzardBase_OnRep_GameFloorRuleData Parms{};

	Parms.InOldGameFloorRuleData = std::move(InOldGameFloorRuleData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.BlizzardInterface.BindBlizzardDataDelegate
// (Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGameBlizzardData& InBlizzardData)>InBindDelegate                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBlizzardInterface::BindBlizzardDataDelegate(TDelegate<void(struct FGameBlizzardData& InBlizzardData)> InBindDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlizzardInterface", "BindBlizzardDataDelegate");

	Params::BlizzardInterface_BindBlizzardDataDelegate Parms{};

	Parms.InBindDelegate = InBindDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.BlizzardInterface.UnbindBlizzardDataDelegate
// (Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InBoundObject                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBlizzardInterface::UnbindBlizzardDataDelegate(class UObject* InBoundObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlizzardInterface", "UnbindBlizzardDataDelegate");

	Params::BlizzardInterface_UnbindBlizzardDataDelegate Parms{};

	Parms.InBoundObject = InBoundObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.BlizzardInterface.GetBlizzardData
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameBlizzardData                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameBlizzardData IBlizzardInterface::GetBlizzardData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlizzardInterface", "GetBlizzardData");

	Params::BlizzardInterface_GetBlizzardData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.BlizzardInterface.LogHandleBlizzardData
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          InHandler                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameBlizzardData                InBlizzardData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IBlizzardInterface::LogHandleBlizzardData(const class UObject* InHandler, const struct FGameBlizzardData& InBlizzardData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlizzardInterface", "LogHandleBlizzardData");

	Params::BlizzardInterface_LogHandleBlizzardData Parms{};

	Parms.InHandler = InHandler;
	Parms.InBlizzardData = std::move(InBlizzardData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayCue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::AddGameplayCue(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "AddGameplayCue");

	Params::DCAbilitySystemBlueprintLibrary_AddGameplayCue Parms{};

	Parms.InActor = InActor;
	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayCueLocal
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::AddGameplayCueLocal(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "AddGameplayCueLocal");

	Params::DCAbilitySystemBlueprintLibrary_AddGameplayCueLocal Parms{};

	Parms.InActor = InActor;
	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::AddGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "AddGameplayTag");

	Params::DCAbilitySystemBlueprintLibrary_AddGameplayTag Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayTagContainer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            InGameplayTagContainer                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UDCAbilitySystemBlueprintLibrary::AddGameplayTagContainer(class AActor* InActor, const struct FGameplayTagContainer& InGameplayTagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "AddGameplayTagContainer");

	Params::DCAbilitySystemBlueprintLibrary_AddGameplayTagContainer Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTagContainer = std::move(InGameplayTagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddLooseGameplayTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::AddLooseGameplayTag(class AActor* InActor, const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "AddLooseGameplayTag");

	Params::DCAbilitySystemBlueprintLibrary_AddLooseGameplayTag Parms{};

	Parms.InActor = InActor;
	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimFromHitResultToActorViewPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHitResults                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::AimFromHitResultToActorViewPoint(class AActor* InActor, const struct FHitResult& InHitResult, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "AimFromHitResultToActorViewPoint");

	Params::DCAbilitySystemBlueprintLibrary_AimFromHitResultToActorViewPoint Parms{};

	Parms.InActor = InActor;
	Parms.InHitResult = std::move(InHitResult);
	Parms.TraceChannel = TraceChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResults != nullptr)
		*OutHitResults = std::move(Parms.OutHitResults);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimLineWithActorPointToViewPointResult
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceStart                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHitResults                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::AimLineWithActorPointToViewPointResult(class AActor* InActor, const struct FVector& TraceStart, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel, float MaxRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "AimLineWithActorPointToViewPointResult");

	Params::DCAbilitySystemBlueprintLibrary_AimLineWithActorPointToViewPointResult Parms{};

	Parms.InActor = InActor;
	Parms.TraceStart = std::move(TraceStart);
	Parms.TraceChannel = TraceChannel;
	Parms.MaxRange = MaxRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResults != nullptr)
		*OutHitResults = std::move(Parms.OutHitResults);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimLineWithActorViewPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHitResults                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::AimLineWithActorViewPoint(class AActor* InActor, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel, float MaxRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "AimLineWithActorViewPoint");

	Params::DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint Parms{};

	Parms.InActor = InActor;
	Parms.TraceChannel = TraceChannel;
	Parms.MaxRange = MaxRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResults != nullptr)
		*OutHitResults = std::move(Parms.OutHitResults);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimLineWithActorViewPointToPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceEnd                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHitResults                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::AimLineWithActorViewPointToPoint(class AActor* InActor, const struct FVector& TraceEnd, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "AimLineWithActorViewPointToPoint");

	Params::DCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint Parms{};

	Parms.InActor = InActor;
	Parms.TraceEnd = std::move(TraceEnd);
	Parms.TraceChannel = TraceChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResults != nullptr)
		*OutHitResults = std::move(Parms.OutHitResults);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimSphereWithActorViewPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHitResults                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::AimSphereWithActorViewPoint(class AActor* InActor, float Radius, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel, float MaxRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "AimSphereWithActorViewPoint");

	Params::DCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint Parms{};

	Parms.InActor = InActor;
	Parms.Radius = Radius;
	Parms.TraceChannel = TraceChannel;
	Parms.MaxRange = MaxRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResults != nullptr)
		*OutHitResults = std::move(Parms.OutHitResults);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyEffectContainerSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCGameplayEffectContainerSpec   ContainerSpec                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InStackCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsApplyTargetSelf                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UDCAbilitySystemBlueprintLibrary::ApplyEffectContainerSpec(const struct FDCGameplayEffectContainerSpec& ContainerSpec, int32 InStackCount, bool bIsApplyTargetSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "ApplyEffectContainerSpec");

	Params::DCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec Parms{};

	Parms.ContainerSpec = std::move(ContainerSpec);
	Parms.InStackCount = InStackCount;
	Parms.bIsApplyTargetSelf = bIsApplyTargetSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffect
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataGameplayEffect        InDesignDataGameplayEffect                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           InSourceActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UDCAbilitySystemBlueprintLibrary::ApplyGameplayEffect(class AActor* InActor, const struct FDesignDataGameplayEffect& InDesignDataGameplayEffect, class AActor* InSourceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "ApplyGameplayEffect");

	Params::DCAbilitySystemBlueprintLibrary_ApplyGameplayEffect Parms{};

	Parms.InActor = InActor;
	Parms.InDesignDataGameplayEffect = std::move(InDesignDataGameplayEffect);
	Parms.InSourceActor = InSourceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffectByIds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          InGameplayEffectIdArray                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           InSourceActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UDCAbilitySystemBlueprintLibrary::ApplyGameplayEffectByIds(class AActor* InActor, const TArray<struct FPrimaryAssetId>& InGameplayEffectIdArray, class AActor* InSourceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "ApplyGameplayEffectByIds");

	Params::DCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayEffectIdArray = std::move(InGameplayEffectIdArray);
	Parms.InSourceActor = InSourceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffects
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayEffectData>    InGameplayEffectDataArray                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           InSourceActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UDCAbilitySystemBlueprintLibrary::ApplyGameplayEffects(class AActor* InActor, const TArray<struct FDCGameplayEffectData>& InGameplayEffectDataArray, class AActor* InSourceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "ApplyGameplayEffects");

	Params::DCAbilitySystemBlueprintLibrary_ApplyGameplayEffects Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayEffectDataArray = std::move(InGameplayEffectDataArray);
	Parms.InSourceActor = InSourceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyPremadeSpecArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ContainerTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UDCAbilitySystemBlueprintLibrary::ApplyPremadeSpecArray(class AActor* InActor, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "ApplyPremadeSpecArray");

	Params::DCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray Parms{};

	Parms.InActor = InActor;
	Parms.ContainerTag = std::move(ContainerTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.CancelAllAbilities
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::CancelAllAbilities(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "CancelAllAbilities");

	Params::DCAbilitySystemBlueprintLibrary_CancelAllAbilities Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ClearAllAbilities
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::ClearAllAbilities(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "ClearAllAbilities");

	Params::DCAbilitySystemBlueprintLibrary_ClearAllAbilities Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextAddHitResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::DCEffectContextAddHitResult(const struct FDCGameplayEffectContext& EffectContext, const struct FHitResult& HitResult, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextAddHitResult");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.HitResult = std::move(HitResult);
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetEffectCauser
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDCAbilitySystemBlueprintLibrary::DCEffectContextGetEffectCauser(const struct FDCGameplayEffectContext& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextGetEffectCauser");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetHitResult
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UDCAbilitySystemBlueprintLibrary::DCEffectContextGetHitResult(const struct FDCGameplayEffectContext& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextGetHitResult");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetInstigatorActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDCAbilitySystemBlueprintLibrary::DCEffectContextGetInstigatorActor(const struct FDCGameplayEffectContext& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextGetInstigatorActor");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetOrigin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDCAbilitySystemBlueprintLibrary::DCEffectContextGetOrigin(const struct FDCGameplayEffectContext& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextGetOrigin");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetOriginalInstigatorActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDCAbilitySystemBlueprintLibrary::DCEffectContextGetOriginalInstigatorActor(const struct FDCGameplayEffectContext& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextGetOriginalInstigatorActor");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetSoundDataPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDCAbilitySystemBlueprintLibrary::DCEffectContextGetSoundDataPrimaryAssetId(const struct FDCGameplayEffectContext& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextGetSoundDataPrimaryAssetId");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetSourceObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UDCAbilitySystemBlueprintLibrary::DCEffectContextGetSourceObject(const struct FDCGameplayEffectContext& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextGetSourceObject");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextHasHitResult
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::DCEffectContextHasHitResult(const struct FDCGameplayEffectContext& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextHasHitResult");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextSetOrigin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::DCEffectContextSetOrigin(const struct FDCGameplayEffectContext& EffectContext, const struct FVector& Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextSetOrigin");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextSetSoundDataPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDCGameplayEffectContext         EffectContext                                          (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::DCEffectContextSetSoundDataPrimaryAssetId(const struct FDCGameplayEffectContext& EffectContext, const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "DCEffectContextSetSoundDataPrimaryAssetId");

	Params::DCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetEffectId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDCAbilitySystemBlueprintLibrary::EffectContextGetEffectId(const struct FGameplayEffectContextHandle& EffectContextHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "EffectContextGetEffectId");

	Params::DCAbilitySystemBlueprintLibrary_EffectContextGetEffectId Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetItemDatas
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// TArray<struct FItemData>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FItemData> UDCAbilitySystemBlueprintLibrary::EffectContextGetItemDatas(const struct FGameplayEffectContextHandle& EffectContextHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "EffectContextGetItemDatas");

	Params::DCAbilitySystemBlueprintLibrary_EffectContextGetItemDatas Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetSoundData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// class USoundData*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundData* UDCAbilitySystemBlueprintLibrary::EffectContextGetSoundData(const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "EffectContextGetSoundData");

	Params::DCAbilitySystemBlueprintLibrary_EffectContextGetSoundData Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetSoundDataPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDCAbilitySystemBlueprintLibrary::EffectContextGetSoundDataPrimaryAssetId(const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "EffectContextGetSoundDataPrimaryAssetId");

	Params::DCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextSetSoundDataPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::EffectContextSetSoundDataPrimaryAssetId(const struct FGameplayEffectContextHandle& EffectContext, const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "EffectContextSetSoundDataPrimaryAssetId");

	Params::DCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ExecuteGameplayCue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::ExecuteGameplayCue(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "ExecuteGameplayCue");

	Params::DCAbilitySystemBlueprintLibrary_ExecuteGameplayCue Parms{};

	Parms.InActor = InActor;
	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ExecuteGameplayCueLocal
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::ExecuteGameplayCueLocal(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "ExecuteGameplayCueLocal");

	Params::DCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal Parms{};

	Parms.InActor = InActor;
	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.FindSocketOwningMeshComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             SocketName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AvatarActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UDCAbilitySystemBlueprintLibrary::FindSocketOwningMeshComponent(const class FName SocketName, const class UObject* Object, const class AActor* AvatarActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "FindSocketOwningMeshComponent");

	Params::DCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent Parms{};

	Parms.SocketName = SocketName;
	Parms.Object = Object;
	Parms.AvatarActor = AvatarActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetActorAttributeValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               InAttribute                                            (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetActorAttributeValue(class AActor* InActor, const struct FGameplayAttribute& InAttribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetActorAttributeValue");

	Params::DCAbilitySystemBlueprintLibrary_GetActorAttributeValue Parms{};

	Parms.InActor = InActor;
	Parms.InAttribute = std::move(InAttribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetBoundingBoxPointsLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutTop                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutBottom                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLeft                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutRight                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutCenter                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetBoundingBoxPointsLocation(class AActor* InActor, class AActor* InTarget, struct FVector& OutTop, struct FVector& OutBottom, struct FVector& OutLeft, struct FVector& OutRight, struct FVector& OutCenter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetBoundingBoxPointsLocation");

	Params::DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocation Parms{};

	Parms.InActor = InActor;
	Parms.InTarget = InTarget;
	Parms.OutTop = std::move(OutTop);
	Parms.OutBottom = std::move(OutBottom);
	Parms.OutLeft = std::move(OutLeft);
	Parms.OutRight = std::move(OutRight);
	Parms.OutCenter = std::move(OutCenter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutTop = std::move(Parms.OutTop);
	OutBottom = std::move(Parms.OutBottom);
	OutLeft = std::move(Parms.OutLeft);
	OutRight = std::move(Parms.OutRight);
	OutCenter = std::move(Parms.OutCenter);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetBoundingBoxPointsLocationFromLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InStartLocation                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutTop                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutBottom                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLeft                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutRight                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutCenter                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetBoundingBoxPointsLocationFromLocation(class AActor* InTarget, const struct FVector& InStartLocation, struct FVector& OutTop, struct FVector& OutBottom, struct FVector& OutLeft, struct FVector& OutRight, struct FVector& OutCenter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetBoundingBoxPointsLocationFromLocation");

	Params::DCAbilitySystemBlueprintLibrary_GetBoundingBoxPointsLocationFromLocation Parms{};

	Parms.InTarget = InTarget;
	Parms.InStartLocation = std::move(InStartLocation);
	Parms.OutTop = std::move(OutTop);
	Parms.OutBottom = std::move(OutBottom);
	Parms.OutLeft = std::move(OutLeft);
	Parms.OutRight = std::move(OutRight);
	Parms.OutCenter = std::move(OutCenter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutTop = std::move(Parms.OutTop);
	OutBottom = std::move(Parms.OutBottom);
	OutLeft = std::move(Parms.OutLeft);
	OutRight = std::move(Parms.OutRight);
	OutCenter = std::move(Parms.OutCenter);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetCharacterPrimitiveAttributes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FGameplayAttribute> ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FGameplayAttribute> UDCAbilitySystemBlueprintLibrary::GetCharacterPrimitiveAttributes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetCharacterPrimitiveAttributes");

	Params::DCAbilitySystemBlueprintLibrary_GetCharacterPrimitiveAttributes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetCurrentMontagePlayRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetCurrentMontagePlayRate(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetCurrentMontagePlayRate");

	Params::DCAbilitySystemBlueprintLibrary_GetCurrentMontagePlayRate Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetCurrentMontageSectionName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDCAbilitySystemBlueprintLibrary::GetCurrentMontageSectionName(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetCurrentMontageSectionName");

	Params::DCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetCurseDebuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetCurseDebuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetCurseDebuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetCurseDebuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetDCAbilitySystemComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAbilitySystemComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAbilitySystemComponent* UDCAbilitySystemBlueprintLibrary::GetDCAbilitySystemComponent(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetDCAbilitySystemComponent");

	Params::DCAbilitySystemBlueprintLibrary_GetDCAbilitySystemComponent Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetDefaultUnscaledCapsuleSize
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutRadius                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutHalfHeight                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetDefaultUnscaledCapsuleSize(class AActor* InActor, float* OutRadius, float* OutHalfHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetDefaultUnscaledCapsuleSize");

	Params::DCAbilitySystemBlueprintLibrary_GetDefaultUnscaledCapsuleSize Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeight != nullptr)
		*OutHalfHeight = Parms.OutHalfHeight;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetEffectAssetTagsInEffectContainerArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InEventTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayEffectContainer>InEffectContainer                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UDCAbilitySystemBlueprintLibrary::GetEffectAssetTagsInEffectContainerArray(const struct FGameplayTag& InEventTag, const TArray<struct FDCGameplayEffectContainer>& InEffectContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetEffectAssetTagsInEffectContainerArray");

	Params::DCAbilitySystemBlueprintLibrary_GetEffectAssetTagsInEffectContainerArray Parms{};

	Parms.InEventTag = std::move(InEventTag);
	Parms.InEffectContainer = std::move(InEffectContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetEffectSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpec              OutEffectSpec                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetEffectSpec(const struct FGameplayEffectSpecHandle& SpecHandle, struct FGameplayEffectSpec* OutEffectSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetEffectSpec");

	Params::DCAbilitySystemBlueprintLibrary_GetEffectSpec Parms{};

	Parms.SpecHandle = std::move(SpecHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEffectSpec != nullptr)
		*OutEffectSpec = std::move(Parms.OutEffectSpec);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayAbilityData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDesignDataGameplayAbility       InDesignDataGameplayAbility                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDCGameplayAbilityData           OutGameplayAbilityData                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetGameplayAbilityData(const struct FDesignDataGameplayAbility& InDesignDataGameplayAbility, struct FDCGameplayAbilityData& OutGameplayAbilityData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetGameplayAbilityData");

	Params::DCAbilitySystemBlueprintLibrary_GetGameplayAbilityData Parms{};

	Parms.InDesignDataGameplayAbility = std::move(InDesignDataGameplayAbility);
	Parms.OutGameplayAbilityData = std::move(OutGameplayAbilityData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutGameplayAbilityData = std::move(Parms.OutGameplayAbilityData);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayDataFromDesignDataSkill
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDesignDataSkill                 InDesignDataSkill                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayAbilityData>   OutGameplayAbilityDataArray                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayEffectData>    OutGameplayEffectDataArray                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetGameplayDataFromDesignDataSkill(const struct FDesignDataSkill& InDesignDataSkill, TArray<struct FDCGameplayAbilityData>* OutGameplayAbilityDataArray, TArray<struct FDCGameplayEffectData>* OutGameplayEffectDataArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetGameplayDataFromDesignDataSkill");

	Params::DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSkill Parms{};

	Parms.InDesignDataSkill = std::move(InDesignDataSkill);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGameplayAbilityDataArray != nullptr)
		*OutGameplayAbilityDataArray = std::move(Parms.OutGameplayAbilityDataArray);

	if (OutGameplayEffectDataArray != nullptr)
		*OutGameplayEffectDataArray = std::move(Parms.OutGameplayEffectDataArray);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayDataFromDesignDataSpell
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDesignDataSpell                 InDesignDataSpell                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayAbilityData>   OutGameplayAbilityDataArray                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayEffectData>    OutGameplayEffectDataArray                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetGameplayDataFromDesignDataSpell(const struct FDesignDataSpell& InDesignDataSpell, TArray<struct FDCGameplayAbilityData>* OutGameplayAbilityDataArray, TArray<struct FDCGameplayEffectData>* OutGameplayEffectDataArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetGameplayDataFromDesignDataSpell");

	Params::DCAbilitySystemBlueprintLibrary_GetGameplayDataFromDesignDataSpell Parms{};

	Parms.InDesignDataSpell = std::move(InDesignDataSpell);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGameplayAbilityDataArray != nullptr)
		*OutGameplayAbilityDataArray = std::move(Parms.OutGameplayAbilityDataArray);

	if (OutGameplayEffectDataArray != nullptr)
		*OutGameplayEffectDataArray = std::move(Parms.OutGameplayEffectDataArray);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDesignDataGameplayEffect        InDesignDataGameplayEffect                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDCGameplayEffectData            OutGameplayEffectData                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetGameplayEffectData(const struct FDesignDataGameplayEffect& InDesignDataGameplayEffect, struct FDCGameplayEffectData& OutGameplayEffectData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetGameplayEffectData");

	Params::DCAbilitySystemBlueprintLibrary_GetGameplayEffectData Parms{};

	Parms.InDesignDataGameplayEffect = std::move(InDesignDataGameplayEffect);
	Parms.OutGameplayEffectData = std::move(OutGameplayEffectData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutGameplayEffectData = std::move(Parms.OutGameplayEffectData);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectSetByCallerValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InSetByCallerTag                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InSetByCallerValue                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetGameplayEffectSetByCallerValue(const struct FGameplayTag& InSetByCallerTag, int32 InSetByCallerValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetGameplayEffectSetByCallerValue");

	Params::DCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue Parms{};

	Parms.InSetByCallerTag = std::move(InSetByCallerTag);
	Parms.InSetByCallerValue = InSetByCallerValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGrantedTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UDCAbilitySystemBlueprintLibrary::GetGrantedTag(const struct FGameplayEffectSpecHandle& SpecHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetGrantedTag");

	Params::DCAbilitySystemBlueprintLibrary_GetGrantedTag Parms{};

	Parms.SpecHandle = std::move(SpecHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetItemActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     Handle                                                 (Parm, NativeAccessSpecifierPublic)
// class AItemActor*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemActor* UDCAbilitySystemBlueprintLibrary::GetItemActor(const struct FGameplayEffectContextHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetItemActor");

	Params::DCAbilitySystemBlueprintLibrary_GetItemActor Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetItemDataFromDesignData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDesignDataItem                  InDesignDataItem                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FItemData                        OutItemData                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetItemDataFromDesignData(const struct FDesignDataItem& InDesignDataItem, struct FItemData& OutItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetItemDataFromDesignData");

	Params::DCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData Parms{};

	Parms.InDesignDataItem = std::move(InDesignDataItem);
	Parms.OutItemData = std::move(OutItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutItemData = std::move(Parms.OutItemData);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMagicBuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetMagicBuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetMagicBuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetMagicBuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMagicDebuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetMagicDebuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetMagicDebuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetMagicDebuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMatchingAbilityActivated
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDCGameplayAbilityBase*>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDCGameplayAbilityBase*> UDCAbilitySystemBlueprintLibrary::GetMatchingAbilityActivated(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetMatchingAbilityActivated");

	Params::DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivated Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMatchingAbilityActivatedCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCAbilitySystemBlueprintLibrary::GetMatchingAbilityActivatedCount(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetMatchingAbilityActivatedCount");

	Params::DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMatchingAbilityActivatedTriggers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> UDCAbilitySystemBlueprintLibrary::GetMatchingAbilityActivatedTriggers(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetMatchingAbilityActivatedTriggers");

	Params::DCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedTriggers Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMeleeAttackAbilityDamageRatioFromDesignData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDesignDataGameplayAbility       DesignDataGameplayAbility                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetMeleeAttackAbilityDamageRatioFromDesignData(const struct FDesignDataGameplayAbility& DesignDataGameplayAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetMeleeAttackAbilityDamageRatioFromDesignData");

	Params::DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromDesignData Parms{};

	Parms.DesignDataGameplayAbility = std::move(DesignDataGameplayAbility);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMeleeAttackAbilityDamageRatioFromEffectSpec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpec              InSpec                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetMeleeAttackAbilityDamageRatioFromEffectSpec(const struct FGameplayEffectSpec& InSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetMeleeAttackAbilityDamageRatioFromEffectSpec");

	Params::DCAbilitySystemBlueprintLibrary_GetMeleeAttackAbilityDamageRatioFromEffectSpec Parms{};

	Parms.InSpec = std::move(InSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMoveSpeedBuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetMoveSpeedBuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetMoveSpeedBuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetMoveSpeedBuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMoveSpeedDebuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetMoveSpeedDebuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetMoveSpeedDebuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetMoveSpeedDebuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetOwnedGameplayTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TagContainer                                           (Parm, OutParm, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetOwnedGameplayTags(class AActor* InActor, struct FGameplayTagContainer* TagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetOwnedGameplayTags");

	Params::DCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TagContainer != nullptr)
		*TagContainer = std::move(Parms.TagContainer);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetProjectileDamageCurveFloatValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpec              InSpec                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetProjectileDamageCurveFloatValue(const struct FGameplayEffectSpec& InSpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetProjectileDamageCurveFloatValue");

	Params::DCAbilitySystemBlueprintLibrary_GetProjectileDamageCurveFloatValue Parms{};

	Parms.InSpec = std::move(InSpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetProtectionBuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetProtectionBuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetProtectionBuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetProtectionBuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableBuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetRemovableBuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetRemovableBuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetRemovableBuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableCurseDebuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetRemovableCurseDebuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetRemovableCurseDebuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetRemovableCurseDebuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableDebuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetRemovableDebuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetRemovableDebuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetRemovableDebuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableDrunkDebuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetRemovableDrunkDebuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetRemovableDrunkDebuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetRemovableDrunkDebuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableMagicBuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetRemovableMagicBuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetRemovableMagicBuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetRemovableMagicBuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableMagicDebuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetRemovableMagicDebuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetRemovableMagicDebuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetRemovableMagicDebuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableMoveSpeedBuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetRemovableMoveSpeedBuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetRemovableMoveSpeedBuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedBuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableMoveSpeedDebuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetRemovableMoveSpeedDebuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetRemovableMoveSpeedDebuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetRemovableMoveSpeedDebuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetRemovableProtectionBuffEffectTagQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectQuery             ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayEffectQuery UDCAbilitySystemBlueprintLibrary::GetRemovableProtectionBuffEffectTagQuery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetRemovableProtectionBuffEffectTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_GetRemovableProtectionBuffEffectTagQuery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInAbilityAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InEventTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InSetByCallerDataTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDesignDataAssetGameplayAbility*>InAbilities                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetSetByCallerValueInAbilityAssets(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, const TArray<class UDesignDataAssetGameplayAbility*>& InAbilities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetSetByCallerValueInAbilityAssets");

	Params::DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityAssets Parms{};

	Parms.InEventTag = std::move(InEventTag);
	Parms.InSetByCallerDataTag = std::move(InSetByCallerDataTag);
	Parms.InAbilities = std::move(InAbilities);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInAbilityData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InEventTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InSetByCallerDataTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCGameplayAbilityData           InAbilityData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bShouldGetOnlyOneValueInData                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetSetByCallerValueInAbilityData(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, const struct FDCGameplayAbilityData& InAbilityData, bool bShouldGetOnlyOneValueInData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetSetByCallerValueInAbilityData");

	Params::DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityData Parms{};

	Parms.InEventTag = std::move(InEventTag);
	Parms.InSetByCallerDataTag = std::move(InSetByCallerDataTag);
	Parms.InAbilityData = std::move(InAbilityData);
	Parms.bShouldGetOnlyOneValueInData = bShouldGetOnlyOneValueInData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInAbilityIds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InEventTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InSetByCallerDataTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          InAbilities                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetSetByCallerValueInAbilityIds(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, const TArray<struct FPrimaryAssetId>& InAbilities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetSetByCallerValueInAbilityIds");

	Params::DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInAbilityIds Parms{};

	Parms.InEventTag = std::move(InEventTag);
	Parms.InSetByCallerDataTag = std::move(InSetByCallerDataTag);
	Parms.InAbilities = std::move(InAbilities);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInContainer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InEventTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InSetByCallerDataTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayEffectContainer>InEffectContainer                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetSetByCallerValueInContainer(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, const TArray<struct FDCGameplayEffectContainer>& InEffectContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetSetByCallerValueInContainer");

	Params::DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer Parms{};

	Parms.InEventTag = std::move(InEventTag);
	Parms.InSetByCallerDataTag = std::move(InSetByCallerDataTag);
	Parms.InEffectContainer = std::move(InEffectContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInContainerSpecArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InEventTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InSetByCallerDataTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayEffectContainerSpec>InEffectHandle                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetSetByCallerValueInContainerSpecArray(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, const TArray<struct FDCGameplayEffectContainerSpec>& InEffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetSetByCallerValueInContainerSpecArray");

	Params::DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray Parms{};

	Parms.InEventTag = std::move(InEventTag);
	Parms.InSetByCallerDataTag = std::move(InSetByCallerDataTag);
	Parms.InEffectHandle = std::move(InEffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInEffectAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InSetByCallerDataTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDesignDataAssetGameplayEffect*>InEffects                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetSetByCallerValueInEffectAssets(const struct FGameplayTag& InSetByCallerDataTag, const TArray<class UDesignDataAssetGameplayEffect*>& InEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetSetByCallerValueInEffectAssets");

	Params::DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectAssets Parms{};

	Parms.InSetByCallerDataTag = std::move(InSetByCallerDataTag);
	Parms.InEffects = std::move(InEffects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInEffectData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InSetByCallerDataTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCGameplayEffectData            InEffectData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetSetByCallerValueInEffectData(const struct FGameplayTag& InSetByCallerDataTag, const struct FDCGameplayEffectData& InEffectData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetSetByCallerValueInEffectData");

	Params::DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectData Parms{};

	Parms.InSetByCallerDataTag = std::move(InSetByCallerDataTag);
	Parms.InEffectData = std::move(InEffectData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInEffectIds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InSetByCallerDataTag                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          InEffects                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAbilitySystemBlueprintLibrary::GetSetByCallerValueInEffectIds(const struct FGameplayTag& InSetByCallerDataTag, const TArray<struct FPrimaryAssetId>& InEffects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetSetByCallerValueInEffectIds");

	Params::DCAbilitySystemBlueprintLibrary_GetSetByCallerValueInEffectIds Parms{};

	Parms.InSetByCallerDataTag = std::move(InSetByCallerDataTag);
	Parms.InEffects = std::move(InEffects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSocketLocationBySocketName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             SocketName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AvatarActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutSocketLocation                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::GetSocketLocationBySocketName(const class FName SocketName, const class UObject* Object, const class AActor* AvatarActor, struct FVector& OutSocketLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GetSocketLocationBySocketName");

	Params::DCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName Parms{};

	Parms.SocketName = SocketName;
	Parms.Object = Object;
	Parms.AvatarActor = AvatarActor;
	Parms.OutSocketLocation = std::move(OutSocketLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutSocketLocation = std::move(Parms.OutSocketLocation);
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GiveAbilities
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayAbilityData>   InGameplayAbilityDataArray                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTriggerOnlyOnce                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayAbilitySpecHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayAbilitySpecHandle> UDCAbilitySystemBlueprintLibrary::GiveAbilities(class UObject* SourceObject, class AActor* InActor, const TArray<struct FDCGameplayAbilityData>& InGameplayAbilityDataArray, bool bTriggerOnlyOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GiveAbilities");

	Params::DCAbilitySystemBlueprintLibrary_GiveAbilities Parms{};

	Parms.SourceObject = SourceObject;
	Parms.InActor = InActor;
	Parms.InGameplayAbilityDataArray = std::move(InGameplayAbilityDataArray);
	Parms.bTriggerOnlyOnce = bTriggerOnlyOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GiveAbility
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCGameplayAbilityData           InGameplayAbilityData                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTriggerOnlyOnce                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilitySpecHandle       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayAbilitySpecHandle UDCAbilitySystemBlueprintLibrary::GiveAbility(class UObject* SourceObject, class AActor* InActor, const struct FDCGameplayAbilityData& InGameplayAbilityData, bool bTriggerOnlyOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "GiveAbility");

	Params::DCAbilitySystemBlueprintLibrary_GiveAbility Parms{};

	Parms.SourceObject = SourceObject;
	Parms.InActor = InActor;
	Parms.InGameplayAbilityData = std::move(InGameplayAbilityData);
	Parms.bTriggerOnlyOnce = bTriggerOnlyOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.HasAnyMatchingGameplayTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::HasAnyMatchingGameplayTags(class AActor* InActor, const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "HasAnyMatchingGameplayTags");

	Params::DCAbilitySystemBlueprintLibrary_HasAnyMatchingGameplayTags Parms{};

	Parms.InActor = InActor;
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.HasMatchingGameplayTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     TagToCheck                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::HasMatchingGameplayTag(class AActor* InActor, const struct FGameplayTag& TagToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "HasMatchingGameplayTag");

	Params::DCAbilitySystemBlueprintLibrary_HasMatchingGameplayTag Parms{};

	Parms.InActor = InActor;
	Parms.TagToCheck = std::move(TagToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsInstigatorAppliedEffectToTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InInstigator                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsInstigatorAppliedEffectToTarget(const class AActor* InInstigator, class AActor* InTarget, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsInstigatorAppliedEffectToTarget");

	Params::DCAbilitySystemBlueprintLibrary_IsInstigatorAppliedEffectToTarget Parms{};

	Parms.InInstigator = InInstigator;
	Parms.InTarget = InTarget;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsMagicalAttackHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsMagicalAttackHit(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsMagicalAttackHit");

	Params::DCAbilitySystemBlueprintLibrary_IsMagicalAttackHit Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsMatchingAbilityActivated
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsMatchingAbilityActivated(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsMatchingAbilityActivated");

	Params::DCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsMeaningfulCharacterTarget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InTarget                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsMeaningfulCharacterTarget(const class AActor* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsMeaningfulCharacterTarget");

	Params::DCAbilitySystemBlueprintLibrary_IsMeaningfulCharacterTarget Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsMeleeAttackHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsMeleeAttackHit(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsMeleeAttackHit");

	Params::DCAbilitySystemBlueprintLibrary_IsMeleeAttackHit Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsOnHitSkillActivatingPhysicalAttackHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsOnHitSkillActivatingPhysicalAttackHit(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsOnHitSkillActivatingPhysicalAttackHit");

	Params::DCAbilitySystemBlueprintLibrary_IsOnHitSkillActivatingPhysicalAttackHit Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsProjectileAttackHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsProjectileAttackHit(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsProjectileAttackHit");

	Params::DCAbilitySystemBlueprintLibrary_IsProjectileAttackHit Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsRangedMagicalAttackHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsRangedMagicalAttackHit(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsRangedMagicalAttackHit");

	Params::DCAbilitySystemBlueprintLibrary_IsRangedMagicalAttackHit Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsRangedPhysicalAttackHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsRangedPhysicalAttackHit(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsRangedPhysicalAttackHit");

	Params::DCAbilitySystemBlueprintLibrary_IsRangedPhysicalAttackHit Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsSameTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsSameTeam(class AActor* SourceActor, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsSameTeam");

	Params::DCAbilitySystemBlueprintLibrary_IsSameTeam Parms{};

	Parms.SourceActor = SourceActor;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsSameTeamWithPartyId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           SourceActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InPartyId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsSameTeamWithPartyId(class AActor* SourceActor, const class FString& InPartyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsSameTeamWithPartyId");

	Params::DCAbilitySystemBlueprintLibrary_IsSameTeamWithPartyId Parms{};

	Parms.SourceActor = SourceActor;
	Parms.InPartyId = std::move(InPartyId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsSystemDamage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsSystemDamage(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsSystemDamage");

	Params::DCAbilitySystemBlueprintLibrary_IsSystemDamage Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsSystemDamageFromEffectData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsSystemDamageFromEffectData(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsSystemDamageFromEffectData");

	Params::DCAbilitySystemBlueprintLibrary_IsSystemDamageFromEffectData Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsTargetLocationSightBlocked
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsTargetLocationSightBlocked(class AActor* InActor, const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsTargetLocationSightBlocked");

	Params::DCAbilitySystemBlueprintLibrary_IsTargetLocationSightBlocked Parms{};

	Parms.InActor = InActor;
	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsTargetSightBlocked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTargetExcluded                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsTargetSightBlocked(class AActor* InActor, class AActor* InTarget, bool bIsTargetExcluded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsTargetSightBlocked");

	Params::DCAbilitySystemBlueprintLibrary_IsTargetSightBlocked Parms{};

	Parms.InActor = InActor;
	Parms.InTarget = InTarget;
	Parms.bIsTargetExcluded = bIsTargetExcluded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsTargetSightBlockedFromLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTargetExcluded                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsTargetSightBlockedFromLocation(class AActor* InTarget, const struct FVector& InLocation, bool bIsTargetExcluded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsTargetSightBlockedFromLocation");

	Params::DCAbilitySystemBlueprintLibrary_IsTargetSightBlockedFromLocation Parms{};

	Parms.InTarget = InTarget;
	Parms.InLocation = std::move(InLocation);
	Parms.bIsTargetExcluded = bIsTargetExcluded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsUtilityThrowableAttackHit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::IsUtilityThrowableAttackHit(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "IsUtilityThrowableAttackHit");

	Params::DCAbilitySystemBlueprintLibrary_IsUtilityThrowableAttackHit Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.MatchesQuery
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagQuery                InTagQuery                                             (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::MatchesQuery(class AActor* InActor, const struct FGameplayTagQuery& InTagQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "MatchesQuery");

	Params::DCAbilitySystemBlueprintLibrary_MatchesQuery Parms{};

	Parms.InActor = InActor;
	Parms.InTagQuery = std::move(InTagQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.MessageNotifyByReasonTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MsgDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::MessageNotifyByReasonTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag, float MsgDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "MessageNotifyByReasonTag");

	Params::DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTag Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.MsgDuration = MsgDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.MessageNotifyByReasonTagContainer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            InGameplayTags                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MsgDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::MessageNotifyByReasonTagContainer(class AActor* InActor, const struct FGameplayTagContainer& InGameplayTags, float MsgDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "MessageNotifyByReasonTagContainer");

	Params::DCAbilitySystemBlueprintLibrary_MessageNotifyByReasonTagContainer Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTags = std::move(InGameplayTags);
	Parms.MsgDuration = MsgDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ParseOptionGameplayTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InOptionStr                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InOptionKey                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UDCAbilitySystemBlueprintLibrary::ParseOptionGameplayTag(const class FString& InOptionStr, const class FString& InOptionKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "ParseOptionGameplayTag");

	Params::DCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag Parms{};

	Parms.InOptionStr = std::move(InOptionStr);
	Parms.InOptionKey = std::move(InOptionKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveActiveEffectsWithGrantedTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCAbilitySystemBlueprintLibrary::RemoveActiveEffectsWithGrantedTags(class AActor* InActor, const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "RemoveActiveEffectsWithGrantedTags");

	Params::DCAbilitySystemBlueprintLibrary_RemoveActiveEffectsWithGrantedTags Parms{};

	Parms.InActor = InActor;
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveActiveGameplayEffect
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      InHandle                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::RemoveActiveGameplayEffect(class AActor* InActor, const struct FActiveGameplayEffectHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "RemoveActiveGameplayEffect");

	Params::DCAbilitySystemBlueprintLibrary_RemoveActiveGameplayEffect Parms{};

	Parms.InActor = InActor;
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveEffectWithTagQuery
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectQuery             InGameplayTagQuery                                     (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCAbilitySystemBlueprintLibrary::RemoveEffectWithTagQuery(class AActor* InActor, const struct FGameplayEffectQuery& InGameplayTagQuery)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "RemoveEffectWithTagQuery");

	Params::DCAbilitySystemBlueprintLibrary_RemoveEffectWithTagQuery Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTagQuery = std::move(InGameplayTagQuery);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayCue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::RemoveGameplayCue(class AActor* InActor, const struct FGameplayTag& GameplayCueTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "RemoveGameplayCue");

	Params::DCAbilitySystemBlueprintLibrary_RemoveGameplayCue Parms{};

	Parms.InActor = InActor;
	Parms.GameplayCueTag = std::move(GameplayCueTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayCueLocal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::RemoveGameplayCueLocal(class AActor* InActor, const struct FGameplayTag& GameplayCueTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "RemoveGameplayCueLocal");

	Params::DCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal Parms{};

	Parms.InActor = InActor;
	Parms.GameplayCueTag = std::move(GameplayCueTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::RemoveGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "RemoveGameplayTag");

	Params::DCAbilitySystemBlueprintLibrary_RemoveGameplayTag Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveLooseGameplayTagAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::RemoveLooseGameplayTagAll(class AActor* InActor, const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "RemoveLooseGameplayTagAll");

	Params::DCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll Parms{};

	Parms.InActor = InActor;
	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SendGameplayEventToActorOverride
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayEffectData>    InOverrideGameplayEffectDataArray                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAbilitySystemBlueprintLibrary::SendGameplayEventToActorOverride(class AActor* Actor, const struct FGameplayTag& EventTag, const TArray<struct FDCGameplayEffectData>& InOverrideGameplayEffectDataArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "SendGameplayEventToActorOverride");

	Params::DCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride Parms{};

	Parms.Actor = Actor;
	Parms.EventTag = std::move(EventTag);
	Parms.InOverrideGameplayEffectDataArray = std::move(InOverrideGameplayEffectDataArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SetAnimationStateGameplayTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::SetAnimationStateGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "SetAnimationStateGameplayTag");

	Params::DCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SetModeGameplayTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAbilitySystemBlueprintLibrary::SetModeGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "SetModeGameplayTag");

	Params::DCAbilitySystemBlueprintLibrary_SetModeGameplayTag Parms{};

	Parms.InActor = InActor;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.TriggerAbilityFromGameplayEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               Payload                                                (Parm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCAbilitySystemBlueprintLibrary::TriggerAbilityFromGameplayEvent(class AActor* Actor, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAbilitySystemBlueprintLibrary", "TriggerAbilityFromGameplayEvent");

	Params::DCAbilitySystemBlueprintLibrary_TriggerAbilityFromGameplayEvent Parms{};

	Parms.Actor = Actor;
	Parms.EventTag = std::move(EventTag);
	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.BlockUserSlotWidget.OnRightClicked
// (Native, Protected)

void UBlockUserSlotWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockUserSlotWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerWidget.GetSelectCategoryTextVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCReportPlayerWidget::GetSelectCategoryTextVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerWidget", "GetSelectCategoryTextVisibility");

	Params::DCReportPlayerWidget_GetSelectCategoryTextVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCReportPlayerWidget.HandleBlockButtonClicked
// (Final, Native, Protected)

void UDCReportPlayerWidget::HandleBlockButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerWidget", "HandleBlockButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerWidget.HandleCancelButtonClicked
// (Final, Native, Private)

void UDCReportPlayerWidget::HandleCancelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerWidget", "HandleCancelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerWidget.HandleCheckStatedChanged
// (Final, Native, Private)
// Parameters:
// EDCReportPlayerCategory                 InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbNewChecked                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCReportPlayerWidget::HandleCheckStatedChanged(EDCReportPlayerCategory InCategory, bool InbNewChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerWidget", "HandleCheckStatedChanged");

	Params::DCReportPlayerWidget_HandleCheckStatedChanged Parms{};

	Parms.InCategory = InCategory;
	Parms.InbNewChecked = InbNewChecked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerWidget.HandleReportButtonClicked
// (Final, Native, Private)

void UDCReportPlayerWidget::HandleReportButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerWidget", "HandleReportButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerWidget.HandleReportTextChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCReportPlayerWidget::HandleReportTextChanged(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerWidget", "HandleReportTextChanged");

	Params::DCReportPlayerWidget_HandleReportTextChanged Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerWidget.IsReportCategorySelected
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCReportPlayerWidget::IsReportCategorySelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerWidget", "IsReportCategorySelected");

	Params::DCReportPlayerWidget_IsReportCategorySelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCReportPlayerWidget.OnBlockConfirmed
// (Final, Native, Protected)
// Parameters:
// EPopupResult                            PopupResult                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCReportPlayerWidget::OnBlockConfirmed(const EPopupResult PopupResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerWidget", "OnBlockConfirmed");

	Params::DCReportPlayerWidget_OnBlockConfirmed Parms{};

	Parms.PopupResult = PopupResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerWidget.OnSelectedCategoryChanged
// (Event, Protected, BlueprintEvent)

void UDCReportPlayerWidget::OnSelectedCategoryChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerWidget", "OnSelectedCategoryChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.SentInvitationSlotWidget.OnRightClicked
// (Native, Protected)

void USentInvitationSlotWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SentInvitationSlotWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.BTT_BlueprintBase.OnTaskFinished
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AAIController*                    OwnerController                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ControlledPawn                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBTNodeResult                           TaskResult                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTT_BlueprintBase::OnTaskFinished(class AAIController* OwnerController, class APawn* ControlledPawn, EBTNodeResult TaskResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTT_BlueprintBase", "OnTaskFinished");

	Params::BTT_BlueprintBase_OnTaskFinished Parms{};

	Parms.OwnerController = OwnerController;
	Parms.ControlledPawn = ControlledPawn;
	Parms.TaskResult = TaskResult;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAT_WaitGameplayTags.GameplayTagCallback
// (Native, Public)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAT_WaitGameplayTags::GameplayTagCallback(const struct FGameplayTag& Tag, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitGameplayTags", "GameplayTagCallback");

	Params::DCAT_WaitGameplayTags_GameplayTagCallback Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitGameplayTagsAdded.WaitGameplayTagsAdded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TagContainer                                           (Parm, NativeAccessSpecifierPublic)
// bool                                    bIsWaitAnyTag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOptionalExternalTarget                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOnlyTriggerOnce                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitGameplayTagsAdded*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitGameplayTagsAdded* UDCAT_WaitGameplayTagsAdded::WaitGameplayTagsAdded(class UGameplayAbility* OwningAbility, const struct FGameplayTagContainer& TagContainer, bool bIsWaitAnyTag, class AActor* InOptionalExternalTarget, bool bIsOnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitGameplayTagsAdded", "WaitGameplayTagsAdded");

	Params::DCAT_WaitGameplayTagsAdded_WaitGameplayTagsAdded Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TagContainer = std::move(TagContainer);
	Parms.bIsWaitAnyTag = bIsWaitAnyTag;
	Parms.InOptionalExternalTarget = InOptionalExternalTarget;
	Parms.bIsOnlyTriggerOnce = bIsOnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerState.OnRep_ForceExitWorldTimeSeconds
// (Final, Native, Private)

void ADCPlayerState::OnRep_ForceExitWorldTimeSeconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerState", "OnRep_ForceExitWorldTimeSeconds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerState.OnRep_GameOver
// (Final, Native, Private)

void ADCPlayerState::OnRep_GameOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerState", "OnRep_GameOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerState.OnRep_IsUserLoaded
// (Final, Native, Private)

void ADCPlayerState::OnRep_IsUserLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerState", "OnRep_IsUserLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerState.GetForceExitRemainSeconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADCPlayerState::GetForceExitRemainSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerState", "GetForceExitRemainSeconds");

	Params::DCPlayerState_GetForceExitRemainSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GRACPopup.ClosePopup
// (Final, Native, Protected, BlueprintCallable)

void UGRACPopup::ClosePopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GRACPopup", "ClosePopup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountStatusUpgradeShopWidget.OnSetContentsBlockHours
// (Event, Protected, BlueprintEvent)
// Parameters:
// EServicePolicyType                      InPolicyType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InBlockHours                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAccountStatusUpgradeShopWidget::OnSetContentsBlockHours(const EServicePolicyType InPolicyType, const int32 InBlockHours)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountStatusUpgradeShopWidget", "OnSetContentsBlockHours");

	Params::DCAccountStatusUpgradeShopWidget_OnSetContentsBlockHours Parms{};

	Parms.InPolicyType = InPolicyType;
	Parms.InBlockHours = InBlockHours;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAccountStatusUpgradeShopWidget.OnSetUpgradeShopInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDCAccountStatusUpgradeShopInfo  InUpgradeShopInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAccountStatusUpgradeShopWidget::OnSetUpgradeShopInfo(const struct FDCAccountStatusUpgradeShopInfo& InUpgradeShopInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountStatusUpgradeShopWidget", "OnSetUpgradeShopInfo");

	Params::DCAccountStatusUpgradeShopWidget_OnSetUpgradeShopInfo Parms{};

	Parms.InUpgradeShopInfo = std::move(InUpgradeShopInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAccountStatusUpgradeShopWidget.OnUpgradeButtonClicked
// (Final, Native, Private)

void UDCAccountStatusUpgradeShopWidget::OnUpgradeButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountStatusUpgradeShopWidget", "OnUpgradeButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCQuestRequirementFetchWidget.OnButtonFill
// (Final, Native, Private)

void UDCQuestRequirementFetchWidget::OnButtonFill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestRequirementFetchWidget", "OnButtonFill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCQuestRequirementFetchWidget.GetFetchRequiredTitle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCQuestRequirementFetchWidget::GetFetchRequiredTitle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestRequirementFetchWidget", "GetFetchRequiredTitle");

	Params::DCQuestRequirementFetchWidget_GetFetchRequiredTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCQuestRequirementFetchWidget.IsFilled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCQuestRequirementFetchWidget::IsFilled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestRequirementFetchWidget", "IsFilled");

	Params::DCQuestRequirementFetchWidget_IsFilled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCQuestRequirementFetchWidget.IsItemDeliveryAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCQuestRequirementFetchWidget::IsItemDeliveryAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestRequirementFetchWidget", "IsItemDeliveryAvailable");

	Params::DCQuestRequirementFetchWidget_IsItemDeliveryAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCQuestRequirementFetchWidget.OnAnyItemFilled
// (Event, Protected, BlueprintEvent, Const)

void UDCQuestRequirementFetchWidget::OnAnyItemFilled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestRequirementFetchWidget", "OnAnyItemFilled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCRewardTokensWidgetBase.OnClickRedeemButton
// (Final, Native, Private)

void UDCRewardTokensWidgetBase::OnClickRedeemButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRewardTokensWidgetBase", "OnClickRedeemButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LobbyGroupTradingWidget.OnLeaveChannelButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void ULobbyGroupTradingWidget::OnLeaveChannelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyGroupTradingWidget", "OnLeaveChannelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LobbyGroupTradingWidget.OnReadRulesButtonClicked
// (Final, Native, Private)

void ULobbyGroupTradingWidget::OnReadRulesButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyGroupTradingWidget", "OnReadRulesButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountNameChangeShopConfirmPopup.OnCancel
// (Final, Native, Private)

void UDCAccountNameChangeShopConfirmPopup::OnCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountNameChangeShopConfirmPopup", "OnCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountNameChangeShopConfirmPopup.OnConfirm
// (Final, Native, Private)

void UDCAccountNameChangeShopConfirmPopup::OnConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountNameChangeShopConfirmPopup", "OnConfirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterCreateWidget.CanLaunchRedstoneShardShop
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterCreateWidget::CanLaunchRedstoneShardShop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "CanLaunchRedstoneShardShop");

	Params::CharacterCreateWidget_CanLaunchRedstoneShardShop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterCreateWidget.GetCanCreateVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UCharacterCreateWidget::GetCanCreateVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "GetCanCreateVisibility");

	Params::CharacterCreateWidget_GetCanCreateVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterCreateWidget.GetCannotCreateVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UCharacterCreateWidget::GetCannotCreateVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "GetCannotCreateVisibility");

	Params::CharacterCreateWidget_GetCannotCreateVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterCreateWidget.GetCashPrice
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterCreateWidget::GetCashPrice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "GetCashPrice");

	Params::CharacterCreateWidget_GetCashPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterCreateWidget.GetPrice
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterCreateWidget::GetPrice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "GetPrice");

	Params::CharacterCreateWidget_GetPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterCreateWidget.HandleConfirmButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UCharacterCreateWidget::HandleConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "HandleConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterCreateWidget.HandleExitButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UCharacterCreateWidget::HandleExitButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "HandleExitButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterCreateWidget.OnClassSelectTileViewItemSelectionChanged
// (Final, Native, Private)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCreateWidget::OnClassSelectTileViewItemSelectionChanged(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "OnClassSelectTileViewItemSelectionChanged");

	Params::CharacterCreateWidget_OnClassSelectTileViewItemSelectionChanged Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterCreateWidget.OnGenderClicked
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDCGender                               Gender                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCreateWidget::OnGenderClicked(const EDCGender Gender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "OnGenderClicked");

	Params::CharacterCreateWidget_OnGenderClicked Parms{};

	Parms.Gender = Gender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterCreateWidget.OnLaunchShopURLButtonClicked
// (Final, Native, Private)

void UCharacterCreateWidget::OnLaunchShopURLButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "OnLaunchShopURLButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterCreateWidget.OnPurchaseButtonClicked
// (Final, Native, Private)

void UCharacterCreateWidget::OnPurchaseButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "OnPurchaseButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterCreateWidget.OnTextChangedNickName
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InNickName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterCreateWidget::OnTextChangedNickName(const class FText& InNickName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "OnTextChangedNickName");

	Params::CharacterCreateWidget_OnTextChangedNickName Parms{};

	Parms.InNickName = std::move(InNickName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterCreateWidget.SelectCharacterClass
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDCCharacterClass                       CharacterClass                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterCreateWidget::SelectCharacterClass(const EDCCharacterClass CharacterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCreateWidget", "SelectCharacterClass");

	Params::CharacterCreateWidget_SelectCharacterClass Parms{};

	Parms.CharacterClass = CharacterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDataComponent.OnRep_AssetId
// (Final, Native, Private, HasDefaults)
// Parameters:
// struct FPrimaryAssetId                  PrevAssetId                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCDataComponent::OnRep_AssetId(const struct FPrimaryAssetId& PrevAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDataComponent", "OnRep_AssetId");

	Params::DCDataComponent_OnRep_AssetId Parms{};

	Parms.PrevAssetId = std::move(PrevAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayRandomMontageWaitForEvent.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_PlayRandomMontageWaitForEvent::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayRandomMontageWaitForEvent", "AbilityActivated");

	Params::GA_PlayRandomMontageWaitForEvent_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayRandomMontageWaitForEvent.EventReceived
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayRandomMontageWaitForEvent::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayRandomMontageWaitForEvent", "EventReceived");

	Params::GA_PlayRandomMontageWaitForEvent_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayRandomMontageWaitForEvent.EventReceivedBlueprint
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayRandomMontageWaitForEvent::EventReceivedBlueprint(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayRandomMontageWaitForEvent", "EventReceivedBlueprint");

	Params::GA_PlayRandomMontageWaitForEvent_EventReceivedBlueprint Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayRandomMontageWaitForEvent.OnCancelled
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayRandomMontageWaitForEvent::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayRandomMontageWaitForEvent", "OnCancelled");

	Params::GA_PlayRandomMontageWaitForEvent_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayRandomMontageWaitForEvent.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayRandomMontageWaitForEvent::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayRandomMontageWaitForEvent", "OnCompleted");

	Params::GA_PlayRandomMontageWaitForEvent_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectCharListWidget.GetPageArrowVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UCharacterSelectCharListWidget::GetPageArrowVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharListWidget", "GetPageArrowVisibility");

	Params::CharacterSelectCharListWidget_GetPageArrowVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterSelectCharListWidget.GetSelectedCharacterWidgetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCharacterSelectCharacterSlotWidgetData*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterSelectCharacterSlotWidgetData* UCharacterSelectCharListWidget::GetSelectedCharacterWidgetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharListWidget", "GetSelectedCharacterWidgetData");

	Params::CharacterSelectCharListWidget_GetSelectedCharacterWidgetData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterSelectCharListWidget.HandleCharacterCreateClicked
// (Final, Native, Protected, BlueprintCallable)

void UCharacterSelectCharListWidget::HandleCharacterCreateClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharListWidget", "HandleCharacterCreateClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectCharListWidget.HandleCharacterDeleteClicked
// (Final, Native, Protected, BlueprintCallable)

void UCharacterSelectCharListWidget::HandleCharacterDeleteClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharListWidget", "HandleCharacterDeleteClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectCharListWidget.OnCharacterSlotData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FCharacterSlotData               NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCharacterSlotData               OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterSelectCharListWidget::OnCharacterSlotData(const struct FCharacterSlotData& NewValue, const struct FCharacterSlotData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharListWidget", "OnCharacterSlotData");

	Params::CharacterSelectCharListWidget_OnCharacterSlotData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterSelectCharListWidget.OnCharacterSlotListViewItemClicked
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSelectCharListWidget::OnCharacterSlotListViewItemClicked(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharListWidget", "OnCharacterSlotListViewItemClicked");

	Params::CharacterSelectCharListWidget_OnCharacterSlotListViewItemClicked Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectCharListWidget.OnListLeftButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UCharacterSelectCharListWidget::OnListLeftButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharListWidget", "OnListLeftButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectCharListWidget.OnListRightButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UCharacterSelectCharListWidget::OnListRightButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharListWidget", "OnListRightButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectCharListWidget.OnPageNumber
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   CurrentPage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxPage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSelectCharListWidget::OnPageNumber(const int32 CurrentPage, const int32 MaxPage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharListWidget", "OnPageNumber");

	Params::CharacterSelectCharListWidget_OnPageNumber Parms{};

	Parms.CurrentPage = CurrentPage;
	Parms.MaxPage = MaxPage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterSelectCharListWidget.OnSelectedCharacterId
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           CharacterId                                            (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSelectCharListWidget::OnSelectedCharacterId(const class FString& CharacterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharListWidget", "OnSelectedCharacterId");

	Params::CharacterSelectCharListWidget_OnSelectedCharacterId Parms{};

	Parms.CharacterId = std::move(CharacterId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectCharSlotWidget.CanSelect
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterSelectCharSlotWidget::CanSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharSlotWidget", "CanSelect");

	Params::CharacterSelectCharSlotWidget_CanSelect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterSelectCharSlotWidget.OnCharacterSlot
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FCharacterSlot                   NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCharacterSlot                   OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterSelectCharSlotWidget::OnCharacterSlot(const struct FCharacterSlot& NewValue, const struct FCharacterSlot& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharSlotWidget", "OnCharacterSlot");

	Params::CharacterSelectCharSlotWidget_OnCharacterSlot Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterSelectCharSlotWidget.OnFMsgWidgetStreamingModeNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetStreamingModeNotify    InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterSelectCharSlotWidget::OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharSlotWidget", "OnFMsgWidgetStreamingModeNotifyBlueprint");

	Params::CharacterSelectCharSlotWidget_OnFMsgWidgetStreamingModeNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterSelectCharSlotWidget.IsSelected
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterSelectCharSlotWidget::IsSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectCharSlotWidget", "IsSelected");

	Params::CharacterSelectCharSlotWidget_IsSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCRecentMatchCharacterSlotWidget.OnCloseClicked
// (Final, Native, Private)

void UDCRecentMatchCharacterSlotWidget::OnCloseClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRecentMatchCharacterSlotWidget", "OnCloseClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRecentMatchCharacterSlotWidget.OnInvitePartyClicked
// (Final, Native, Private)

void UDCRecentMatchCharacterSlotWidget::OnInvitePartyClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRecentMatchCharacterSlotWidget", "OnInvitePartyClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRecentMatchCharacterSlotWidget.OnRequestFriendClicked
// (Final, Native, Private)

void UDCRecentMatchCharacterSlotWidget::OnRequestFriendClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRecentMatchCharacterSlotWidget", "OnRequestFriendClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectWidget.CanEnterLobby
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterSelectWidget::CanEnterLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectWidget", "CanEnterLobby");

	Params::CharacterSelectWidget_CanEnterLobby Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterSelectWidget.CanLaunchRedstoneShardShop
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterSelectWidget::CanLaunchRedstoneShardShop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectWidget", "CanLaunchRedstoneShardShop");

	Params::CharacterSelectWidget_CanLaunchRedstoneShardShop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterSelectWidget.GetCashPrice
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterSelectWidget::GetCashPrice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectWidget", "GetCashPrice");

	Params::CharacterSelectWidget_GetCashPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterSelectWidget.GetPrice
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterSelectWidget::GetPrice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectWidget", "GetPrice");

	Params::CharacterSelectWidget_GetPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterSelectWidget.HandleExitButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UCharacterSelectWidget::HandleExitButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectWidget", "HandleExitButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectWidget.HandleLobbyButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UCharacterSelectWidget::HandleLobbyButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectWidget", "HandleLobbyButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectWidget.HandleOptionButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UCharacterSelectWidget::HandleOptionButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectWidget", "HandleOptionButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectWidget.IsNeedPurchase
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterSelectWidget::IsNeedPurchase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectWidget", "IsNeedPurchase");

	Params::CharacterSelectWidget_IsNeedPurchase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CharacterSelectWidget.OnLaunchShopURLButtonClicked
// (Final, Native, Private)

void UCharacterSelectWidget::OnLaunchShopURLButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectWidget", "OnLaunchShopURLButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterSelectWidget.OnPurchaseButtonClicked
// (Final, Native, Private)

void UCharacterSelectWidget::OnPurchaseButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelectWidget", "OnPurchaseButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnActionSpeed
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnActionSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnActionSpeed");

	Params::CharacterStatusDetailWidget_OnActionSpeed Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnAgility
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnAgility(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnAgility");

	Params::CharacterStatusDetailWidget_OnAgility Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnAirMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnAirMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnAirMagicalReduction");

	Params::CharacterStatusDetailWidget_OnAirMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnAirMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnAirMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnAirMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnAirMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnAirMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnAirMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnAirMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnAirMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnAirMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnAirMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnAirMagicResistance");

	Params::CharacterStatusDetailWidget_OnAirMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnArcaneMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnArcaneMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnArcaneMagicalReduction");

	Params::CharacterStatusDetailWidget_OnArcaneMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnArcaneMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnArcaneMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnArcaneMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnArcaneMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnArcaneMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnArcaneMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnArcaneMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnArcaneMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnArcaneMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnArcaneMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnArcaneMagicResistance");

	Params::CharacterStatusDetailWidget_OnArcaneMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnArmorPenetration
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnArmorPenetration(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnArmorPenetration");

	Params::CharacterStatusDetailWidget_OnArmorPenetration Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnArmorRating
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnArmorRating(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnArmorRating");

	Params::CharacterStatusDetailWidget_OnArmorRating Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnBuffDurationMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnBuffDurationMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnBuffDurationMod");

	Params::CharacterStatusDetailWidget_OnBuffDurationMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnCooldownReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnCooldownReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnCooldownReductionMod");

	Params::CharacterStatusDetailWidget_OnCooldownReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDarkMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDarkMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDarkMagicalReduction");

	Params::CharacterStatusDetailWidget_OnDarkMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDarkMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDarkMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDarkMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnDarkMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDarkMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDarkMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDarkMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnDarkMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDarkMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDarkMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDarkMagicResistance");

	Params::CharacterStatusDetailWidget_OnDarkMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDebuffDurationMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDebuffDurationMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDebuffDurationMod");

	Params::CharacterStatusDetailWidget_OnDebuffDurationMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDemonReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDemonReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDemonReductionMod");

	Params::CharacterStatusDetailWidget_OnDemonReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDexterity
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDexterity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDexterity");

	Params::CharacterStatusDetailWidget_OnDexterity Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDivineMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDivineMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDivineMagicalReduction");

	Params::CharacterStatusDetailWidget_OnDivineMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDivineMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDivineMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDivineMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnDivineMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDivineMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDivineMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDivineMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnDivineMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnDivineMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnDivineMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnDivineMagicResistance");

	Params::CharacterStatusDetailWidget_OnDivineMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnEarthMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnEarthMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnEarthMagicalReduction");

	Params::CharacterStatusDetailWidget_OnEarthMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnEarthMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnEarthMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnEarthMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnEarthMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnEarthMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnEarthMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnEarthMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnEarthMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnEarthMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnEarthMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnEarthMagicResistance");

	Params::CharacterStatusDetailWidget_OnEarthMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnEvilMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnEvilMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnEvilMagicalReduction");

	Params::CharacterStatusDetailWidget_OnEvilMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnEvilMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnEvilMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnEvilMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnEvilMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnEvilMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnEvilMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnEvilMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnEvilMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnEvilMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnEvilMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnEvilMagicResistance");

	Params::CharacterStatusDetailWidget_OnEvilMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnFireMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnFireMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnFireMagicalReduction");

	Params::CharacterStatusDetailWidget_OnFireMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnFireMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnFireMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnFireMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnFireMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnFireMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnFireMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnFireMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnFireMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnFireMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnFireMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnFireMagicResistance");

	Params::CharacterStatusDetailWidget_OnFireMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnHeadshotReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnHeadshotReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnHeadshotReductionMod");

	Params::CharacterStatusDetailWidget_OnHeadshotReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnHealth
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnHealth");

	Params::CharacterStatusDetailWidget_OnHealth Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnHealthRecoveryMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnHealthRecoveryMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnHealthRecoveryMod");

	Params::CharacterStatusDetailWidget_OnHealthRecoveryMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnIceMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnIceMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnIceMagicalReduction");

	Params::CharacterStatusDetailWidget_OnIceMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnIceMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnIceMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnIceMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnIceMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnIceMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnIceMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnIceMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnIceMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnIceMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnIceMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnIceMagicResistance");

	Params::CharacterStatusDetailWidget_OnIceMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnImpactPower
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnImpactPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnImpactPower");

	Params::CharacterStatusDetailWidget_OnImpactPower Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnItemEquipSpeed
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnItemEquipSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnItemEquipSpeed");

	Params::CharacterStatusDetailWidget_OnItemEquipSpeed Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnKnowledge
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnKnowledge(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnKnowledge");

	Params::CharacterStatusDetailWidget_OnKnowledge Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnLightMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnLightMagicalReduction");

	Params::CharacterStatusDetailWidget_OnLightMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnLightMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnLightMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnLightMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnLightMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnLightMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnLightMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnLightMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnLightMagicResistance");

	Params::CharacterStatusDetailWidget_OnLightMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightningMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnLightningMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnLightningMagicalReduction");

	Params::CharacterStatusDetailWidget_OnLightningMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightningMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnLightningMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnLightningMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnLightningMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightningMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnLightningMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnLightningMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnLightningMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnLightningMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnLightningMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnLightningMagicResistance");

	Params::CharacterStatusDetailWidget_OnLightningMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnLuck
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnLuck(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnLuck");

	Params::CharacterStatusDetailWidget_OnLuck Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalDamageAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalDamageAdd");

	Params::CharacterStatusDetailWidget_OnMagicalDamageAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalDamageBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalDamageBase");

	Params::CharacterStatusDetailWidget_OnMagicalDamageBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalDamageMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalDamageMod");

	Params::CharacterStatusDetailWidget_OnMagicalDamageMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageModBonus
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalDamageModBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalDamageModBonus");

	Params::CharacterStatusDetailWidget_OnMagicalDamageModBonus Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageModMagicalPower
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalDamageModMagicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalDamageModMagicalPower");

	Params::CharacterStatusDetailWidget_OnMagicalDamageModMagicalPower Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageTrue
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalDamageTrue(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalDamageTrue");

	Params::CharacterStatusDetailWidget_OnMagicalDamageTrue Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalHealBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalHealBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalHealBase");

	Params::CharacterStatusDetailWidget_OnMagicalHealBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalHealingReceiveMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalHealingReceiveMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalHealingReceiveMod");

	Params::CharacterStatusDetailWidget_OnMagicalHealingReceiveMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalHealMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalHealMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalHealMod");

	Params::CharacterStatusDetailWidget_OnMagicalHealMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalInteractionSpeed
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalInteractionSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalInteractionSpeed");

	Params::CharacterStatusDetailWidget_OnMagicalInteractionSpeed Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalPower
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalPower");

	Params::CharacterStatusDetailWidget_OnMagicalPower Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalReduction");

	Params::CharacterStatusDetailWidget_OnMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionBonus
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalReductionBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalReductionBonus");

	Params::CharacterStatusDetailWidget_OnMagicalReductionBonus Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicPenetration
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicPenetration(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicPenetration");

	Params::CharacterStatusDetailWidget_OnMagicPenetration Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMagicResistance");

	Params::CharacterStatusDetailWidget_OnMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnManualDexterity
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnManualDexterity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnManualDexterity");

	Params::CharacterStatusDetailWidget_OnManualDexterity Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealth
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMaxHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMaxHealth");

	Params::CharacterStatusDetailWidget_OnMaxHealth Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMaxHealthAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMaxHealthAdd");

	Params::CharacterStatusDetailWidget_OnMaxHealthAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMaxHealthBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMaxHealthBase");

	Params::CharacterStatusDetailWidget_OnMaxHealthBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMaxHealthMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMaxHealthMod");

	Params::CharacterStatusDetailWidget_OnMaxHealthMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxSpellCountMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMaxSpellCountMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMaxSpellCountMod");

	Params::CharacterStatusDetailWidget_OnMaxSpellCountMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryCapacity
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMemoryCapacity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMemoryCapacity");

	Params::CharacterStatusDetailWidget_OnMemoryCapacity Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryCapacityAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMemoryCapacityAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMemoryCapacityAdd");

	Params::CharacterStatusDetailWidget_OnMemoryCapacityAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryCapacityBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMemoryCapacityBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMemoryCapacityBase");

	Params::CharacterStatusDetailWidget_OnMemoryCapacityBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryCapacityMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMemoryCapacityMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMemoryCapacityMod");

	Params::CharacterStatusDetailWidget_OnMemoryCapacityMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryMusicPayload
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMemoryMusicPayload(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMemoryMusicPayload");

	Params::CharacterStatusDetailWidget_OnMemoryMusicPayload Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemoryRecoveryMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMemoryRecoveryMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMemoryRecoveryMod");

	Params::CharacterStatusDetailWidget_OnMemoryRecoveryMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMemorySpellPayload
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMemorySpellPayload(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMemorySpellPayload");

	Params::CharacterStatusDetailWidget_OnMemorySpellPayload Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeed
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMoveSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMoveSpeed");

	Params::CharacterStatusDetailWidget_OnMoveSpeed Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMoveSpeedAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMoveSpeedAdd");

	Params::CharacterStatusDetailWidget_OnMoveSpeedAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMoveSpeedBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMoveSpeedBase");

	Params::CharacterStatusDetailWidget_OnMoveSpeedBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMoveSpeedMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMoveSpeedMod");

	Params::CharacterStatusDetailWidget_OnMoveSpeedMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedWithModifier
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnMoveSpeedWithModifier(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnMoveSpeedWithModifier");

	Params::CharacterStatusDetailWidget_OnMoveSpeedWithModifier Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnOverhealedHealth
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnOverhealedHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnOverhealedHealth");

	Params::CharacterStatusDetailWidget_OnOverhealedHealth Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPersuasiveness
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPersuasiveness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPersuasiveness");

	Params::CharacterStatusDetailWidget_OnPersuasiveness Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalDamageAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalDamageAdd");

	Params::CharacterStatusDetailWidget_OnPhysicalDamageAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalDamageBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalDamageBase");

	Params::CharacterStatusDetailWidget_OnPhysicalDamageBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalDamageMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalDamageMod");

	Params::CharacterStatusDetailWidget_OnPhysicalDamageMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageModBonus
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalDamageModBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalDamageModBonus");

	Params::CharacterStatusDetailWidget_OnPhysicalDamageModBonus Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageModPhysicalPower
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalDamageModPhysicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalDamageModPhysicalPower");

	Params::CharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageTrue
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalDamageTrue(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalDamageTrue");

	Params::CharacterStatusDetailWidget_OnPhysicalDamageTrue Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageWeaponPrimary
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalDamageWeaponPrimary(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalDamageWeaponPrimary");

	Params::CharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageWeaponSecondary
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalDamageWeaponSecondary(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalDamageWeaponSecondary");

	Params::CharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalHeadshotPenetration
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalHeadshotPenetration(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalHeadshotPenetration");

	Params::CharacterStatusDetailWidget_OnPhysicalHeadshotPenetration Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalHealBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalHealBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalHealBase");

	Params::CharacterStatusDetailWidget_OnPhysicalHealBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalHealingReceiveMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalHealingReceiveMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalHealingReceiveMod");

	Params::CharacterStatusDetailWidget_OnPhysicalHealingReceiveMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalHealMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalHealMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalHealMod");

	Params::CharacterStatusDetailWidget_OnPhysicalHealMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalPower
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalPower");

	Params::CharacterStatusDetailWidget_OnPhysicalPower Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalReduction");

	Params::CharacterStatusDetailWidget_OnPhysicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionArmorRating
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalReductionArmorRating(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalReductionArmorRating");

	Params::CharacterStatusDetailWidget_OnPhysicalReductionArmorRating Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionBonus
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalReductionBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalReductionBonus");

	Params::CharacterStatusDetailWidget_OnPhysicalReductionBonus Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPhysicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPhysicalReductionMod");

	Params::CharacterStatusDetailWidget_OnPhysicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPrimaryAbilityWidgetArray
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UItemTooltipStatWidgetData*>NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UItemTooltipStatWidgetData*>OldValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPrimaryAbilityWidgetArray(const TArray<class UItemTooltipStatWidgetData*>& NewValue, const TArray<class UItemTooltipStatWidgetData*>& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPrimaryAbilityWidgetArray");

	Params::CharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnPrimaryWeaponImpactPower
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnPrimaryWeaponImpactPower(const float& NewValue, const float& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnPrimaryWeaponImpactPower");

	Params::CharacterStatusDetailWidget_OnPrimaryWeaponImpactPower Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnProjectileReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnProjectileReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnProjectileReductionMod");

	Params::CharacterStatusDetailWidget_OnProjectileReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnRegularInteractionSpeed
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnRegularInteractionSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnRegularInteractionSpeed");

	Params::CharacterStatusDetailWidget_OnRegularInteractionSpeed Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnRegularInteractionSpeedBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnRegularInteractionSpeedBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnRegularInteractionSpeedBase");

	Params::CharacterStatusDetailWidget_OnRegularInteractionSpeedBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnResourcefulness
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnResourcefulness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnResourcefulness");

	Params::CharacterStatusDetailWidget_OnResourcefulness Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnSecondaryAbilityWidgetArray
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UItemTooltipStatWidgetData*>NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UItemTooltipStatWidgetData*>OldValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnSecondaryAbilityWidgetArray(const TArray<class UItemTooltipStatWidgetData*>& NewValue, const TArray<class UItemTooltipStatWidgetData*>& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnSecondaryAbilityWidgetArray");

	Params::CharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnSecondaryWeaponImpactPower
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnSecondaryWeaponImpactPower(const float& NewValue, const float& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnSecondaryWeaponImpactPower");

	Params::CharacterStatusDetailWidget_OnSecondaryWeaponImpactPower Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCastingSpeed
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnSpellCastingSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnSpellCastingSpeed");

	Params::CharacterStatusDetailWidget_OnSpellCastingSpeed Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnSpiritMagicalReduction
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnSpiritMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnSpiritMagicalReduction");

	Params::CharacterStatusDetailWidget_OnSpiritMagicalReduction Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnSpiritMagicalReductionMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnSpiritMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnSpiritMagicalReductionMagicResistance");

	Params::CharacterStatusDetailWidget_OnSpiritMagicalReductionMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnSpiritMagicalReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnSpiritMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnSpiritMagicalReductionMod");

	Params::CharacterStatusDetailWidget_OnSpiritMagicalReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnSpiritMagicResistance
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnSpiritMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnSpiritMagicResistance");

	Params::CharacterStatusDetailWidget_OnSpiritMagicResistance Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnStrength
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnStrength(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnStrength");

	Params::CharacterStatusDetailWidget_OnStrength Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnUndeadDamageMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnUndeadDamageMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnUndeadDamageMod");

	Params::CharacterStatusDetailWidget_OnUndeadDamageMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnUndeadReductionMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnUndeadReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnUndeadReductionMod");

	Params::CharacterStatusDetailWidget_OnUndeadReductionMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectiveness
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnUtilityEffectiveness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnUtilityEffectiveness");

	Params::CharacterStatusDetailWidget_OnUtilityEffectiveness Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnUtilityEffectivenessAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnUtilityEffectivenessAdd");

	Params::CharacterStatusDetailWidget_OnUtilityEffectivenessAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnUtilityEffectivenessBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnUtilityEffectivenessBase");

	Params::CharacterStatusDetailWidget_OnUtilityEffectivenessBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnUtilityEffectivenessMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnUtilityEffectivenessMod");

	Params::CharacterStatusDetailWidget_OnUtilityEffectivenessMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnVigor
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnVigor(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnVigor");

	Params::CharacterStatusDetailWidget_OnVigor Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnWeight
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnWeight(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnWeight");

	Params::CharacterStatusDetailWidget_OnWeight Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimit
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnWeightLimit(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnWeightLimit");

	Params::CharacterStatusDetailWidget_OnWeightLimit Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnWeightLimitAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnWeightLimitAdd");

	Params::CharacterStatusDetailWidget_OnWeightLimitAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnWeightLimitBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnWeightLimitBase");

	Params::CharacterStatusDetailWidget_OnWeightLimitBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnWeightLimitMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnWeightLimitMod");

	Params::CharacterStatusDetailWidget_OnWeightLimitMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.OnWill
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::OnWill(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "OnWill");

	Params::CharacterStatusDetailWidget_OnWill Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusDetailWidget.SetupLobbyCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADCCharacterV2*                   InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterStatusDetailWidget::SetupLobbyCharacter(const class ADCCharacterV2* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusDetailWidget", "SetupLobbyCharacter");

	Params::CharacterStatusDetailWidget_SetupLobbyCharacter Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_StoppablePassiveBase.OnAllStopStateTagsRemoved
// (Final, Native, Private)

void UGA_StoppablePassiveBase::OnAllStopStateTagsRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_StoppablePassiveBase", "OnAllStopStateTagsRemoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_StoppablePassiveBase.OnAnyStopStateTagAdded
// (Final, Native, Private)

void UGA_StoppablePassiveBase::OnAnyStopStateTagAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_StoppablePassiveBase", "OnAnyStopStateTagAdded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_StoppablePassiveBase.OnPassiveStart
// (Native, Event, Protected, BlueprintEvent)

void UGA_StoppablePassiveBase::OnPassiveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_StoppablePassiveBase", "OnPassiveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_StoppablePassiveBase.OnPassiveStop
// (Native, Event, Protected, BlueprintEvent)

void UGA_StoppablePassiveBase::OnPassiveStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_StoppablePassiveBase", "OnPassiveStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_InteractPassive.OnFoundNewInteractableTarget
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_InteractPassive::OnFoundNewInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractPassive", "OnFoundNewInteractableTarget");

	Params::GA_InteractPassive_OnFoundNewInteractableTarget Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_InteractPassive.OnLostInteractableTarget
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_InteractPassive::OnLostInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractPassive", "OnLostInteractableTarget");

	Params::GA_InteractPassive_OnLostInteractableTarget Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_InteractPassive.OnTargetGameplayTagChange
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_InteractPassive::OnTargetGameplayTagChange(const struct FGameplayTag& InGameplayTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractPassive", "OnTargetGameplayTagChange");

	Params::GA_InteractPassive_OnTargetGameplayTagChange Parms{};

	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_InteractPassive.ReceivedEvent
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_InteractPassive::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractPassive", "ReceivedEvent");

	Params::GA_InteractPassive_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_InteractPassive.RefreshInteractionData
// (Final, Native, Protected)

void UGA_InteractPassive::RefreshInteractionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractPassive", "RefreshInteractionData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CharacterStatusWidget.OnAgility
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnAgility(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnAgility");

	Params::CharacterStatusWidget_OnAgility Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnDexterity
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnDexterity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnDexterity");

	Params::CharacterStatusWidget_OnDexterity Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnHealth
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnHealth");

	Params::CharacterStatusWidget_OnHealth Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnKnowledge
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnKnowledge(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnKnowledge");

	Params::CharacterStatusWidget_OnKnowledge Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnMaxHealth
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnMaxHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnMaxHealth");

	Params::CharacterStatusWidget_OnMaxHealth Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnMaxHealthAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnMaxHealthAdd");

	Params::CharacterStatusWidget_OnMaxHealthAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnMaxHealthBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnMaxHealthBase");

	Params::CharacterStatusWidget_OnMaxHealthBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnMaxHealthMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnMaxHealthMod");

	Params::CharacterStatusWidget_OnMaxHealthMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnMemoryCapacity
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnMemoryCapacity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnMemoryCapacity");

	Params::CharacterStatusWidget_OnMemoryCapacity Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnMemoryCapacityAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnMemoryCapacityAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnMemoryCapacityAdd");

	Params::CharacterStatusWidget_OnMemoryCapacityAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnMemoryCapacityBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnMemoryCapacityBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnMemoryCapacityBase");

	Params::CharacterStatusWidget_OnMemoryCapacityBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnMemoryCapacityMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnMemoryCapacityMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnMemoryCapacityMod");

	Params::CharacterStatusWidget_OnMemoryCapacityMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnMemoryMusicPayload
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnMemoryMusicPayload(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnMemoryMusicPayload");

	Params::CharacterStatusWidget_OnMemoryMusicPayload Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnMemorySpellPayload
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnMemorySpellPayload(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnMemorySpellPayload");

	Params::CharacterStatusWidget_OnMemorySpellPayload Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnOverhealedHealth
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnOverhealedHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnOverhealedHealth");

	Params::CharacterStatusWidget_OnOverhealedHealth Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnResourcefulness
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnResourcefulness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnResourcefulness");

	Params::CharacterStatusWidget_OnResourcefulness Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnStrength
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnStrength(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnStrength");

	Params::CharacterStatusWidget_OnStrength Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectiveness
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnUtilityEffectiveness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnUtilityEffectiveness");

	Params::CharacterStatusWidget_OnUtilityEffectiveness Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnUtilityEffectivenessAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnUtilityEffectivenessAdd");

	Params::CharacterStatusWidget_OnUtilityEffectivenessAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnUtilityEffectivenessBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnUtilityEffectivenessBase");

	Params::CharacterStatusWidget_OnUtilityEffectivenessBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnUtilityEffectivenessMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnUtilityEffectivenessMod");

	Params::CharacterStatusWidget_OnUtilityEffectivenessMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnVigor
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnVigor(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnVigor");

	Params::CharacterStatusWidget_OnVigor Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnWeight
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnWeight(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnWeight");

	Params::CharacterStatusWidget_OnWeight Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnWeightLimit
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnWeightLimit(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnWeightLimit");

	Params::CharacterStatusWidget_OnWeightLimit Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitAdd
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnWeightLimitAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnWeightLimitAdd");

	Params::CharacterStatusWidget_OnWeightLimitAdd Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitBase
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnWeightLimitBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnWeightLimitBase");

	Params::CharacterStatusWidget_OnWeightLimitBase Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitMod
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnWeightLimitMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnWeightLimitMod");

	Params::CharacterStatusWidget_OnWeightLimitMod Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CharacterStatusWidget.OnWill
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayAttributeData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterStatusWidget::OnWill(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatusWidget", "OnWill");

	Params::CharacterStatusWidget_OnWill Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DungeonSelectWidget.BroadcastLegendaryStatusContentsSelected
// (Final, Native, Protected, BlueprintCallable)

void UDungeonSelectWidget::BroadcastLegendaryStatusContentsSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "BroadcastLegendaryStatusContentsSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DungeonSelectWidget.CancelSelected
// (Final, Native, Protected, BlueprintCallable)

void UDungeonSelectWidget::CancelSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "CancelSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DungeonSelectWidget.OnDungeonRotationTimerData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDungeonRotationTimerData        NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDungeonRotationTimerData        OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDungeonSelectWidget::OnDungeonRotationTimerData(const struct FDungeonRotationTimerData& NewValue, const struct FDungeonRotationTimerData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "OnDungeonRotationTimerData");

	Params::DungeonSelectWidget_OnDungeonRotationTimerData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DungeonSelectWidget.OnGameType
// (Event, Protected, BlueprintEvent)
// Parameters:
// EGameType                               NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameType                               OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectWidget::OnGameType(EGameType NewValue, EGameType OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "OnGameType");

	Params::DungeonSelectWidget_OnGameType Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DungeonSelectWidget.OnGameUserSettingControlsChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameUserSettingControls         InGameUserSettingControls                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameUserSettingControls         InOldGameUserSettingControls                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectWidget::OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "OnGameUserSettingControlsChanged");

	Params::DungeonSelectWidget_OnGameUserSettingControlsChanged Parms{};

	Parms.InGameUserSettingControls = std::move(InGameUserSettingControls);
	Parms.InOldGameUserSettingControls = std::move(InOldGameUserSettingControls);
	Parms.bInForce = bInForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DungeonSelectWidget.OnMatchMode
// (Event, Protected, BlueprintEvent)
// Parameters:
// EMatchMode                              NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchMode                              OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectWidget::OnMatchMode(EMatchMode NewValue, EMatchMode OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "OnMatchMode");

	Params::DungeonSelectWidget_OnMatchMode Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DungeonSelectWidget.OnSetFeatureLockExpiredTime
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// bool                                    InIsLocked                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        InRemainTime                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectWidget::OnSetFeatureLockExpiredTime(const bool InIsLocked, const struct FTimespan& InRemainTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "OnSetFeatureLockExpiredTime");

	Params::DungeonSelectWidget_OnSetFeatureLockExpiredTime Parms{};

	Parms.InIsLocked = InIsLocked;
	Parms.InRemainTime = std::move(InRemainTime);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DungeonSelectWidget.SetGameType
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EMatchMode                              InMatchMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectWidget::SetGameType(EMatchMode InMatchMode, EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "SetGameType");

	Params::DungeonSelectWidget_SetGameType Parms{};

	Parms.InMatchMode = InMatchMode;
	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DungeonSelectWidget.GetArenaAssistStat
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDungeonSelectWidget::GetArenaAssistStat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "GetArenaAssistStat");

	Params::DungeonSelectWidget_GetArenaAssistStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DungeonSelectWidget.GetArenaBeginTime
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UDungeonSelectWidget::GetArenaBeginTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "GetArenaBeginTime");

	Params::DungeonSelectWidget_GetArenaBeginTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DungeonSelectWidget.GetArenaDeathStat
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDungeonSelectWidget::GetArenaDeathStat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "GetArenaDeathStat");

	Params::DungeonSelectWidget_GetArenaDeathStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DungeonSelectWidget.GetArenaDrawStat
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDungeonSelectWidget::GetArenaDrawStat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "GetArenaDrawStat");

	Params::DungeonSelectWidget_GetArenaDrawStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DungeonSelectWidget.GetArenaEndTime
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UDungeonSelectWidget::GetArenaEndTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "GetArenaEndTime");

	Params::DungeonSelectWidget_GetArenaEndTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DungeonSelectWidget.GetArenaKillStat
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDungeonSelectWidget::GetArenaKillStat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "GetArenaKillStat");

	Params::DungeonSelectWidget_GetArenaKillStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DungeonSelectWidget.GetArenaLoseStat
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDungeonSelectWidget::GetArenaLoseStat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "GetArenaLoseStat");

	Params::DungeonSelectWidget_GetArenaLoseStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DungeonSelectWidget.GetArenaWinStat
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDungeonSelectWidget::GetArenaWinStat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "GetArenaWinStat");

	Params::DungeonSelectWidget_GetArenaWinStat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DungeonSelectWidget.IsDungeonRestricted
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDungeonSelectWidget::IsDungeonRestricted(EGameType InGameType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectWidget", "IsDungeonRestricted");

	Params::DungeonSelectWidget_IsDungeonRestricted Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_InteractRope.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_InteractRope::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractRope", "AbilityActivated");

	Params::GA_InteractRope_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_InteractRope.AbilityCancel
// (Event, Protected, BlueprintEvent)

void UGA_InteractRope::AbilityCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractRope", "AbilityCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_InteractRope.EventReceived
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_InteractRope::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractRope", "EventReceived");

	Params::GA_InteractRope_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_InteractRope.HitKnockBackAttack
// (Final, Native, Protected)

void UGA_InteractRope::HitKnockBackAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractRope", "HitKnockBackAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_InteractRope.OnCancelled
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_InteractRope::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractRope", "OnCancelled");

	Params::GA_InteractRope_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_InteractRope.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_InteractRope::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_InteractRope", "OnCompleted");

	Params::GA_InteractRope_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatEditWidgetBase.IsEditableTextHasFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChatEditWidgetBase::IsEditableTextHasFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatEditWidgetBase", "IsEditableTextHasFocus");

	Params::ChatEditWidgetBase_IsEditableTextHasFocus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ChatEditWidgetBase.OnTextChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UChatEditWidgetBase::OnTextChanged(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatEditWidgetBase", "OnTextChanged");

	Params::ChatEditWidgetBase_OnTextChanged Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatEditWidgetBase.OnTextCommitted
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ETextCommit                             InCommitMethod                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatEditWidgetBase::OnTextCommitted(const class FText& InText, ETextCommit InCommitMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatEditWidgetBase", "OnTextCommitted");

	Params::ChatEditWidgetBase_OnTextCommitted Parms{};

	Parms.InText = std::move(InText);
	Parms.InCommitMethod = InCommitMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatEditWidgetBase.SetUserFocusText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatEditWidgetBase::SetUserFocusText(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatEditWidgetBase", "SetUserFocusText");

	Params::ChatEditWidgetBase_SetUserFocusText Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatFilterListEntryWidget.OnCheckStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bIsChecked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatFilterListEntryWidget::OnCheckStateChanged(bool bIsChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatFilterListEntryWidget", "OnCheckStateChanged");

	Params::ChatFilterListEntryWidget_OnCheckStateChanged Parms{};

	Parms.bIsChecked = bIsChecked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableTargetComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "BroadcastMsgBlueprint");

	Params::InteractableTargetComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.CancelAllInteractions
// (Final, Native, Public, BlueprintCallable)

void UInteractableTargetComponent::CancelAllInteractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "CancelAllInteractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.CanInteract
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractableTargetComponent::CanInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "CanInteract");

	Params::InteractableTargetComponent_CanInteract Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InteractableTargetComponent.InteractFailed
// (Final, Native, Private)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     TriggerTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableTargetComponent::InteractFailed(class AActor* InteractingActor, const struct FGameplayTag& TriggerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "InteractFailed");

	Params::InteractableTargetComponent_InteractFailed Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.TriggerTag = std::move(TriggerTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.InteractSucceed
// (Final, Native, Private)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     TriggerTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     StateTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInteractableTargetComponent::InteractSucceed(class AActor* InteractingActor, const struct FGameplayTag& TriggerTag, const struct FGameplayTag& StateTag, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "InteractSucceed");

	Params::InteractableTargetComponent_InteractSucceed Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.TriggerTag = std::move(TriggerTag);
	Parms.StateTag = std::move(StateTag);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.RegisterInteracter
// (Final, Native, Private)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableTargetComponent::RegisterInteracter(class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "RegisterInteracter");

	Params::InteractableTargetComponent_RegisterInteracter Parms{};

	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.SetInteractionData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDesignDataPropsInteract         InteractionData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInteractableTargetComponent::SetInteractionData(const struct FDesignDataPropsInteract& InteractionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "SetInteractionData");

	Params::InteractableTargetComponent_SetInteractionData Parms{};

	Parms.InteractionData = std::move(InteractionData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.SetInteractionDataV2
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDCPropsInteractDataAsset*        InteractionSettingData                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableTargetComponent::SetInteractionDataV2(const class UDCPropsInteractDataAsset* InteractionSettingData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "SetInteractionDataV2");

	Params::InteractableTargetComponent_SetInteractionDataV2 Parms{};

	Parms.InteractionSettingData = InteractionSettingData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.ShouldCancelOthersWhenInteractSucceed
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     StateTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractableTargetComponent::ShouldCancelOthersWhenInteractSucceed(const struct FGameplayTag& StateTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "ShouldCancelOthersWhenInteractSucceed");

	Params::InteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed Parms{};

	Parms.StateTag = std::move(StateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InteractableTargetComponent.TerminateBase
// (Native, Public)

void UInteractableTargetComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableTargetComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "UnbindMsg");

	Params::InteractableTargetComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableTargetComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "UnbindMsgAll");

	Params::InteractableTargetComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.UnregisterInteracter
// (Final, Native, Private)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractableTargetComponent::UnregisterInteracter(class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "UnregisterInteracter");

	Params::InteractableTargetComponent_UnregisterInteracter Parms{};

	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InteractableTargetComponent.GetData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     StateTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInteractionData                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInteractionData UInteractableTargetComponent::GetData(const struct FGameplayTag& StateTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "GetData");

	Params::InteractableTargetComponent_GetData Parms{};

	Parms.StateTag = std::move(StateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InteractableTargetComponent.GetInteractability
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OutInteractFailedTag                                   (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDCInteractableType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCInteractableType UInteractableTargetComponent::GetInteractability(class AActor* Interacter, struct FGameplayTag* OutInteractFailedTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "GetInteractability");

	Params::InteractableTargetComponent_GetInteractability Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInteractFailedTag != nullptr)
		*OutInteractFailedTag = std::move(Parms.OutInteractFailedTag);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InteractableTargetComponent.GetInteractableDataByStateMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<struct FGameplayTag, struct FInteractionData>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, struct FInteractionData> UInteractableTargetComponent::GetInteractableDataByStateMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "GetInteractableDataByStateMap");

	Params::InteractableTargetComponent_GetInteractableDataByStateMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InteractableTargetComponent.GetInteractTargetData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInteractTargetData              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInteractTargetData UInteractableTargetComponent::GetInteractTargetData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "GetInteractTargetData");

	Params::InteractableTargetComponent_GetInteractTargetData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InteractableTargetComponent.GetRemainingInteractCount
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInteractableTargetComponent::GetRemainingInteractCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "GetRemainingInteractCount");

	Params::InteractableTargetComponent_GetRemainingInteractCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InteractableTargetComponent.GetStateTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     TriggerTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UInteractableTargetComponent::GetStateTag(const struct FGameplayTag& TriggerTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "GetStateTag");

	Params::InteractableTargetComponent_GetStateTag Parms{};

	Parms.TriggerTag = std::move(TriggerTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InteractableTargetComponent.IsDetectable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractableTargetComponent::IsDetectable(class AActor* Interacter) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "IsDetectable");

	Params::InteractableTargetComponent_IsDetectable Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InteractableTargetComponent.ShouldConsumeHoldingItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsInteractionSucceed                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractableTargetComponent::ShouldConsumeHoldingItem(class AActor* Interacter, bool bIsInteractionSucceed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableTargetComponent", "ShouldConsumeHoldingItem");

	Params::InteractableTargetComponent_ShouldConsumeHoldingItem Parms{};

	Parms.Interacter = Interacter;
	Parms.bIsInteractionSucceed = bIsInteractionSucceed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAkComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAkComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkComponent", "BroadcastMsgBlueprint");

	Params::DCAkComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkComponent.PostSoundEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAkComponent::PostSoundEvent(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkComponent", "PostSoundEvent");

	Params::DCAkComponent_PostSoundEvent Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkComponent.SetSoundSwitch
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        SurfaceType                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SwitchGroup                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SwitchState                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAkComponent::SetSoundSwitch(const struct FGameplayTag& Tag, const EPhysicalSurface SurfaceType, const class FString& SwitchGroup, const class FString& SwitchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkComponent", "SetSoundSwitch");

	Params::DCAkComponent_SetSoundSwitch Parms{};

	Parms.Tag = std::move(Tag);
	Parms.SurfaceType = SurfaceType;
	Parms.SwitchGroup = std::move(SwitchGroup);
	Parms.SwitchState = std::move(SwitchState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkComponent.TerminateBase
// (Native, Public)

void UDCAkComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAkComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkComponent", "UnbindMsg");

	Params::DCAkComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAkComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkComponent", "UnbindMsgAll");

	Params::DCAkComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatFilterWidget.OnAddChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatFilterWidget::OnAddChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatFilterWidget", "OnAddChatFilterTag");

	Params::ChatFilterWidget_OnAddChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatFilterWidget.OnAnyChatFilterTagSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInSet                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatFilterWidget::OnAnyChatFilterTagSet(bool bInSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatFilterWidget", "OnAnyChatFilterTagSet");

	Params::ChatFilterWidget_OnAnyChatFilterTagSet Parms{};

	Parms.bInSet = bInSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ChatFilterWidget.OnRemoveChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatFilterWidget::OnRemoveChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatFilterWidget", "OnRemoveChatFilterTag");

	Params::ChatFilterWidget_OnRemoveChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatFilterWidget.RegenerateListItems
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             FindFilter                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UChatFilterWidget::RegenerateListItems(const class FText& FindFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatFilterWidget", "RegenerateListItems");

	Params::ChatFilterWidget_RegenerateListItems Parms{};

	Parms.FindFilter = std::move(FindFilter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatFilterWidget.ResetChatFilter
// (Final, Native, Protected, BlueprintCallable)

void UChatFilterWidget::ResetChatFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatFilterWidget", "ResetChatFilter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatFilterWidget.SetChatFilterListVisible
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InbVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatFilterWidget::SetChatFilterListVisible(bool InbVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatFilterWidget", "SetChatFilterListVisible");

	Params::ChatFilterWidget_SetChatFilterListVisible Parms{};

	Parms.InbVisible = InbVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ChatSetWidgetBase.AddSystemChatItemLinkDesc
// (Final, Native, Public, BlueprintCallable)

void UChatSetWidgetBase::AddSystemChatItemLinkDesc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "AddSystemChatItemLinkDesc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatSetWidgetBase.ChatKeyboardFocusEvent
// (Event, Protected, BlueprintEvent)

void UChatSetWidgetBase::ChatKeyboardFocusEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "ChatKeyboardFocusEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ChatSetWidgetBase.ChatScrollToBottom
// (Final, Native, Public, BlueprintCallable)

void UChatSetWidgetBase::ChatScrollToBottom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "ChatScrollToBottom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatSetWidgetBase.HideChatWidget
// (Event, Protected, BlueprintEvent)

void UChatSetWidgetBase::HideChatWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "HideChatWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ChatSetWidgetBase.IsTimerStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsFocused                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatSetWidgetBase::IsTimerStart(bool bIsFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "IsTimerStart");

	Params::ChatSetWidgetBase_IsTimerStart Parms{};

	Parms.bIsFocused = bIsFocused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ChatSetWidgetBase.OnChatAccountData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FChatAccountData                 NewItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FChatAccountData                 OldItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UChatSetWidgetBase::OnChatAccountData(const struct FChatAccountData& NewItemData, const struct FChatAccountData& OldItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "OnChatAccountData");

	Params::ChatSetWidgetBase_OnChatAccountData Parms{};

	Parms.NewItemData = std::move(NewItemData);
	Parms.OldItemData = std::move(OldItemData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ChatSetWidgetBase.OnChatDataChanged
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UChatSetWidgetBase::OnChatDataChanged(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "OnChatDataChanged");

	Params::ChatSetWidgetBase_OnChatDataChanged Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatSetWidgetBase.OnChatDataCommitted
// (Native, Protected, HasOutParams)
// Parameters:
// struct FChatData                        InChatData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChatSetWidgetBase::OnChatDataCommitted(const struct FChatData& InChatData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "OnChatDataCommitted");

	Params::ChatSetWidgetBase_OnChatDataCommitted Parms{};

	Parms.InChatData = std::move(InChatData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ChatSetWidgetBase.OnChatEditFocus
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    InbFocus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatSetWidgetBase::OnChatEditFocus(bool InbFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "OnChatEditFocus");

	Params::ChatSetWidgetBase_OnChatEditFocus Parms{};

	Parms.InbFocus = InbFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatSetWidgetBase.OnChatType
// (Event, Protected, BlueprintEvent)
// Parameters:
// EChatType                               NewItemData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EChatType                               OldItemData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatSetWidgetBase::OnChatType(EChatType NewItemData, EChatType OldItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "OnChatType");

	Params::ChatSetWidgetBase_OnChatType Parms{};

	Parms.NewItemData = NewItemData;
	Parms.OldItemData = OldItemData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ChatSetWidgetBase.OnEditableFocusLost
// (Event, Protected, BlueprintEvent)

void UChatSetWidgetBase::OnEditableFocusLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "OnEditableFocusLost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ChatSetWidgetBase.OnPlayChatReceiveSound
// (Event, Protected, BlueprintEvent)

void UChatSetWidgetBase::OnPlayChatReceiveSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "OnPlayChatReceiveSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ChatSetWidgetBase.SetBindChatWidgetToComp
// (Final, Native, Protected, BlueprintCallable)

void UChatSetWidgetBase::SetBindChatWidgetToComp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "SetBindChatWidgetToComp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatSetWidgetBase.SetChatKeyboardFocus
// (Final, Native, Public, BlueprintCallable)

void UChatSetWidgetBase::SetChatKeyboardFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "SetChatKeyboardFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatSetWidgetBase.SetIsChatFocused
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bIsFocused                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatSetWidgetBase::SetIsChatFocused(bool bIsFocused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "SetIsChatFocused");

	Params::ChatSetWidgetBase_SetIsChatFocused Parms{};

	Parms.bIsFocused = bIsFocused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatSetWidgetBase.SetTimerTime
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    IsStart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimerTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChatSetWidgetBase::SetTimerTime(bool IsStart, float TimerTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatSetWidgetBase", "SetTimerTime");

	Params::ChatSetWidgetBase_SetTimerTime Parms{};

	Parms.IsStart = IsStart;
	Parms.TimerTime = TimerTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.CreateCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstance*                InMaterial                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      InCurve                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     InParameterNames                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FName                             InMaterialName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UDCPostProcessingComponent::CreateCameraPostProcess(class UMaterialInstance* InMaterial, class UCurveFloat* InCurve, const TArray<class FName>& InParameterNames, class FName InMaterialName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "CreateCameraPostProcess");

	Params::DCPostProcessingComponent_CreateCameraPostProcess Parms{};

	Parms.InMaterial = InMaterial;
	Parms.InCurve = InCurve;
	Parms.InParameterNames = std::move(InParameterNames);
	Parms.InMaterialName = InMaterialName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPostProcessingComponent.FindCameraPostProcessMID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InMaterialName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UDCPostProcessingComponent::FindCameraPostProcessMID(class FName InMaterialName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "FindCameraPostProcessMID");

	Params::DCPostProcessingComponent_FindCameraPostProcessMID Parms{};

	Parms.InMaterialName = InMaterialName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPostProcessingComponent.IsCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCPostProcessingComponent::IsCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "IsCameraPostProcess");

	Params::DCPostProcessingComponent_IsCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPostProcessingComponent.OnCameraPostProcessDataTimelineFinished
// (Final, Native, Protected)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETimelineDirection                      InTimelineDirection                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::OnCameraPostProcessDataTimelineFinished(float DeltaTime, ETimelineDirection InTimelineDirection, class UMaterialInstanceDynamic* InMIDKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "OnCameraPostProcessDataTimelineFinished");

	Params::DCPostProcessingComponent_OnCameraPostProcessDataTimelineFinished Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.InTimelineDirection = InTimelineDirection;
	Parms.InMIDKey = InMIDKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.OnCameraPostProcessDataTimelineUpdate
// (Final, Native, Protected)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETimelineDirection                      InTimelineDirection                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::OnCameraPostProcessDataTimelineUpdate(float DeltaTime, ETimelineDirection InTimelineDirection, class UMaterialInstanceDynamic* InMIDKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "OnCameraPostProcessDataTimelineUpdate");

	Params::DCPostProcessingComponent_OnCameraPostProcessDataTimelineUpdate Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.InTimelineDirection = InTimelineDirection;
	Parms.InMIDKey = InMIDKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.PlayCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::PlayCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "PlayCameraPostProcess");

	Params::DCPostProcessingComponent_PlayCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.PlayFromStartCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::PlayFromStartCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "PlayFromStartCameraPostProcess");

	Params::DCPostProcessingComponent_PlayFromStartCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.RemoveCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InMaterialName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::RemoveCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey, class FName InMaterialName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "RemoveCameraPostProcess");

	Params::DCPostProcessingComponent_RemoveCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;
	Parms.InMaterialName = InMaterialName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.RemoveDeletedPostProcessData
// (Final, Native, Private)

void UDCPostProcessingComponent::RemoveDeletedPostProcessData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "RemoveDeletedPostProcessData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.ReverseFromEndPlayCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::ReverseFromEndPlayCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "ReverseFromEndPlayCameraPostProcess");

	Params::DCPostProcessingComponent_ReverseFromEndPlayCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.ReversePlayCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::ReversePlayCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "ReversePlayCameraPostProcess");

	Params::DCPostProcessingComponent_ReversePlayCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.SetCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      InCurve                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     InParameterNames                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCPostProcessingComponent::SetCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey, class UCurveFloat* InCurve, const TArray<class FName>& InParameterNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "SetCameraPostProcess");

	Params::DCPostProcessingComponent_SetCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;
	Parms.InCurve = InCurve;
	Parms.InParameterNames = std::move(InParameterNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPostProcessingComponent.SetPlayPositionCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireEvents                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireUpdate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::SetPlayPositionCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey, float NewTime, bool bFireEvents, bool bFireUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "SetPlayPositionCameraPostProcess");

	Params::DCPostProcessingComponent_SetPlayPositionCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;
	Parms.NewTime = NewTime;
	Parms.bFireEvents = bFireEvents;
	Parms.bFireUpdate = bFireUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.SetPlayRateCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewRate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::SetPlayRateCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey, float NewRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "SetPlayRateCameraPostProcess");

	Params::DCPostProcessingComponent_SetPlayRateCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;
	Parms.NewRate = NewRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.SetTimeCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::SetTimeCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey, float NewTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "SetTimeCameraPostProcess");

	Params::DCPostProcessingComponent_SetTimeCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;
	Parms.NewTime = NewTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPostProcessingComponent.StopCameraPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         InMIDKey                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPostProcessingComponent::StopCameraPostProcess(class UMaterialInstanceDynamic* InMIDKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPostProcessingComponent", "StopCameraPostProcess");

	Params::DCPostProcessingComponent_StopCameraPostProcess Parms{};

	Parms.InMIDKey = InMIDKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CreateAccountNicknamePopup.OnTextChangedAccountNickname
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             InAccountNickname                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCreateAccountNicknamePopup::OnTextChangedAccountNickname(const class FText& InAccountNickname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreateAccountNicknamePopup", "OnTextChangedAccountNickname");

	Params::CreateAccountNicknamePopup_OnTextChangedAccountNickname Parms{};

	Parms.InAccountNickname = std::move(InAccountNickname);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ChatWidgetBase.ChangeDateTimeAsText
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        DateTime                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UChatWidgetBase::ChangeDateTimeAsText(const struct FDateTime& DateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatWidgetBase", "ChangeDateTimeAsText");

	Params::ChatWidgetBase_ChangeDateTimeAsText Parms{};

	Parms.DateTime = std::move(DateTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ChatWidgetBase.FilterStreamingMode
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           OriginalStr                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UChatWidgetBase::FilterStreamingMode(const class FString& OriginalStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatWidgetBase", "FilterStreamingMode");

	Params::ChatWidgetBase_FilterStreamingMode Parms{};

	Parms.OriginalStr = std::move(OriginalStr);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ChatWidgetBase.OnChatRecordData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FChatRecord                      NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FChatRecord                      OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UChatWidgetBase::OnChatRecordData(const struct FChatRecord& NewValue, const struct FChatRecord& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatWidgetBase", "OnChatRecordData");

	Params::ChatWidgetBase_OnChatRecordData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ChatWidgetBase.OnRightClicked
// (Native, Protected)

void UChatWidgetBase::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatWidgetBase", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.AbilityActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "AbilityActivated");

	Params::GA_RangedAttackBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_RangedAttackBase.ActivateCrossHairPullAnimation
// (Final, Native, Protected)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::ActivateCrossHairPullAnimation(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "ActivateCrossHairPullAnimation");

	Params::GA_RangedAttackBase_ActivateCrossHairPullAnimation Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.CreatedProjectile
// (Native, Protected, BlueprintCallable)
// Parameters:
// class AProjectileActor*                 Projectile                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::CreatedProjectile(class AProjectileActor* Projectile, const struct FHitResult& HitResult, const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "CreatedProjectile");

	Params::GA_RangedAttackBase_CreatedProjectile Parms{};

	Parms.Projectile = Projectile;
	Parms.HitResult = std::move(HitResult);
	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.CreateProjectiles
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// float                                   FirePower                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::CreateProjectiles(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower, const struct FVector& StartLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "CreateProjectiles");

	Params::GA_RangedAttackBase_CreateProjectiles Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);
	Parms.FirePower = FirePower;
	Parms.StartLocation = std::move(StartLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_RangedAttackBase.EventReceived
// (Native, Public)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "EventReceived");

	Params::GA_RangedAttackBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.FireProjectile
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// float                                   FirePower                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::FireProjectile(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "FireProjectile");

	Params::GA_RangedAttackBase_FireProjectile Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);
	Parms.FirePower = FirePower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.FireSocketSightBlocked
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::FireSocketSightBlocked(const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "FireSocketSightBlocked");

	Params::GA_RangedAttackBase_FireSocketSightBlocked Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.FireSocketSightUnblocked
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::FireSocketSightUnblocked(const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "FireSocketSightUnblocked");

	Params::GA_RangedAttackBase_FireSocketSightUnblocked Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.MultiFireProjectiles
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// float                                   FirePower                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::MultiFireProjectiles(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "MultiFireProjectiles");

	Params::GA_RangedAttackBase_MultiFireProjectiles Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);
	Parms.FirePower = FirePower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.OnCancelled
// (Final, Native, Public)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "OnCancelled");

	Params::GA_RangedAttackBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.OnCompleted
// (Final, Native, Public)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "OnCompleted");

	Params::GA_RangedAttackBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.ProjectileFired
// (Event, Protected, BlueprintEvent)

void UGA_RangedAttackBase::ProjectileFired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "ProjectileFired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_RangedAttackBase.ReceivedEvent
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "ReceivedEvent");

	Params::GA_RangedAttackBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.UpdatedRangedWeaponCrosshairs
// (Final, Native, Protected)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_RangedAttackBase::UpdatedRangedWeaponCrosshairs(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "UpdatedRangedWeaponCrosshairs");

	Params::GA_RangedAttackBase_UpdatedRangedWeaponCrosshairs Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_RangedAttackBase.GetProjectileActorClass
// (Final, Native, Public, Const)
// Parameters:
// TSubclassOf<class AProjectileActor>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AProjectileActor> UGA_RangedAttackBase::GetProjectileActorClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_RangedAttackBase", "GetProjectileActorClass");

	Params::GA_RangedAttackBase_GetProjectileActorClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDrawbridge.InteractFailedWheel
// (Final, Native, Private)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCDrawbridge::InteractFailedWheel(class AActor* Interacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDrawbridge", "InteractFailedWheel");

	Params::DCDrawbridge_InteractFailedWheel Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDrawbridge.InteractPlaybackWheel
// (Final, Native, Private)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCDrawbridge::InteractPlaybackWheel(class AActor* Interacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDrawbridge", "InteractPlaybackWheel");

	Params::DCDrawbridge_InteractPlaybackWheel Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDrawbridge.InteractRewindWheel
// (Final, Native, Private)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCDrawbridge::InteractRewindWheel(class AActor* Interacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDrawbridge", "InteractRewindWheel");

	Params::DCDrawbridge_InteractRewindWheel Parms{};

	Parms.Interacter = Interacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDrawbridge.OnRep_PlaybackWheel
// (Final, Native, Private)

void ADCDrawbridge::OnRep_PlaybackWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDrawbridge", "OnRep_PlaybackWheel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDrawbridge.OnRep_RewindWheel
// (Final, Native, Private)

void ADCDrawbridge::OnRep_RewindWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDrawbridge", "OnRep_RewindWheel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDrawbridge.SetPlaybackWheel
// (Final, Native, Private)
// Parameters:
// class APropsActorBase*                  InChildActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCDrawbridge::SetPlaybackWheel(class APropsActorBase* InChildActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDrawbridge", "SetPlaybackWheel");

	Params::DCDrawbridge_SetPlaybackWheel Parms{};

	Parms.InChildActor = InChildActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDrawbridge.SetRewindWheel
// (Final, Native, Private)
// Parameters:
// class APropsActorBase*                  InChildActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCDrawbridge::SetRewindWheel(class APropsActorBase* InChildActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDrawbridge", "SetRewindWheel");

	Params::DCDrawbridge_SetRewindWheel Parms{};

	Parms.InChildActor = InChildActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.AbilityActivated
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "AbilityActivated");

	Params::GA_MeleeAttackBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.ClientReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     InEffectTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InChannelTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::ClientReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "ClientReceivedTargetData");

	Params::GA_MeleeAttackBase_ClientReceivedTargetData Parms{};

	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InChannelTag = std::move(InChannelTag);
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.ClientTargetDataReceived
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InChannelTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::ClientTargetDataReceived(const struct FGameplayTag& EventTag, const struct FGameplayTag& InChannelTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "ClientTargetDataReceived");

	Params::GA_MeleeAttackBase_ClientTargetDataReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.InChannelTag = std::move(InChannelTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.EventReceived
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "EventReceived");

	Params::GA_MeleeAttackBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.MontageJumpToNextSection
// (Final, Native, Protected)

void UGA_MeleeAttackBase::MontageJumpToNextSection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "MontageJumpToNextSection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.OnBlendOut
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "OnBlendOut");

	Params::GA_MeleeAttackBase_OnBlendOut Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.OnCancelled
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "OnCancelled");

	Params::GA_MeleeAttackBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.OnCompleted
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "OnCompleted");

	Params::GA_MeleeAttackBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.OnHitFinish
// (Final, Native, Protected)

void UGA_MeleeAttackBase::OnHitFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "OnHitFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.OnInterrupted
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "OnInterrupted");

	Params::GA_MeleeAttackBase_OnInterrupted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.OnInterruptFinish
// (Final, Native, Protected)

void UGA_MeleeAttackBase::OnInterruptFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "OnInterruptFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.OnStuckFinish
// (Final, Native, Protected)

void UGA_MeleeAttackBase::OnStuckFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "OnStuckFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.ReceivedEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "ReceivedEvent");

	Params::GA_MeleeAttackBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.ReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "ReceivedTargetData");

	Params::GA_MeleeAttackBase_ReceivedTargetData Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.ServerTargetDataReceived
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InChannelTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_MeleeAttackBase::ServerTargetDataReceived(const struct FGameplayTag& EventTag, const struct FGameplayTag& InChannelTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "ServerTargetDataReceived");

	Params::GA_MeleeAttackBase_ServerTargetDataReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.InChannelTag = std::move(InChannelTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MeleeAttackBase.GetMeleeAttackData
// (Final, Native, Public, Const)
// Parameters:
// const class UDesignDataAssetMeleeAttack*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDesignDataAssetMeleeAttack* UGA_MeleeAttackBase::GetMeleeAttackData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MeleeAttackBase", "GetMeleeAttackData");

	Params::GA_MeleeAttackBase_GetMeleeAttackData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassIconWidget.OnClickedClassIconButton
// (Final, Native, Protected, BlueprintCallable)

void UClassIconWidget::OnClickedClassIconButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassIconWidget", "OnClickedClassIconButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.HandleBackButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UInvitePartyWidget::HandleBackButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "HandleBackButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.InitCurrentPageIndex
// (Final, Native, Protected, BlueprintCallable)

void UInvitePartyWidget::InitCurrentPageIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "InitCurrentPageIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnBlockUserSlotData
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FBlockUserSlotData               NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBlockUserSlotData               OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnBlockUserSlotData(const struct FBlockUserSlotData& NewValue, const struct FBlockUserSlotData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnBlockUserSlotData");

	Params::InvitePartyWidget_OnBlockUserSlotData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnButtonInviteAcceptAll
// (Final, Native, Protected)

void UInvitePartyWidget::OnButtonInviteAcceptAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnButtonInviteAcceptAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnButtonInviteDeclineAll
// (Final, Native, Protected)

void UInvitePartyWidget::OnButtonInviteDeclineAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnButtonInviteDeclineAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnButtonInviteFriend
// (Final, Native, Protected)

void UInvitePartyWidget::OnButtonInviteFriend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnButtonInviteFriend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnDrawBlockList
// (Final, Native, Protected, BlueprintCallable)

void UInvitePartyWidget::OnDrawBlockList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnDrawBlockList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnDrawFriendList
// (Final, Native, Protected, BlueprintCallable)

void UInvitePartyWidget::OnDrawFriendList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnDrawFriendList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnDrawPartyList
// (Final, Native, Protected, BlueprintCallable)

void UInvitePartyWidget::OnDrawPartyList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnDrawPartyList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnDrawPlayerList
// (Final, Native, Protected, BlueprintCallable)

void UInvitePartyWidget::OnDrawPlayerList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnDrawPlayerList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnDrawReceivedInvitationList
// (Final, Native, Protected, BlueprintCallable)

void UInvitePartyWidget::OnDrawReceivedInvitationList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnDrawReceivedInvitationList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnDrawSentInvitationList
// (Final, Native, Protected, BlueprintCallable)

void UInvitePartyWidget::OnDrawSentInvitationList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnDrawSentInvitationList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnFriendLocateNumber
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   LobbyCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DungeonCount                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OfflineCount                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BlockCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnFriendLocateNumber(const int32 LobbyCount, const int32 DungeonCount, const int32 OfflineCount, const int32 BlockCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnFriendLocateNumber");

	Params::InvitePartyWidget_OnFriendLocateNumber Parms{};

	Parms.LobbyCount = LobbyCount;
	Parms.DungeonCount = DungeonCount;
	Parms.OfflineCount = OfflineCount;
	Parms.BlockCount = BlockCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.InvitePartyWidget.OnFriendSlotData
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FFriendSlotData                  NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FFriendSlotData                  OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnFriendSlotData(const struct FFriendSlotData& NewValue, const struct FFriendSlotData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnFriendSlotData");

	Params::InvitePartyWidget_OnFriendSlotData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnInvitePartyUserSlotData
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FInvitePartyUserSlotData         NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FInvitePartyUserSlotData         OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnInvitePartyUserSlotData(const struct FInvitePartyUserSlotData& NewValue, const struct FInvitePartyUserSlotData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnInvitePartyUserSlotData");

	Params::InvitePartyWidget_OnInvitePartyUserSlotData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnLeftButtonCkicked
// (Final, Native, Protected, BlueprintCallable)

void UInvitePartyWidget::OnLeftButtonCkicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnLeftButtonCkicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnPageNumber
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   CurrentPage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxPage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnPageNumber(const int32 CurrentPage, const int32 MaxPage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnPageNumber");

	Params::InvitePartyWidget_OnPageNumber Parms{};

	Parms.CurrentPage = CurrentPage;
	Parms.MaxPage = MaxPage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.InvitePartyWidget.OnPlayerLocateNumber
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   LobbyCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DungeonCount                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BlockCount                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnPlayerLocateNumber(const int32 LobbyCount, const int32 DungeonCount, const int32 BlockCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnPlayerLocateNumber");

	Params::InvitePartyWidget_OnPlayerLocateNumber Parms{};

	Parms.LobbyCount = LobbyCount;
	Parms.DungeonCount = DungeonCount;
	Parms.BlockCount = BlockCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.InvitePartyWidget.OnPopupSWidgetFriendPartyInviteResult
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// EPopupResult                            PopupResult                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCFriendInfo                    TargetUser                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnPopupSWidgetFriendPartyInviteResult(EPopupResult PopupResult, const struct FDCFriendInfo& TargetUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnPopupSWidgetFriendPartyInviteResult");

	Params::InvitePartyWidget_OnPopupSWidgetFriendPartyInviteResult Parms{};

	Parms.PopupResult = PopupResult;
	Parms.TargetUser = std::move(TargetUser);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnPopupSWidgetPlayerPartyInviteResult
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// EPopupResult                            PopupResult                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInvitePartyUserSlot             TargetUser                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnPopupSWidgetPlayerPartyInviteResult(EPopupResult PopupResult, const struct FInvitePartyUserSlot& TargetUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnPopupSWidgetPlayerPartyInviteResult");

	Params::InvitePartyWidget_OnPopupSWidgetPlayerPartyInviteResult Parms{};

	Parms.PopupResult = PopupResult;
	Parms.TargetUser = std::move(TargetUser);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnReceivedInvitationSlotData
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FReceivedInvitationSlotData      NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FReceivedInvitationSlotData      OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnReceivedInvitationSlotData(const struct FReceivedInvitationSlotData& NewValue, const struct FReceivedInvitationSlotData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnReceivedInvitationSlotData");

	Params::InvitePartyWidget_OnReceivedInvitationSlotData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnRightButtonCkicked
// (Final, Native, Protected, BlueprintCallable)

void UInvitePartyWidget::OnRightButtonCkicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnRightButtonCkicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnSentInvitationSlotData
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSentInvitationSlotData          NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSentInvitationSlotData          OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnSentInvitationSlotData(const struct FSentInvitationSlotData& NewValue, const struct FSentInvitationSlotData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnSentInvitationSlotData");

	Params::InvitePartyWidget_OnSentInvitationSlotData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.OnTextChangedFindBlock
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             AccountNickname                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInvitePartyWidget::OnTextChangedFindBlock(const class FText& AccountNickname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnTextChangedFindBlock");

	Params::InvitePartyWidget_OnTextChangedFindBlock Parms{};

	Parms.AccountNickname = std::move(AccountNickname);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InvitePartyWidget.OnTextChangedFindFriend
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             AccountNickname                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInvitePartyWidget::OnTextChangedFindFriend(const class FText& AccountNickname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnTextChangedFindFriend");

	Params::InvitePartyWidget_OnTextChangedFindFriend Parms{};

	Parms.AccountNickname = std::move(AccountNickname);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InvitePartyWidget.OnTextChangedFindPlayer
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             AccountNickname                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInvitePartyWidget::OnTextChangedFindPlayer(const class FText& AccountNickname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnTextChangedFindPlayer");

	Params::InvitePartyWidget_OnTextChangedFindPlayer Parms{};

	Parms.AccountNickname = std::move(AccountNickname);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InvitePartyWidget.OnUserListFindPlayerClicked
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             AccountNickname                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInvitePartyWidget::OnUserListFindPlayerClicked(const class FText& AccountNickname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "OnUserListFindPlayerClicked");

	Params::InvitePartyWidget_OnUserListFindPlayerClicked Parms{};

	Parms.AccountNickname = std::move(AccountNickname);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.RefreshPlayerList
// (Final, Native, Private, BlueprintCallable)

void UInvitePartyWidget::RefreshPlayerList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "RefreshPlayerList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InvitePartyWidget.TryFriendRequestInviteParty
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFriendSlotWidgetData*            FriendSlotWidgetData                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvitePartyWidget::TryFriendRequestInviteParty(const class UFriendSlotWidgetData* FriendSlotWidgetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "TryFriendRequestInviteParty");

	Params::InvitePartyWidget_TryFriendRequestInviteParty Parms{};

	Parms.FriendSlotWidgetData = FriendSlotWidgetData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.InvitePartyWidget.TryPlayerRequestInviteParty
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPlayerSlotWidgetData*            PlayerSlotWidgetData                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvitePartyWidget::TryPlayerRequestInviteParty(const class UPlayerSlotWidgetData* PlayerSlotWidgetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvitePartyWidget", "TryPlayerRequestInviteParty");

	Params::InvitePartyWidget_TryPlayerRequestInviteParty Parms{};

	Parms.PlayerSlotWidgetData = PlayerSlotWidgetData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAT_WaitForCharacterUnCrouch.WaitForCharacterUnCrouch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitForCharacterUnCrouch*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitForCharacterUnCrouch* UDCAT_WaitForCharacterUnCrouch::WaitForCharacterUnCrouch(class UGameplayAbility* OwningAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitForCharacterUnCrouch", "WaitForCharacterUnCrouch");

	Params::DCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch Parms{};

	Parms.OwningAbility = OwningAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.MusicSlotWidgetBase.OnMusicDataChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMusicData                       InMusicData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDesignDataMusic                 InDesignDataMusic                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMusicSlotWidgetBase::OnMusicDataChanged(const struct FMusicData& InMusicData, const struct FDesignDataMusic& InDesignDataMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicSlotWidgetBase", "OnMusicDataChanged");

	Params::MusicSlotWidgetBase_OnMusicDataChanged Parms{};

	Parms.InMusicData = std::move(InMusicData);
	Parms.InDesignDataMusic = std::move(InDesignDataMusic);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.MusicSlotWidgetBase.OnReset
// (Event, Protected, BlueprintEvent)

void UMusicSlotWidgetBase::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicSlotWidgetBase", "OnReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.MusicSlotWidgetBase.OnSetMusicArtData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UArtDataMusic*                    InArtMusicData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicSlotWidgetBase::OnSetMusicArtData(const class UArtDataMusic* InArtMusicData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicSlotWidgetBase", "OnSetMusicArtData");

	Params::MusicSlotWidgetBase_OnSetMusicArtData Parms{};

	Parms.InArtMusicData = InArtMusicData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.MusicSlotWidgetBase.Reset
// (Final, Native, Public)

void UMusicSlotWidgetBase::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicSlotWidgetBase", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicSlotWidgetBase.SetMusicData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMusicData                       InMusicData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDesignDataMusic                 InDesignDataMusic                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMusicSlotWidgetBase::SetMusicData(const struct FMusicData& InMusicData, const struct FDesignDataMusic& InDesignDataMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicSlotWidgetBase", "SetMusicData");

	Params::MusicSlotWidgetBase_SetMusicData Parms{};

	Parms.InMusicData = std::move(InMusicData);
	Parms.InDesignDataMusic = std::move(InDesignDataMusic);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicCapacityWidgetBase.OnMusicCapacityChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InMusicCurrentCapacity                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMusicMaxCapacity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicCapacityWidgetBase::OnMusicCapacityChanged(float InMusicCurrentCapacity, float InMusicMaxCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicCapacityWidgetBase", "OnMusicCapacityChanged");

	Params::MusicCapacityWidgetBase_OnMusicCapacityChanged Parms{};

	Parms.InMusicCurrentCapacity = InMusicCurrentCapacity;
	Parms.InMusicMaxCapacity = InMusicMaxCapacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassMusicCapacityWidget.OnMusicListChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FMusicData>               InMusicDataArray                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UClassMusicCapacityWidget::OnMusicListChanged(const TArray<struct FMusicData>& InMusicDataArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassMusicCapacityWidget", "OnMusicListChanged");

	Params::ClassMusicCapacityWidget_OnMusicListChanged Parms{};

	Parms.InMusicDataArray = std::move(InMusicDataArray);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCDungeonResultWidget.OnBackToLastGameButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UDCDungeonResultWidget::OnBackToLastGameButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "OnBackToLastGameButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDungeonResultWidget.OnCloseButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UDCDungeonResultWidget::OnCloseButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "OnCloseButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDungeonResultWidget.OnDeathCamPlaybackButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UDCDungeonResultWidget::OnDeathCamPlaybackButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "OnDeathCamPlaybackButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDungeonResultWidget.OnExitButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UDCDungeonResultWidget::OnExitButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "OnExitButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDungeonResultWidget.SetGameResultInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameResultInfo                  InGameResultInfo                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCDungeonResultWidget::SetGameResultInfo(const struct FGameResultInfo& InGameResultInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "SetGameResultInfo");

	Params::DCDungeonResultWidget_SetGameResultInfo Parms{};

	Parms.InGameResultInfo = std::move(InGameResultInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCDungeonResultWidget.GetArenaBlueTeamWinCount
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCDungeonResultWidget::GetArenaBlueTeamWinCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "GetArenaBlueTeamWinCount");

	Params::DCDungeonResultWidget_GetArenaBlueTeamWinCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDungeonResultWidget.GetArenaRedTeamWinCount
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCDungeonResultWidget::GetArenaRedTeamWinCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "GetArenaRedTeamWinCount");

	Params::DCDungeonResultWidget_GetArenaRedTeamWinCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDungeonResultWidget.GetArenaRoundCount
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCDungeonResultWidget::GetArenaRoundCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "GetArenaRoundCount");

	Params::DCDungeonResultWidget_GetArenaRoundCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDungeonResultWidget.GetForceResultReason
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDungeonResultWidget::GetForceResultReason() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "GetForceResultReason");

	Params::DCDungeonResultWidget_GetForceResultReason Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDungeonResultWidget.HasWinner
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDungeonResultWidget::HasWinner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "HasWinner");

	Params::DCDungeonResultWidget_HasWinner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDungeonResultWidget.IsWinner
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDungeonResultWidget::IsWinner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonResultWidget", "IsWinner");

	Params::DCDungeonResultWidget_IsWinner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassMusicEquippedWidget.OnAddItem
// (Event, Protected, BlueprintEvent)

void UClassMusicEquippedWidget::OnAddItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassMusicEquippedWidget", "OnAddItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassMusicEquippedWidget.OnRemoveItem
// (Event, Protected, BlueprintEvent)

void UClassMusicEquippedWidget::OnRemoveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassMusicEquippedWidget", "OnRemoveItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassMusicListWidget.OnHideEquippableSlot
// (Event, Protected, BlueprintEvent)

void UClassMusicListWidget::OnHideEquippableSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassMusicListWidget", "OnHideEquippableSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassMusicListWidget.OnShowEquippableSlot
// (Event, Protected, BlueprintEvent)

void UClassMusicListWidget::OnShowEquippableSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassMusicListWidget", "OnShowEquippableSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.NickNameWidgetBase.OnNickNameStr
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           NewValue                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OldValue                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNickNameWidgetBase::OnNickNameStr(const class FString& NewValue, const class FString& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NickNameWidgetBase", "OnNickNameStr");

	Params::NickNameWidgetBase_OnNickNameStr Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.NickNameWidgetBase.SetNickName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNickname                        InNickName                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNickNameWidgetBase::SetNickName(const struct FNickname& InNickName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NickNameWidgetBase", "SetNickName");

	Params::NickNameWidgetBase_SetNickName Parms{};

	Parms.InNickName = std::move(InNickName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionKillWidget.SetImageEvent
// (Event, Protected, BlueprintEvent)

void UDCReligionKillWidget::SetImageEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionKillWidget", "SetImageEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.MoveWithInputVectorCurve
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DestLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     InVelocityVector                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceTolerance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTeleportWhenFinished                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_MoveWithInputVectorCurve*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_MoveWithInputVectorCurve* UDCAT_MoveWithInputVectorCurve::MoveWithInputVectorCurve(class UGameplayAbility* OwningAbility, const struct FVector& DestLocation, class UCurveVector* InVelocityVector, float DistanceTolerance, bool bShouldTeleportWhenFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_MoveWithInputVectorCurve", "MoveWithInputVectorCurve");

	Params::DCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.DestLocation = std::move(DestLocation);
	Parms.InVelocityVector = InVelocityVector;
	Parms.DistanceTolerance = DistanceTolerance;
	Parms.bShouldTeleportWhenFinished = bShouldTeleportWhenFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.HandleTimelineFinished
// (Final, Native, Protected)

void UDCAT_MoveWithInputVectorCurve::HandleTimelineFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_MoveWithInputVectorCurve", "HandleTimelineFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.HandleTimelineUpdate
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FVector                          InVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAT_MoveWithInputVectorCurve::HandleTimelineUpdate(const struct FVector& InVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_MoveWithInputVectorCurve", "HandleTimelineUpdate");

	Params::DCAT_MoveWithInputVectorCurve_HandleTimelineUpdate Parms{};

	Parms.InVector = std::move(InVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassPerkListWidgetBase.GetSelectedSlotIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClassPerkListWidgetBase::GetSelectedSlotIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassPerkListWidgetBase", "GetSelectedSlotIndex");

	Params::ClassPerkListWidgetBase_GetSelectedSlotIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassPerkListWidgetBase.GetSelectedSlotPerkId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UClassPerkListWidgetBase::GetSelectedSlotPerkId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassPerkListWidgetBase", "GetSelectedSlotPerkId");

	Params::ClassPerkListWidgetBase_GetSelectedSlotPerkId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassPerkListWidgetBase.OnAddItem
// (Event, Protected, BlueprintEvent)

void UClassPerkListWidgetBase::OnAddItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassPerkListWidgetBase", "OnAddItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyInMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UClassPerkListWidgetBase::OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint(const struct FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassPerkListWidgetBase", "OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint");

	Params::ClassPerkListWidgetBase_OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetClassLevelNotify       InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UClassPerkListWidgetBase::OnFMsgWidgetClassLevelNotifyBlueprint(const struct FMsgWidgetClassLevelNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassPerkListWidgetBase", "OnFMsgWidgetClassLevelNotifyBlueprint");

	Params::ClassPerkListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetClassSlotUnLockLevelNotifyInMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UClassPerkListWidgetBase::OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint(const struct FMsgWidgetClassSlotUnLockLevelNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassPerkListWidgetBase", "OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");

	Params::ClassPerkListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassPerkListWidgetBase.OnRemoveItem
// (Event, Protected, BlueprintEvent)

void UClassPerkListWidgetBase::OnRemoveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassPerkListWidgetBase", "OnRemoveItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassPerkListWidgetBase.SetSelectedSlotIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSlotIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClassPerkListWidgetBase::SetSelectedSlotIndex(int32 InSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassPerkListWidgetBase", "SetSelectedSlotIndex");

	Params::ClassPerkListWidgetBase_SetSelectedSlotIndex Parms{};

	Parms.InSlotIndex = InSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.AutoTeamRegisterSingle
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    IsRegister                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::AutoTeamRegisterSingle(bool IsRegister)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "AutoTeamRegisterSingle");

	Params::PlayWidget_AutoTeamRegisterSingle Parms{};

	Parms.IsRegister = IsRegister;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnCancelButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UPlayWidget::OnCancelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnCancelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnChangedMatchingState
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsInMatching                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnChangedMatchingState(const bool IsInMatching)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnChangedMatchingState");

	Params::PlayWidget_OnChangedMatchingState Parms{};

	Parms.IsInMatching = IsInMatching;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.OnClickedDungeonSelect
// (Final, Native, Protected, BlueprintCallable)

void UPlayWidget::OnClickedDungeonSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnClickedDungeonSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnDungeonMatchEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDungeonMatchState                      InDungeonMatchState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnDungeonMatchEvent(EDungeonMatchState InDungeonMatchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnDungeonMatchEvent");

	Params::PlayWidget_OnDungeonMatchEvent Parms{};

	Parms.InDungeonMatchState = InDungeonMatchState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.OnDungeonSelect
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EMatchMode                              InMatchMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameType                               GameType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnDungeonSelect(EMatchMode InMatchMode, EGameType GameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnDungeonSelect");

	Params::PlayWidget_OnDungeonSelect Parms{};

	Parms.InMatchMode = InMatchMode;
	Parms.GameType = GameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnDungeonSelectListPopupOpen
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDungeonSelectParam              InDungeonSelectParam                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayWidget::OnDungeonSelectListPopupOpen(const struct FDungeonSelectParam& InDungeonSelectParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnDungeonSelectListPopupOpen");

	Params::PlayWidget_OnDungeonSelectListPopupOpen Parms{};

	Parms.InDungeonSelectParam = std::move(InDungeonSelectParam);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.OnGameUserSettingControlsChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameUserSettingControls         InGameUserSettingControls                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameUserSettingControls         InOldGameUserSettingControls                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnGameUserSettingControlsChanged");

	Params::PlayWidget_OnGameUserSettingControlsChanged Parms{};

	Parms.InGameUserSettingControls = std::move(InGameUserSettingControls);
	Parms.InOldGameUserSettingControls = std::move(InOldGameUserSettingControls);
	Parms.bInForce = bInForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnInvitePartyButtonClicked
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// EWidgetPartyUserLocate                  UserLocate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnInvitePartyButtonClicked(const EWidgetPartyUserLocate& UserLocate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnInvitePartyButtonClicked");

	Params::PlayWidget_OnInvitePartyButtonClicked Parms{};

	Parms.UserLocate = UserLocate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnKarmaButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UPlayWidget::OnKarmaButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnKarmaButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnLeaderUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsPartyLeader                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnLeaderUpdated(bool IsPartyLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnLeaderUpdated");

	Params::PlayWidget_OnLeaderUpdated Parms{};

	Parms.IsPartyLeader = IsPartyLeader;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.OnMatchCancel
// (Event, Protected, BlueprintEvent)

void UPlayWidget::OnMatchCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnMatchCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.PlayWidget.OnMatchStart
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    InbCanCancel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMatchCancelDelayTimeSec                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnMatchStart(bool InbCanCancel, float InMatchCancelDelayTimeSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnMatchStart");

	Params::PlayWidget_OnMatchStart Parms{};

	Parms.InbCanCancel = InbCanCancel;
	Parms.InMatchCancelDelayTimeSec = InMatchCancelDelayTimeSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnNotRandomPartyMemberChecked
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bInNotRandomPartyMember                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnNotRandomPartyMemberChecked(bool bInNotRandomPartyMember)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnNotRandomPartyMemberChecked");

	Params::PlayWidget_OnNotRandomPartyMemberChecked Parms{};

	Parms.bInNotRandomPartyMember = bInNotRandomPartyMember;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnPartyExitButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UPlayWidget::OnPartyExitButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnPartyExitButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnPartyReadyButtonClicked
// (Final, Native, Protected)
// Parameters:
// bool                                    IsReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnPartyReadyButtonClicked(bool IsReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnPartyReadyButtonClicked");

	Params::PlayWidget_OnPartyReadyButtonClicked Parms{};

	Parms.IsReady = IsReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnPlayPartyReadyStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bMine                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReady                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnPlayPartyReadyStateChanged(bool bMine, bool bReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnPlayPartyReadyStateChanged");

	Params::PlayWidget_OnPlayPartyReadyStateChanged Parms{};

	Parms.bMine = bMine;
	Parms.bReady = bReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.OnPlayPartyUserInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPlayPartyUserInfo               PlayPartyUserInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnPlayPartyUserInfo(const struct FPlayPartyUserInfo& PlayPartyUserInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnPlayPartyUserInfo");

	Params::PlayWidget_OnPlayPartyUserInfo Parms{};

	Parms.PlayPartyUserInfo = std::move(PlayPartyUserInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.OnPlayPartyUserInfoData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPlayPartyUserInfoData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPlayPartyUserInfoData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayWidget::OnPlayPartyUserInfoData(const struct FPlayPartyUserInfoData& NewValue, const struct FPlayPartyUserInfoData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnPlayPartyUserInfoData");

	Params::PlayWidget_OnPlayPartyUserInfoData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.OnPopupSWidgetInvitePartyRequest
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UPopupDataBase*                   PopupData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnAccountID                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnPopupSWidgetInvitePartyRequest(class UPopupDataBase* PopupData, const class FString& ReturnAccountID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnPopupSWidgetInvitePartyRequest");

	Params::PlayWidget_OnPopupSWidgetInvitePartyRequest Parms{};

	Parms.PopupData = PopupData;
	Parms.ReturnAccountID = std::move(ReturnAccountID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.OnPopupSWidgetInvitePartyResponse
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EPopupResult                            PopupResult                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnAccountID                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnPopupSWidgetInvitePartyResponse(EPopupResult PopupResult, const class FString& ReturnAccountID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnPopupSWidgetInvitePartyResponse");

	Params::PlayWidget_OnPopupSWidgetInvitePartyResponse Parms{};

	Parms.PopupResult = PopupResult;
	Parms.ReturnAccountID = std::move(ReturnAccountID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnQuestLogButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UPlayWidget::OnQuestLogButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnQuestLogButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnRegionDataSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   RegionIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnRegionDataSet(int32 RegionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnRegionDataSet");

	Params::PlayWidget_OnRegionDataSet Parms{};

	Parms.RegionIndex = RegionIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.OnRegionSelected
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   RegionIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::OnRegionSelected(const int32 RegionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnRegionSelected");

	Params::PlayWidget_OnRegionSelected Parms{};

	Parms.RegionIndex = RegionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnSqurieShortCutButtonClicked
// (Final, Native, Private)

void UPlayWidget::OnSqurieShortCutButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnSqurieShortCutButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnStartButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UPlayWidget::OnStartButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnStartButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayWidget.OnUpdateLobbyCharacterData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyCharacterInfo              LobbyInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayWidget::OnUpdateLobbyCharacterData(const struct FLobbyCharacterInfo& LobbyInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "OnUpdateLobbyCharacterData");

	Params::PlayWidget_OnUpdateLobbyCharacterData Parms{};

	Parms.LobbyInfo = std::move(LobbyInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.UpdateQuestLogAvailable
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsAvailable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayWidget::UpdateQuestLogAvailable(bool bIsAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "UpdateQuestLogAvailable");

	Params::PlayWidget_UpdateQuestLogAvailable Parms{};

	Parms.bIsAvailable = bIsAvailable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.PlayWidget.UpdateRandomPartyMember
// (Event, Protected, BlueprintEvent)

void UPlayWidget::UpdateRandomPartyMember()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "UpdateRandomPartyMember");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.PlayWidget.IsDuo
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayWidget::IsDuo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "IsDuo");

	Params::PlayWidget_IsDuo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.PlayWidget.IsSolo
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayWidget::IsSolo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayWidget", "IsSolo");

	Params::PlayWidget_IsSolo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemWidgetBase.IsSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCItemWidgetBase::IsSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemWidgetBase", "IsSet");

	Params::DCItemWidgetBase_IsSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemCommonWidget.GetTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCItemCommonWidget::GetTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemCommonWidget", "GetTooltipWidget");

	Params::DCItemCommonWidget_GetTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemCommonWidget.OnDragDropFinished
// (Final, Native, Private)
// Parameters:
// class UDragDropOperation*               Operation                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCItemCommonWidget::OnDragDropFinished(class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemCommonWidget", "OnDragDropFinished");

	Params::DCItemCommonWidget_OnDragDropFinished Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCBagItemWidget.IsGold
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCBagItemWidget::IsGold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCBagItemWidget", "IsGold");

	Params::DCBagItemWidget_IsGold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassRankIconBase.ClearRankData
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UClassRankIconBase::ClearRankData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassRankIconBase", "ClearRankData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassRankIconBase.SetClassIcon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                       InClassIconTex                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClassRankIconBase::SetClassIcon(const class UTexture2D* InClassIconTex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassRankIconBase", "SetClassIcon");

	Params::ClassRankIconBase_SetClassIcon Parms{};

	Parms.InClassIconTex = InClassIconTex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassRankIconBase.SetRankData
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDCLeaderboardRankDataAsset*      InLeaderboardRankData                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClassRankIconBase::SetRankData(const class UDCLeaderboardRankDataAsset* InLeaderboardRankData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassRankIconBase", "SetRankData");

	Params::ClassRankIconBase_SetRankData Parms{};

	Parms.InLeaderboardRankData = InLeaderboardRankData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassRankIconBase.SetRankGroupData
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDCLeaderboardRankGroupDataAsset* InLeaderboardRankGroupData                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClassRankIconBase::SetRankGroupData(const class UDCLeaderboardRankGroupDataAsset* InLeaderboardRankGroupData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassRankIconBase", "SetRankGroupData");

	Params::ClassRankIconBase_SetRankGroupData Parms{};

	Parms.InLeaderboardRankGroupData = InLeaderboardRankGroupData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAT_WaitMovementModeChange.WaitMovementModeChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyTriggerOnce                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitMovementModeChange*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitMovementModeChange* UDCAT_WaitMovementModeChange::WaitMovementModeChange(class UGameplayAbility* OwningAbility, EMovementMode NewMode, bool bOnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitMovementModeChange", "WaitMovementModeChange");

	Params::DCAT_WaitMovementModeChange_WaitMovementModeChange Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.NewMode = NewMode;
	Parms.bOnlyTriggerOnce = bOnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitMovementModeChange.OnMovementModeChange
// (Final, Native, Public)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAT_WaitMovementModeChange::OnMovementModeChange(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitMovementModeChange", "OnMovementModeChange");

	Params::DCAT_WaitMovementModeChange_OnMovementModeChange Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGiftCodePopupBase.Close
// (Final, Native, Private)

void UDCGiftCodePopupBase::Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGiftCodePopupBase", "Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGiftCodePopupBase.GetWarningTextVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCGiftCodePopupBase::GetWarningTextVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGiftCodePopupBase", "GetWarningTextVisibility");

	Params::DCGiftCodePopupBase_GetWarningTextVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGiftCodePopupBase.MoveToNextCodeBlock
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InRemainText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InCodeBlockIndex                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGiftCodePopupBase::MoveToNextCodeBlock(const class FText& InRemainText, const int32& InCodeBlockIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGiftCodePopupBase", "MoveToNextCodeBlock");

	Params::DCGiftCodePopupBase_MoveToNextCodeBlock Parms{};

	Parms.InRemainText = std::move(InRemainText);
	Parms.InCodeBlockIndex = InCodeBlockIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGiftCodePopupBase.MoveToPrevCodeBlock
// (Final, Native, Private, HasOutParams)
// Parameters:
// int32                                   InCodeBlockIndex                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGiftCodePopupBase::MoveToPrevCodeBlock(const int32& InCodeBlockIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGiftCodePopupBase", "MoveToPrevCodeBlock");

	Params::DCGiftCodePopupBase_MoveToPrevCodeBlock Parms{};

	Parms.InCodeBlockIndex = InCodeBlockIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGiftCodePopupBase.OnAcceptButtonClicked
// (Final, Native, Private)

void UDCGiftCodePopupBase::OnAcceptButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGiftCodePopupBase", "OnAcceptButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerChecklistSlotWidget.GetReportCheckBoxEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCReportPlayerChecklistSlotWidget::GetReportCheckBoxEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerChecklistSlotWidget", "GetReportCheckBoxEnabled");

	Params::DCReportPlayerChecklistSlotWidget_GetReportCheckBoxEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCReportPlayerChecklistSlotWidget.GetReportedCategoryVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCReportPlayerChecklistSlotWidget::GetReportedCategoryVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerChecklistSlotWidget", "GetReportedCategoryVisibility");

	Params::DCReportPlayerChecklistSlotWidget_GetReportedCategoryVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCReportPlayerChecklistSlotWidget.HandleChangedCheckState
// (Final, Native, Private)
// Parameters:
// bool                                    bNewState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCReportPlayerChecklistSlotWidget::HandleChangedCheckState(bool bNewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerChecklistSlotWidget", "HandleChangedCheckState");

	Params::DCReportPlayerChecklistSlotWidget_HandleChangedCheckState Parms{};

	Parms.bNewState = bNewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_TickInvoke.OnForceFinish
// (Final, Native, Public, BlueprintCallable)

void UDCAT_TickInvoke::OnForceFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_TickInvoke", "OnForceFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ComboBoxWidget.AddItem
// (Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxWidget::AddItem(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "AddItem");

	Params::ComboBoxWidget_AddItem Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ComboBoxWidget.ClearItems
// (Native, Public, BlueprintCallable)

void UComboBoxWidget::ClearItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "ClearItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ComboBoxWidget.GetSelectedItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UComboBoxWidget::GetSelectedItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "GetSelectedItem");

	Params::ComboBoxWidget_GetSelectedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ComboBoxWidget.OnComboButtonPressed
// (Final, Native, Private)

void UComboBoxWidget::OnComboButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "OnComboButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ComboBoxWidget.OnComboItemSelected
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxWidget::OnComboItemSelected(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "OnComboItemSelected");

	Params::ComboBoxWidget_OnComboItemSelected Parms{};

	Parms.InItem = InItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ComboBoxWidget.RegenerateAllEntries
// (Final, Native, Public, BlueprintCallable)

void UComboBoxWidget::RegenerateAllEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "RegenerateAllEntries");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ComboBoxWidget.RemoveItem
// (Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxWidget::RemoveItem(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "RemoveItem");

	Params::ComboBoxWidget_RemoveItem Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ComboBoxWidget.SetPlaceHolderText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UComboBoxWidget::SetPlaceHolderText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "SetPlaceHolderText");

	Params::ComboBoxWidget_SetPlaceHolderText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ComboBoxWidget.SetSelectedIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxWidget::SetSelectedIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "SetSelectedIndex");

	Params::ComboBoxWidget_SetSelectedIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ComboBoxWidget.GetIndexForItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          InItem                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UComboBoxWidget::GetIndexForItem(const class UObject* InItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "GetIndexForItem");

	Params::ComboBoxWidget_GetIndexForItem Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ComboBoxWidget.GetNumItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UComboBoxWidget::GetNumItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "GetNumItems");

	Params::ComboBoxWidget_GetNumItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ComboBoxWidget.IsItemSelected
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UComboBoxWidget::IsItemSelected(class UObject* InItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ComboBoxWidget", "IsItemSelected");

	Params::ComboBoxWidget_IsItemSelected Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCSearchableComboBoxWidget.RefreshSelections
// (Final, Native, Private)

void UDCSearchableComboBoxWidget::RefreshSelections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSearchableComboBoxWidget", "RefreshSelections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSearchableComboBoxWidget.RegenerateListItems
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             FindFilter                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCSearchableComboBoxWidget::RegenerateListItems(const class FText& FindFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSearchableComboBoxWidget", "RegenerateListItems");

	Params::DCSearchableComboBoxWidget_RegenerateListItems Parms{};

	Parms.FindFilter = std::move(FindFilter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSearchableComboBoxWidget.ResetSearchText
// (Final, Native, Private)
// Parameters:
// class UObject*                          SelectedItem                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSearchableComboBoxWidget::ResetSearchText(class UObject* SelectedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSearchableComboBoxWidget", "ResetSearchText");

	Params::DCSearchableComboBoxWidget_ResetSearchText Parms{};

	Parms.SelectedItem = SelectedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSearchableComboBoxWidget.UpdateFilterTitle
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSearchableComboBoxWidget::UpdateFilterTitle(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSearchableComboBoxWidget", "UpdateFilterTitle");

	Params::DCSearchableComboBoxWidget_UpdateFilterTitle Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassSelectWidget.OnClassSelectButtonClicked
// (Final, Native, Private)

void UClassSelectWidget::OnClassSelectButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSelectWidget", "OnClassSelectButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassSelectWidget.OnGenderClicked
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDCGender                               InGender                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClassSelectWidget::OnGenderClicked(const EDCGender InGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSelectWidget", "OnGenderClicked");

	Params::ClassSelectWidget_OnGenderClicked Parms{};

	Parms.InGender = InGender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassShapeShiftComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClassShapeShiftComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassShapeShiftComponent", "BroadcastMsgBlueprint");

	Params::ClassShapeShiftComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassShapeShiftComponent.OnRep_ShapeShiftDatas
// (Final, Native, Private)

void UClassShapeShiftComponent::OnRep_ShapeShiftDatas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassShapeShiftComponent", "OnRep_ShapeShiftDatas");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassShapeShiftComponent.TerminateBase
// (Native, Public)

void UClassShapeShiftComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassShapeShiftComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassShapeShiftComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClassShapeShiftComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassShapeShiftComponent", "UnbindMsg");

	Params::ClassShapeShiftComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassShapeShiftComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClassShapeShiftComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassShapeShiftComponent", "UnbindMsgAll");

	Params::ClassShapeShiftComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassShapeShiftEquippedWidget.OnAddItem
// (Event, Protected, BlueprintEvent)

void UClassShapeShiftEquippedWidget::OnAddItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassShapeShiftEquippedWidget", "OnAddItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassShapeShiftEquippedWidget.OnRemoveItem
// (Event, Protected, BlueprintEvent)

void UClassShapeShiftEquippedWidget::OnRemoveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassShapeShiftEquippedWidget", "OnRemoveItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCReligionWidget.OnReligionKillDataEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FDCReligionKillnfo>       Info                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCReligionWidget::OnReligionKillDataEvent(const TArray<struct FDCReligionKillnfo>& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionWidget", "OnReligionKillDataEvent");

	Params::DCReligionWidget_OnReligionKillDataEvent Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionWidget.OnSeasonComboBoxSelected
// (Final, Native, Protected)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCReligionWidget::OnSeasonComboBoxSelected(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionWidget", "OnSeasonComboBoxSelected");

	Params::DCReligionWidget_OnSeasonComboBoxSelected Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionWidget.SetReligionTimer
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FReligionRankTimerInfo           Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDCReligionWidget::SetReligionTimer(const struct FReligionRankTimerInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionWidget", "SetReligionTimer");

	Params::DCReligionWidget_SetReligionTimer Parms{};

	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassShapeShiftListWidget.OnHideEquippableSlot
// (Event, Protected, BlueprintEvent)

void UClassShapeShiftListWidget::OnHideEquippableSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassShapeShiftListWidget", "OnHideEquippableSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassShapeShiftListWidget.OnShowEquippableSlot
// (Event, Protected, BlueprintEvent)

void UClassShapeShiftListWidget::OnShowEquippableSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassShapeShiftListWidget", "OnShowEquippableSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCCharacterBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "BroadcastMsgBlueprint");

	Params::DCCharacterBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.FinishLooting
// (Final, Native, Public, BlueprintCallable)

void ADCCharacterBase::FinishLooting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "FinishLooting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.GameplayTagUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "GameplayTagUpdated");

	Params::DCCharacterBase_GameplayTagUpdated Parms{};

	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InCount = InCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCCharacterBase.GetCameraComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* ADCCharacterBase::GetCameraComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "GetCameraComponent");

	Params::DCCharacterBase_GetCameraComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterBase.GetCapsuleBottomLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADCCharacterBase::GetCapsuleBottomLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "GetCapsuleBottomLocation");

	Params::DCCharacterBase_GetCapsuleBottomLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterBase.GetCapsuleTopLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADCCharacterBase::GetCapsuleTopLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "GetCapsuleTopLocation");

	Params::DCCharacterBase_GetCapsuleTopLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterBase.GetPerspectiveCameraComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bFirstPersonPerspective                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* ADCCharacterBase::GetPerspectiveCameraComponent(bool bFirstPersonPerspective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "GetPerspectiveCameraComponent");

	Params::DCCharacterBase_GetPerspectiveCameraComponent Parms{};

	Parms.bFirstPersonPerspective = bFirstPersonPerspective;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterBase.InteractFound
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InteractPart                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::InteractFound(class AActor* Interacter, class UPrimitiveComponent* InteractPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "InteractFound");

	Params::DCCharacterBase_InteractFound Parms{};

	Parms.Interacter = Interacter;
	Parms.InteractPart = InteractPart;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCCharacterBase.InteractLost
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::InteractLost(class AActor* Interacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "InteractLost");

	Params::DCCharacterBase_InteractLost Parms{};

	Parms.Interacter = Interacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCCharacterBase.InteractSucceed
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     StateTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     TriggerTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADCCharacterBase::InteractSucceed(class AActor* Interacter, const struct FGameplayTag& StateTag, const struct FGameplayTag& TriggerTag, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "InteractSucceed");

	Params::DCCharacterBase_InteractSucceed Parms{};

	Parms.Interacter = Interacter;
	Parms.StateTag = std::move(StateTag);
	Parms.TriggerTag = std::move(TriggerTag);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.NPCInteractFinishEventBroadcast_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCCharacterBase::NPCInteractFinishEventBroadcast_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "NPCInteractFinishEventBroadcast_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.OnCharacterMoved
// (Native, Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   InDeltaSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InOldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InOldVelocity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::OnCharacterMoved(float InDeltaSeconds, const struct FVector& InOldLocation, const struct FVector& InOldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "OnCharacterMoved");

	Params::DCCharacterBase_OnCharacterMoved Parms{};

	Parms.InDeltaSeconds = InDeltaSeconds;
	Parms.InOldLocation = std::move(InOldLocation);
	Parms.InOldVelocity = std::move(InOldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.OnFMsgGASActorDieNotifyBlueprint
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgGASActorDieNotify            InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADCCharacterBase::OnFMsgGASActorDieNotifyBlueprint(const struct FMsgGASActorDieNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "OnFMsgGASActorDieNotifyBlueprint");

	Params::DCCharacterBase_OnFMsgGASActorDieNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.OnGameState
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameStateData                   InGameStateData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADCCharacterBase::OnGameState(const struct FGameStateData& InGameStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "OnGameState");

	Params::DCCharacterBase_OnGameState Parms{};

	Parms.InGameStateData = std::move(InGameStateData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.OnRep_AccountId
// (Final, Native, Protected)
// Parameters:
// class FString                           OldAccountId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::OnRep_AccountId(const class FString& OldAccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "OnRep_AccountId");

	Params::DCCharacterBase_OnRep_AccountId Parms{};

	Parms.OldAccountId = std::move(OldAccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.OnSetPerspective
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsFirstPersonPerspective                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::OnSetPerspective(class APlayerController* InPlayerController, const bool bInIsFirstPersonPerspective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "OnSetPerspective");

	Params::DCCharacterBase_OnSetPerspective Parms{};

	Parms.InPlayerController = InPlayerController;
	Parms.bInIsFirstPersonPerspective = bInIsFirstPersonPerspective;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCCharacterBase.OnTarget
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bTarget                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::OnTarget(bool bTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "OnTarget");

	Params::DCCharacterBase_OnTarget Parms{};

	Parms.bTarget = bTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCCharacterBase.OnUpdateTeammateState
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsTeammateWithLocalPlayer                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::OnUpdateTeammateState(bool bIsTeammateWithLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "OnUpdateTeammateState");

	Params::DCCharacterBase_OnUpdateTeammateState Parms{};

	Parms.bIsTeammateWithLocalPlayer = bIsTeammateWithLocalPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCCharacterBase.ReceivePreInitializeComponents
// (Event, Protected, BlueprintEvent)

void ADCCharacterBase::ReceivePreInitializeComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "ReceivePreInitializeComponents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCCharacterBase.RemoveAllLocalStateTags
// (Final, Native, Private)

void ADCCharacterBase::RemoveAllLocalStateTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "RemoveAllLocalStateTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.ServerSetRemoteViewYaw
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// uint8                                   InRemoteViewYaw                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::ServerSetRemoteViewYaw(uint8 InRemoteViewYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "ServerSetRemoteViewYaw");

	Params::DCCharacterBase_ServerSetRemoteViewYaw Parms{};

	Parms.InRemoteViewYaw = InRemoteViewYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.SetForceHide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInForceHide                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::SetForceHide(bool bInForceHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "SetForceHide");

	Params::DCCharacterBase_SetForceHide Parms{};

	Parms.bInForceHide = bInForceHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.SetGenericTeamId
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGenericTeamId                   TeamID                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::SetGenericTeamId(const struct FGenericTeamId& TeamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "SetGenericTeamId");

	Params::DCCharacterBase_SetGenericTeamId Parms{};

	Parms.TeamID = std::move(TeamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.SetIsDead
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    IsDead                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::SetIsDead(bool IsDead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "SetIsDead");

	Params::DCCharacterBase_SetIsDead Parms{};

	Parms.IsDead = IsDead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.StartInspecting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 Inspector                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::StartInspecting(class ADCCharacterBase* Inspector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "StartInspecting");

	Params::DCCharacterBase_StartInspecting Parms{};

	Parms.Inspector = Inspector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.StartLooting
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCPlayerCharacterBase*           Looter                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADCCharacterBase::StartLooting(class ADCPlayerCharacterBase* Looter, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "StartLooting");

	Params::DCCharacterBase_StartLooting Parms{};

	Parms.Looter = Looter;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.TerminateBase
// (Native, Public)

void ADCCharacterBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.TogglePerspective
// (Final, Native, Protected, BlueprintCallable)

void ADCCharacterBase::TogglePerspective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "TogglePerspective");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "UnbindMsg");

	Params::DCCharacterBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "UnbindMsgAll");

	Params::DCCharacterBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterBase.GetAccountId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADCCharacterBase::GetAccountId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "GetAccountId");

	Params::DCCharacterBase_GetAccountId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterBase.GetGenericTeamId
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGenericTeamId                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGenericTeamId ADCCharacterBase::GetGenericTeamId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "GetGenericTeamId");

	Params::DCCharacterBase_GetGenericTeamId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterBase.GetHitBoxLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHitBoxType                             HitBoxType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCCharacterBase::GetHitBoxLocation(EHitBoxType HitBoxType, struct FVector* Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "GetHitBoxLocation");

	Params::DCCharacterBase_GetHitBoxLocation Parms{};

	Parms.HitBoxType = HitBoxType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterBase.GetNickNameCached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FNickname                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNickname ADCCharacterBase::GetNickNameCached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "GetNickNameCached");

	Params::DCCharacterBase_GetNickNameCached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterBase.GetPartyIdString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADCCharacterBase::GetPartyIdString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "GetPartyIdString");

	Params::DCCharacterBase_GetPartyIdString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterBase.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCCharacterBase::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "IsDead");

	Params::DCCharacterBase_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterBase.IsInFirstPersonPerspective
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCCharacterBase::IsInFirstPersonPerspective() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterBase", "IsInFirstPersonPerspective");

	Params::DCCharacterBase_IsInFirstPersonPerspective Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCClassTrainingWidgetBase.OnCanRedeemLearnTokenEnabled
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bCanRedeem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCClassTrainingWidgetBase::OnCanRedeemLearnTokenEnabled(bool bCanRedeem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCClassTrainingWidgetBase", "OnCanRedeemLearnTokenEnabled");

	Params::DCClassTrainingWidgetBase_OnCanRedeemLearnTokenEnabled Parms{};

	Parms.bCanRedeem = bCanRedeem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCClassTrainingWidgetBase.OnTrainingStateUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDCTrainingState                        InTrainingState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCClassTrainingWidgetBase::OnTrainingStateUpdated(EDCTrainingState InTrainingState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCClassTrainingWidgetBase", "OnTrainingStateUpdated");

	Params::DCClassTrainingWidgetBase_OnTrainingStateUpdated Parms{};

	Parms.InTrainingState = InTrainingState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassSkillListWidgetBase.GetSelectedSlotIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UClassSkillListWidgetBase::GetSelectedSlotIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSkillListWidgetBase", "GetSelectedSlotIndex");

	Params::ClassSkillListWidgetBase_GetSelectedSlotIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassSkillListWidgetBase.GetSelectedSlotSkillId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UClassSkillListWidgetBase::GetSelectedSlotSkillId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSkillListWidgetBase", "GetSelectedSlotSkillId");

	Params::ClassSkillListWidgetBase_GetSelectedSlotSkillId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassSkillListWidgetBase.OnAddItem
// (Event, Protected, BlueprintEvent)

void UClassSkillListWidgetBase::OnAddItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSkillListWidgetBase", "OnAddItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyInMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UClassSkillListWidgetBase::OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint(const struct FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSkillListWidgetBase", "OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint");

	Params::ClassSkillListWidgetBase_OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetClassLevelNotify       InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UClassSkillListWidgetBase::OnFMsgWidgetClassLevelNotifyBlueprint(const struct FMsgWidgetClassLevelNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSkillListWidgetBase", "OnFMsgWidgetClassLevelNotifyBlueprint");

	Params::ClassSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetClassSlotUnLockLevelNotifyInMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UClassSkillListWidgetBase::OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint(const struct FMsgWidgetClassSlotUnLockLevelNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSkillListWidgetBase", "OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");

	Params::ClassSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassSkillListWidgetBase.OnRemoveItem
// (Event, Protected, BlueprintEvent)

void UClassSkillListWidgetBase::OnRemoveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSkillListWidgetBase", "OnRemoveItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassSkillListWidgetBase.SetSelectedSlotIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSlotIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClassSkillListWidgetBase::SetSelectedSlotIndex(int32 InSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSkillListWidgetBase", "SetSelectedSlotIndex");

	Params::ClassSkillListWidgetBase_SetSelectedSlotIndex Parms{};

	Parms.InSlotIndex = InSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopConfirmPurchasePopupBase.GetBluestoneShardVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCShopConfirmPurchasePopupBase::GetBluestoneShardVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopConfirmPurchasePopupBase", "GetBluestoneShardVisibility");

	Params::DCShopConfirmPurchasePopupBase_GetBluestoneShardVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopConfirmPurchasePopupBase.GetRedstoneShardVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCShopConfirmPurchasePopupBase::GetRedstoneShardVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopConfirmPurchasePopupBase", "GetRedstoneShardVisibility");

	Params::DCShopConfirmPurchasePopupBase_GetRedstoneShardVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopConfirmPurchasePopupBase.OnCancelClicked
// (Final, Native, Private)

void UDCShopConfirmPurchasePopupBase::OnCancelClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopConfirmPurchasePopupBase", "OnCancelClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopConfirmPurchasePopupBase.OnConfirmClicked
// (Final, Native, Private)

void UDCShopConfirmPurchasePopupBase::OnConfirmClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopConfirmPurchasePopupBase", "OnConfirmClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellSlotWidgetBase.OnReset
// (Event, Protected, BlueprintEvent)

void USpellSlotWidgetBase::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellSlotWidgetBase", "OnReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.SpellSlotWidgetBase.OnSetSpellArtData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UArtDataSpell*                    InArtSpellData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpellSlotWidgetBase::OnSetSpellArtData(const class UArtDataSpell* InArtSpellData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellSlotWidgetBase", "OnSetSpellArtData");

	Params::SpellSlotWidgetBase_OnSetSpellArtData Parms{};

	Parms.InArtSpellData = InArtSpellData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.SpellSlotWidgetBase.OnSpellDataChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSpellData                       InSpellData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDesignDataSpell                 InDesignDataSpell                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USpellSlotWidgetBase::OnSpellDataChanged(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellSlotWidgetBase", "OnSpellDataChanged");

	Params::SpellSlotWidgetBase_OnSpellDataChanged Parms{};

	Parms.InSpellData = std::move(InSpellData);
	Parms.InDesignDataSpell = std::move(InDesignDataSpell);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.SpellSlotWidgetBase.Reset
// (Final, Native, Public)

void USpellSlotWidgetBase::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellSlotWidgetBase", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellSlotWidgetBase.SetSpellData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSpellData                       InSpellData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDesignDataSpell                 InDesignDataSpell                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USpellSlotWidgetBase::SetSpellData(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellSlotWidgetBase", "SetSpellData");

	Params::SpellSlotWidgetBase_SetSpellData Parms{};

	Parms.InSpellData = std::move(InSpellData);
	Parms.InDesignDataSpell = std::move(InDesignDataSpell);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillActor.OnRep_SkillData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FSkillData                       OldSkillData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASkillActor::OnRep_SkillData(const struct FSkillData& OldSkillData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillActor", "OnRep_SkillData");

	Params::SkillActor_OnRep_SkillData Parms{};

	Parms.OldSkillData = std::move(OldSkillData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillActor.GetArtDataSkill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UArtDataSkill*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArtDataSkill* ASkillActor::GetArtDataSkill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillActor", "GetArtDataSkill");

	Params::SkillActor_GetArtDataSkill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SkillActor.GetDesignDataSkill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDesignDataSkill                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataSkill ASkillActor::GetDesignDataSkill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillActor", "GetDesignDataSkill");

	Params::SkillActor_GetDesignDataSkill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SkillActor.GetSkillData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSkillData                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSkillData ASkillActor::GetSkillData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillActor", "GetSkillData");

	Params::SkillActor_GetSkillData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SkillActor.GetSoundDataSkill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundData*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundData* ASkillActor::GetSoundDataSkill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillActor", "GetSoundDataSkill");

	Params::SkillActor_GetSoundDataSkill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCSessionRuleComponent.OnBlizzardData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameBlizzardData                InBlizzardData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCSessionRuleComponent::OnBlizzardData(const struct FGameBlizzardData& InBlizzardData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSessionRuleComponent", "OnBlizzardData");

	Params::DCSessionRuleComponent_OnBlizzardData Parms{};

	Parms.InBlizzardData = std::move(InBlizzardData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSessionRuleComponent.OnDeathSwarmData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameDeathSwarmData              InDeathSwarmData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCSessionRuleComponent::OnDeathSwarmData(const struct FGameDeathSwarmData& InDeathSwarmData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSessionRuleComponent", "OnDeathSwarmData");

	Params::DCSessionRuleComponent_OnDeathSwarmData Parms{};

	Parms.InDeathSwarmData = std::move(InDeathSwarmData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSessionRuleComponent.OnFloorRuleActorRegistered
// (Final, Native, Private)
// Parameters:
// class AActor*                           InFloorRuleActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSessionRuleComponent::OnFloorRuleActorRegistered(class AActor* InFloorRuleActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSessionRuleComponent", "OnFloorRuleActorRegistered");

	Params::DCSessionRuleComponent_OnFloorRuleActorRegistered Parms{};

	Parms.InFloorRuleActor = InFloorRuleActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSessionRuleComponent.OnFloorRuleData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameFloorRuleData               InFloorRuleData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCSessionRuleComponent::OnFloorRuleData(const struct FGameFloorRuleData& InFloorRuleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSessionRuleComponent", "OnFloorRuleData");

	Params::DCSessionRuleComponent_OnFloorRuleData Parms{};

	Parms.InFloorRuleData = std::move(InFloorRuleData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSessionRuleComponent.LogHandleBlizzardData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          InHandler                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameBlizzardData                InBlizzardData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCSessionRuleComponent::LogHandleBlizzardData(const class UObject* InHandler, const struct FGameBlizzardData& InBlizzardData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSessionRuleComponent", "LogHandleBlizzardData");

	Params::DCSessionRuleComponent_LogHandleBlizzardData Parms{};

	Parms.InHandler = InHandler;
	Parms.InBlizzardData = std::move(InBlizzardData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSessionRuleComponent.LogHandleDeathSwarmData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          InHandler                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameDeathSwarmData              InDeathSwarmData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCSessionRuleComponent::LogHandleDeathSwarmData(const class UObject* InHandler, const struct FGameDeathSwarmData& InDeathSwarmData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSessionRuleComponent", "LogHandleDeathSwarmData");

	Params::DCSessionRuleComponent_LogHandleDeathSwarmData Parms{};

	Parms.InHandler = InHandler;
	Parms.InDeathSwarmData = std::move(InDeathSwarmData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSessionRuleComponent.LogHandleFloorRuleData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          InHandler                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameFloorRuleData               InFloorRuleData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCSessionRuleComponent::LogHandleFloorRuleData(const class UObject* InHandler, const struct FGameFloorRuleData& InFloorRuleData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSessionRuleComponent", "LogHandleFloorRuleData");

	Params::DCSessionRuleComponent_LogHandleFloorRuleData Parms{};

	Parms.InHandler = InHandler;
	Parms.InFloorRuleData = std::move(InFloorRuleData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellCapacityWidgetBase.OnSpellCapacityChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InSpellCurrentCapacity                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSpellMaxCapacity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpellCapacityWidgetBase::OnSpellCapacityChanged(float InSpellCurrentCapacity, float InSpellMaxCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellCapacityWidgetBase", "OnSpellCapacityChanged");

	Params::SpellCapacityWidgetBase_OnSpellCapacityChanged Parms{};

	Parms.InSpellCurrentCapacity = InSpellCurrentCapacity;
	Parms.InSpellMaxCapacity = InSpellMaxCapacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassSpellCapacityWidget.OnSpellListChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FSpellData>               InSpellDataArray                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UClassSpellCapacityWidget::OnSpellListChanged(const TArray<struct FSpellData>& InSpellDataArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSpellCapacityWidget", "OnSpellListChanged");

	Params::ClassSpellCapacityWidget_OnSpellListChanged Parms{};

	Parms.InSpellDataArray = std::move(InSpellDataArray);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCInventoryMsgWrapperComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCInventoryMsgWrapperComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryMsgWrapperComponent", "BroadcastMsgBlueprint");

	Params::DCInventoryMsgWrapperComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryMsgWrapperComponent.ClientShowMessage
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// class FText                             Msg                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCInventoryMsgWrapperComponent::ClientShowMessage(const class FText& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryMsgWrapperComponent", "ClientShowMessage");

	Params::DCInventoryMsgWrapperComponent_ClientShowMessage Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryMsgWrapperComponent.TerminateBase
// (Native, Public)

void UDCInventoryMsgWrapperComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryMsgWrapperComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryMsgWrapperComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCInventoryMsgWrapperComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryMsgWrapperComponent", "UnbindMsg");

	Params::DCInventoryMsgWrapperComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryMsgWrapperComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCInventoryMsgWrapperComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryMsgWrapperComponent", "UnbindMsgAll");

	Params::DCInventoryMsgWrapperComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassSpellEquippedWidget.OnAddItem
// (Event, Protected, BlueprintEvent)

void UClassSpellEquippedWidget::OnAddItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSpellEquippedWidget", "OnAddItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassSpellEquippedWidget.OnRemoveItem
// (Event, Protected, BlueprintEvent)

void UClassSpellEquippedWidget::OnRemoveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSpellEquippedWidget", "OnRemoveItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCChannelChatWidget.OnNickname
// (Event, Protected, BlueprintEvent)

void UDCChannelChatWidget::OnNickname()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCChannelChatWidget", "OnNickname");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCGiftCodeEditableText.OnCodeTextChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InCodeText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCGiftCodeEditableText::OnCodeTextChanged(const class FText& InCodeText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGiftCodeEditableText", "OnCodeTextChanged");

	Params::DCGiftCodeEditableText_OnCodeTextChanged Parms{};

	Parms.InCodeText = std::move(InCodeText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGiftCodeEditableText.OnCodeTextCommitted
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InCodeText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ETextCommit                             CommitType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGiftCodeEditableText::OnCodeTextCommitted(const class FText& InCodeText, ETextCommit CommitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGiftCodeEditableText", "OnCodeTextCommitted");

	Params::DCGiftCodeEditableText_OnCodeTextCommitted Parms{};

	Parms.InCodeText = std::move(InCodeText);
	Parms.CommitType = CommitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DungeonCrawler.DCGiftCodeEditableText.OnGiftCodeFilledEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// class FText                             RemainText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGiftCodeEditableText::OnGiftCodeFilledEvent__DelegateSignature(const class FText& RemainText, const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGiftCodeEditableText", "OnGiftCodeFilledEvent__DelegateSignature");

	Params::DCGiftCodeEditableText_OnGiftCodeFilledEvent__DelegateSignature Parms{};

	Parms.RemainText = std::move(RemainText);
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction DungeonCrawler.DCGiftCodeEditableText.OnGiftCodeWipedEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// int32                                   Param_Index                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGiftCodeEditableText::OnGiftCodeWipedEvent__DelegateSignature(const int32& Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGiftCodeEditableText", "OnGiftCodeWipedEvent__DelegateSignature");

	Params::DCGiftCodeEditableText_OnGiftCodeWipedEvent__DelegateSignature Parms{};

	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCRewardItemWidget.GetTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCRewardItemWidget::GetTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRewardItemWidget", "GetTooltipWidget");

	Params::DCRewardItemWidget_GetTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCRewardItemWidget.SetRewardItem
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCRewardInfo                    Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDCRewardItemWidget::SetRewardItem(const struct FDCRewardInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRewardItemWidget", "SetRewardItem");

	Params::DCRewardItemWidget_SetRewardItem Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameSession.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameSession::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSession", "BroadcastMsgBlueprint");

	Params::DCGameSession_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameSession.CharacterResurrection
// (Final, Native, Private)
// Parameters:
// class FString                           AccountId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ADCCharacterBase>     DCCharacterClass                                       (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FDCGameplayEffectData>    InInitGameplayEffectDataArray                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIsRemoveAllItem                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       ResurrectionCharacter                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameSession::CharacterResurrection(const class FString& AccountId, TSubclassOf<class ADCCharacterBase> DCCharacterClass, const TArray<struct FDCGameplayEffectData>& InInitGameplayEffectDataArray, bool bIsRemoveAllItem, class ACharacter* ResurrectionCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSession", "CharacterResurrection");

	Params::DCGameSession_CharacterResurrection Parms{};

	Parms.AccountId = std::move(AccountId);
	Parms.DCCharacterClass = DCCharacterClass;
	Parms.InInitGameplayEffectDataArray = std::move(InInitGameplayEffectDataArray);
	Parms.bIsRemoveAllItem = bIsRemoveAllItem;
	Parms.ResurrectionCharacter = ResurrectionCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameSession.TerminateBase
// (Native, Public)

void ADCGameSession::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSession", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameSession.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameSession::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSession", "UnbindMsg");

	Params::DCGameSession_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameSession.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameSession::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSession", "UnbindMsgAll");

	Params::DCGameSession_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClassSpellListWidget.OnHideEquippableSlot
// (Event, Protected, BlueprintEvent)

void UClassSpellListWidget::OnHideEquippableSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSpellListWidget", "OnHideEquippableSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassSpellListWidget.OnShowEquippableSlot
// (Event, Protected, BlueprintEvent)

void UClassSpellListWidget::OnShowEquippableSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSpellListWidget", "OnShowEquippableSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassSpellSkillListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetClassLevelNotify       InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UClassSpellSkillListWidgetBase::OnFMsgWidgetClassLevelNotifyBlueprint(const struct FMsgWidgetClassLevelNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSpellSkillListWidgetBase", "OnFMsgWidgetClassLevelNotifyBlueprint");

	Params::ClassSpellSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ClassSpellSkillListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetClassSlotUnLockLevelNotifyInMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UClassSpellSkillListWidgetBase::OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint(const struct FMsgWidgetClassSlotUnLockLevelNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassSpellSkillListWidgetBase", "OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");

	Params::ClassSpellSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAT_InteractionSkillCheck.InteractionSkillCheck
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SucceedSectionStartTime                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SucceedSectionEndTime                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PerfectSucceedSectionStartTime                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PerfectSucceedSectionEndTime                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_InteractionSkillCheck*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_InteractionSkillCheck* UDCAT_InteractionSkillCheck::InteractionSkillCheck(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, float Duration, float SucceedSectionStartTime, float SucceedSectionEndTime, float PerfectSucceedSectionStartTime, float PerfectSucceedSectionEndTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_InteractionSkillCheck", "InteractionSkillCheck");

	Params::DCAT_InteractionSkillCheck_InteractionSkillCheck Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.Duration = Duration;
	Parms.SucceedSectionStartTime = SucceedSectionStartTime;
	Parms.SucceedSectionEndTime = SucceedSectionEndTime;
	Parms.PerfectSucceedSectionStartTime = PerfectSucceedSectionStartTime;
	Parms.PerfectSucceedSectionEndTime = PerfectSucceedSectionEndTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassTabMenuWidget.OnSkillClassAbilitiesUpdated_BP
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<EDCSkillClassAbility>            SkillClassAbilities                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UClassTabMenuWidget::OnSkillClassAbilitiesUpdated_BP(const TArray<EDCSkillClassAbility>& SkillClassAbilities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassTabMenuWidget", "OnSkillClassAbilitiesUpdated_BP");

	Params::ClassTabMenuWidget_OnSkillClassAbilitiesUpdated_BP Parms{};

	Parms.SkillClassAbilities = std::move(SkillClassAbilities);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCShopCurrencyTypeSelectPopupBase.IsBluestoneShardSelected
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCShopCurrencyTypeSelectPopupBase::IsBluestoneShardSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopCurrencyTypeSelectPopupBase", "IsBluestoneShardSelected");

	Params::DCShopCurrencyTypeSelectPopupBase_IsBluestoneShardSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopCurrencyTypeSelectPopupBase.IsRedstoneShardSelected
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCShopCurrencyTypeSelectPopupBase::IsRedstoneShardSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopCurrencyTypeSelectPopupBase", "IsRedstoneShardSelected");

	Params::DCShopCurrencyTypeSelectPopupBase_IsRedstoneShardSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopCurrencyTypeSelectPopupBase.OnCancelClicked
// (Final, Native, Private)

void UDCShopCurrencyTypeSelectPopupBase::OnCancelClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopCurrencyTypeSelectPopupBase", "OnCancelClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopCurrencyTypeSelectPopupBase.OnConfirmClicked
// (Final, Native, Private)

void UDCShopCurrencyTypeSelectPopupBase::OnConfirmClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopCurrencyTypeSelectPopupBase", "OnConfirmClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopCurrencyTypeSelectPopupBase.OnCurrencySelected
// (Final, Native, Private)
// Parameters:
// EDCShopCurrencyType                     CurrencyType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCShopCurrencyTypeSelectPopupBase::OnCurrencySelected(const EDCShopCurrencyType CurrencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopCurrencyTypeSelectPopupBase", "OnCurrencySelected");

	Params::DCShopCurrencyTypeSelectPopupBase_OnCurrencySelected Parms{};

	Parms.CurrencyType = CurrencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTrainingTokenRedeemResultWidgetBase.OnOptionsUpdated
// (Event, Protected, BlueprintEvent)

void UDCTrainingTokenRedeemResultWidgetBase::OnOptionsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingTokenRedeemResultWidgetBase", "OnOptionsUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCTrainingTokenRedeemResultWidgetBase.OnReceiveButtonClicked
// (Final, Native, Private)

void UDCTrainingTokenRedeemResultWidgetBase::OnReceiveButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingTokenRedeemResultWidgetBase", "OnReceiveButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTrainingTokenRedeemResultWidgetBase.IsEnableReceiveButton
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCTrainingTokenRedeemResultWidgetBase::IsEnableReceiveButton() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingTokenRedeemResultWidgetBase", "IsEnableReceiveButton");

	Params::DCTrainingTokenRedeemResultWidgetBase_IsEnableReceiveButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitVelocityChange.WaitVelocityChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinimumMagnitude                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitVelocityChange*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitVelocityChange* UDCAT_WaitVelocityChange::WaitVelocityChange(class UGameplayAbility* OwningAbility, float MinimumMagnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitVelocityChange", "WaitVelocityChange");

	Params::DCAT_WaitVelocityChange_WaitVelocityChange Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.MinimumMagnitude = MinimumMagnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.GetSelectedPerkId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UClassUnEquipmentPerkandSkillListWidget::GetSelectedPerkId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassUnEquipmentPerkandSkillListWidget", "GetSelectedPerkId");

	Params::ClassUnEquipmentPerkandSkillListWidget_GetSelectedPerkId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.GetSelectedSkillId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UClassUnEquipmentPerkandSkillListWidget::GetSelectedSkillId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassUnEquipmentPerkandSkillListWidget", "GetSelectedSkillId");

	Params::ClassUnEquipmentPerkandSkillListWidget_GetSelectedSkillId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.OnCompletedPerkTileViewRegenerateAllEntries
// (Event, Public, BlueprintEvent)

void UClassUnEquipmentPerkandSkillListWidget::OnCompletedPerkTileViewRegenerateAllEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassUnEquipmentPerkandSkillListWidget", "OnCompletedPerkTileViewRegenerateAllEntries");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.OnCompletedSkillTileViewRegenerateAllEntries
// (Event, Public, BlueprintEvent)

void UClassUnEquipmentPerkandSkillListWidget::OnCompletedSkillTileViewRegenerateAllEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassUnEquipmentPerkandSkillListWidget", "OnCompletedSkillTileViewRegenerateAllEntries");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.OnSetCompletedPerkTileView
// (Event, Public, BlueprintEvent)

void UClassUnEquipmentPerkandSkillListWidget::OnSetCompletedPerkTileView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassUnEquipmentPerkandSkillListWidget", "OnSetCompletedPerkTileView");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.OnSetCompletedSkillTileView
// (Event, Public, BlueprintEvent)

void UClassUnEquipmentPerkandSkillListWidget::OnSetCompletedSkillTileView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClassUnEquipmentPerkandSkillListWidget", "OnSetCompletedSkillTileView");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.InjectionItemSelectedPropertyWidgetBase.OnPropertyValueChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInjectionItemSelectedPropertyWidgetBase::OnPropertyValueChanged(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InjectionItemSelectedPropertyWidgetBase", "OnPropertyValueChanged");

	Params::InjectionItemSelectedPropertyWidgetBase_OnPropertyValueChanged Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InjectionItemSelectedPropertyWidgetBase.OnPropertyValueSet
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ETextCommit                             CommitMethod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInjectionItemSelectedPropertyWidgetBase::OnPropertyValueSet(const class FText& Text, ETextCommit CommitMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InjectionItemSelectedPropertyWidgetBase", "OnPropertyValueSet");

	Params::InjectionItemSelectedPropertyWidgetBase_OnPropertyValueSet Parms{};

	Parms.Text = std::move(Text);
	Parms.CommitMethod = CommitMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction DungeonCrawler.InjectionItemSelectedPropertyWidgetBase.OnSelectedPropertyValueChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// struct FPrimaryAssetId                  PropertyTypeAssetId                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_PropertyValue                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInjectionItemSelectedPropertyWidgetBase::OnSelectedPropertyValueChanged__DelegateSignature(const struct FPrimaryAssetId& PropertyTypeAssetId, int32 Param_PropertyValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InjectionItemSelectedPropertyWidgetBase", "OnSelectedPropertyValueChanged__DelegateSignature");

	Params::InjectionItemSelectedPropertyWidgetBase_OnSelectedPropertyValueChanged__DelegateSignature Parms{};

	Parms.PropertyTypeAssetId = std::move(PropertyTypeAssetId);
	Parms.Param_PropertyValue = Param_PropertyValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCActionSkinWidget.GetActionSkinTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCActionSkinWidget::GetActionSkinTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActionSkinWidget", "GetActionSkinTooltipWidget");

	Params::DCActionSkinWidget_GetActionSkinTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCActionSkinListEntryWidget.OnRightClicked
// (Native, Public)

void UDCActionSkinListEntryWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActionSkinListEntryWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_OverlapActorsInRadius.OverlapActorsInRadius
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CollisionProfileName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           OverlapTargetClass                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_OverlapActorsInRadius*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_OverlapActorsInRadius* UDCAT_OverlapActorsInRadius::OverlapActorsInRadius(class UGameplayAbility* OwningAbility, float Radius, class FName CollisionProfileName, class UClass* OverlapTargetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_OverlapActorsInRadius", "OverlapActorsInRadius");

	Params::DCAT_OverlapActorsInRadius_OverlapActorsInRadius Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Radius = Radius;
	Parms.CollisionProfileName = CollisionProfileName;
	Parms.OverlapTargetClass = OverlapTargetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_OverlapActorsInRadius.OnOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAT_OverlapActorsInRadius::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_OverlapActorsInRadius", "OnOverlapBegin");

	Params::DCAT_OverlapActorsInRadius_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_OverlapActorsInRadius.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAT_OverlapActorsInRadius::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_OverlapActorsInRadius", "OnOverlapEnd");

	Params::DCAT_OverlapActorsInRadius_OnOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCBagWidget.OnDragCanceled
// (Final, Native, Private)
// Parameters:
// class UDragDropOperation*               Operation                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCBagWidget::OnDragCanceled(class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCBagWidget", "OnDragCanceled");

	Params::DCBagWidget_OnDragCanceled Parms{};

	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCBagWidget.GetGoldAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCBagWidget::GetGoldAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCBagWidget", "GetGoldAmount");

	Params::DCBagWidget_GetGoldAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCBagWidget.GetInventoryName
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCBagWidget::GetInventoryName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCBagWidget", "GetInventoryName");

	Params::DCBagWidget_GetInventoryName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCBagWidget.GetItemWidgets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<struct FDCItemId, class UDCBagItemWidget*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TMap<struct FDCItemId, class UDCBagItemWidget*> UDCBagWidget::GetItemWidgets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCBagWidget", "GetItemWidgets");

	Params::DCBagWidget_GetItemWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitDelayRestartable.WaitDelay
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitDelayRestartable*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitDelayRestartable* UDCAT_WaitDelayRestartable::WaitDelay(class UGameplayAbility* OwningAbility, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitDelayRestartable", "WaitDelay");

	Params::DCAT_WaitDelayRestartable_WaitDelay Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitDelayRestartable.RestartTimer
// (Final, Native, Private, BlueprintCallable)

void UDCAT_WaitDelayRestartable::RestartTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitDelayRestartable", "RestartTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientAccountSubsystem.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientAccountSubsystem::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientAccountSubsystem", "BroadcastMsgBlueprint");

	Params::ClientAccountSubsystem_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientAccountSubsystem.TerminateBase
// (Native, Public)

void UClientAccountSubsystem::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientAccountSubsystem", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientAccountSubsystem.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientAccountSubsystem::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientAccountSubsystem", "UnbindMsg");

	Params::ClientAccountSubsystem_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientAccountSubsystem.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientAccountSubsystem::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientAccountSubsystem", "UnbindMsgAll");

	Params::ClientAccountSubsystem_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ActionSpeed
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ActionSpeed(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ActionSpeed");

	Params::DCAttributeSet_OnRep_ActionSpeed Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Agility
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Agility(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Agility");

	Params::DCAttributeSet_OnRep_Agility Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_AgilityBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_AgilityBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_AgilityBase");

	Params::DCAttributeSet_OnRep_AgilityBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_AgilityMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_AgilityMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_AgilityMod");

	Params::DCAttributeSet_OnRep_AgilityMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_AirMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_AirMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_AirMagicalReduction");

	Params::DCAttributeSet_OnRep_AirMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_AirMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_AirMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_AirMagicalReductionMod");

	Params::DCAttributeSet_OnRep_AirMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_AirMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_AirMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_AirMagicResistance");

	Params::DCAttributeSet_OnRep_AirMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ArcaneMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ArcaneMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ArcaneMagicalReduction");

	Params::DCAttributeSet_OnRep_ArcaneMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ArcaneMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ArcaneMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ArcaneMagicalReductionMod");

	Params::DCAttributeSet_OnRep_ArcaneMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ArcaneMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ArcaneMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ArcaneMagicResistance");

	Params::DCAttributeSet_OnRep_ArcaneMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ArmorPenetration
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ArmorPenetration(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ArmorPenetration");

	Params::DCAttributeSet_OnRep_ArmorPenetration Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ArmorRating
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ArmorRating(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ArmorRating");

	Params::DCAttributeSet_OnRep_ArmorRating Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_BuffDurationMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_BuffDurationMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_BuffDurationMod");

	Params::DCAttributeSet_OnRep_BuffDurationMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Coldness
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Coldness(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Coldness");

	Params::DCAttributeSet_OnRep_Coldness Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_CooldownReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_CooldownReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_CooldownReductionMod");

	Params::DCAttributeSet_OnRep_CooldownReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_DarkMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_DarkMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_DarkMagicalReduction");

	Params::DCAttributeSet_OnRep_DarkMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_DarkMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_DarkMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_DarkMagicalReductionMod");

	Params::DCAttributeSet_OnRep_DarkMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_DarkMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_DarkMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_DarkMagicResistance");

	Params::DCAttributeSet_OnRep_DarkMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_DebuffDurationMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_DebuffDurationMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_DebuffDurationMod");

	Params::DCAttributeSet_OnRep_DebuffDurationMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_DemonReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_DemonReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_DemonReductionMod");

	Params::DCAttributeSet_OnRep_DemonReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Dexterity
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Dexterity(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Dexterity");

	Params::DCAttributeSet_OnRep_Dexterity Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_DexterityBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_DexterityBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_DexterityBase");

	Params::DCAttributeSet_OnRep_DexterityBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_DexterityMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_DexterityMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_DexterityMod");

	Params::DCAttributeSet_OnRep_DexterityMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_DivineMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_DivineMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_DivineMagicalReduction");

	Params::DCAttributeSet_OnRep_DivineMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_DivineMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_DivineMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_DivineMagicalReductionMod");

	Params::DCAttributeSet_OnRep_DivineMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_DivineMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_DivineMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_DivineMagicResistance");

	Params::DCAttributeSet_OnRep_DivineMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_EarthMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_EarthMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_EarthMagicalReduction");

	Params::DCAttributeSet_OnRep_EarthMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_EarthMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_EarthMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_EarthMagicalReductionMod");

	Params::DCAttributeSet_OnRep_EarthMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_EarthMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_EarthMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_EarthMagicResistance");

	Params::DCAttributeSet_OnRep_EarthMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_EvilMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_EvilMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_EvilMagicalReduction");

	Params::DCAttributeSet_OnRep_EvilMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_EvilMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_EvilMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_EvilMagicalReductionMod");

	Params::DCAttributeSet_OnRep_EvilMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_EvilMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_EvilMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_EvilMagicResistance");

	Params::DCAttributeSet_OnRep_EvilMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_FireMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_FireMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_FireMagicalReduction");

	Params::DCAttributeSet_OnRep_FireMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_FireMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_FireMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_FireMagicalReductionMod");

	Params::DCAttributeSet_OnRep_FireMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_FireMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_FireMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_FireMagicResistance");

	Params::DCAttributeSet_OnRep_FireMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_HeadshotReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_HeadshotReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_HeadshotReductionMod");

	Params::DCAttributeSet_OnRep_HeadshotReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Health
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Health(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Health");

	Params::DCAttributeSet_OnRep_Health Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_HealthRecoveryMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_HealthRecoveryMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_HealthRecoveryMod");

	Params::DCAttributeSet_OnRep_HealthRecoveryMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_IceMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_IceMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_IceMagicalReduction");

	Params::DCAttributeSet_OnRep_IceMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_IceMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_IceMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_IceMagicalReductionMod");

	Params::DCAttributeSet_OnRep_IceMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_IceMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_IceMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_IceMagicResistance");

	Params::DCAttributeSet_OnRep_IceMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ImpactEndurance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ImpactEndurance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ImpactEndurance");

	Params::DCAttributeSet_OnRep_ImpactEndurance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ImpactPower
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ImpactPower(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ImpactPower");

	Params::DCAttributeSet_OnRep_ImpactPower Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ImpactResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ImpactResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ImpactResistance");

	Params::DCAttributeSet_OnRep_ImpactResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ItemArmorRating
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ItemArmorRating(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ItemArmorRating");

	Params::DCAttributeSet_OnRep_ItemArmorRating Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ItemArmorRatingMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ItemArmorRatingMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ItemArmorRatingMod");

	Params::DCAttributeSet_OnRep_ItemArmorRatingMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ItemEquipSpeed
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ItemEquipSpeed(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ItemEquipSpeed");

	Params::DCAttributeSet_OnRep_ItemEquipSpeed Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Knowledge
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Knowledge(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Knowledge");

	Params::DCAttributeSet_OnRep_Knowledge Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_KnowledgeBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_KnowledgeBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_KnowledgeBase");

	Params::DCAttributeSet_OnRep_KnowledgeBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_KnowledgeMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_KnowledgeMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_KnowledgeMod");

	Params::DCAttributeSet_OnRep_KnowledgeMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_LightMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_LightMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_LightMagicalReduction");

	Params::DCAttributeSet_OnRep_LightMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_LightMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_LightMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_LightMagicalReductionMod");

	Params::DCAttributeSet_OnRep_LightMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_LightMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_LightMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_LightMagicResistance");

	Params::DCAttributeSet_OnRep_LightMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_LightningMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_LightningMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_LightningMagicalReduction");

	Params::DCAttributeSet_OnRep_LightningMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_LightningMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_LightningMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_LightningMagicalReductionMod");

	Params::DCAttributeSet_OnRep_LightningMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_LightningMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_LightningMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_LightningMagicResistance");

	Params::DCAttributeSet_OnRep_LightningMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Luck
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Luck(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Luck");

	Params::DCAttributeSet_OnRep_Luck Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalAbsoluteReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalAbsoluteReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalAbsoluteReduction");

	Params::DCAttributeSet_OnRep_MagicalAbsoluteReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalArcaneDamageAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalArcaneDamageAdd");

	Params::DCAttributeSet_OnRep_MagicalArcaneDamageAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalArcaneDamageBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalArcaneDamageBase");

	Params::DCAttributeSet_OnRep_MagicalArcaneDamageBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalArcaneDamageMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalArcaneDamageMod");

	Params::DCAttributeSet_OnRep_MagicalArcaneDamageMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDamageAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDamageAdd");

	Params::DCAttributeSet_OnRep_MagicalDamageAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDamageBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDamageBase");

	Params::DCAttributeSet_OnRep_MagicalDamageBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDamageMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDamageMod");

	Params::DCAttributeSet_OnRep_MagicalDamageMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageTrue
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDamageTrue(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDamageTrue");

	Params::DCAttributeSet_OnRep_MagicalDamageTrue Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageWeaponPrimary
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDamageWeaponPrimary(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDamageWeaponPrimary");

	Params::DCAttributeSet_OnRep_MagicalDamageWeaponPrimary Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageWeaponSecondary
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDamageWeaponSecondary(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDamageWeaponSecondary");

	Params::DCAttributeSet_OnRep_MagicalDamageWeaponSecondary Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDarkDamageAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDarkDamageAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDarkDamageAdd");

	Params::DCAttributeSet_OnRep_MagicalDarkDamageAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDarkDamageBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDarkDamageBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDarkDamageBase");

	Params::DCAttributeSet_OnRep_MagicalDarkDamageBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDarkDamageMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDarkDamageMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDarkDamageMod");

	Params::DCAttributeSet_OnRep_MagicalDarkDamageMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDivineDamageAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDivineDamageAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDivineDamageAdd");

	Params::DCAttributeSet_OnRep_MagicalDivineDamageAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDivineDamageBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDivineDamageBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDivineDamageBase");

	Params::DCAttributeSet_OnRep_MagicalDivineDamageBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDivineDamageMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalDivineDamageMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalDivineDamageMod");

	Params::DCAttributeSet_OnRep_MagicalDivineDamageMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalFireDamageAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalFireDamageAdd");

	Params::DCAttributeSet_OnRep_MagicalFireDamageAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalFireDamageBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalFireDamageBase");

	Params::DCAttributeSet_OnRep_MagicalFireDamageBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalFireDamageMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalFireDamageMod");

	Params::DCAttributeSet_OnRep_MagicalFireDamageMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalHealBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalHealBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalHealBase");

	Params::DCAttributeSet_OnRep_MagicalHealBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalHealingReceiveMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalHealingReceiveMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalHealingReceiveMod");

	Params::DCAttributeSet_OnRep_MagicalHealingReceiveMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalHealMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalHealMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalHealMod");

	Params::DCAttributeSet_OnRep_MagicalHealMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalIceDamageAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalIceDamageAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalIceDamageAdd");

	Params::DCAttributeSet_OnRep_MagicalIceDamageAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalIceDamageBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalIceDamageBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalIceDamageBase");

	Params::DCAttributeSet_OnRep_MagicalIceDamageBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalIceDamageMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalIceDamageMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalIceDamageMod");

	Params::DCAttributeSet_OnRep_MagicalIceDamageMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalInteractionSpeed
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalInteractionSpeed(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalInteractionSpeed");

	Params::DCAttributeSet_OnRep_MagicalInteractionSpeed Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalPower
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalPower(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalPower");

	Params::DCAttributeSet_OnRep_MagicalPower Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalReduction");

	Params::DCAttributeSet_OnRep_MagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalReductionMod");

	Params::DCAttributeSet_OnRep_MagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalShield
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalShield(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalShield");

	Params::DCAttributeSet_OnRep_MagicalShield Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalSpiritDamageAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalSpiritDamageAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalSpiritDamageAdd");

	Params::DCAttributeSet_OnRep_MagicalSpiritDamageAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalSpiritDamageBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalSpiritDamageBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalSpiritDamageBase");

	Params::DCAttributeSet_OnRep_MagicalSpiritDamageBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicalSpiritDamageMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicalSpiritDamageMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicalSpiritDamageMod");

	Params::DCAttributeSet_OnRep_MagicalSpiritDamageMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicPenetration
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicPenetration(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicPenetration");

	Params::DCAttributeSet_OnRep_MagicPenetration Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MagicResistance");

	Params::DCAttributeSet_OnRep_MagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ManualDexterity
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ManualDexterity(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ManualDexterity");

	Params::DCAttributeSet_OnRep_ManualDexterity Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealth
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MaxHealth(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MaxHealth");

	Params::DCAttributeSet_OnRep_MaxHealth Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MaxHealthAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MaxHealthAdd");

	Params::DCAttributeSet_OnRep_MaxHealthAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MaxHealthBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MaxHealthBase");

	Params::DCAttributeSet_OnRep_MaxHealthBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MaxHealthMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MaxHealthMod");

	Params::DCAttributeSet_OnRep_MaxHealthMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MaxImpactEndurance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MaxImpactEndurance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MaxImpactEndurance");

	Params::DCAttributeSet_OnRep_MaxImpactEndurance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MaxMagicalShield
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MaxMagicalShield(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MaxMagicalShield");

	Params::DCAttributeSet_OnRep_MaxMagicalShield Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MaxPhysicalShield
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MaxPhysicalShield(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MaxPhysicalShield");

	Params::DCAttributeSet_OnRep_MaxPhysicalShield Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MaxSpellCountMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MaxSpellCountMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MaxSpellCountMod");

	Params::DCAttributeSet_OnRep_MaxSpellCountMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MaxTotalShield
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MaxTotalShield(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MaxTotalShield");

	Params::DCAttributeSet_OnRep_MaxTotalShield Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryCapacity
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MemoryCapacity(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MemoryCapacity");

	Params::DCAttributeSet_OnRep_MemoryCapacity Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryCapacityAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MemoryCapacityAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MemoryCapacityAdd");

	Params::DCAttributeSet_OnRep_MemoryCapacityAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryCapacityBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MemoryCapacityBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MemoryCapacityBase");

	Params::DCAttributeSet_OnRep_MemoryCapacityBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryCapacityMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MemoryCapacityMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MemoryCapacityMod");

	Params::DCAttributeSet_OnRep_MemoryCapacityMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryMusicPayload
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MemoryMusicPayload(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MemoryMusicPayload");

	Params::DCAttributeSet_OnRep_MemoryMusicPayload Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MemoryRecoveryMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MemoryRecoveryMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MemoryRecoveryMod");

	Params::DCAttributeSet_OnRep_MemoryRecoveryMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MemorySpellPayload
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MemorySpellPayload(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MemorySpellPayload");

	Params::DCAttributeSet_OnRep_MemorySpellPayload Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeed
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MoveSpeed(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MoveSpeed");

	Params::DCAttributeSet_OnRep_MoveSpeed Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MoveSpeedAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MoveSpeedAdd");

	Params::DCAttributeSet_OnRep_MoveSpeedAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedArmorPenalty
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MoveSpeedArmorPenalty(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MoveSpeedArmorPenalty");

	Params::DCAttributeSet_OnRep_MoveSpeedArmorPenalty Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedArmorPenaltyMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MoveSpeedArmorPenaltyMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MoveSpeedArmorPenaltyMod");

	Params::DCAttributeSet_OnRep_MoveSpeedArmorPenaltyMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MoveSpeedBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MoveSpeedBase");

	Params::DCAttributeSet_OnRep_MoveSpeedBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MoveSpeedMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MoveSpeedMod");

	Params::DCAttributeSet_OnRep_MoveSpeedMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedWithModifier
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_MoveSpeedWithModifier(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_MoveSpeedWithModifier");

	Params::DCAttributeSet_OnRep_MoveSpeedWithModifier Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_OverhealedHealth
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_OverhealedHealth(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_OverhealedHealth");

	Params::DCAttributeSet_OnRep_OverhealedHealth Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Persuasiveness
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Persuasiveness(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Persuasiveness");

	Params::DCAttributeSet_OnRep_Persuasiveness Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalAbsoluteReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalAbsoluteReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalAbsoluteReduction");

	Params::DCAttributeSet_OnRep_PhysicalAbsoluteReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalBackstabPower
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalBackstabPower(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalBackstabPower");

	Params::DCAttributeSet_OnRep_PhysicalBackstabPower Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalDamageAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalDamageAdd");

	Params::DCAttributeSet_OnRep_PhysicalDamageAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalDamageBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalDamageBase");

	Params::DCAttributeSet_OnRep_PhysicalDamageBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalDamageMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalDamageMod");

	Params::DCAttributeSet_OnRep_PhysicalDamageMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageTrue
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalDamageTrue(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalDamageTrue");

	Params::DCAttributeSet_OnRep_PhysicalDamageTrue Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageWeaponPrimary
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalDamageWeaponPrimary(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalDamageWeaponPrimary");

	Params::DCAttributeSet_OnRep_PhysicalDamageWeaponPrimary Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageWeaponSecondary
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalDamageWeaponSecondary(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalDamageWeaponSecondary");

	Params::DCAttributeSet_OnRep_PhysicalDamageWeaponSecondary Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHeadshotPenetration
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalHeadshotPenetration(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalHeadshotPenetration");

	Params::DCAttributeSet_OnRep_PhysicalHeadshotPenetration Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHeadshotPower
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalHeadshotPower(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalHeadshotPower");

	Params::DCAttributeSet_OnRep_PhysicalHeadshotPower Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHealBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalHealBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalHealBase");

	Params::DCAttributeSet_OnRep_PhysicalHealBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHealingReceiveMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalHealingReceiveMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalHealingReceiveMod");

	Params::DCAttributeSet_OnRep_PhysicalHealingReceiveMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHealMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalHealMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalHealMod");

	Params::DCAttributeSet_OnRep_PhysicalHealMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalPower
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalPower(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalPower");

	Params::DCAttributeSet_OnRep_PhysicalPower Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalReduction");

	Params::DCAttributeSet_OnRep_PhysicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalReductionMod");

	Params::DCAttributeSet_OnRep_PhysicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalShield
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_PhysicalShield(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_PhysicalShield");

	Params::DCAttributeSet_OnRep_PhysicalShield Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ProjectileReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ProjectileReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ProjectileReductionMod");

	Params::DCAttributeSet_OnRep_ProjectileReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_RecoverableHealth
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_RecoverableHealth(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_RecoverableHealth");

	Params::DCAttributeSet_OnRep_RecoverableHealth Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_RegularInteractionSpeed
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_RegularInteractionSpeed(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_RegularInteractionSpeed");

	Params::DCAttributeSet_OnRep_RegularInteractionSpeed Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_RegularInteractionSpeedBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_RegularInteractionSpeedBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_RegularInteractionSpeedBase");

	Params::DCAttributeSet_OnRep_RegularInteractionSpeedBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Resourcefulness
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Resourcefulness(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Resourcefulness");

	Params::DCAttributeSet_OnRep_Resourcefulness Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ResourcefulnessBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ResourcefulnessBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ResourcefulnessBase");

	Params::DCAttributeSet_OnRep_ResourcefulnessBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_ResourcefulnessMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_ResourcefulnessMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_ResourcefulnessMod");

	Params::DCAttributeSet_OnRep_ResourcefulnessMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Rigidity
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Rigidity(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Rigidity");

	Params::DCAttributeSet_OnRep_Rigidity Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_SpellCastingSpeed
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_SpellCastingSpeed(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_SpellCastingSpeed");

	Params::DCAttributeSet_OnRep_SpellCastingSpeed Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_SpiritMagicalReduction
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_SpiritMagicalReduction(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_SpiritMagicalReduction");

	Params::DCAttributeSet_OnRep_SpiritMagicalReduction Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_SpiritMagicalReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_SpiritMagicalReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_SpiritMagicalReductionMod");

	Params::DCAttributeSet_OnRep_SpiritMagicalReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_SpiritMagicResistance
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_SpiritMagicResistance(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_SpiritMagicResistance");

	Params::DCAttributeSet_OnRep_SpiritMagicResistance Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Strength
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Strength(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Strength");

	Params::DCAttributeSet_OnRep_Strength Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_StrengthBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_StrengthBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_StrengthBase");

	Params::DCAttributeSet_OnRep_StrengthBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_StrengthMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_StrengthMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_StrengthMod");

	Params::DCAttributeSet_OnRep_StrengthMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_TotalShield
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_TotalShield(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_TotalShield");

	Params::DCAttributeSet_OnRep_TotalShield Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_UndeadDamageMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_UndeadDamageMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_UndeadDamageMod");

	Params::DCAttributeSet_OnRep_UndeadDamageMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_UndeadReductionMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_UndeadReductionMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_UndeadReductionMod");

	Params::DCAttributeSet_OnRep_UndeadReductionMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectiveness
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_UtilityEffectiveness(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_UtilityEffectiveness");

	Params::DCAttributeSet_OnRep_UtilityEffectiveness Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_UtilityEffectivenessAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_UtilityEffectivenessAdd");

	Params::DCAttributeSet_OnRep_UtilityEffectivenessAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_UtilityEffectivenessBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_UtilityEffectivenessBase");

	Params::DCAttributeSet_OnRep_UtilityEffectivenessBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_UtilityEffectivenessMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_UtilityEffectivenessMod");

	Params::DCAttributeSet_OnRep_UtilityEffectivenessMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Vigor
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Vigor(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Vigor");

	Params::DCAttributeSet_OnRep_Vigor Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_VigorBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_VigorBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_VigorBase");

	Params::DCAttributeSet_OnRep_VigorBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_VigorMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_VigorMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_VigorMod");

	Params::DCAttributeSet_OnRep_VigorMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Weight
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Weight(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Weight");

	Params::DCAttributeSet_OnRep_Weight Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimit
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_WeightLimit(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_WeightLimit");

	Params::DCAttributeSet_OnRep_WeightLimit Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitAdd
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_WeightLimitAdd(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_WeightLimitAdd");

	Params::DCAttributeSet_OnRep_WeightLimitAdd Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_WeightLimitBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_WeightLimitBase");

	Params::DCAttributeSet_OnRep_WeightLimitBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_WeightLimitMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_WeightLimitMod");

	Params::DCAttributeSet_OnRep_WeightLimitMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_Will
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_Will(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_Will");

	Params::DCAttributeSet_OnRep_Will Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_WillBase
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_WillBase(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_WillBase");

	Params::DCAttributeSet_OnRep_WillBase Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAttributeSet.OnRep_WillMod
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAttributeSet::OnRep_WillMod(const struct FGameplayAttributeData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAttributeSet", "OnRep_WillMod");

	Params::DCAttributeSet_OnRep_WillMod Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientPartySubsystem.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientPartySubsystem::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientPartySubsystem", "BroadcastMsgBlueprint");

	Params::ClientPartySubsystem_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientPartySubsystem.TerminateBase
// (Native, Public)

void UClientPartySubsystem::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientPartySubsystem", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientPartySubsystem.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientPartySubsystem::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientPartySubsystem", "UnbindMsg");

	Params::ClientPartySubsystem_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientPartySubsystem.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientPartySubsystem::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientPartySubsystem", "UnbindMsgAll");

	Params::ClientPartySubsystem_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientShopSubsystem.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientShopSubsystem::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientShopSubsystem", "BroadcastMsgBlueprint");

	Params::ClientShopSubsystem_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientShopSubsystem.TerminateBase
// (Native, Public)

void UClientShopSubsystem::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientShopSubsystem", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientShopSubsystem.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientShopSubsystem::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientShopSubsystem", "UnbindMsg");

	Params::ClientShopSubsystem_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ClientShopSubsystem.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientShopSubsystem::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientShopSubsystem", "UnbindMsgAll");

	Params::ClientShopSubsystem_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitAimDirChangedFromLoc.WaitAimDirectionChangedFromLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InitialAimTargetLocation                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitAimDirChangedFromLoc*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitAimDirChangedFromLoc* UDCAT_WaitAimDirChangedFromLoc::WaitAimDirectionChangedFromLocation(class UGameplayAbility* OwningAbility, const struct FVector& InitialAimTargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitAimDirChangedFromLoc", "WaitAimDirectionChangedFromLocation");

	Params::DCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InitialAimTargetLocation = std::move(InitialAimTargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CommemorativePlaqueTextWidget.SetCommemorativePlaqueText
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ScriptId                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommemorativePlaqueTextWidget::SetCommemorativePlaqueText(const struct FPrimaryAssetId& ScriptId, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommemorativePlaqueTextWidget", "SetCommemorativePlaqueText");

	Params::CommemorativePlaqueTextWidget_SetCommemorativePlaqueText Parms{};

	Parms.ScriptId = std::move(ScriptId);
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CommemorativePlaqueTextWidget.SnedWidgetToggleMsg
// (Final, Native, Public, BlueprintCallable)

void UCommemorativePlaqueTextWidget::SnedWidgetToggleMsg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommemorativePlaqueTextWidget", "SnedWidgetToggleMsg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CommemorativePlaqueTextWidget.UpdateCommenorativePlaqueText
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// TArray<class FText>                     InText                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCommemorativePlaqueTextWidget::UpdateCommenorativePlaqueText(const TArray<class FText>& InText, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommemorativePlaqueTextWidget", "UpdateCommenorativePlaqueText");

	Params::CommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText Parms{};

	Parms.InText = std::move(InText);
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAT_WaitGameplayEffectAdd.WaitGameplayEffectAdded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitGameplayEffectAdd*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitGameplayEffectAdd* UDCAT_WaitGameplayEffectAdd::WaitGameplayEffectAdded(class UGameplayAbility* OwningAbility, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitGameplayEffectAdd", "WaitGameplayEffectAdded");

	Params::DCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitGameplayEffectAdd.OnApplyGameplayEffectCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpec              SpecApplied                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAT_WaitGameplayEffectAdd::OnApplyGameplayEffectCallback(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitGameplayEffectAdd", "OnApplyGameplayEffectCallback");

	Params::DCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback Parms{};

	Parms.Target = Target;
	Parms.SpecApplied = std::move(SpecApplied);
	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PopupDataSWidget.Cancel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPopupDataSWidget::Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PopupDataSWidget", "Cancel");

	Params::PopupDataSWidget_Cancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CommonPopupSWidget.CheckBanAppealVisibleType
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCommonPopupSWidget::CheckBanAppealVisibleType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonPopupSWidget", "CheckBanAppealVisibleType");

	Params::CommonPopupSWidget_CheckBanAppealVisibleType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.CommonPopupSWidget.HandleLeftButtonClicked
// (Final, Native, Protected)

void UCommonPopupSWidget::HandleLeftButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonPopupSWidget", "HandleLeftButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CommonPopupSWidget.HandleLeftDeleteCharacterButtonClicked
// (Final, Native, Protected)

void UCommonPopupSWidget::HandleLeftDeleteCharacterButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonPopupSWidget", "HandleLeftDeleteCharacterButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CommonPopupSWidget.HandleRightButtonClicked
// (Final, Native, Protected)

void UCommonPopupSWidget::HandleRightButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonPopupSWidget", "HandleRightButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CommonPopupSWidget.HandleRightDeleteCharacterButtonClicked
// (Final, Native, Protected)

void UCommonPopupSWidget::HandleRightDeleteCharacterButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonPopupSWidget", "HandleRightDeleteCharacterButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CommonPopupSWidget.HandleSingleButtonClicked
// (Final, Native, Protected)

void UCommonPopupSWidget::HandleSingleButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonPopupSWidget", "HandleSingleButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.CommonPopupSWidget.OnCreatePopup
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPopupSWidgetData                PopupSWidgetData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCommonPopupSWidget::OnCreatePopup(const struct FPopupSWidgetData& PopupSWidgetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonPopupSWidget", "OnCreatePopup");

	Params::CommonPopupSWidget_OnCreatePopup Parms{};

	Parms.PopupSWidgetData = std::move(PopupSWidgetData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.CommonPopupSWidget.OnRemovePopup
// (Event, Protected, BlueprintEvent)

void UCommonPopupSWidget::OnRemovePopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonPopupSWidget", "OnRemovePopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.CommonPopupSWidget.PlayOpenSound
// (Final, Native, Protected)

void UCommonPopupSWidget::PlayOpenSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CommonPopupSWidget", "PlayOpenSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAnimInstanceBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAnimInstanceBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAnimInstanceBase", "BroadcastMsgBlueprint");

	Params::DCAnimInstanceBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAnimInstanceBase.EventAllMontageInstancesEnded
// (Final, Native, Private)

void UDCAnimInstanceBase::EventAllMontageInstancesEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAnimInstanceBase", "EventAllMontageInstancesEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAnimInstanceBase.EventMontageStarted
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAnimInstanceBase::EventMontageStarted(class UAnimMontage* InMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAnimInstanceBase", "EventMontageStarted");

	Params::DCAnimInstanceBase_EventMontageStarted Parms{};

	Parms.InMontage = InMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAnimInstanceBase.GetOriginActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDCAnimInstanceBase::GetOriginActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAnimInstanceBase", "GetOriginActor");

	Params::DCAnimInstanceBase_GetOriginActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAnimInstanceBase.TerminateBase
// (Native, Public)

void UDCAnimInstanceBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAnimInstanceBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAnimInstanceBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAnimInstanceBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAnimInstanceBase", "UnbindMsg");

	Params::DCAnimInstanceBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAnimInstanceBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAnimInstanceBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAnimInstanceBase", "UnbindMsgAll");

	Params::DCAnimInstanceBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRedeemLearningTokenCheckPopup.OnCancelButtonClicked
// (Final, Native, Private)

void UDCRedeemLearningTokenCheckPopup::OnCancelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRedeemLearningTokenCheckPopup", "OnCancelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRedeemLearningTokenCheckPopup.OnRedeemButtonClicked
// (Final, Native, Private)

void UDCRedeemLearningTokenCheckPopup::OnRedeemButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRedeemLearningTokenCheckPopup", "OnRedeemButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ContainerInventoryGroupWidget.OnItemDropDetected
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        DropScreenPos                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldOwnerActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContainerInventoryGroupWidget::OnItemDropDetected(const struct FItemData& ItemData, const struct FVector2D& DropScreenPos, class AActor* OldOwnerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryGroupWidget", "OnItemDropDetected");

	Params::ContainerInventoryGroupWidget_OnItemDropDetected Parms{};

	Parms.ItemData = std::move(ItemData);
	Parms.DropScreenPos = std::move(DropScreenPos);
	Parms.OldOwnerActor = OldOwnerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ContainerInventoryGroupWidget.OnPopItemSelectWidget
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        DropScreenPos                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldOwnerActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContainerInventoryGroupWidget::OnPopItemSelectWidget(const struct FItemData& ItemData, const struct FVector2D& DropScreenPos, class AActor* OldOwnerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryGroupWidget", "OnPopItemSelectWidget");

	Params::ContainerInventoryGroupWidget_OnPopItemSelectWidget Parms{};

	Parms.ItemData = std::move(ItemData);
	Parms.DropScreenPos = std::move(DropScreenPos);
	Parms.OldOwnerActor = OldOwnerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ContainerInventoryGroupWidget.ResetContainerInventoryWidgets
// (Final, Native, Public, BlueprintCallable)

void UContainerInventoryGroupWidget::ResetContainerInventoryWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryGroupWidget", "ResetContainerInventoryWidgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ContainerInventoryWidget.CanSetItemAt
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   SlotId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UContainerInventoryWidget::CanSetItemAt(const struct FItemData& ItemData, const int32 SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryWidget", "CanSetItemAt");

	Params::ContainerInventoryWidget_CanSetItemAt Parms{};

	Parms.ItemData = std::move(ItemData);
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ContainerInventoryWidget.GetSlotIdByScreenPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ScreenPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UContainerInventoryWidget::GetSlotIdByScreenPosition(const struct FVector2D& ScreenPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryWidget", "GetSlotIdByScreenPosition");

	Params::ContainerInventoryWidget_GetSlotIdByScreenPosition Parms{};

	Parms.ScreenPos = std::move(ScreenPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ContainerInventoryWidget.OnAddItem
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FItemData                        InItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UItemWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemWidget* UContainerInventoryWidget::OnAddItem(const struct FItemData& InItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryWidget", "OnAddItem");

	Params::ContainerInventoryWidget_OnAddItem Parms{};

	Parms.InItemData = std::move(InItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ContainerInventoryWidget.OnItemDragDetected
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        DragScreenPos                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContainerInventoryWidget::OnItemDragDetected(const struct FItemData& ItemData, const struct FVector2D& DragScreenPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryWidget", "OnItemDragDetected");

	Params::ContainerInventoryWidget_OnItemDragDetected Parms{};

	Parms.ItemData = std::move(ItemData);
	Parms.DragScreenPos = std::move(DragScreenPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ContainerInventoryWidget.OnItemWidgetDropOrLeave
// (Final, Native, Protected, BlueprintCallable)

void UContainerInventoryWidget::OnItemWidgetDropOrLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryWidget", "OnItemWidgetDropOrLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ContainerInventoryWidget.OnMoveItem
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FItemData                        OldItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FItemData                        NewItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UContainerInventoryWidget::OnMoveItem(const struct FItemData& OldItemData, const struct FItemData& NewItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryWidget", "OnMoveItem");

	Params::ContainerInventoryWidget_OnMoveItem Parms{};

	Parms.OldItemData = std::move(OldItemData);
	Parms.NewItemData = std::move(NewItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ContainerInventoryWidget.OnRemoveItem
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FItemData                        InItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UContainerInventoryWidget::OnRemoveItem(const struct FItemData& InItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryWidget", "OnRemoveItem");

	Params::ContainerInventoryWidget_OnRemoveItem Parms{};

	Parms.InItemData = std::move(InItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ContainerInventoryWidget.UpdateItemCanBeSet
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FItemData                        InItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   SlotId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContainerInventoryWidget::UpdateItemCanBeSet(const struct FItemData& InItemData, const int32 SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerInventoryWidget", "UpdateItemCanBeSet");

	Params::ContainerInventoryWidget_UpdateItemCanBeSet Parms{};

	Parms.InItemData = std::move(InItemData);
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionConvertPopUp.OnCancelButtonClicked
// (Final, Native, Private)

void UDCReligionConvertPopUp::OnCancelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionConvertPopUp", "OnCancelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionConvertPopUp.OnConfirmButtonClicked
// (Final, Native, Private)

void UDCReligionConvertPopUp::OnConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionConvertPopUp", "OnConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionConvertPopUp.SetReligionImageEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FSlateBrush                      Bursh                                                  (Parm, NativeAccessSpecifierPublic)

void UDCReligionConvertPopUp::SetReligionImageEvent(const struct FSlateBrush& Bursh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionConvertPopUp", "SetReligionImageEvent");

	Params::DCReligionConvertPopUp_SetReligionImageEvent Parms{};

	Parms.Bursh = std::move(Bursh);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ContainerSlotWidget.OnLeaveItemWidget
// (Event, Public, BlueprintEvent)

void UContainerSlotWidget::OnLeaveItemWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerSlotWidget", "OnLeaveItemWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ContainerSlotWidget.OnOverlapItemWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bCanSetItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContainerSlotWidget::OnOverlapItemWidget(bool bCanSetItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerSlotWidget", "OnOverlapItemWidget");

	Params::ContainerSlotWidget_OnOverlapItemWidget Parms{};

	Parms.bCanSetItem = bCanSetItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ContainerSlotWidget.OnRemoveItem
// (Event, Public, BlueprintEvent)

void UContainerSlotWidget::OnRemoveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerSlotWidget", "OnRemoveItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ContainerSlotWidget.OnSetNewItem
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bFullfilledAll                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContainerSlotWidget::OnSetNewItem(bool bFullfilledAll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContainerSlotWidget", "OnSetNewItem");

	Params::ContainerSlotWidget_OnSetNewItem Parms{};

	Parms.bFullfilledAll = bFullfilledAll;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ContextMenuHolderInterface.OnRightClicked
// (Native, Public, BlueprintCallable)

void IContextMenuHolderInterface::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextMenuHolderInterface", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PartyChatWidget.OnPartyChatFocus
// (Event, Public, BlueprintEvent)

void UPartyChatWidget::OnPartyChatFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyChatWidget", "OnPartyChatFocus");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCAT_WaitTargetData.DCWaitTargetData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayTargetingConfirmation          ConfirmationType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameplayAbilityTargetActor*      InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitTargetData*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitTargetData* UDCAT_WaitTargetData::DCWaitTargetData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType, class AGameplayAbilityTargetActor* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitTargetData", "DCWaitTargetData");

	Params::DCAT_WaitTargetData_DCWaitTargetData Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.ConfirmationType = ConfirmationType;
	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ContextMenuWidgetBase.RequestCloseMenu
// (Final, Native, Protected, BlueprintCallable)

void UContextMenuWidgetBase::RequestCloseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextMenuWidgetBase", "RequestCloseMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ContextMenuWidgetBase.SetContextMenuWidgetPosition
// (Final, Native, Protected, BlueprintCallable)

void UContextMenuWidgetBase::SetContextMenuWidgetPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextMenuWidgetBase", "SetContextMenuWidgetPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitForInputAction.WaitForInputAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     InInputAction                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyTriggerOnce                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitForInputAction*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitForInputAction* UDCAT_WaitForInputAction::WaitForInputAction(class UGameplayAbility* OwningAbility, const class UInputAction* InInputAction, bool bOnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitForInputAction", "WaitForInputAction");

	Params::DCAT_WaitForInputAction_WaitForInputAction Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InInputAction = InInputAction;
	Parms.bOnlyTriggerOnce = bOnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ContextOptionListEntryWidgetBase.OnSelect
// (Final, Native, Private)

void UContextOptionListEntryWidgetBase::OnSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextOptionListEntryWidgetBase", "OnSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LeaderboardRankRecordMineWidget.OnFMsgWidgetStreamingModeNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetStreamingModeNotify    InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULeaderboardRankRecordMineWidget::OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardRankRecordMineWidget", "OnFMsgWidgetStreamingModeNotifyBlueprint");

	Params::LeaderboardRankRecordMineWidget_OnFMsgWidgetStreamingModeNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardRankRecordMineWidget.OnLeaderboardRankRecordMineData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLeaderboardRankRecordMineData   NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLeaderboardRankRecordMineData   OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULeaderboardRankRecordMineWidget::OnLeaderboardRankRecordMineData(const struct FLeaderboardRankRecordMineData& NewValue, const struct FLeaderboardRankRecordMineData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardRankRecordMineWidget", "OnLeaderboardRankRecordMineData");

	Params::LeaderboardRankRecordMineWidget_OnLeaderboardRankRecordMineData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAbilitySystemComponent.AddDamageTransferLink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDCAbilitySystemComponent*        InAbilitySystemComponent                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::AddDamageTransferLink(class UDCAbilitySystemComponent* InAbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "AddDamageTransferLink");

	Params::DCAbilitySystemComponent_AddDamageTransferLink Parms{};

	Parms.InAbilitySystemComponent = InAbilitySystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.AddGameplayCueLocal
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "AddGameplayCueLocal");

	Params::DCAbilitySystemComponent_AddGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "BroadcastMsgBlueprint");

	Params::DCAbilitySystemComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.ExecuteGameplayCueLocal
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "ExecuteGameplayCueLocal");

	Params::DCAbilitySystemComponent_ExecuteGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.GetContainerSpecArray
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FDCGameplayEffectContainerSpec>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDCGameplayEffectContainerSpec> UDCAbilitySystemComponent::GetContainerSpecArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "GetContainerSpecArray");

	Params::DCAbilitySystemComponent_GetContainerSpecArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAbilitySystemComponent.OnRep_AbilityHandleDataArray
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FDCGameplayAbilityHandleData>InOldAbilityHandleDataArray                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::OnRep_AbilityHandleDataArray(const TArray<struct FDCGameplayAbilityHandleData>& InOldAbilityHandleDataArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "OnRep_AbilityHandleDataArray");

	Params::DCAbilitySystemComponent_OnRep_AbilityHandleDataArray Parms{};

	Parms.InOldAbilityHandleDataArray = std::move(InOldAbilityHandleDataArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.OnRep_ActorDieData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FActorDieData                    InOldActorDieData                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::OnRep_ActorDieData(const struct FActorDieData& InOldActorDieData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "OnRep_ActorDieData");

	Params::DCAbilitySystemComponent_OnRep_ActorDieData Parms{};

	Parms.InOldActorDieData = std::move(InOldActorDieData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.OnRep_ActorRigidData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FActorRigidData                  OldActorRigidData                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::OnRep_ActorRigidData(const struct FActorRigidData& OldActorRigidData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "OnRep_ActorRigidData");

	Params::DCAbilitySystemComponent_OnRep_ActorRigidData Parms{};

	Parms.OldActorRigidData = std::move(OldActorRigidData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.OnRep_ImpactEnduranceExhaustedData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FImpactEnduranceExhaustedData    OldImpactEnduranceExhaustedData                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::OnRep_ImpactEnduranceExhaustedData(const struct FImpactEnduranceExhaustedData& OldImpactEnduranceExhaustedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "OnRep_ImpactEnduranceExhaustedData");

	Params::DCAbilitySystemComponent_OnRep_ImpactEnduranceExhaustedData Parms{};

	Parms.OldImpactEnduranceExhaustedData = std::move(OldImpactEnduranceExhaustedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.PlayMontageOnSourceObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 InAnimatingAbility                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityActivationInfo   ActivationInfo                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimMontage*                     NewAnimMontage                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSectionName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTimeSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::PlayMontageOnSourceObject(class UGameplayAbility* InAnimatingAbility, const struct FGameplayAbilityActivationInfo& ActivationInfo, class UAnimMontage* NewAnimMontage, float InPlayRate, class FName StartSectionName, float StartTimeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "PlayMontageOnSourceObject");

	Params::DCAbilitySystemComponent_PlayMontageOnSourceObject Parms{};

	Parms.InAnimatingAbility = InAnimatingAbility;
	Parms.ActivationInfo = std::move(ActivationInfo);
	Parms.NewAnimMontage = NewAnimMontage;
	Parms.InPlayRate = InPlayRate;
	Parms.StartSectionName = StartSectionName;
	Parms.StartTimeSeconds = StartTimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.RemoveDamageTransferLink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDCAbilitySystemComponent*        InAbilitySystemComponent                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::RemoveDamageTransferLink(class UDCAbilitySystemComponent* InAbilitySystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "RemoveDamageTransferLink");

	Params::DCAbilitySystemComponent_RemoveDamageTransferLink Parms{};

	Parms.InAbilitySystemComponent = InAbilitySystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.RemoveGameplayCueLocal
// (Final, Native, Public)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "RemoveGameplayCueLocal");

	Params::DCAbilitySystemComponent_RemoveGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.SendInventoryEventData_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FPredictionKey                   PredictionKey                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCInventoryEventData            EventData                                              (ConstParm, Parm, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::SendInventoryEventData_Server(const struct FPredictionKey& PredictionKey, const struct FDCInventoryEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "SendInventoryEventData_Server");

	Params::DCAbilitySystemComponent_SendInventoryEventData_Server Parms{};

	Parms.PredictionKey = std::move(PredictionKey);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.SetTagQueryData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          InHitTagQueryDataIdArray                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          InBeHitTagQueryDataIdArray                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::SetTagQueryData(const TArray<struct FPrimaryAssetId>& InHitTagQueryDataIdArray, const TArray<struct FPrimaryAssetId>& InBeHitTagQueryDataIdArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "SetTagQueryData");

	Params::DCAbilitySystemComponent_SetTagQueryData Parms{};

	Parms.InHitTagQueryDataIdArray = std::move(InHitTagQueryDataIdArray);
	Parms.InBeHitTagQueryDataIdArray = std::move(InBeHitTagQueryDataIdArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.TerminateBase
// (Native, Public)

void UDCAbilitySystemComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "UnbindMsg");

	Params::DCAbilitySystemComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAbilitySystemComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAbilitySystemComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAbilitySystemComponent", "UnbindMsgAll");

	Params::DCAbilitySystemComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountNameChangeShopWidget.OnAccountNameChangeButtonClicked
// (Final, Native, Private)

void UDCAccountNameChangeShopWidget::OnAccountNameChangeButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountNameChangeShopWidget", "OnAccountNameChangeButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountNameChangeShopWidget.OnAccountNameCheckState
// (Event, Protected, BlueprintEvent)

void UDCAccountNameChangeShopWidget::OnAccountNameCheckState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountNameChangeShopWidget", "OnAccountNameCheckState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCAccountNameChangeShopWidget.OnNewAccountNameCheckButtonClicked
// (Final, Native, Private)

void UDCAccountNameChangeShopWidget::OnNewAccountNameCheckButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountNameChangeShopWidget", "OnNewAccountNameCheckButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountNameChangeShopWidget.OnOldAccountNameCheckButtonClicked
// (Final, Native, Private)

void UDCAccountNameChangeShopWidget::OnOldAccountNameCheckButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountNameChangeShopWidget", "OnOldAccountNameCheckButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountNameChangeShopWidget.OnSetShopInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDCAccountNameChangeShopInfo     InShopInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAccountNameChangeShopWidget::OnSetShopInfo(const struct FDCAccountNameChangeShopInfo& InShopInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountNameChangeShopWidget", "OnSetShopInfo");

	Params::DCAccountNameChangeShopWidget_OnSetShopInfo Parms{};

	Parms.InShopInfo = std::move(InShopInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAccountNameChangeShopWidget.OnTextChangedNewAccountName
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             InAccountName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAccountNameChangeShopWidget::OnTextChangedNewAccountName(const class FText& InAccountName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountNameChangeShopWidget", "OnTextChangedNewAccountName");

	Params::DCAccountNameChangeShopWidget_OnTextChangedNewAccountName Parms{};

	Parms.InAccountName = std::move(InAccountName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountNameChangeShopWidget.OnTextChangedOldAccountName
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FText                             InAccountName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAccountNameChangeShopWidget::OnTextChangedOldAccountName(const class FText& InAccountName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountNameChangeShopWidget", "OnTextChangedOldAccountName");

	Params::DCAccountNameChangeShopWidget_OnTextChangedOldAccountName Parms{};

	Parms.InAccountName = std::move(InAccountName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountNameChangeShopWidget.ResetData
// (Final, Native, Public, BlueprintCallable)

void UDCAccountNameChangeShopWidget::ResetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountNameChangeShopWidget", "ResetData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountStatusUpgradeCompletePopup.Close
// (Final, Native, Private)

void UDCAccountStatusUpgradeCompletePopup::Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountStatusUpgradeCompletePopup", "Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAccountStatusWidget.OnAccountStatusUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDCAccountStatus                        InAccountStatus                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAccountStatusWidget::OnAccountStatusUpdated(const EDCAccountStatus InAccountStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountStatusWidget", "OnAccountStatusUpdated");

	Params::DCAccountStatusWidget_OnAccountStatusUpdated Parms{};

	Parms.InAccountStatus = InAccountStatus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAccountStatusWidget.ShowLegendaryStatusPopup
// (Final, Native, Private)

void UDCAccountStatusWidget::ShowLegendaryStatusPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAccountStatusWidget", "ShowLegendaryStatusPopup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActionSkinComponent.OnRep_Datas
// (Final, Native, Private)
// Parameters:
// TArray<class UDCActionSkinDataAsset*>   OldDatas                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCActionSkinComponent::OnRep_Datas(const TArray<class UDCActionSkinDataAsset*>& OldDatas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActionSkinComponent", "OnRep_Datas");

	Params::DCActionSkinComponent_OnRep_Datas Parms{};

	Parms.OldDatas = std::move(OldDatas);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorStatusComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCActorStatusComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorStatusComponent", "BroadcastMsgBlueprint");

	Params::DCActorStatusComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorStatusComponent.GameplayEffectDurationChanged
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      EffectHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewStartWorldTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCActorStatusComponent::GameplayEffectDurationChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, float NewStartWorldTime, float NewDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorStatusComponent", "GameplayEffectDurationChanged");

	Params::DCActorStatusComponent_GameplayEffectDurationChanged Parms{};

	Parms.EffectGameplayTag = std::move(EffectGameplayTag);
	Parms.EffectHandle = std::move(EffectHandle);
	Parms.NewStartWorldTime = NewStartWorldTime;
	Parms.NewDuration = NewDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorStatusComponent.GameplayEffectInhibitChanged
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      EffectHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsInhibited                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCActorStatusComponent::GameplayEffectInhibitChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, bool bIsInhibited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorStatusComponent", "GameplayEffectInhibitChanged");

	Params::DCActorStatusComponent_GameplayEffectInhibitChanged Parms{};

	Parms.EffectGameplayTag = std::move(EffectGameplayTag);
	Parms.EffectHandle = std::move(EffectHandle);
	Parms.bIsInhibited = bIsInhibited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorStatusComponent.GameplayEffectStackChanged
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      EffectHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewStackCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PreviousStackCount                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCActorStatusComponent::GameplayEffectStackChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, int32 NewStackCount, int32 PreviousStackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorStatusComponent", "GameplayEffectStackChanged");

	Params::DCActorStatusComponent_GameplayEffectStackChanged Parms{};

	Parms.EffectGameplayTag = std::move(EffectGameplayTag);
	Parms.EffectHandle = std::move(EffectHandle);
	Parms.NewStackCount = NewStackCount;
	Parms.PreviousStackCount = PreviousStackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorStatusComponent.OnRep_ActorStatusDatas
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FActorStatusData>         OldActorStatusDatas                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCActorStatusComponent::OnRep_ActorStatusDatas(const TArray<struct FActorStatusData>& OldActorStatusDatas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorStatusComponent", "OnRep_ActorStatusDatas");

	Params::DCActorStatusComponent_OnRep_ActorStatusDatas Parms{};

	Parms.OldActorStatusDatas = std::move(OldActorStatusDatas);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorStatusComponent.TerminateBase
// (Native, Public)

void UDCActorStatusComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorStatusComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorStatusComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCActorStatusComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorStatusComponent", "UnbindMsg");

	Params::DCActorStatusComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCActorStatusComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCActorStatusComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCActorStatusComponent", "UnbindMsgAll");

	Params::DCActorStatusComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkSpatialAudioVolume.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAkSpatialAudioVolume::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkSpatialAudioVolume", "BroadcastMsgBlueprint");

	Params::DCAkSpatialAudioVolume_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkSpatialAudioVolume.OnOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADCAkSpatialAudioVolume::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkSpatialAudioVolume", "OnOverlapBegin");

	Params::DCAkSpatialAudioVolume_OnOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkSpatialAudioVolume.OnOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAkSpatialAudioVolume::OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkSpatialAudioVolume", "OnOverlapEnd");

	Params::DCAkSpatialAudioVolume_OnOverlapEnd Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkSpatialAudioVolume.OnTargetPlayerPawnEnterVolume
// (Final, Native, Private)

void ADCAkSpatialAudioVolume::OnTargetPlayerPawnEnterVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkSpatialAudioVolume", "OnTargetPlayerPawnEnterVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkSpatialAudioVolume.OnTargetPlayerPawnExitVolume
// (Final, Native, Private)

void ADCAkSpatialAudioVolume::OnTargetPlayerPawnExitVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkSpatialAudioVolume", "OnTargetPlayerPawnExitVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkSpatialAudioVolume.TerminateBase
// (Native, Public)

void ADCAkSpatialAudioVolume::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkSpatialAudioVolume", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkSpatialAudioVolume.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAkSpatialAudioVolume::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkSpatialAudioVolume", "UnbindMsg");

	Params::DCAkSpatialAudioVolume_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAkSpatialAudioVolume.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAkSpatialAudioVolume::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAkSpatialAudioVolume", "UnbindMsgAll");

	Params::DCAkSpatialAudioVolume_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAnimInstanceV2.GetIdleAnim
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* UDCAnimInstanceV2::GetIdleAnim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAnimInstanceV2", "GetIdleAnim");

	Params::DCAnimInstanceV2_GetIdleAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeAIControllerBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAoeAIControllerBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeAIControllerBase", "BroadcastMsgBlueprint");

	Params::DCAoeAIControllerBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAoeAIControllerBase.TerminateBase
// (Native, Public)

void ADCAoeAIControllerBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeAIControllerBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAoeAIControllerBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAoeAIControllerBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeAIControllerBase", "UnbindMsg");

	Params::DCAoeAIControllerBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAoeAIControllerBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAoeAIControllerBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeAIControllerBase", "UnbindMsgAll");

	Params::DCAoeAIControllerBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MusicBase.AbilityActivated
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_MusicBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicBase", "AbilityActivated");

	Params::GA_MusicBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MusicBase.ApplyToSelf
// (Native, Protected, BlueprintCallable)

void UGA_MusicBase::ApplyToSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicBase", "ApplyToSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MusicBase.ApplyToTarget
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGA_MusicBase::ApplyToTarget(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicBase", "ApplyToTarget");

	Params::GA_MusicBase_ApplyToTarget Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MusicBase.OnApplied
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_MusicBase::OnApplied(class AActor* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicBase", "OnApplied");

	Params::GA_MusicBase_OnApplied Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MusicBase.GetRange
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGA_MusicBase::GetRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicBase", "GetRange");

	Params::GA_MusicBase_GetRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_MusicChannelingBase.ApplyToOverlappedTargets
// (Native, Protected, BlueprintCallable)

void UGA_MusicChannelingBase::ApplyToOverlappedTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicChannelingBase", "ApplyToOverlappedTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MusicChannelingBase.EventReceived
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_MusicChannelingBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicChannelingBase", "EventReceived");

	Params::GA_MusicChannelingBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MusicChannelingBase.OnTargetActorBeginOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_MusicChannelingBase::OnTargetActorBeginOverlap(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicChannelingBase", "OnTargetActorBeginOverlap");

	Params::GA_MusicChannelingBase_OnTargetActorBeginOverlap Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MusicChannelingBase.OnTargetActorEndOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_MusicChannelingBase::OnTargetActorEndOverlap(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicChannelingBase", "OnTargetActorEndOverlap");

	Params::GA_MusicChannelingBase_OnTargetActorEndOverlap Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAoeBase.AddBeginOverlapActor
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADCCharacterBase*                 CharacterBase                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAoeBase::AddBeginOverlapActor(class ADCCharacterBase* CharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeBase", "AddBeginOverlapActor");

	Params::DCAoeBase_AddBeginOverlapActor Parms{};

	Parms.CharacterBase = CharacterBase;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAoeBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAoeBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeBase", "BroadcastMsgBlueprint");

	Params::DCAoeBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAoeBase.OnSetAI
// (Event, Protected, BlueprintEvent)

void ADCAoeBase::OnSetAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeBase", "OnSetAI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCAoeBase.RemoveEndOverlapActor
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADCCharacterBase*                 CharacterBase                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAoeBase::RemoveEndOverlapActor(class ADCCharacterBase* CharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeBase", "RemoveEndOverlapActor");

	Params::DCAoeBase_RemoveEndOverlapActor Parms{};

	Parms.CharacterBase = CharacterBase;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAoeBase.TerminateBase
// (Native, Public)

void ADCAoeBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAoeBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAoeBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeBase", "UnbindMsg");

	Params::DCAoeBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAoeBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCAoeBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAoeBase", "UnbindMsgAll");

	Params::DCAoeBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DeferredAoeFinish
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCAoeBase*                       Aoe                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    bSuccessfully                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAoeSystemBlueprintLibrary::DeferredAoeFinish(class ADCCharacterBase*& DCCharacterBase, class ADCAoeBase* Aoe, const struct FTransform& Transform, const struct FGameplayEventData& EventData, bool* bSuccessfully)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "DeferredAoeFinish");

	Params::DCAoeSystemBlueprintLibrary_DeferredAoeFinish Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.Aoe = Aoe;
	Parms.Transform = std::move(Transform);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;

	if (bSuccessfully != nullptr)
		*bSuccessfully = Parms.bSuccessfully;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAoeSystemBlueprintLibrary::DespawnAoeAll(class ADCCharacterBase* DCCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "DespawnAoeAll");

	Params::DCAoeSystemBlueprintLibrary_DespawnAoeAll Parms{};

	Parms.DCCharacterBase = DCCharacterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeByPrimaryAssetId
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAoeSystemBlueprintLibrary::DespawnAoeByPrimaryAssetId(class ADCCharacterBase*& DCCharacterBase, const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "DespawnAoeByPrimaryAssetId");

	Params::DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeByPrimaryAssetIdWithinDistance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAoeSystemBlueprintLibrary::DespawnAoeByPrimaryAssetIdWithinDistance(class ADCCharacterBase*& DCCharacterBase, const struct FPrimaryAssetId& PrimaryAssetId, const struct FVector& Location, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "DespawnAoeByPrimaryAssetIdWithinDistance");

	Params::DCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.PrimaryAssetId = std::move(PrimaryAssetId);
	Parms.Location = std::move(Location);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeWithinDistance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAoeSystemBlueprintLibrary::DespawnAoeWithinDistance(class ADCCharacterBase*& DCCharacterBase, const struct FVector& Location, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "DespawnAoeWithinDistance");

	Params::DCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.Location = std::move(Location);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterMonsterTargets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAoeSystemBlueprintLibrary::FilterMonsterTargets(TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "FilterMonsterTargets");

	Params::DCAoeSystemBlueprintLibrary_FilterMonsterTargets Parms{};

	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterPlayerCharacterTargets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAoeSystemBlueprintLibrary::FilterPlayerCharacterTargets(TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "FilterPlayerCharacterTargets");

	Params::DCAoeSystemBlueprintLibrary_FilterPlayerCharacterTargets Parms{};

	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTagedTargets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAoeSystemBlueprintLibrary::FilterTagedTargets(TArray<class ADCCharacterBase*>& TargetArray, const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "FilterTagedTargets");

	Params::DCAoeSystemBlueprintLibrary_FilterTagedTargets Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTargetsOverDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCAoeBase*                       DCAoeBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAoeSystemBlueprintLibrary::FilterTargetsOverDistance(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "FilterTargetsOverDistance");

	Params::DCAoeSystemBlueprintLibrary_FilterTargetsOverDistance Parms{};

	Parms.DCAoeBase = DCAoeBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCAoeBase = Parms.DCAoeBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTargetsWithinDirectionAngleAndAllowedAngle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCAoeBase*                       DCAoeBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DirectionalAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AllowedAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAoeSystemBlueprintLibrary::FilterTargetsWithinDirectionAngleAndAllowedAngle(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray, float DirectionalAngle, float AllowedAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "FilterTargetsWithinDirectionAngleAndAllowedAngle");

	Params::DCAoeSystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle Parms{};

	Parms.DCAoeBase = DCAoeBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.DirectionalAngle = DirectionalAngle;
	Parms.AllowedAngle = AllowedAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCAoeBase = Parms.DCAoeBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTargetsWithinDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCAoeBase*                       DCAoeBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAoeSystemBlueprintLibrary::FilterTargetsWithinDistance(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "FilterTargetsWithinDistance");

	Params::DCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance Parms{};

	Parms.DCAoeBase = DCAoeBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCAoeBase = Parms.DCAoeBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterUnTagedTargets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAoeSystemBlueprintLibrary::FilterUnTagedTargets(TArray<class ADCCharacterBase*>& TargetArray, const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "FilterUnTagedTargets");

	Params::DCAoeSystemBlueprintLibrary_FilterUnTagedTargets Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.GetAoeArrayByClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ADCAoeBase>           InAoeClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCAoeBase*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADCAoeBase*> UDCAoeSystemBlueprintLibrary::GetAoeArrayByClass(const class AActor* InActor, TSubclassOf<class ADCAoeBase> InAoeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "GetAoeArrayByClass");

	Params::DCAoeSystemBlueprintLibrary_GetAoeArrayByClass Parms{};

	Parms.InActor = InActor;
	Parms.InAoeClass = InAoeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.GetAoeCountByClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ADCAoeBase>           InAoeClass                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCAoeSystemBlueprintLibrary::GetAoeCountByClass(const class AActor* InActor, TSubclassOf<class ADCAoeBase> InAoeClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "GetAoeCountByClass");

	Params::DCAoeSystemBlueprintLibrary_GetAoeCountByClass Parms{};

	Parms.InActor = InActor;
	Parms.InAoeClass = InAoeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.GetCircularLocations
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InPivotLocation                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InOffsetLocation                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDistance                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UDCAoeSystemBlueprintLibrary::GetCircularLocations(const struct FVector& InPivotLocation, const struct FVector& InOffsetLocation, const int32 InCount, const float InDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "GetCircularLocations");

	Params::DCAoeSystemBlueprintLibrary_GetCircularLocations Parms{};

	Parms.InPivotLocation = std::move(InPivotLocation);
	Parms.InOffsetLocation = std::move(InOffsetLocation);
	Parms.InCount = InCount;
	Parms.InDistance = InDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.GetTargetArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCAoeBase*                       DCAoeBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAoeSystemBlueprintLibrary::GetTargetArray(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "GetTargetArray");

	Params::DCAoeSystemBlueprintLibrary_GetTargetArray Parms{};

	Parms.DCAoeBase = DCAoeBase;
	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCAoeBase = Parms.DCAoeBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.PickRandomTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCCharacterBase* UDCAoeSystemBlueprintLibrary::PickRandomTarget(TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "PickRandomTarget");

	Params::DCAoeSystemBlueprintLibrary_PickRandomTarget Parms{};

	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.PickTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCCharacterBase* UDCAoeSystemBlueprintLibrary::PickTarget(TArray<class ADCCharacterBase*>& TargetArray, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "PickTarget");

	Params::DCAoeSystemBlueprintLibrary_PickTarget Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SortTargetsByDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCAoeBase*                       DCAoeBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EAoeFilterSortingType                   AoeFilterSortingType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCAoeSystemBlueprintLibrary::SortTargetsByDistance(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray, EAoeFilterSortingType AoeFilterSortingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "SortTargetsByDistance");

	Params::DCAoeSystemBlueprintLibrary_SortTargetsByDistance Parms{};

	Parms.DCAoeBase = DCAoeBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.AoeFilterSortingType = AoeFilterSortingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCAoeBase = Parms.DCAoeBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SortTargetsByDistanceAndPickTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCAoeBase*                       DCAoeBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EAoeFilterSortingType                   AoeFilterSortingType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCCharacterBase* UDCAoeSystemBlueprintLibrary::SortTargetsByDistanceAndPickTarget(class ADCAoeBase*& DCAoeBase, TArray<class ADCCharacterBase*>& TargetArray, EAoeFilterSortingType AoeFilterSortingType, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "SortTargetsByDistanceAndPickTarget");

	Params::DCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget Parms{};

	Parms.DCAoeBase = DCAoeBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.AoeFilterSortingType = AoeFilterSortingType;
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCAoeBase = Parms.DCAoeBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SpawnAoe
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ADCAoeBase>           AoeClass                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCGameplayAbilityBase*           DCGameplayAbilityBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    bSuccessfully                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCAoeBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCAoeBase* UDCAoeSystemBlueprintLibrary::SpawnAoe(class ADCCharacterBase*& DCCharacterBase, TSubclassOf<class ADCAoeBase> AoeClass, const struct FVector& Location, class UDCGameplayAbilityBase* DCGameplayAbilityBase, const struct FGameplayEventData& EventData, bool* bSuccessfully)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "SpawnAoe");

	Params::DCAoeSystemBlueprintLibrary_SpawnAoe Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.AoeClass = AoeClass;
	Parms.Location = std::move(Location);
	Parms.DCGameplayAbilityBase = DCGameplayAbilityBase;
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;

	if (bSuccessfully != nullptr)
		*bSuccessfully = Parms.bSuccessfully;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SpawnAoeDeferred
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ADCAoeBase>           AoeClass                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCGameplayAbilityBase*           DCGameplayAbilityBase                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    bSuccessfully                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCAoeBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCAoeBase* UDCAoeSystemBlueprintLibrary::SpawnAoeDeferred(class ADCCharacterBase*& DCCharacterBase, TSubclassOf<class ADCAoeBase> AoeClass, class UDCGameplayAbilityBase* DCGameplayAbilityBase, const struct FGameplayEventData& EventData, bool* bSuccessfully)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAoeSystemBlueprintLibrary", "SpawnAoeDeferred");

	Params::DCAoeSystemBlueprintLibrary_SpawnAoeDeferred Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.AoeClass = AoeClass;
	Parms.DCGameplayAbilityBase = DCGameplayAbilityBase;
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;

	if (bSuccessfully != nullptr)
		*bSuccessfully = Parms.bSuccessfully;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameStateBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameStateBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "BroadcastMsgBlueprint");

	Params::DCGameStateBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameStateBase.OnGameInfoSet
// (Native, Protected, HasOutParams)
// Parameters:
// struct FDCGameInfo                      OldGameInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCGameStateBase::OnGameInfoSet(const struct FDCGameInfo& OldGameInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "OnGameInfoSet");

	Params::DCGameStateBase_OnGameInfoSet Parms{};

	Parms.OldGameInfo = std::move(OldGameInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameStateBase.OnRep_AccountDataReplicationArray
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FAccountDataReplication>  OldAccountDataReplicationArray                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADCGameStateBase::OnRep_AccountDataReplicationArray(const TArray<struct FAccountDataReplication>& OldAccountDataReplicationArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "OnRep_AccountDataReplicationArray");

	Params::DCGameStateBase_OnRep_AccountDataReplicationArray Parms{};

	Parms.OldAccountDataReplicationArray = std::move(OldAccountDataReplicationArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameStateBase.OnRep_GameInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCGameInfo                      OldGameInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCGameStateBase::OnRep_GameInfo(const struct FDCGameInfo& OldGameInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "OnRep_GameInfo");

	Params::DCGameStateBase_OnRep_GameInfo Parms{};

	Parms.OldGameInfo = std::move(OldGameInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameStateBase.OnRep_GameStateDataArray
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FGameStateData>           OldGameStateDataArray                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADCGameStateBase::OnRep_GameStateDataArray(const TArray<struct FGameStateData>& OldGameStateDataArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "OnRep_GameStateDataArray");

	Params::DCGameStateBase_OnRep_GameStateDataArray Parms{};

	Parms.OldGameStateDataArray = std::move(OldGameStateDataArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameStateBase.OnRep_PartyDataArray
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FPartyData>               OldPartyDataArray                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADCGameStateBase::OnRep_PartyDataArray(const TArray<struct FPartyData>& OldPartyDataArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "OnRep_PartyDataArray");

	Params::DCGameStateBase_OnRep_PartyDataArray Parms{};

	Parms.OldPartyDataArray = std::move(OldPartyDataArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameStateBase.OnRep_State
// (Final, Native, Private)
// Parameters:
// EGameStateType                          OldState                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameStateBase::OnRep_State(const EGameStateType OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "OnRep_State");

	Params::DCGameStateBase_OnRep_State Parms{};

	Parms.OldState = OldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameStateBase.TerminateBase
// (Native, Public)

void ADCGameStateBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameStateBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameStateBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "UnbindMsg");

	Params::DCGameStateBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameStateBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameStateBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "UnbindMsgAll");

	Params::DCGameStateBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameStateBase.GetFloorRuleActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ADCGameStateBase::GetFloorRuleActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "GetFloorRuleActor");

	Params::DCGameStateBase_GetFloorRuleActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameStateBase.GetGameInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDCGameInfo                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDCGameInfo ADCGameStateBase::GetGameInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameStateBase", "GetGameInfo");

	Params::DCGameStateBase_GetGameInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCArenaGameState.OnUpdated
// (Final, Native, Private)

void ADCArenaGameState::OnUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArenaGameState", "OnUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCArmorSkinComponent.AddArmorSkinForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UDCArmorSkinDataAsset*            ArmorSkin                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCArmorSkinComponent::AddArmorSkinForDebug_Server(const class UDCArmorSkinDataAsset* ArmorSkin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArmorSkinComponent", "AddArmorSkinForDebug_Server");

	Params::DCArmorSkinComponent_AddArmorSkinForDebug_Server Parms{};

	Parms.ArmorSkin = ArmorSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCArmorSkinComponent.OnRep_ArmorSkins
// (Final, Native, Private)

void UDCArmorSkinComponent::OnRep_ArmorSkins()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArmorSkinComponent", "OnRep_ArmorSkins");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCArmorSkinComponent.RemoveArmorSkinForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UDCArmorSkinDataAsset*            ArmorSkin                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCArmorSkinComponent::RemoveArmorSkinForDebug_Server(const class UDCArmorSkinDataAsset* ArmorSkin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCArmorSkinComponent", "RemoveArmorSkinForDebug_Server");

	Params::DCArmorSkinComponent_RemoveArmorSkinForDebug_Server Parms{};

	Parms.ArmorSkin = ArmorSkin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LeaderboardContentWidget.OnContentDesc
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULeaderboardContentWidget::OnContentDesc(const class FText& NewValue, const class FText& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardContentWidget", "OnContentDesc");

	Params::LeaderboardContentWidget_OnContentDesc Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardContentWidget.OnContentName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULeaderboardContentWidget::OnContentName(const class FText& NewValue, const class FText& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardContentWidget", "OnContentName");

	Params::LeaderboardContentWidget_OnContentName Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardContentWidget.OnContentScoreName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULeaderboardContentWidget::OnContentScoreName(const class FText& NewValue, const class FText& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardContentWidget", "OnContentScoreName");

	Params::LeaderboardContentWidget_OnContentScoreName Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCAT_DashToLocation.DashToLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DestLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AllowedDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Teleport                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_DashToLocation*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_DashToLocation* UDCAT_DashToLocation::DashToLocation(class UGameplayAbility* OwningAbility, const struct FVector& DestLocation, float AllowedDistance, float Speed, bool Teleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_DashToLocation", "DashToLocation");

	Params::DCAT_DashToLocation_DashToLocation Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.DestLocation = std::move(DestLocation);
	Parms.AllowedDistance = AllowedDistance;
	Parms.Speed = Speed;
	Parms.Teleport = Teleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_JudgeMusicPlay.JudgeMusicPlay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     InInputAction                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GoodSectionStartTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GoodSectionEndTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PerfectSectionStartTime                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PerfectSectionEndTime                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_JudgeMusicPlay*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_JudgeMusicPlay* UDCAT_JudgeMusicPlay::JudgeMusicPlay(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const class UInputAction* InInputAction, float Duration, float GoodSectionStartTime, float GoodSectionEndTime, float PerfectSectionStartTime, float PerfectSectionEndTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_JudgeMusicPlay", "JudgeMusicPlay");

	Params::DCAT_JudgeMusicPlay_JudgeMusicPlay Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InInputAction = InInputAction;
	Parms.Duration = Duration;
	Parms.GoodSectionStartTime = GoodSectionStartTime;
	Parms.GoodSectionEndTime = GoodSectionEndTime;
	Parms.PerfectSectionStartTime = PerfectSectionStartTime;
	Parms.PerfectSectionEndTime = PerfectSectionEndTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_OverlapActorsInComponent.OverlapActorsInComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OverlapPrimitiveComponent                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           OverlapTargetClass                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InIgnoreActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_OverlapActorsInComponent*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_OverlapActorsInComponent* UDCAT_OverlapActorsInComponent::OverlapActorsInComponent(class UGameplayAbility* OwningAbility, class UPrimitiveComponent* OverlapPrimitiveComponent, class UClass* OverlapTargetClass, class AActor* InIgnoreActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_OverlapActorsInComponent", "OverlapActorsInComponent");

	Params::DCAT_OverlapActorsInComponent_OverlapActorsInComponent Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.OverlapPrimitiveComponent = OverlapPrimitiveComponent;
	Parms.OverlapTargetClass = OverlapTargetClass;
	Parms.InIgnoreActor = InIgnoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_OverlapActorsInComponent.AddIgnoreActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   InAddIgnoreActors                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCAT_OverlapActorsInComponent::AddIgnoreActors(const TArray<class AActor*>& InAddIgnoreActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_OverlapActorsInComponent", "AddIgnoreActors");

	Params::DCAT_OverlapActorsInComponent_AddIgnoreActors Parms{};

	Parms.InAddIgnoreActors = std::move(InAddIgnoreActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_OverlapActorsInComponent.ClearIgnoreActors
// (Final, Native, Public, BlueprintCallable)

void UDCAT_OverlapActorsInComponent::ClearIgnoreActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_OverlapActorsInComponent", "ClearIgnoreActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_OverlapActorsInComponent.GetTargetList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UDCAT_OverlapActorsInComponent::GetTargetList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_OverlapActorsInComponent", "GetTargetList");

	Params::DCAT_OverlapActorsInComponent_GetTargetList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_OverlapActorsInComponent.OnOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAT_OverlapActorsInComponent::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_OverlapActorsInComponent", "OnOverlapBegin");

	Params::DCAT_OverlapActorsInComponent_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_OverlapActorsInComponent.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAT_OverlapActorsInComponent::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_OverlapActorsInComponent", "OnOverlapEnd");

	Params::DCAT_OverlapActorsInComponent_OnOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_PlayMontageAndWaitForEvent.PlayMontageAndWaitForEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Param_MontageToPlay                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Param_EventTags                                        (Parm, NativeAccessSpecifierPublic)
// float                                   Param_Rate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Param_StartSection                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param_bStopWhenAbilityEnds                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_AnimRootMotionTranslationScale                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param_StartTimeSeconds                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_PlayMontageAndWaitForEvent* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_PlayMontageAndWaitForEvent* UDCAT_PlayMontageAndWaitForEvent::PlayMontageAndWaitForEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* Param_MontageToPlay, const struct FGameplayTagContainer& Param_EventTags, float Param_Rate, class FName Param_StartSection, bool Param_bStopWhenAbilityEnds, float Param_AnimRootMotionTranslationScale, float Param_StartTimeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_PlayMontageAndWaitForEvent", "PlayMontageAndWaitForEvent");

	Params::DCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.Param_MontageToPlay = Param_MontageToPlay;
	Parms.Param_EventTags = std::move(Param_EventTags);
	Parms.Param_Rate = Param_Rate;
	Parms.Param_StartSection = Param_StartSection;
	Parms.Param_bStopWhenAbilityEnds = Param_bStopWhenAbilityEnds;
	Parms.Param_AnimRootMotionTranslationScale = Param_AnimRootMotionTranslationScale;
	Parms.Param_StartTimeSeconds = Param_StartTimeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_RotateToActor.RotateToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitBoxType                             HitBox                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WithoutPitch                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WithoutRoll                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_RotateToActor*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_RotateToActor* UDCAT_RotateToActor::RotateToActor(class UGameplayAbility* OwningAbility, class AActor* Actor, EHitBoxType HitBox, float Speed, bool WithoutPitch, bool WithoutRoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_RotateToActor", "RotateToActor");

	Params::DCAT_RotateToActor_RotateToActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Actor = Actor;
	Parms.HitBox = HitBox;
	Parms.Speed = Speed;
	Parms.WithoutPitch = WithoutPitch;
	Parms.WithoutRoll = WithoutRoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_ServerWaitClientTargetData.ServerWaitForClientTargetData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_ServerWaitClientTargetData* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_ServerWaitClientTargetData* UDCAT_ServerWaitClientTargetData::ServerWaitForClientTargetData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, bool TriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_ServerWaitClientTargetData", "ServerWaitForClientTargetData");

	Params::DCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.TriggerOnce = TriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_ServerWaitClientTargetData.OnTargetDataReplicatedCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ActivationTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAT_ServerWaitClientTargetData::OnTargetDataReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& Data, const struct FGameplayTag& ActivationTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_ServerWaitClientTargetData", "OnTargetDataReplicatedCallback");

	Params::DCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.ActivationTag = std::move(ActivationTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MailBoxWidgetBase.FriendPrivacyOffBlueprint
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UMailBoxWidgetBase::FriendPrivacyOffBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MailBoxWidgetBase", "FriendPrivacyOffBlueprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.MailBoxWidgetBase.FriendPrivacyOnBlueprint
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UMailBoxWidgetBase::FriendPrivacyOnBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MailBoxWidgetBase", "FriendPrivacyOnBlueprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.MailBoxWidgetBase.IsFriendPrivacyOn
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMailBoxWidgetBase::IsFriendPrivacyOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MailBoxWidgetBase", "IsFriendPrivacyOn");

	Params::MailBoxWidgetBase_IsFriendPrivacyOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.MailBoxWidgetBase.IsPartyPrivacyOn
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMailBoxWidgetBase::IsPartyPrivacyOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MailBoxWidgetBase", "IsPartyPrivacyOn");

	Params::MailBoxWidgetBase_IsPartyPrivacyOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.MailBoxWidgetBase.OnFMsgWidgetStreamingModeNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetStreamingModeNotify    InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMailBoxWidgetBase::OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MailBoxWidgetBase", "OnFMsgWidgetStreamingModeNotifyBlueprint");

	Params::MailBoxWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.MailBoxWidgetBase.OnSetFriendPrivacy
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bOn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMailBoxWidgetBase::OnSetFriendPrivacy(bool bOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MailBoxWidgetBase", "OnSetFriendPrivacy");

	Params::MailBoxWidgetBase_OnSetFriendPrivacy Parms{};

	Parms.bOn = bOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MailBoxWidgetBase.OnSetPartyPrivacy
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bOn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMailBoxWidgetBase::OnSetPartyPrivacy(bool bOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MailBoxWidgetBase", "OnSetPartyPrivacy");

	Params::MailBoxWidgetBase_OnSetPartyPrivacy Parms{};

	Parms.bOn = bOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_SpawnProjectile.SpawnProjectile
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           SpawnClass                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FirePower                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_SpawnProjectile*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_SpawnProjectile* UDCAT_SpawnProjectile::SpawnProjectile(class UGameplayAbility* OwningAbility, class UClass* SpawnClass, const struct FTransform& SpawnTransform, float FirePower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_SpawnProjectile", "SpawnProjectile");

	Params::DCAT_SpawnProjectile_SpawnProjectile Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.SpawnClass = SpawnClass;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.FirePower = FirePower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_TargetActorRadius.TargetActorRadius
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           TargetingClass                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_TargetActorRadius*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_TargetActorRadius* UDCAT_TargetActorRadius::TargetActorRadius(class UGameplayAbility* OwningAbility, float Radius, ECollisionChannel CollisionChannel, class UClass* TargetingClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_TargetActorRadius", "TargetActorRadius");

	Params::DCAT_TargetActorRadius_TargetActorRadius Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Radius = Radius;
	Parms.CollisionChannel = CollisionChannel;
	Parms.TargetingClass = TargetingClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitAimDirChangedFromActor.WaitAimDirectionChangedFromActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitAimDirChangedFromActor* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitAimDirChangedFromActor* UDCAT_WaitAimDirChangedFromActor::WaitAimDirectionChangedFromActor(class UGameplayAbility* OwningAbility, class AActor* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitAimDirChangedFromActor", "WaitAimDirectionChangedFromActor");

	Params::DCAT_WaitAimDirChangedFromActor_WaitAimDirectionChangedFromActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ShapeShiftSlotWidgetBase.OnReset
// (Event, Protected, BlueprintEvent)

void UShapeShiftSlotWidgetBase::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShapeShiftSlotWidgetBase", "OnReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ShapeShiftSlotWidgetBase.OnSetShapeShiftArtData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDCCharacterShapeShiftArtData*    InShapeShiftArtData                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShapeShiftSlotWidgetBase::OnSetShapeShiftArtData(const class UDCCharacterShapeShiftArtData* InShapeShiftArtData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShapeShiftSlotWidgetBase", "OnSetShapeShiftArtData");

	Params::ShapeShiftSlotWidgetBase_OnSetShapeShiftArtData Parms{};

	Parms.InShapeShiftArtData = InShapeShiftArtData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ShapeShiftSlotWidgetBase.OnShapeShiftDataChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FShapeShiftData                  InShapeShiftData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UShapeShiftSlotWidgetBase::OnShapeShiftDataChanged(const struct FShapeShiftData& InShapeShiftData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShapeShiftSlotWidgetBase", "OnShapeShiftDataChanged");

	Params::ShapeShiftSlotWidgetBase_OnShapeShiftDataChanged Parms{};

	Parms.InShapeShiftData = std::move(InShapeShiftData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ShapeShiftSlotWidgetBase.Reset
// (Final, Native, Public)

void UShapeShiftSlotWidgetBase::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShapeShiftSlotWidgetBase", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ShapeShiftSlotWidgetBase.SetShapeShiftData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FShapeShiftData                  InShapeShiftData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UDCShapeShiftDataAsset*           InShapeShiftDataAsset                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShapeShiftSlotWidgetBase::SetShapeShiftData(const struct FShapeShiftData& InShapeShiftData, const class UDCShapeShiftDataAsset* InShapeShiftDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShapeShiftSlotWidgetBase", "SetShapeShiftData");

	Params::ShapeShiftSlotWidgetBase_SetShapeShiftData Parms{};

	Parms.InShapeShiftData = std::move(InShapeShiftData);
	Parms.InShapeShiftDataAsset = InShapeShiftDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitAimDirectionChanged.WaitAimDirectionChanged
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitAimDirectionChanged*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitAimDirectionChanged* UDCAT_WaitAimDirectionChanged::WaitAimDirectionChanged(class UGameplayAbility* OwningAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitAimDirectionChanged", "WaitAimDirectionChanged");

	Params::DCAT_WaitAimDirectionChanged_WaitAimDirectionChanged Parms{};

	Parms.OwningAbility = OwningAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitAttributeChangeByExecution.WaitForAttributeChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OptionalExternalOwner                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitAttributeChangeByExecution*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitAttributeChangeByExecution* UDCAT_WaitAttributeChangeByExecution::WaitForAttributeChange(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& Attribute, bool TriggerOnce, class AActor* OptionalExternalOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitAttributeChangeByExecution", "WaitForAttributeChange");

	Params::DCAT_WaitAttributeChangeByExecution_WaitForAttributeChange Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Attribute = std::move(Attribute);
	Parms.TriggerOnce = TriggerOnce;
	Parms.OptionalExternalOwner = OptionalExternalOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitAttributeChangeByExecution.WaitForAttributesChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayAttribute>       Attributes                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    TriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OptionalExternalOwner                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitAttributeChangeByExecution*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitAttributeChangeByExecution* UDCAT_WaitAttributeChangeByExecution::WaitForAttributesChange(class UGameplayAbility* OwningAbility, const TArray<struct FGameplayAttribute>& Attributes, bool TriggerOnce, class AActor* OptionalExternalOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitAttributeChangeByExecution", "WaitForAttributesChange");

	Params::DCAT_WaitAttributeChangeByExecution_WaitForAttributesChange Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Attributes = std::move(Attributes);
	Parms.TriggerOnce = TriggerOnce;
	Parms.OptionalExternalOwner = OptionalExternalOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitDelayPausable.WaitDelay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitDelayPausable*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitDelayPausable* UDCAT_WaitDelayPausable::WaitDelay(class UGameplayAbility* OwningAbility, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitDelayPausable", "WaitDelay");

	Params::DCAT_WaitDelayPausable_WaitDelay Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitDelayPausable.AddTimerElapsedTimeRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   AdditionalRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAT_WaitDelayPausable::AddTimerElapsedTimeRatio(float AdditionalRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitDelayPausable", "AddTimerElapsedTimeRatio");

	Params::DCAT_WaitDelayPausable_AddTimerElapsedTimeRatio Parms{};

	Parms.AdditionalRatio = AdditionalRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitDelayPausable.PauseTimer
// (Final, Native, Public, BlueprintCallable)

void UDCAT_WaitDelayPausable::PauseTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitDelayPausable", "PauseTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitDelayPausable.ResumeTimer
// (Final, Native, Public, BlueprintCallable)

void UDCAT_WaitDelayPausable::ResumeTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitDelayPausable", "ResumeTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitDelayPausable.GetElapsedTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCAT_WaitDelayPausable::GetElapsedTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitDelayPausable", "GetElapsedTime");

	Params::DCAT_WaitDelayPausable_GetElapsedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitDistChangeFromActor.WaitDistanceChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaximumDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitDistChangeFromActor*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitDistChangeFromActor* UDCAT_WaitDistChangeFromActor::WaitDistanceChange(class UGameplayAbility* OwningAbility, class AActor* TargetActor, float MaximumDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitDistChangeFromActor", "WaitDistanceChange");

	Params::DCAT_WaitDistChangeFromActor_WaitDistanceChange Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetActor = TargetActor;
	Parms.MaximumDistance = MaximumDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitDistChangeFromView.WaitDistanceChange
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaximumDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CollisionRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitDistChangeFromView*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitDistChangeFromView* UDCAT_WaitDistChangeFromView::WaitDistanceChange(class UGameplayAbility* OwningAbility, class AActor* TargetActor, const struct FVector& TargetLocation, float MaximumDistance, float CollisionRadius, ECollisionChannel CollisionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitDistChangeFromView", "WaitDistanceChange");

	Params::DCAT_WaitDistChangeFromView_WaitDistanceChange Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetActor = TargetActor;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.MaximumDistance = MaximumDistance;
	Parms.CollisionRadius = CollisionRadius;
	Parms.CollisionChannel = CollisionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitForGameplayEvents.WaitForGameplayEvents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            InEventTags                                            (Parm, NativeAccessSpecifierPublic)
// class UDCAT_WaitForGameplayEvents*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitForGameplayEvents* UDCAT_WaitForGameplayEvents::WaitForGameplayEvents(class UGameplayAbility* OwningAbility, const struct FGameplayTagContainer& InEventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitForGameplayEvents", "WaitForGameplayEvents");

	Params::DCAT_WaitForGameplayEvents_WaitForGameplayEvents Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InEventTags = std::move(InEventTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEnd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     WithTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     WithoutTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOptionalExternalTarget                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTriggerOnce                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitGameplayAbilityActivateOrEnd*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitGameplayAbilityActivateOrEnd* UDCAT_WaitGameplayAbilityActivateOrEnd::WaitForAbilityActivateOrEnd(class UGameplayAbility* OwningAbility, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, class AActor* InOptionalExternalTarget, bool bTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitGameplayAbilityActivateOrEnd", "WaitForAbilityActivateOrEnd");

	Params::DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.WithTag = std::move(WithTag);
	Parms.WithoutTag = std::move(WithoutTag);
	Parms.InOptionalExternalTarget = InOptionalExternalTarget;
	Parms.bTriggerOnce = bTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEnd_Query
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagQuery                Query                                                  (Parm, NativeAccessSpecifierPublic)
// class AActor*                           InOptionalExternalTarget                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTriggerOnce                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitGameplayAbilityActivateOrEnd*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitGameplayAbilityActivateOrEnd* UDCAT_WaitGameplayAbilityActivateOrEnd::WaitForAbilityActivateOrEnd_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& Query, class AActor* InOptionalExternalTarget, bool bTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitGameplayAbilityActivateOrEnd", "WaitForAbilityActivateOrEnd_Query");

	Params::DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Query = std::move(Query);
	Parms.InOptionalExternalTarget = InOptionalExternalTarget;
	Parms.bTriggerOnce = bTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEndWithTagRequirements
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagRequirements         TagRequirements                                        (Parm, NativeAccessSpecifierPublic)
// class AActor*                           InOptionalExternalTarget                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTriggerOnce                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitGameplayAbilityActivateOrEnd*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitGameplayAbilityActivateOrEnd* UDCAT_WaitGameplayAbilityActivateOrEnd::WaitForAbilityActivateOrEndWithTagRequirements(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& TagRequirements, class AActor* InOptionalExternalTarget, bool bTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitGameplayAbilityActivateOrEnd", "WaitForAbilityActivateOrEndWithTagRequirements");

	Params::DCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TagRequirements = std::move(TagRequirements);
	Parms.InOptionalExternalTarget = InOptionalExternalTarget;
	Parms.bTriggerOnce = bTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.OnAbilityActivate
// (Final, Native, Protected)
// Parameters:
// class UGameplayAbility*                 ActivatedAbility                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCAT_WaitGameplayAbilityActivateOrEnd::OnAbilityActivate(class UGameplayAbility* ActivatedAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitGameplayAbilityActivateOrEnd", "OnAbilityActivate");

	Params::DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityActivate Parms{};

	Parms.ActivatedAbility = ActivatedAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.OnAbilityEnd
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FAbilityEndedData                AbilityEndedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDCAT_WaitGameplayAbilityActivateOrEnd::OnAbilityEnd(const struct FAbilityEndedData& AbilityEndedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitGameplayAbilityActivateOrEnd", "OnAbilityEnd");

	Params::DCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityEnd Parms{};

	Parms.AbilityEndedData = std::move(AbilityEndedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitGameplayTagsRemoved.WaitGameplayTagsRemoved
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TagContainer                                           (Parm, NativeAccessSpecifierPublic)
// bool                                    bIsWaitAnyTag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOptionalExternalTarget                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOnlyTriggerOnce                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBroadcastImmediately                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitGameplayTagsRemoved*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitGameplayTagsRemoved* UDCAT_WaitGameplayTagsRemoved::WaitGameplayTagsRemoved(class UGameplayAbility* OwningAbility, const struct FGameplayTagContainer& TagContainer, bool bIsWaitAnyTag, class AActor* InOptionalExternalTarget, bool bIsOnlyTriggerOnce, bool bShouldBroadcastImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitGameplayTagsRemoved", "WaitGameplayTagsRemoved");

	Params::DCAT_WaitGameplayTagsRemoved_WaitGameplayTagsRemoved Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TagContainer = std::move(TagContainer);
	Parms.bIsWaitAnyTag = bIsWaitAnyTag;
	Parms.InOptionalExternalTarget = InOptionalExternalTarget;
	Parms.bIsOnlyTriggerOnce = bIsOnlyTriggerOnce;
	Parms.bShouldBroadcastImmediately = bShouldBroadcastImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitInteractableTarget.WaitInteractableTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCGATA_LineTraceInteractable*    InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitInteractableTarget*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitInteractableTarget* UDCAT_WaitInteractableTarget::WaitInteractableTarget(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class ADCGATA_LineTraceInteractable* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitInteractableTarget", "WaitInteractableTarget");

	Params::DCAT_WaitInteractableTarget_WaitInteractableTarget Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitInteractableTarget.OnFoundNewInteractableTarget
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAT_WaitInteractableTarget::OnFoundNewInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitInteractableTarget", "OnFoundNewInteractableTarget");

	Params::DCAT_WaitInteractableTarget_OnFoundNewInteractableTarget Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitInteractableTarget.OnLostInteractableTarget
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAT_WaitInteractableTarget::OnLostInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitInteractableTarget", "OnLostInteractableTarget");

	Params::DCAT_WaitInteractableTarget_OnLostInteractableTarget Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitInteractableTarget.ResetTargeting
// (Final, Native, Public)

void UDCAT_WaitInteractableTarget::ResetTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitInteractableTarget", "ResetTargeting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitInteractableTarget.StartTargeting
// (Final, Native, Public, BlueprintCallable)

void UDCAT_WaitInteractableTarget::StartTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitInteractableTarget", "StartTargeting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitInteractableTarget.StopTargeting
// (Final, Native, Public, BlueprintCallable)

void UDCAT_WaitInteractableTarget::StopTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitInteractableTarget", "StopTargeting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.WaitSocketBlockedStateChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCGATA_AimTraceToSocket*         InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitSocketBlockedStateChange*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitSocketBlockedStateChange* UDCAT_WaitSocketBlockedStateChange::WaitSocketBlockedStateChange(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class ADCGATA_AimTraceToSocket* InTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitSocketBlockedStateChange", "WaitSocketBlockedStateChange");

	Params::DCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InTargetActor = InTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.OnSocketSightBlocked
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAT_WaitSocketBlockedStateChange::OnSocketSightBlocked(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitSocketBlockedStateChange", "OnSocketSightBlocked");

	Params::DCAT_WaitSocketBlockedStateChange_OnSocketSightBlocked Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.OnSocketSightUnblocked
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCAT_WaitSocketBlockedStateChange::OnSocketSightUnblocked(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitSocketBlockedStateChange", "OnSocketSightUnblocked");

	Params::DCAT_WaitSocketBlockedStateChange_OnSocketSightUnblocked Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.ResetTargeting
// (Final, Native, Public)

void UDCAT_WaitSocketBlockedStateChange::ResetTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitSocketBlockedStateChange", "ResetTargeting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.StartTargeting
// (Final, Native, Public, BlueprintCallable)

void UDCAT_WaitSocketBlockedStateChange::StartTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitSocketBlockedStateChange", "StartTargeting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.StopTargeting
// (Final, Native, Public, BlueprintCallable)

void UDCAT_WaitSocketBlockedStateChange::StopTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitSocketBlockedStateChange", "StopTargeting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitTargetGameplayTagEvent.WaitTargetGameplayTagEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InTargetTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOptionalExternalTarget                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitTargetGameplayTagEvent* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitTargetGameplayTagEvent* UDCAT_WaitTargetGameplayTagEvent::WaitTargetGameplayTagEvent(class UGameplayAbility* OwningAbility, const struct FGameplayTag& InTargetTag, class AActor* InOptionalExternalTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitTargetGameplayTagEvent", "WaitTargetGameplayTagEvent");

	Params::DCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InTargetTag = std::move(InTargetTag);
	Parms.InOptionalExternalTarget = InOptionalExternalTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitVelocityZero.WaitVelocityZero
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitVelocityZero*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitVelocityZero* UDCAT_WaitVelocityZero::WaitVelocityZero(class UGameplayAbility* OwningAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitVelocityZero", "WaitVelocityZero");

	Params::DCAT_WaitVelocityZero_WaitVelocityZero Parms{};

	Parms.OwningAbility = OwningAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCInventoryContainerComponent.OnRep_InventoryList
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class UDCInventoryBase*>         OldInventoryList                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCInventoryContainerComponent::OnRep_InventoryList(const TArray<class UDCInventoryBase*>& OldInventoryList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryContainerComponent", "OnRep_InventoryList");

	Params::DCInventoryContainerComponent_OnRep_InventoryList Parms{};

	Parms.OldInventoryList = std::move(OldInventoryList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCButtonNumberSetterWidget.OnInputTextChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCButtonNumberSetterWidget::OnInputTextChanged(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCButtonNumberSetterWidget", "OnInputTextChanged");

	Params::DCButtonNumberSetterWidget_OnInputTextChanged Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCButtonNumberSetterWidget.OnInputTextCommitted
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ETextCommit                             InCommitType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCButtonNumberSetterWidget::OnInputTextCommitted(const class FText& InText, ETextCommit InCommitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCButtonNumberSetterWidget", "OnInputTextCommitted");

	Params::DCButtonNumberSetterWidget_OnInputTextCommitted Parms{};

	Parms.InText = std::move(InText);
	Parms.InCommitType = InCommitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCButtonNumberSetterWidget.OnMinusOneButtonClicked
// (Final, Native, Private)

void UDCButtonNumberSetterWidget::OnMinusOneButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCButtonNumberSetterWidget", "OnMinusOneButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCButtonNumberSetterWidget.OnPlusOneButtonClicked
// (Final, Native, Private)

void UDCButtonNumberSetterWidget::OnPlusOneButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCButtonNumberSetterWidget", "OnPlusOneButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCameraPostProcessTimelineData.HandleTimelineFinished
// (Final, Native, Protected)

void UDCCameraPostProcessTimelineData::HandleTimelineFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCameraPostProcessTimelineData", "HandleTimelineFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCameraPostProcessTimelineData.HandleTimelineUpdate
// (Final, Native, Protected)
// Parameters:
// float                                   UpdateValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCameraPostProcessTimelineData::HandleTimelineUpdate(float UpdateValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCameraPostProcessTimelineData", "HandleTimelineUpdate");

	Params::DCCameraPostProcessTimelineData_HandleTimelineUpdate Parms{};

	Parms.UpdateValue = UpdateValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.CalculateProjectileHitNiagaraTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InSourceObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UDCGameplayCueBlueprintLibrary::CalculateProjectileHitNiagaraTransform(const class UObject* InSourceObject, const struct FHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCGameplayCueBlueprintLibrary", "CalculateProjectileHitNiagaraTransform");

	Params::DCGameplayCueBlueprintLibrary_CalculateProjectileHitNiagaraTransform Parms{};

	Parms.InSourceObject = InSourceObject;
	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.GetProjectileDefaultNiagaraSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InSourceObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* UDCGameplayCueBlueprintLibrary::GetProjectileDefaultNiagaraSystem(const class UObject* InSourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCGameplayCueBlueprintLibrary", "GetProjectileDefaultNiagaraSystem");

	Params::DCGameplayCueBlueprintLibrary_GetProjectileDefaultNiagaraSystem Parms{};

	Parms.InSourceObject = InSourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.GetProjectileHitCharacterNiagaraSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InSourceObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* UDCGameplayCueBlueprintLibrary::GetProjectileHitCharacterNiagaraSystem(const class UObject* InSourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCGameplayCueBlueprintLibrary", "GetProjectileHitCharacterNiagaraSystem");

	Params::DCGameplayCueBlueprintLibrary_GetProjectileHitCharacterNiagaraSystem Parms{};

	Parms.InSourceObject = InSourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.GetProjectileHitNiagaraSystemScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InSourceObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCGameplayCueBlueprintLibrary::GetProjectileHitNiagaraSystemScale(const class UObject* InSourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCGameplayCueBlueprintLibrary", "GetProjectileHitNiagaraSystemScale");

	Params::DCGameplayCueBlueprintLibrary_GetProjectileHitNiagaraSystemScale Parms{};

	Parms.InSourceObject = InSourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.GetProjectileHitObjectNiagaraSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InSourceObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* UDCGameplayCueBlueprintLibrary::GetProjectileHitObjectNiagaraSystem(const class UObject* InSourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCGameplayCueBlueprintLibrary", "GetProjectileHitObjectNiagaraSystem");

	Params::DCGameplayCueBlueprintLibrary_GetProjectileHitObjectNiagaraSystem Parms{};

	Parms.InSourceObject = InSourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.GetProjectileHitShieldNiagaraSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InSourceObject                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* UDCGameplayCueBlueprintLibrary::GetProjectileHitShieldNiagaraSystem(const class UObject* InSourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCGameplayCueBlueprintLibrary", "GetProjectileHitShieldNiagaraSystem");

	Params::DCGameplayCueBlueprintLibrary_GetProjectileHitShieldNiagaraSystem Parms{};

	Parms.InSourceObject = InSourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.PlayHitDirectionWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InHitActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameplayCueBlueprintLibrary::PlayHitDirectionWidget(class AActor* InHitActor, const class AActor* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCGameplayCueBlueprintLibrary", "PlayHitDirectionWidget");

	Params::DCGameplayCueBlueprintLibrary_PlayHitDirectionWidget Parms{};

	Parms.InHitActor = InHitActor;
	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.PlayHitDirectionWidgetWithParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayCueParameters           InCueParams                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCGameplayCueBlueprintLibrary::PlayHitDirectionWidgetWithParams(const struct FGameplayCueParameters& InCueParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCGameplayCueBlueprintLibrary", "PlayHitDirectionWidgetWithParams");

	Params::DCGameplayCueBlueprintLibrary_PlayHitDirectionWidgetWithParams Parms{};

	Parms.InCueParams = std::move(InCueParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.PlayHitReactionAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InHitActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameplayCueBlueprintLibrary::PlayHitReactionAnimation(class AActor* InHitActor, const class AActor* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCGameplayCueBlueprintLibrary", "PlayHitReactionAnimation");

	Params::DCGameplayCueBlueprintLibrary_PlayHitReactionAnimation Parms{};

	Parms.InHitActor = InHitActor;
	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayCueBlueprintLibrary.PlayHitReactionAnimationWithParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayCueParameters           InCueParams                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCGameplayCueBlueprintLibrary::PlayHitReactionAnimationWithParams(const struct FGameplayCueParameters& InCueParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCGameplayCueBlueprintLibrary", "PlayHitReactionAnimationWithParams");

	Params::DCGameplayCueBlueprintLibrary_PlayHitReactionAnimationWithParams Parms{};

	Parms.InCueParams = std::move(InCueParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionBaseWidget.OnHovered
// (Final, Native, Public, BlueprintCallable)

void UGameMenuOptionBaseWidget::OnHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionBaseWidget", "OnHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionTwitchDropsWidget.OnClickTwitchDropsButton
// (Final, Native, Protected)

void UGameMenuOptionTwitchDropsWidget::OnClickTwitchDropsButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionTwitchDropsWidget", "OnClickTwitchDropsButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.VoipUserWidget.OnAccountId
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDCAccountId                     NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCAccountId                     OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoipUserWidget::OnAccountId(const struct FDCAccountId& NewValue, const struct FDCAccountId& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipUserWidget", "OnAccountId");

	Params::VoipUserWidget_OnAccountId Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.VoipUserWidget.OnbVoipForceParty
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoipUserWidget::OnbVoipForceParty(bool NewValue, bool OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipUserWidget", "OnbVoipForceParty");

	Params::VoipUserWidget_OnbVoipForceParty Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.VoipUserWidget.OnMuteButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UVoipUserWidget::OnMuteButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipUserWidget", "OnMuteButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.VoipUserWidget.OnVoipPartyData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FVoipPartyData                   NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVoipPartyData                   OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVoipUserWidget::OnVoipPartyData(const struct FVoipPartyData& NewValue, const struct FVoipPartyData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipUserWidget", "OnVoipPartyData");

	Params::VoipUserWidget_OnVoipPartyData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.VoipUserWidget.OnVoipUserData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FVoipUserData                    NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoipUserData                    OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UVoipUserWidget::OnVoipUserData(const struct FVoipUserData& NewValue, const struct FVoipUserData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipUserWidget", "OnVoipUserData");

	Params::VoipUserWidget_OnVoipUserData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.VoipUserWidget.OnVoipVolumeChanged
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InVoipVolume                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoipUserWidget::OnVoipVolumeChanged(float InVoipVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipUserWidget", "OnVoipVolumeChanged");

	Params::VoipUserWidget_OnVoipVolumeChanged Parms{};

	Parms.InVoipVolume = InVoipVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.VoipUserWidget.SetAccountId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCAccountId                     InAccountId                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoipUserWidget::SetAccountId(const struct FDCAccountId& InAccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipUserWidget", "SetAccountId");

	Params::VoipUserWidget_SetAccountId Parms{};

	Parms.InAccountId = std::move(InAccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.VoipUserWidget.SetVoipForceParty
// (Final, Native, Private)
// Parameters:
// bool                                    bInVoipForceParty                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoipUserWidget::SetVoipForceParty(bool bInVoipForceParty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipUserWidget", "SetVoipForceParty");

	Params::VoipUserWidget_SetVoipForceParty Parms{};

	Parms.bInVoipForceParty = bInVoipForceParty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.VoipUserWidget.SetVoipPartyData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FVoipPartyData                   InVoipPartyData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVoipUserWidget::SetVoipPartyData(const struct FVoipPartyData& InVoipPartyData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipUserWidget", "SetVoipPartyData");

	Params::VoipUserWidget_SetVoipPartyData Parms{};

	Parms.InVoipPartyData = std::move(InVoipPartyData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.VoipUserWidget.SetVoipUserData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FVoipUserData                    InVoipUserData                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UVoipUserWidget::SetVoipUserData(const struct FVoipUserData& InVoipUserData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipUserWidget", "SetVoipUserData");

	Params::VoipUserWidget_SetVoipUserData Parms{};

	Parms.InVoipUserData = std::move(InVoipUserData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInteractTargetInterface.InteractTargetInfoName
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Param_Name                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void IDCInteractTargetInterface::InteractTargetInfoName(class FText* Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInteractTargetInterface", "InteractTargetInfoName");

	Params::DCInteractTargetInterface_InteractTargetInfoName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param_Name != nullptr)
		*Param_Name = std::move(Parms.Param_Name);
}


// Function DungeonCrawler.DCInteractTargetInterface.InteractTargetInfoRarity
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     RarityTag                                              (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDCInteractTargetInterface::InteractTargetInfoRarity(struct FGameplayTag* RarityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInteractTargetInterface", "InteractTargetInfoRarity");

	Params::DCInteractTargetInterface_InteractTargetInfoRarity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (RarityTag != nullptr)
		*RarityTag = std::move(Parms.RarityTag);
}


// Function DungeonCrawler.DCChannelPlayerListWidget.OnSearchTextChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             Keyword                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCChannelPlayerListWidget::OnSearchTextChanged(const class FText& Keyword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCChannelPlayerListWidget", "OnSearchTextChanged");

	Params::DCChannelPlayerListWidget_OnSearchTextChanged Parms{};

	Parms.Keyword = std::move(Keyword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayCueNotify_Actor.ClearAkComponentRTPCValue
// (Final, Native, Protected, BlueprintCallable)

void ADCGameplayCueNotify_Actor::ClearAkComponentRTPCValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayCueNotify_Actor", "ClearAkComponentRTPCValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayCueNotify_Actor.SetAkComponentRTPCValue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UAkComponent*                     AkComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkRtpc*                          RtpcValue                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTickValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTotalValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxRTPCValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameplayCueNotify_Actor::SetAkComponentRTPCValue(class UAkComponent* AkComponent, const class UAkRtpc* RtpcValue, float InTickValue, float InTotalValue, float InMaxRTPCValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayCueNotify_Actor", "SetAkComponentRTPCValue");

	Params::DCGameplayCueNotify_Actor_SetAkComponentRTPCValue Parms{};

	Parms.AkComponent = AkComponent;
	Parms.RtpcValue = RtpcValue;
	Parms.InTickValue = InTickValue;
	Parms.InTotalValue = InTotalValue;
	Parms.InMaxRTPCValue = InMaxRTPCValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterInfoWidget.SetLevelAndFame
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Fame                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCharacterInfoWidget::SetLevelAndFame(int32 Level, int32 Fame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterInfoWidget", "SetLevelAndFame");

	Params::DCCharacterInfoWidget_SetLevelAndFame Parms{};

	Parms.Level = Level;
	Parms.Fame = Fame;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCCharacterV2.GetPartHeadComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ADCCharacterV2::GetPartHeadComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterV2", "GetPartHeadComponent");

	Params::DCCharacterV2_GetPartHeadComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterV2.GetPerkDataComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDCPerkDataComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCPerkDataComponent* ADCCharacterV2::GetPerkDataComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterV2", "GetPerkDataComponent");

	Params::DCCharacterV2_GetPerkDataComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerCharacterV2.OnRep_AccountId
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCAccountId                     OldAccountId                                           (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerCharacterV2::OnRep_AccountId(const struct FDCAccountId& OldAccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterV2", "OnRep_AccountId");

	Params::DCPlayerCharacterV2_OnRep_AccountId Parms{};

	Parms.OldAccountId = std::move(OldAccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterV2.OnRep_PartyId
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCPartyId                       OldPartyId                                             (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerCharacterV2::OnRep_PartyId(const struct FDCPartyId& OldPartyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterV2", "OnRep_PartyId");

	Params::DCPlayerCharacterV2_OnRep_PartyId Parms{};

	Parms.OldPartyId = std::move(OldPartyId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterLobbyCapture.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterLobbyCapture::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterLobbyCapture", "BroadcastMsgBlueprint");

	Params::DCCharacterLobbyCapture_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterLobbyCapture.GetNickname
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FNickname                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNickname ADCCharacterLobbyCapture::GetNickname()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterLobbyCapture", "GetNickname");

	Params::DCCharacterLobbyCapture_GetNickname Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterLobbyCapture.OnLobbyPoseSkinChanged
// (Final, Native, Private)
// Parameters:
// class UDCActionSkinDataAsset*           ActionSkinData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsEquipped                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterLobbyCapture::OnLobbyPoseSkinChanged(const class UDCActionSkinDataAsset* ActionSkinData, const bool bIsEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterLobbyCapture", "OnLobbyPoseSkinChanged");

	Params::DCCharacterLobbyCapture_OnLobbyPoseSkinChanged Parms{};

	Parms.ActionSkinData = ActionSkinData;
	Parms.bIsEquipped = bIsEquipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterLobbyCapture.TerminateBase
// (Native, Public)

void ADCCharacterLobbyCapture::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterLobbyCapture", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterLobbyCapture.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterLobbyCapture::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterLobbyCapture", "UnbindMsg");

	Params::DCCharacterLobbyCapture_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterLobbyCapture.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCCharacterLobbyCapture::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterLobbyCapture", "UnbindMsgAll");

	Params::DCCharacterLobbyCapture_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterLobbyCapture.GetPartyLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWidgetPartyUserLocate                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWidgetPartyUserLocate ADCCharacterLobbyCapture::GetPartyLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterLobbyCapture", "GetPartyLocation");

	Params::DCCharacterLobbyCapture_GetPartyLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.EventReceived
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftCastBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftCastBase", "EventReceived");

	Params::GA_PlayerShapeShiftCastBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnBlendOut
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftCastBase::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftCastBase", "OnBlendOut");

	Params::GA_PlayerShapeShiftCastBase_OnBlendOut Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnCancelled
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftCastBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftCastBase", "OnCancelled");

	Params::GA_PlayerShapeShiftCastBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnCastTriggerSync
// (Final, Native, Protected)

void UGA_PlayerShapeShiftCastBase::OnCastTriggerSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftCastBase", "OnCastTriggerSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnCompleted
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftCastBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftCastBase", "OnCompleted");

	Params::GA_PlayerShapeShiftCastBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnFinish
// (Final, Native, Protected)

void UGA_PlayerShapeShiftCastBase::OnFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftCastBase", "OnFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnInterrupted
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftCastBase::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftCastBase", "OnInterrupted");

	Params::GA_PlayerShapeShiftCastBase_OnInterrupted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.OnStartSync
// (Final, Native, Protected)

void UGA_PlayerShapeShiftCastBase::OnStartSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftCastBase", "OnStartSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftCastBase.SendActivateShapeShiftCrossHairNotify
// (Final, Native, Protected)
// Parameters:
// bool                                    IsActivate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftCastBase::SendActivateShapeShiftCrossHairNotify(bool IsActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftCastBase", "SendActivateShapeShiftCrossHairNotify");

	Params::GA_PlayerShapeShiftCastBase_SendActivateShapeShiftCrossHairNotify Parms{};

	Parms.IsActivate = IsActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterMovementComponent.AddMovementModifier
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDesignDataMovementModifier      MovementModifier                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDCCharacterMovementComponent::AddMovementModifier(const struct FDesignDataMovementModifier& MovementModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterMovementComponent", "AddMovementModifier");

	Params::DCCharacterMovementComponent_AddMovementModifier Parms{};

	Parms.MovementModifier = std::move(MovementModifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterMovementComponent.AddMovementModifiers
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FDesignDataMovementModifier>MovementModifiers                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCCharacterMovementComponent::AddMovementModifiers(const TArray<struct FDesignDataMovementModifier>& MovementModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterMovementComponent", "AddMovementModifiers");

	Params::DCCharacterMovementComponent_AddMovementModifiers Parms{};

	Parms.MovementModifiers = std::move(MovementModifiers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterMovementComponent.IsInputProcessing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCCharacterMovementComponent::IsInputProcessing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterMovementComponent", "IsInputProcessing");

	Params::DCCharacterMovementComponent_IsInputProcessing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterMovementComponent.RemoveMovementModifier
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDesignDataMovementModifier      MovementModifier                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDCCharacterMovementComponent::RemoveMovementModifier(const struct FDesignDataMovementModifier& MovementModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterMovementComponent", "RemoveMovementModifier");

	Params::DCCharacterMovementComponent_RemoveMovementModifier Parms{};

	Parms.MovementModifier = std::move(MovementModifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterMovementComponent.RemoveMovementModifiers
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FDesignDataMovementModifier>MovementModifiers                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCCharacterMovementComponent::RemoveMovementModifiers(const TArray<struct FDesignDataMovementModifier>& MovementModifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterMovementComponent", "RemoveMovementModifiers");

	Params::DCCharacterMovementComponent_RemoveMovementModifiers Parms{};

	Parms.MovementModifiers = std::move(MovementModifiers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterMovementComponent.SetInputProcessing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCharacterMovementComponent::SetInputProcessing(bool bSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterMovementComponent", "SetInputProcessing");

	Params::DCCharacterMovementComponent_SetInputProcessing Parms{};

	Parms.bSet = bSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterMovementComponent.SetIsTrapped
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    InbIsTrapped                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InTrapPinnedLocation                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTrapRange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCharacterMovementComponent::SetIsTrapped(bool InbIsTrapped, const struct FVector& InTrapPinnedLocation, float InTrapRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterMovementComponent", "SetIsTrapped");

	Params::DCCharacterMovementComponent_SetIsTrapped Parms{};

	Parms.InbIsTrapped = InbIsTrapped;
	Parms.InTrapPinnedLocation = std::move(InTrapPinnedLocation);
	Parms.InTrapRange = InTrapRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterMovementComponent.SetWindForce
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WindVector                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCharacterMovementComponent::SetWindForce(const struct FVector& WindVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterMovementComponent", "SetWindForce");

	Params::DCCharacterMovementComponent_SetWindForce Parms{};

	Parms.WindVector = std::move(WindVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterMovementComponent.IsAffectedByWindForce
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCCharacterMovementComponent::IsAffectedByWindForce() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterMovementComponent", "IsAffectedByWindForce");

	Params::DCCharacterMovementComponent_IsAffectedByWindForce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterProduction.OnItemEquip
// (Event, Public, BlueprintEvent)

void ADCCharacterProduction::OnItemEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterProduction", "OnItemEquip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCCharacterProduction.OnRep_ChangeHeadMesh
// (Final, Native, Private)

void ADCCharacterProduction::OnRep_ChangeHeadMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterProduction", "OnRep_ChangeHeadMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterProduction.OnRep_ItemDataList
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class FString>                   OldItemAssetIDList                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADCCharacterProduction::OnRep_ItemDataList(const TArray<class FString>& OldItemAssetIDList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterProduction", "OnRep_ItemDataList");

	Params::DCCharacterProduction_OnRep_ItemDataList Parms{};

	Parms.OldItemAssetIDList = std::move(OldItemAssetIDList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillBase.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "AbilityActivated");

	Params::GA_PlayerSkillBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayerSkillBase.ClientOnSkillActivate
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     SkillTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     CooldownTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::ClientOnSkillActivate(const struct FGameplayTag& SkillTag, const struct FGameplayTag& CooldownTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "ClientOnSkillActivate");

	Params::GA_PlayerSkillBase_ClientOnSkillActivate Parms{};

	Parms.SkillTag = std::move(SkillTag);
	Parms.CooldownTag = std::move(CooldownTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayerSkillBase.EventReceived
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "EventReceived");

	Params::GA_PlayerSkillBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillBase.OnBlendOut
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "OnBlendOut");

	Params::GA_PlayerSkillBase_OnBlendOut Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillBase.OnCancelled
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "OnCancelled");

	Params::GA_PlayerSkillBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillBase.OnCompleted
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "OnCompleted");

	Params::GA_PlayerSkillBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillBase.OnCooldownStarted
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     SkillTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     CooldownTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CooldownDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::OnCooldownStarted(const struct FGameplayTag& SkillTag, const struct FGameplayTag& CooldownTag, float CooldownDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "OnCooldownStarted");

	Params::GA_PlayerSkillBase_OnCooldownStarted Parms{};

	Parms.SkillTag = std::move(SkillTag);
	Parms.CooldownTag = std::move(CooldownTag);
	Parms.CooldownDuration = CooldownDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayerSkillBase.OnCooldownTagApplied
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      EffectHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewStackCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PreviousStackCount                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::OnCooldownTagApplied(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, int32 NewStackCount, int32 PreviousStackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "OnCooldownTagApplied");

	Params::GA_PlayerSkillBase_OnCooldownTagApplied Parms{};

	Parms.EffectGameplayTag = std::move(EffectGameplayTag);
	Parms.EffectHandle = std::move(EffectHandle);
	Parms.NewStackCount = NewStackCount;
	Parms.PreviousStackCount = PreviousStackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillBase.OnInterrupted
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "OnInterrupted");

	Params::GA_PlayerSkillBase_OnInterrupted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillBase.OnSkillActivateNotify
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::OnSkillActivateNotify(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "OnSkillActivateNotify");

	Params::GA_PlayerSkillBase_OnSkillActivateNotify Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillBase.ReceivedEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "ReceivedEvent");

	Params::GA_PlayerSkillBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillBase.ServerOnSkillActivate
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     SkillTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     CooldownTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::ServerOnSkillActivate(const struct FGameplayTag& SkillTag, const struct FGameplayTag& CooldownTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "ServerOnSkillActivate");

	Params::GA_PlayerSkillBase_ServerOnSkillActivate Parms{};

	Parms.SkillTag = std::move(SkillTag);
	Parms.CooldownTag = std::move(CooldownTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayerSkillBase.SetEquippedItemsHidden
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bShouldHide                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSkillBase::SetEquippedItemsHidden(bool bShouldHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "SetEquippedItemsHidden");

	Params::GA_PlayerSkillBase_SetEquippedItemsHidden Parms{};

	Parms.bShouldHide = bShouldHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillBase.GetCurrentDesignDataSkill
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDesignDataSkill           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FDesignDataSkill UGA_PlayerSkillBase::GetCurrentDesignDataSkill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "GetCurrentDesignDataSkill");

	Params::GA_PlayerSkillBase_GetCurrentDesignDataSkill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_PlayerSkillBase.GetRange
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGA_PlayerSkillBase::GetRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillBase", "GetRange");

	Params::GA_PlayerSkillBase_GetRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingFinish
// (Final, Native, Public)

void UGA_PlayerSkillCastBase::OnCastingFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillCastBase", "OnCastingFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingFinishSync
// (Final, Native, Public)

void UGA_PlayerSkillCastBase::OnCastingFinishSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillCastBase", "OnCastingFinishSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingStartSync
// (Final, Native, Public)

void UGA_PlayerSkillCastBase::OnCastingStartSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillCastBase", "OnCastingStartSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingStartTrigger
// (Event, Public, BlueprintEvent)

void UGA_PlayerSkillCastBase::OnCastingStartTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillCastBase", "OnCastingStartTrigger");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_PlayerSkillCastBase.OnVelocityChange
// (Final, Native, Public)

void UGA_PlayerSkillCastBase::OnVelocityChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillCastBase", "OnVelocityChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameTooltipWithFlavorTextWidget.GetDescriptionVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCGameTooltipWithFlavorTextWidget::GetDescriptionVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameTooltipWithFlavorTextWidget", "GetDescriptionVisibility");

	Params::DCGameTooltipWithFlavorTextWidget_GetDescriptionVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCharacterSkinComponent.OnRep_Data
// (Final, Native, Protected)
// Parameters:
// class UDCCharacterSkinDataAsset*        OldData                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCharacterSkinComponent::OnRep_Data(const class UDCCharacterSkinDataAsset* OldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterSkinComponent", "OnRep_Data");

	Params::DCCharacterSkinComponent_OnRep_Data Parms{};

	Parms.OldData = OldData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterSkinComponent.SetDataForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UDCCharacterSkinDataAsset*        InData                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCharacterSkinComponent::SetDataForDebug_Server(const class UDCCharacterSkinDataAsset* InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterSkinComponent", "SetDataForDebug_Server");

	Params::DCCharacterSkinComponent_SetDataForDebug_Server Parms{};

	Parms.InData = InData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillRouterBase.OnRoutedAbilityEnded
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FAbilityEndedData                AbilityEndedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGA_PlayerSkillRouterBase::OnRoutedAbilityEnded(const struct FAbilityEndedData& AbilityEndedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillRouterBase", "OnRoutedAbilityEnded");

	Params::GA_PlayerSkillRouterBase_OnRoutedAbilityEnded Parms{};

	Parms.AbilityEndedData = std::move(AbilityEndedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCharacterSkinWidget.GetTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCCharacterSkinWidget::GetTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterSkinWidget", "GetTooltipWidget");

	Params::DCCharacterSkinWidget_GetTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameSpawner.OnSetMonsterPeaceAction
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADCMonsterBase*                   Monster                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameSpawner::OnSetMonsterPeaceAction(class ADCMonsterBase* Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSpawner", "OnSetMonsterPeaceAction");

	Params::DCGameSpawner_OnSetMonsterPeaceAction Parms{};

	Parms.Monster = Monster;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCGameSpawner.SetNextPreview
// (Final, Native, Protected)

void ADCGameSpawner::SetNextPreview()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSpawner", "SetNextPreview");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameSpawner.SpawnItemHolder
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InLootDropId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  InLootDropRateId                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInPreview                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemHolderActorBase*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemHolderActorBase* ADCGameSpawner::SpawnItemHolder(const struct FPrimaryAssetId& InLootDropId, const struct FPrimaryAssetId& InLootDropRateId, bool bInPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSpawner", "SpawnItemHolder");

	Params::DCGameSpawner_SpawnItemHolder Parms{};

	Parms.InLootDropId = std::move(InLootDropId);
	Parms.InLootDropRateId = std::move(InLootDropRateId);
	Parms.bInPreview = bInPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameSpawner.SpawnMonster
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InMonsterId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 Summoner                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInPreview                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCMonsterBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCMonsterBase* ADCGameSpawner::SpawnMonster(const struct FPrimaryAssetId& InMonsterId, class ADCCharacterBase* Summoner, bool bInPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSpawner", "SpawnMonster");

	Params::DCGameSpawner_SpawnMonster Parms{};

	Parms.InMonsterId = std::move(InMonsterId);
	Parms.Summoner = Summoner;
	Parms.bInPreview = bInPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameSpawner.SpawnObjectBlueprint
// (Final, Native, Protected, BlueprintCallable)

void ADCGameSpawner::SpawnObjectBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSpawner", "SpawnObjectBlueprint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameSpawner.SpawnProps
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InPropsId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInPreview                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APropsActorBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APropsActorBase* ADCGameSpawner::SpawnProps(const struct FPrimaryAssetId& InPropsId, bool bInPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSpawner", "SpawnProps");

	Params::DCGameSpawner_SpawnProps Parms{};

	Parms.InPropsId = std::move(InPropsId);
	Parms.bInPreview = bInPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameSpawner.UpdateGameState
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameStateData                   InGameStateData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADCGameSpawner::UpdateGameState(const struct FGameStateData& InGameStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSpawner", "UpdateGameState");

	Params::DCGameSpawner_UpdateGameState Parms{};

	Parms.InGameStateData = std::move(InGameStateData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCCharacterSkinListEntryWidget.OnRightClicked
// (Native, Public)

void UDCCharacterSkinListEntryWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCharacterSkinListEntryWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameSpellCurrentSlotWidget.OnSetSpellArtData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UArtDataSpell*                    InArtSpellData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSpellCurrentSlotWidget::OnSetSpellArtData(const class UArtDataSpell* InArtSpellData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellCurrentSlotWidget", "OnSetSpellArtData");

	Params::GameSpellCurrentSlotWidget_OnSetSpellArtData Parms{};

	Parms.InArtSpellData = InArtSpellData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameSpellCurrentSlotWidget.OnSpellDataChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSpellData                       InSpellData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDesignDataSpell                 InDesignDataSpell                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameSpellCurrentSlotWidget::OnSpellDataChanged(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellCurrentSlotWidget", "OnSpellDataChanged");

	Params::GameSpellCurrentSlotWidget_OnSpellDataChanged Parms{};

	Parms.InSpellData = std::move(InSpellData);
	Parms.InDesignDataSpell = std::move(InDesignDataSpell);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameSpellCurrentSlotWidget.SetSpellData
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FSpellData                       InSpellData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDesignDataSpell                 InDesignDataSpell                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameSpellCurrentSlotWidget::SetSpellData(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellCurrentSlotWidget", "SetSpellData");

	Params::GameSpellCurrentSlotWidget_SetSpellData Parms{};

	Parms.InSpellData = std::move(InSpellData);
	Parms.InDesignDataSpell = std::move(InDesignDataSpell);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCChildActorComponent.SpawnChildActor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bIsPreview                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APropsActorBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APropsActorBase* UDCChildActorComponent::SpawnChildActor(bool bIsPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCChildActorComponent", "SpawnChildActor");

	Params::DCChildActorComponent_SpawnChildActor Parms{};

	Parms.bIsPreview = bIsPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameTestComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameTestComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "BroadcastMsgBlueprint");

	Params::GameTestComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassItemMoveRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassItemMoveRequest InMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassItemMoveRequest(const struct FMsgGameTestClassItemMoveRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassItemMoveRequest");

	Params::GameTestComponent_ClientMsgClassItemMoveRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassItemMoveResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassItemMoveResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassItemMoveResponse(const struct FMsgGameTestClassItemMoveResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassItemMoveResponse");

	Params::GameTestComponent_ClientMsgClassItemMoveResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassLevelInfoRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassLevelInfoRequestInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassLevelInfoRequest(const struct FMsgGameTestClassLevelInfoRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassLevelInfoRequest");

	Params::GameTestComponent_ClientMsgClassLevelInfoRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassLevelInfoResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassLevelInfoResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassLevelInfoResponse(const struct FMsgGameTestClassLevelInfoResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassLevelInfoResponse");

	Params::GameTestComponent_ClientMsgClassLevelInfoResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassMusicListRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassMusicListRequestInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassMusicListRequest(const struct FMsgGameTestClassMusicListRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassMusicListRequest");

	Params::GameTestComponent_ClientMsgClassMusicListRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassMusicListResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassMusicListResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassMusicListResponse(const struct FMsgGameTestClassMusicListResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassMusicListResponse");

	Params::GameTestComponent_ClientMsgClassMusicListResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassMusicSlotMoveRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassMusicSlotMoveRequestInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassMusicSlotMoveRequest(const struct FMsgGameTestClassMusicSlotMoveRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassMusicSlotMoveRequest");

	Params::GameTestComponent_ClientMsgClassMusicSlotMoveRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassMusicSlotMoveResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassMusicSlotMoveResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassMusicSlotMoveResponse(const struct FMsgGameTestClassMusicSlotMoveResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassMusicSlotMoveResponse");

	Params::GameTestComponent_ClientMsgClassMusicSlotMoveResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassPerkListRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassPerkListRequest InMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassPerkListRequest(const struct FMsgGameTestClassPerkListRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassPerkListRequest");

	Params::GameTestComponent_ClientMsgClassPerkListRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassPerkListResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassPerkListResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassPerkListResponse(const struct FMsgGameTestClassPerkListResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassPerkListResponse");

	Params::GameTestComponent_ClientMsgClassPerkListResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassShapeShiftListRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassShapeShiftListRequestInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassShapeShiftListRequest(const struct FMsgGameTestClassShapeShiftListRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassShapeShiftListRequest");

	Params::GameTestComponent_ClientMsgClassShapeShiftListRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassShapeShiftListResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassShapeShiftListResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassShapeShiftListResponse(const struct FMsgGameTestClassShapeShiftListResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassShapeShiftListResponse");

	Params::GameTestComponent_ClientMsgClassShapeShiftListResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassShapeShiftSlotMoveRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassShapeShiftSlotMoveRequestInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassShapeShiftSlotMoveRequest(const struct FMsgGameTestClassShapeShiftSlotMoveRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassShapeShiftSlotMoveRequest");

	Params::GameTestComponent_ClientMsgClassShapeShiftSlotMoveRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassShapeShiftSlotMoveResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassShapeShiftSlotMoveResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassShapeShiftSlotMoveResponse(const struct FMsgGameTestClassShapeShiftSlotMoveResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassShapeShiftSlotMoveResponse");

	Params::GameTestComponent_ClientMsgClassShapeShiftSlotMoveResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassSkillListRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassSkillListRequestInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassSkillListRequest(const struct FMsgGameTestClassSkillListRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassSkillListRequest");

	Params::GameTestComponent_ClientMsgClassSkillListRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassSkillListResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassSkillListResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassSkillListResponse(const struct FMsgGameTestClassSkillListResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassSkillListResponse");

	Params::GameTestComponent_ClientMsgClassSkillListResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellListRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassSpellListRequestInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassSpellListRequest(const struct FMsgGameTestClassSpellListRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassSpellListRequest");

	Params::GameTestComponent_ClientMsgClassSpellListRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellListResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassSpellListResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassSpellListResponse(const struct FMsgGameTestClassSpellListResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassSpellListResponse");

	Params::GameTestComponent_ClientMsgClassSpellListResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSequenceChangeRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassSpellSequenceChangeRequestInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassSpellSequenceChangeRequest(const struct FMsgGameTestClassSpellSequenceChangeRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassSpellSequenceChangeRequest");

	Params::GameTestComponent_ClientMsgClassSpellSequenceChangeRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSequenceChangeResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassSpellSequenceChangeResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassSpellSequenceChangeResponse(const struct FMsgGameTestClassSpellSequenceChangeResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassSpellSequenceChangeResponse");

	Params::GameTestComponent_ClientMsgClassSpellSequenceChangeResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSlotMoveRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestClassSpellSlotMoveRequestInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassSpellSlotMoveRequest(const struct FMsgGameTestClassSpellSlotMoveRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassSpellSlotMoveRequest");

	Params::GameTestComponent_ClientMsgClassSpellSlotMoveRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSlotMoveResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestClassSpellSlotMoveResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientMsgClassSpellSlotMoveResponse(const struct FMsgGameTestClassSpellSlotMoveResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientMsgClassSpellSlotMoveResponse");

	Params::GameTestComponent_ClientMsgClassSpellSlotMoveResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientOnUpdateSkillList
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// TArray<struct FPrimaryAssetId>          InSkillIdArray                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientOnUpdateSkillList(const TArray<struct FPrimaryAssetId>& InSkillIdArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientOnUpdateSkillList");

	Params::GameTestComponent_ClientOnUpdateSkillList Parms{};

	Parms.InSkillIdArray = std::move(InSkillIdArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientResReceiveTrainingClassAbility
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UGameTestComponent::ClientResReceiveTrainingClassAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientResReceiveTrainingClassAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientResReceiveTraningReward
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UGameTestComponent::ClientResReceiveTraningReward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientResReceiveTraningReward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientResRedeemLearningToken
// (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient)
// Parameters:
// struct FPrimaryAssetId                  MasterClassId                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          InClassAbilityOptions                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientResRedeemLearningToken(const struct FPrimaryAssetId& MasterClassId, const TArray<struct FPrimaryAssetId>& InClassAbilityOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientResRedeemLearningToken");

	Params::GameTestComponent_ClientResRedeemLearningToken Parms{};

	Parms.MasterClassId = std::move(MasterClassId);
	Parms.InClassAbilityOptions = std::move(InClassAbilityOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientResRedeemRewardToken
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// TArray<struct FPrimaryAssetId>          InRewardOptions                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientResRedeemRewardToken(const TArray<struct FPrimaryAssetId>& InRewardOptions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientResRedeemRewardToken");

	Params::GameTestComponent_ClientResRedeemRewardToken Parms{};

	Parms.InRewardOptions = std::move(InRewardOptions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ClientResTrainingInfo
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FDCGameTestClassTrainingInfo     InTrainingInfo                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ClientResTrainingInfo(const struct FDCGameTestClassTrainingInfo& InTrainingInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ClientResTrainingInfo");

	Params::GameTestComponent_ClientResTrainingInfo Parms{};

	Parms.InTrainingInfo = std::move(InTrainingInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.MsgGameTestChangePlayerCharacterClassRequest
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FMsgGameTestChangePlayerCharacterClassRequestInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::MsgGameTestChangePlayerCharacterClassRequest(const struct FMsgGameTestChangePlayerCharacterClassRequest& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "MsgGameTestChangePlayerCharacterClassRequest");

	Params::GameTestComponent_MsgGameTestChangePlayerCharacterClassRequest Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.MsgGameTestChangePlayerCharacterClassResponse
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameTestChangePlayerCharacterClassResponseInMsg                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::MsgGameTestChangePlayerCharacterClassResponse(const struct FMsgGameTestChangePlayerCharacterClassResponse& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "MsgGameTestChangePlayerCharacterClassResponse");

	Params::GameTestComponent_MsgGameTestChangePlayerCharacterClassResponse Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ServerReqReceiveTrainingClassAbility
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// struct FPrimaryAssetId                  InClassAbilityId                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameTestComponent::ServerReqReceiveTrainingClassAbility(const struct FPrimaryAssetId& InClassAbilityId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ServerReqReceiveTrainingClassAbility");

	Params::GameTestComponent_ServerReqReceiveTrainingClassAbility Parms{};

	Parms.InClassAbilityId = std::move(InClassAbilityId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ServerReqReceiveTraningReward
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UGameTestComponent::ServerReqReceiveTraningReward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ServerReqReceiveTraningReward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ServerReqRedeemLearningToken
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FDCTrainingCharacterInfo         InMasterCharacter                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameTestComponent::ServerReqRedeemLearningToken(const struct FDCTrainingCharacterInfo& InMasterCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ServerReqRedeemLearningToken");

	Params::GameTestComponent_ServerReqRedeemLearningToken Parms{};

	Parms.InMasterCharacter = std::move(InMasterCharacter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ServerReqRedeemRewardToken
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UGameTestComponent::ServerReqRedeemRewardToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ServerReqRedeemRewardToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.ServerReqTrainingInfo
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UGameTestComponent::ServerReqTrainingInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "ServerReqTrainingInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.TerminateBase
// (Native, Public)

void UGameTestComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameTestComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "UnbindMsg");

	Params::GameTestComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameTestComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameTestComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTestComponent", "UnbindMsgAll");

	Params::GameTestComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommonButtonOptionLinkWidget.OnClickEOptionLinkButton
// (Final, Native, Protected, BlueprintCallable)

void UDCCommonButtonOptionLinkWidget::OnClickEOptionLinkButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommonButtonOptionLinkWidget", "OnClickEOptionLinkButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ActivateItemSpecialBase.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_ActivateItemSpecialBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ActivateItemSpecialBase", "AbilityActivated");

	Params::GA_ActivateItemSpecialBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ActivateItemSpecialBase.OnItemSpecialEnded
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FAbilityEndedData                AbilityEndedData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGA_ActivateItemSpecialBase::OnItemSpecialEnded(const struct FAbilityEndedData& AbilityEndedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ActivateItemSpecialBase", "OnItemSpecialEnded");

	Params::GA_ActivateItemSpecialBase_OnItemSpecialEnded Parms{};

	Parms.AbilityEndedData = std::move(AbilityEndedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TopTitleWidgetBase.SetLeftButtonText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             ButtonText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTopTitleWidgetBase::SetLeftButtonText(const class FText& ButtonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TopTitleWidgetBase", "SetLeftButtonText");

	Params::TopTitleWidgetBase_SetLeftButtonText Parms{};

	Parms.ButtonText = std::move(ButtonText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TopTitleWidgetBase.SetRightButtonText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             ButtonText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTopTitleWidgetBase::SetRightButtonText(const class FText& ButtonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TopTitleWidgetBase", "SetRightButtonText");

	Params::TopTitleWidgetBase_SetRightButtonText Parms{};

	Parms.ButtonText = std::move(ButtonText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TopTitleWidgetBase.SetTitleText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             TitleText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTopTitleWidgetBase::SetTitleText(const class FText& TitleText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TopTitleWidgetBase", "SetTitleText");

	Params::TopTitleWidgetBase_SetTitleText Parms{};

	Parms.TitleText = std::move(TitleText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGhostTrailActor.BeginGhostTrailEffect
// (Final, Native, Public, BlueprintCallable)

void ADCGhostTrailActor::BeginGhostTrailEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGhostTrailActor", "BeginGhostTrailEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGhostTrailActor.HandleTimelineFinished
// (Final, Native, Protected)

void ADCGhostTrailActor::HandleTimelineFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGhostTrailActor", "HandleTimelineFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGhostTrailActor.HandleTimelineUpdate
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGhostTrailActor::HandleTimelineUpdate(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGhostTrailActor", "HandleTimelineUpdate");

	Params::DCGhostTrailActor_HandleTimelineUpdate Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGhostTrailActor.SetGhostMaterial
// (Final, Native, Protected)
// Parameters:
// TArray<class UMeshComponent*>           Components                                             (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADCGhostTrailActor::SetGhostMaterial(const TArray<class UMeshComponent*>& Components)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGhostTrailActor", "SetGhostMaterial");

	Params::DCGhostTrailActor_SetGhostMaterial Parms{};

	Parms.Components = std::move(Components);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommunityBlockEntryWidget.CleanupContextMenuWidget
// (Final, Native, Private)

void UDCCommunityBlockEntryWidget::CleanupContextMenuWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommunityBlockEntryWidget", "CleanupContextMenuWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommunityBlockEntryWidget.ExecuteContextMenu
// (Final, Native, Private)
// Parameters:
// EContextOptionType                      Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommunityBlockEntryWidget::ExecuteContextMenu(EContextOptionType Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommunityBlockEntryWidget", "ExecuteContextMenu");

	Params::DCCommunityBlockEntryWidget_ExecuteContextMenu Parms{};

	Parms.Option = Option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommunityBlockWidget.FindId
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             FindText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCCommunityBlockWidget::FindId(const class FText& FindText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommunityBlockWidget", "FindId");

	Params::DCCommunityBlockWidget_FindId Parms{};

	Parms.FindText = std::move(FindText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommunityBlockWidget.OnBlockUpdated
// (Final, Native, Private)

void UDCCommunityBlockWidget::OnBlockUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommunityBlockWidget", "OnBlockUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommunityBlockWidget.OnButtonBack
// (Final, Native, Private)

void UDCCommunityBlockWidget::OnButtonBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommunityBlockWidget", "OnButtonBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommunityBlockWidget.OnButtonPageLeft
// (Final, Native, Private)

void UDCCommunityBlockWidget::OnButtonPageLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommunityBlockWidget", "OnButtonPageLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommunityBlockWidget.OnButtonPageRight
// (Final, Native, Private)

void UDCCommunityBlockWidget::OnButtonPageRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommunityBlockWidget", "OnButtonPageRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCommunityBlockWidget.GetMaxPage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCCommunityBlockWidget::GetMaxPage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommunityBlockWidget", "GetMaxPage");

	Params::DCCommunityBlockWidget_GetMaxPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCommunityBlockWidget.NumItemsPerPage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCCommunityBlockWidget::NumItemsPerPage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommunityBlockWidget", "NumItemsPerPage");

	Params::DCCommunityBlockWidget_NumItemsPerPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCommunityBlockWidget.OnEntryHovered
// (Final, Native, Private, Const)
// Parameters:
// class UObject*                          WidgetData                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsHovered                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCommunityBlockWidget::OnEntryHovered(class UObject* WidgetData, bool bIsHovered) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCommunityBlockWidget", "OnEntryHovered");

	Params::DCCommunityBlockWidget_OnEntryHovered Parms{};

	Parms.WidgetData = WidgetData;
	Parms.bIsHovered = bIsHovered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ChargedRangedAttackBase.InputActionCompleted
// (Final, Native, Protected)

void UGA_ChargedRangedAttackBase::InputActionCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ChargedRangedAttackBase", "InputActionCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ChargedRangedAttackBase.InputActionStarted
// (Final, Native, Protected)

void UGA_ChargedRangedAttackBase::InputActionStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ChargedRangedAttackBase", "InputActionStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ChargedRangedAttackBase.SendPlayShootCrossHairNotify
// (Final, Native, Protected)

void UGA_ChargedRangedAttackBase::SendPlayShootCrossHairNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ChargedRangedAttackBase", "SendPlayShootCrossHairNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCContextComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCContextComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCContextComponent", "BroadcastMsgBlueprint");

	Params::DCContextComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCContextComponent.OnContextMenuHolderVisibilityChaned
// (Final, Native, Private)
// Parameters:
// ESlateVisibility                        Visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCContextComponent::OnContextMenuHolderVisibilityChaned(ESlateVisibility Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCContextComponent", "OnContextMenuHolderVisibilityChaned");

	Params::DCContextComponent_OnContextMenuHolderVisibilityChaned Parms{};

	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCContextComponent.TerminateBase
// (Native, Public)

void UDCContextComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCContextComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCContextComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCContextComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCContextComponent", "UnbindMsg");

	Params::DCContextComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCContextComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCContextComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCContextComponent", "UnbindMsgAll");

	Params::DCContextComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionComboBoxWidget.AddComboBox
// (Final, Native, Public)
// Parameters:
// class FString                           InComboBoxData                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionComboBoxWidget::AddComboBox(const class FString& InComboBoxData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionComboBoxWidget", "AddComboBox");

	Params::GameMenuOptionComboBoxWidget_AddComboBox Parms{};

	Parms.InComboBoxData = std::move(InComboBoxData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionComboBoxWidget.ClearComboBox
// (Final, Native, Public)

void UGameMenuOptionComboBoxWidget::ClearComboBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionComboBoxWidget", "ClearComboBox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionComboBoxWidget.GetPrimaryGamepadFocusWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UGameMenuOptionComboBoxWidget::GetPrimaryGamepadFocusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionComboBoxWidget", "GetPrimaryGamepadFocusWidget");

	Params::GameMenuOptionComboBoxWidget_GetPrimaryGamepadFocusWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionComboBoxWidget.GetSelectedComboBoxIndex
// (Final, Native, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameMenuOptionComboBoxWidget::GetSelectedComboBoxIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionComboBoxWidget", "GetSelectedComboBoxIndex");

	Params::GameMenuOptionComboBoxWidget_GetSelectedComboBoxIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionComboBoxWidget.GetSelectedComboBoxText
// (Final, Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameMenuOptionComboBoxWidget::GetSelectedComboBoxText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionComboBoxWidget", "GetSelectedComboBoxText");

	Params::GameMenuOptionComboBoxWidget_GetSelectedComboBoxText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetComboBoxIndex
// (Final, Native, Public)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionComboBoxWidget::SetComboBoxIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionComboBoxWidget", "SetComboBoxIndex");

	Params::GameMenuOptionComboBoxWidget_SetComboBoxIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetComboBoxList
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<class FString>                   InComboBoxDataList                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGameMenuOptionComboBoxWidget::SetComboBoxList(const TArray<class FString>& InComboBoxDataList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionComboBoxWidget", "SetComboBoxList");

	Params::GameMenuOptionComboBoxWidget_SetComboBoxList Parms{};

	Parms.InComboBoxDataList = std::move(InComboBoxDataList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetSelectedOption
// (Final, Native, Public)
// Parameters:
// class FString                           Option                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionComboBoxWidget::SetSelectedOption(const class FString& Option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionComboBoxWidget", "SetSelectedOption");

	Params::GameMenuOptionComboBoxWidget_SetSelectedOption Parms{};

	Parms.Option = std::move(Option);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetTitle
// (Final, Native, Public)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UGameMenuOptionComboBoxWidget::SetTitle(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionComboBoxWidget", "SetTitle");

	Params::GameMenuOptionComboBoxWidget_SetTitle Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCContextMenuEntryWidget.Execute
// (Final, Native, Protected, BlueprintCallable)

void UDCContextMenuEntryWidget::Execute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCContextMenuEntryWidget", "Execute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCountButtonWidget.SetCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCountButtonWidget::SetCount(int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCountButtonWidget", "SetCount");

	Params::DCCountButtonWidget_SetCount Parms{};

	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnCancelButtonClicked
// (Final, Native, Private)

void UDCCrossPlatformLinkPopup::OnCancelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCrossPlatformLinkPopup", "OnCancelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnCheckBoxStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bIsChecked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCrossPlatformLinkPopup::OnCheckBoxStateChanged(bool bIsChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCrossPlatformLinkPopup", "OnCheckBoxStateChanged");

	Params::DCCrossPlatformLinkPopup_OnCheckBoxStateChanged Parms{};

	Parms.bIsChecked = bIsChecked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnClearCodeButtonClicked
// (Final, Native, Private)

void UDCCrossPlatformLinkPopup::OnClearCodeButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCrossPlatformLinkPopup", "OnClearCodeButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnClearLinkCode
// (Event, Protected, BlueprintEvent)

void UDCCrossPlatformLinkPopup::OnClearLinkCode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCrossPlatformLinkPopup", "OnClearLinkCode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnLinkAccountButtonClicked
// (Final, Native, Private)

void UDCCrossPlatformLinkPopup::OnLinkAccountButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCrossPlatformLinkPopup", "OnLinkAccountButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnOkButtonClicked
// (Final, Native, Private)

void UDCCrossPlatformLinkPopup::OnOkButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCrossPlatformLinkPopup", "OnOkButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDCCrossPlatfromLinkPopupState          InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCrossPlatformLinkPopup::OnStateChanged(EDCCrossPlatfromLinkPopupState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCrossPlatformLinkPopup", "OnStateChanged");

	Params::DCCrossPlatformLinkPopup_OnStateChanged Parms{};

	Parms.InState = InState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnTextChangedLickCode
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InLinkCode                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCCrossPlatformLinkPopup::OnTextChangedLickCode(const class FText& InLinkCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCrossPlatformLinkPopup", "OnTextChangedLickCode");

	Params::DCCrossPlatformLinkPopup_OnTextChangedLickCode Parms{};

	Parms.InLinkCode = std::move(InLinkCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCrossPlatformLinkPopup.OnTryLink
// (Event, Protected, BlueprintEvent)

void UDCCrossPlatformLinkPopup::OnTryLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCrossPlatformLinkPopup", "OnTryLink");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCHitBoxComponent.GetClosestLocationOnMesh
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                       InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDCHitBoxComponent::GetClosestLocationOnMesh(const struct FHitResult& InHitResult, const class AActor* Instigator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCHitBoxComponent", "GetClosestLocationOnMesh");

	Params::DCHitBoxComponent_GetClosestLocationOnMesh Parms{};

	Parms.InHitResult = std::move(InHitResult);
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCHitBoxComponent.GetHitDirection
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          AttackerLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitDirection                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHitDirection UDCHitBoxComponent::GetHitDirection(const struct FVector& AttackerLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCHitBoxComponent", "GetHitDirection");

	Params::DCHitBoxComponent_GetHitDirection Parms{};

	Parms.AttackerLocation = std::move(AttackerLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCHitBoxComponent.GetHitResultFromClosestLocationTraceOnMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                       InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UDCHitBoxComponent::GetHitResultFromClosestLocationTraceOnMesh(const struct FHitResult& InHitResult, const class AActor* Instigator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCHitBoxComponent", "GetHitResultFromClosestLocationTraceOnMesh");

	Params::DCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh Parms{};

	Parms.InHitResult = std::move(InHitResult);
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCustomizeActionSkinListWidget.OnSetActionSkinInfoArray
// (Final, Native, Protected)
// Parameters:
// TArray<struct FDCActionSkinInfo>        ActionSkinInfoArray                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCCustomizeActionSkinListWidget::OnSetActionSkinInfoArray(const TArray<struct FDCActionSkinInfo>& ActionSkinInfoArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeActionSkinListWidget", "OnSetActionSkinInfoArray");

	Params::DCCustomizeActionSkinListWidget_OnSetActionSkinInfoArray Parms{};

	Parms.ActionSkinInfoArray = std::move(ActionSkinInfoArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInGameQuestLogDealTableWidget.OnQuestInfoUpdated
// (Event, Protected, BlueprintEvent)

void UDCInGameQuestLogDealTableWidget::OnQuestInfoUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInGameQuestLogDealTableWidget", "OnQuestInfoUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCInGameQuestLogDealTableWidget.GetQuestState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCQuestState                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCQuestState UDCInGameQuestLogDealTableWidget::GetQuestState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInGameQuestLogDealTableWidget", "GetQuestState");

	Params::DCInGameQuestLogDealTableWidget_GetQuestState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCustomizeCharacterSkinListWidget.OnSetCharacterSkinInfoArray
// (Final, Native, Protected)
// Parameters:
// TArray<struct FDCCharacterSkinInfo>     CharacterSkinInfoArray                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCCustomizeCharacterSkinListWidget::OnSetCharacterSkinInfoArray(const TArray<struct FDCCharacterSkinInfo>& CharacterSkinInfoArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeCharacterSkinListWidget", "OnSetCharacterSkinInfoArray");

	Params::DCCustomizeCharacterSkinListWidget_OnSetCharacterSkinInfoArray Parms{};

	Parms.CharacterSkinInfoArray = std::move(CharacterSkinInfoArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCustomizeEmoteListWidget.OnSetEmoteIdArray
// (Final, Native, Protected)
// Parameters:
// TArray<struct FDCEmoteInfo>             EmoteIdArray                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCCustomizeEmoteListWidget::OnSetEmoteIdArray(const TArray<struct FDCEmoteInfo>& EmoteIdArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeEmoteListWidget", "OnSetEmoteIdArray");

	Params::DCCustomizeEmoteListWidget_OnSetEmoteIdArray Parms{};

	Parms.EmoteIdArray = std::move(EmoteIdArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCustomizeItemSkinListWidget.OnChangedVisibility
// (Final, Native, Private)
// Parameters:
// ESlateVisibility                        InNewVisibility                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCustomizeItemSkinListWidget::OnChangedVisibility(ESlateVisibility InNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeItemSkinListWidget", "OnChangedVisibility");

	Params::DCCustomizeItemSkinListWidget_OnChangedVisibility Parms{};

	Parms.InNewVisibility = InNewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCustomizeItemSkinListWidget.OnSetItemSkinInfoArray
// (Final, Native, Protected)
// Parameters:
// TArray<struct FDCItemSkinInfo>          ItemSkinInfoArray                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCCustomizeItemSkinListWidget::OnSetItemSkinInfoArray(const TArray<struct FDCItemSkinInfo>& ItemSkinInfoArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeItemSkinListWidget", "OnSetItemSkinInfoArray");

	Params::DCCustomizeItemSkinListWidget_OnSetItemSkinInfoArray Parms{};

	Parms.ItemSkinInfoArray = std::move(ItemSkinInfoArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCIngameInventoryPageWidget.IsUnderDropArea
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector2D                        ScreenSpacePosition                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCIngameInventoryPageWidget::IsUnderDropArea(const struct FVector2D& ScreenSpacePosition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCIngameInventoryPageWidget", "IsUnderDropArea");

	Params::DCIngameInventoryPageWidget_IsUnderDropArea Parms{};

	Parms.ScreenSpacePosition = std::move(ScreenSpacePosition);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCustomizeLobbyEmoteListWidget.OnSetLobbyEmoteIdArray
// (Final, Native, Protected)
// Parameters:
// TArray<struct FDCLobbyEmoteInfo>        LobbyEmoteIdArray                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCCustomizeLobbyEmoteListWidget::OnSetLobbyEmoteIdArray(const TArray<struct FDCLobbyEmoteInfo>& LobbyEmoteIdArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeLobbyEmoteListWidget", "OnSetLobbyEmoteIdArray");

	Params::DCCustomizeLobbyEmoteListWidget_OnSetLobbyEmoteIdArray Parms{};

	Parms.LobbyEmoteIdArray = std::move(LobbyEmoteIdArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCustomizeRadialSlotWidget.GetArrowVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCCustomizeRadialSlotWidget::GetArrowVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeRadialSlotWidget", "GetArrowVisibility");

	Params::DCCustomizeRadialSlotWidget_GetArrowVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCustomizeRadialSlotWidget.GetHighlightVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCCustomizeRadialSlotWidget::GetHighlightVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeRadialSlotWidget", "GetHighlightVisibility");

	Params::DCCustomizeRadialSlotWidget_GetHighlightVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCustomizeRadialSlotWidget.GetTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCCustomizeRadialSlotWidget::GetTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeRadialSlotWidget", "GetTooltipWidget");

	Params::DCCustomizeRadialSlotWidget_GetTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCustomizeRadialSlotWidget.OnPlayItemDropSound
// (Event, Protected, BlueprintEvent)

void UDCCustomizeRadialSlotWidget::OnPlayItemDropSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeRadialSlotWidget", "OnPlayItemDropSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCCustomizeRadialSlotWidget.SetIconImageAngle
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCustomizeRadialSlotWidget::SetIconImageAngle(float NewAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeRadialSlotWidget", "SetIconImageAngle");

	Params::DCCustomizeRadialSlotWidget_SetIconImageAngle Parms{};

	Parms.NewAngle = NewAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCCustomizeRadialSlotWidget.IsIconVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCCustomizeRadialSlotWidget::IsIconVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeRadialSlotWidget", "IsIconVisible");

	Params::DCCustomizeRadialSlotWidget_IsIconVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCustomizeRadialSlotWidget.IsPrewiewVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCCustomizeRadialSlotWidget::IsPrewiewVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeRadialSlotWidget", "IsPrewiewVisible");

	Params::DCCustomizeRadialSlotWidget_IsPrewiewVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCustomizeWidgetBase.AnyTabButtonSelected
// (Final, Native, Private)
// Parameters:
// class FName                             InTabButtonId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCustomizeWidgetBase::AnyTabButtonSelected(class FName InTabButtonId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeWidgetBase", "AnyTabButtonSelected");

	Params::DCCustomizeWidgetBase_AnyTabButtonSelected Parms{};

	Parms.InTabButtonId = InTabButtonId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCustomizeWidgetBase.IsCustomizeFirstPage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCCustomizeWidgetBase::IsCustomizeFirstPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeWidgetBase", "IsCustomizeFirstPage");

	Params::DCCustomizeWidgetBase_IsCustomizeFirstPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCustomizeWidgetBase.IsCustomizeLastPage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCCustomizeWidgetBase::IsCustomizeLastPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeWidgetBase", "IsCustomizeLastPage");

	Params::DCCustomizeWidgetBase_IsCustomizeLastPage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCCustomizeWidgetBase.OnCustomizeNextPage
// (Final, Native, Protected)

void UDCCustomizeWidgetBase::OnCustomizeNextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeWidgetBase", "OnCustomizeNextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCustomizeWidgetBase.OnCustomizePrevPage
// (Final, Native, Protected)

void UDCCustomizeWidgetBase::OnCustomizePrevPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeWidgetBase", "OnCustomizePrevPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCustomizeWidgetBase.OnCustomizeWidgetClose
// (Final, Native, Protected, BlueprintCallable)

void UDCCustomizeWidgetBase::OnCustomizeWidgetClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeWidgetBase", "OnCustomizeWidgetClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCustomizeWidgetBase.OnCustomizeWidgetOpen
// (Final, Native, Protected, BlueprintCallable)

void UDCCustomizeWidgetBase::OnCustomizeWidgetOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeWidgetBase", "OnCustomizeWidgetOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCCustomizeWidgetBase.UpdateCustomizeMaxPageIndex
// (Final, Native, Protected)
// Parameters:
// class FName                             InTabButtonId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCCustomizeWidgetBase::UpdateCustomizeMaxPageIndex(class FName InTabButtonId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCCustomizeWidgetBase", "UpdateCustomizeMaxPageIndex");

	Params::DCCustomizeWidgetBase_UpdateCustomizeMaxPageIndex Parms{};

	Parms.InTabButtonId = InTabButtonId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.AccountIdToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCAccountId                     Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDCDataBlueprintLibrary::AccountIdToString(const struct FDCAccountId& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "AccountIdToString");

	Params::DCDataBlueprintLibrary_AccountIdToString Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.CanAddStack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCItemInfo                      ItemInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stack                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::CanAddStack(const struct FDCItemInfo& ItemInfo, int32 Stack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "CanAddStack");

	Params::DCDataBlueprintLibrary_CanAddStack Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.Stack = Stack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.FindActorFromActorClassList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AActor>>       InActorClassList                                       (ConstParm, Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::FindActorFromActorClassList(const class AActor* InActor, const TArray<TSubclassOf<class AActor>>& InActorClassList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "FindActorFromActorClassList");

	Params::DCDataBlueprintLibrary_FindActorFromActorClassList Parms{};

	Parms.InActor = InActor;
	Parms.InActorClassList = std::move(InActorClassList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetActionSkinIdArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          OutActionSkinIdArray                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetActionSkinIdArray(TArray<struct FPrimaryAssetId>* OutActionSkinIdArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetActionSkinIdArray");

	Params::DCDataBlueprintLibrary_GetActionSkinIdArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActionSkinIdArray != nullptr)
		*OutActionSkinIdArray = std::move(Parms.OutActionSkinIdArray);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetArmorSkinIdArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          OutArmorSkinIdArray                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetArmorSkinIdArray(TArray<struct FPrimaryAssetId>* OutArmorSkinIdArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetArmorSkinIdArray");

	Params::DCDataBlueprintLibrary_GetArmorSkinIdArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutArmorSkinIdArray != nullptr)
		*OutArmorSkinIdArray = std::move(Parms.OutArmorSkinIdArray);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetAttackTypeText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InAttackTypeTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetAttackTypeText(const struct FGameplayTag& InAttackTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetAttackTypeText");

	Params::DCDataBlueprintLibrary_GetAttackTypeText Parms{};

	Parms.InAttackTypeTag = std::move(InAttackTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetAttackTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<struct FGameplayTag, class FText>  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetAttackTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetAttackTypeTextMap");

	Params::DCDataBlueprintLibrary_GetAttackTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetAttributeText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayAttribute               Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetAttributeText(const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetAttributeText");

	Params::DCDataBlueprintLibrary_GetAttributeText Parms{};

	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetAttributeTextMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<struct FGameplayAttribute, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayAttribute, class FText> UDCDataBlueprintLibrary::GetAttributeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetAttributeTextMap");

	Params::DCDataBlueprintLibrary_GetAttributeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetCharacterClassText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDCCharacterClass                       InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetCharacterClassText(EDCCharacterClass InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetCharacterClassText");

	Params::DCDataBlueprintLibrary_GetCharacterClassText Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetCharacterSkinIdArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          OutCharacterSkinIdArray                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetCharacterSkinIdArray(TArray<struct FPrimaryAssetId>* OutCharacterSkinIdArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetCharacterSkinIdArray");

	Params::DCDataBlueprintLibrary_GetCharacterSkinIdArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCharacterSkinIdArray != nullptr)
		*OutCharacterSkinIdArray = std::move(Parms.OutCharacterSkinIdArray);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetConstantFloat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InConstantId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCDataBlueprintLibrary::GetConstantFloat(const struct FPrimaryAssetId& InConstantId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetConstantFloat");

	Params::DCDataBlueprintLibrary_GetConstantFloat Parms{};

	Parms.InConstantId = std::move(InConstantId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetConstantInt32
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InConstantId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCDataBlueprintLibrary::GetConstantInt32(const struct FPrimaryAssetId& InConstantId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetConstantInt32");

	Params::DCDataBlueprintLibrary_GetConstantInt32 Parms{};

	Parms.InConstantId = std::move(InConstantId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDescData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDescData*                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDescData* UDCDataBlueprintLibrary::GetDescData(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDescData");

	Params::DCDataBlueprintLibrary_GetDescData Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataAssetItemRequirement
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDesignDataAssetItemRequirement*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDesignDataAssetItemRequirement* UDCDataBlueprintLibrary::GetDesignDataAssetItemRequirement(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataAssetItemRequirement");

	Params::DCDataBlueprintLibrary_GetDesignDataAssetItemRequirement Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataBaseItem
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataBaseItem              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataBaseItem UDCDataBlueprintLibrary::GetDesignDataBaseItem(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataBaseItem");

	Params::DCDataBlueprintLibrary_GetDesignDataBaseItem Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataEmote
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataEmote                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataEmote UDCDataBlueprintLibrary::GetDesignDataEmote(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataEmote");

	Params::DCDataBlueprintLibrary_GetDesignDataEmote Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataGameplayAbility
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataGameplayAbility       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataGameplayAbility UDCDataBlueprintLibrary::GetDesignDataGameplayAbility(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataGameplayAbility");

	Params::DCDataBlueprintLibrary_GetDesignDataGameplayAbility Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataGameplayEffect
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataGameplayEffect        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataGameplayEffect UDCDataBlueprintLibrary::GetDesignDataGameplayEffect(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataGameplayEffect");

	Params::DCDataBlueprintLibrary_GetDesignDataGameplayEffect Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataGEModifier
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataGEModifier            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDesignDataGEModifier UDCDataBlueprintLibrary::GetDesignDataGEModifier(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataGEModifier");

	Params::DCDataBlueprintLibrary_GetDesignDataGEModifier Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItem
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataItem                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataItem UDCDataBlueprintLibrary::GetDesignDataItem(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataItem");

	Params::DCDataBlueprintLibrary_GetDesignDataItem Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemConsume
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataItemConsume           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataItemConsume UDCDataBlueprintLibrary::GetDesignDataItemConsume(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataItemConsume");

	Params::DCDataBlueprintLibrary_GetDesignDataItemConsume Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataItemContainer         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDesignDataItemContainer UDCDataBlueprintLibrary::GetDesignDataItemContainer(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataItemContainer");

	Params::DCDataBlueprintLibrary_GetDesignDataItemContainer Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemIdsByGameplayTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ItemGameplayTag                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FPrimaryAssetId>    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<struct FPrimaryAssetId> UDCDataBlueprintLibrary::GetDesignDataItemIdsByGameplayTag(const struct FGameplayTag& ItemGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataItemIdsByGameplayTag");

	Params::DCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag Parms{};

	Parms.ItemGameplayTag = std::move(ItemGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemProperty
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataItemProperty          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataItemProperty UDCDataBlueprintLibrary::GetDesignDataItemProperty(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataItemProperty");

	Params::DCDataBlueprintLibrary_GetDesignDataItemProperty Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemPropertyType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataItemPropertyType      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDesignDataItemPropertyType UDCDataBlueprintLibrary::GetDesignDataItemPropertyType(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataItemPropertyType");

	Params::DCDataBlueprintLibrary_GetDesignDataItemPropertyType Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemRequirement
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataItemRequirement       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataItemRequirement UDCDataBlueprintLibrary::GetDesignDataItemRequirement(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataItemRequirement");

	Params::DCDataBlueprintLibrary_GetDesignDataItemRequirement Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMeleeAttack
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataMeleeAttack           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDesignDataMeleeAttack UDCDataBlueprintLibrary::GetDesignDataMeleeAttack(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataMeleeAttack");

	Params::DCDataBlueprintLibrary_GetDesignDataMeleeAttack Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMonster
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataMonster               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataMonster UDCDataBlueprintLibrary::GetDesignDataMonster(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataMonster");

	Params::DCDataBlueprintLibrary_GetDesignDataMonster Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMovementModifier
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataMovementModifier      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDesignDataMovementModifier UDCDataBlueprintLibrary::GetDesignDataMovementModifier(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataMovementModifier");

	Params::DCDataBlueprintLibrary_GetDesignDataMovementModifier Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMusic
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataMusic                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataMusic UDCDataBlueprintLibrary::GetDesignDataMusic(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataMusic");

	Params::DCDataBlueprintLibrary_GetDesignDataMusic Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMusicMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<struct FPrimaryAssetId, struct FDesignDataMusic>OutDesignDataMusicMap                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetDesignDataMusicMap(TMap<struct FPrimaryAssetId, struct FDesignDataMusic>* OutDesignDataMusicMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataMusicMap");

	Params::DCDataBlueprintLibrary_GetDesignDataMusicMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDesignDataMusicMap != nullptr)
		*OutDesignDataMusicMap = std::move(Parms.OutDesignDataMusicMap);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPerk
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataPerk                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataPerk UDCDataBlueprintLibrary::GetDesignDataPerk(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataPerk");

	Params::DCDataBlueprintLibrary_GetDesignDataPerk Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPerkMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<struct FPrimaryAssetId, struct FDesignDataPerk>OutDesignDataPerkMap                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetDesignDataPerkMap(TMap<struct FPrimaryAssetId, struct FDesignDataPerk>* OutDesignDataPerkMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataPerkMap");

	Params::DCDataBlueprintLibrary_GetDesignDataPerkMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDesignDataPerkMap != nullptr)
		*OutDesignDataPerkMap = std::move(Parms.OutDesignDataPerkMap);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPlayerCharacter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataPlayerCharacter       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataPlayerCharacter UDCDataBlueprintLibrary::GetDesignDataPlayerCharacter(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataPlayerCharacter");

	Params::DCDataBlueprintLibrary_GetDesignDataPlayerCharacter Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPlayerCharacterMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<struct FPrimaryAssetId, struct FDesignDataPlayerCharacter>OutDesignDataPlayerCharacterMap                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetDesignDataPlayerCharacterMap(TMap<struct FPrimaryAssetId, struct FDesignDataPlayerCharacter>* OutDesignDataPlayerCharacterMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataPlayerCharacterMap");

	Params::DCDataBlueprintLibrary_GetDesignDataPlayerCharacterMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDesignDataPlayerCharacterMap != nullptr)
		*OutDesignDataPlayerCharacterMap = std::move(Parms.OutDesignDataPlayerCharacterMap);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataProps
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataProps                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataProps UDCDataBlueprintLibrary::GetDesignDataProps(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataProps");

	Params::DCDataBlueprintLibrary_GetDesignDataProps Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPropsInteract
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataPropsInteract         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataPropsInteract UDCDataBlueprintLibrary::GetDesignDataPropsInteract(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataPropsInteract");

	Params::DCDataBlueprintLibrary_GetDesignDataPropsInteract Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPropsSkillCheck
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataPropsSkillCheck       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDesignDataPropsSkillCheck UDCDataBlueprintLibrary::GetDesignDataPropsSkillCheck(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataPropsSkillCheck");

	Params::DCDataBlueprintLibrary_GetDesignDataPropsSkillCheck Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataShapeShiftMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<struct FPrimaryAssetId, struct FDesignDataShapeShift>OutDesignDataShapeShiftMap                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetDesignDataShapeShiftMap(TMap<struct FPrimaryAssetId, struct FDesignDataShapeShift>* OutDesignDataShapeShiftMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataShapeShiftMap");

	Params::DCDataBlueprintLibrary_GetDesignDataShapeShiftMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDesignDataShapeShiftMap != nullptr)
		*OutDesignDataShapeShiftMap = std::move(Parms.OutDesignDataShapeShiftMap);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSkill
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataSkill                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataSkill UDCDataBlueprintLibrary::GetDesignDataSkill(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataSkill");

	Params::DCDataBlueprintLibrary_GetDesignDataSkill Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSkillMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<struct FPrimaryAssetId, struct FDesignDataSkill>OutDesignDataSkillMap                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetDesignDataSkillMap(TMap<struct FPrimaryAssetId, struct FDesignDataSkill>* OutDesignDataSkillMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataSkillMap");

	Params::DCDataBlueprintLibrary_GetDesignDataSkillMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDesignDataSkillMap != nullptr)
		*OutDesignDataSkillMap = std::move(Parms.OutDesignDataSkillMap);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSpell
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDesignDataSpell                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataSpell UDCDataBlueprintLibrary::GetDesignDataSpell(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataSpell");

	Params::DCDataBlueprintLibrary_GetDesignDataSpell Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSpellMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<struct FPrimaryAssetId, struct FDesignDataSpell>OutDesignDataSpellMap                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetDesignDataSpellMap(TMap<struct FPrimaryAssetId, struct FDesignDataSpell>* OutDesignDataSpellMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDesignDataSpellMap");

	Params::DCDataBlueprintLibrary_GetDesignDataSpellMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDesignDataSpellMap != nullptr)
		*OutDesignDataSpellMap = std::move(Parms.OutDesignDataSpellMap);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDungeonTextByIdTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InIdTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetDungeonTextByIdTag(const struct FGameplayTag& InIdTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDungeonTextByIdTag");

	Params::DCDataBlueprintLibrary_GetDungeonTextByIdTag Parms{};

	Parms.InIdTag = std::move(InIdTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDungeonTypeChapterText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InIdTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetDungeonTypeChapterText(const struct FGameplayTag& InIdTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDungeonTypeChapterText");

	Params::DCDataBlueprintLibrary_GetDungeonTypeChapterText Parms{};

	Parms.InIdTag = std::move(InIdTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDungeonTypeDescText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InIdTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetDungeonTypeDescText(const struct FGameplayTag& InIdTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDungeonTypeDescText");

	Params::DCDataBlueprintLibrary_GetDungeonTypeDescText Parms{};

	Parms.InIdTag = std::move(InIdTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDungeonTypeGroupText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InIdTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetDungeonTypeGroupText(const struct FGameplayTag& InIdTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDungeonTypeGroupText");

	Params::DCDataBlueprintLibrary_GetDungeonTypeGroupText Parms{};

	Parms.InIdTag = std::move(InIdTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetDungeonTypeText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InIdTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetDungeonTypeText(const struct FGameplayTag& InIdTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetDungeonTypeText");

	Params::DCDataBlueprintLibrary_GetDungeonTypeText Parms{};

	Parms.InIdTag = std::move(InIdTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetEmoteIdArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          OutEmoteIdArray                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetEmoteIdArray(TArray<struct FPrimaryAssetId>* OutEmoteIdArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetEmoteIdArray");

	Params::DCDataBlueprintLibrary_GetEmoteIdArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEmoteIdArray != nullptr)
		*OutEmoteIdArray = std::move(Parms.OutEmoteIdArray);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetFriendErrorMsgText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InResult                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetFriendErrorMsgText(int32 InResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetFriendErrorMsgText");

	Params::DCDataBlueprintLibrary_GetFriendErrorMsgText Parms{};

	Parms.InResult = InResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetGameplayTagByItemRarity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDCItemRarity                           ItemRarity                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UDCDataBlueprintLibrary::GetGameplayTagByItemRarity(const EDCItemRarity ItemRarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetGameplayTagByItemRarity");

	Params::DCDataBlueprintLibrary_GetGameplayTagByItemRarity Parms{};

	Parms.ItemRarity = ItemRarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetGameTypeGroupText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetGameTypeGroupText(EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetGameTypeGroupText");

	Params::DCDataBlueprintLibrary_GetGameTypeGroupText Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetGameTypeText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetGameTypeText(EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetGameTypeText");

	Params::DCDataBlueprintLibrary_GetGameTypeText Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetHighRollerGameType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameType UDCDataBlueprintLibrary::GetHighRollerGameType(EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetHighRollerGameType");

	Params::DCDataBlueprintLibrary_GetHighRollerGameType Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetIdTagGroupContainer
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UDCDataBlueprintLibrary::GetIdTagGroupContainer(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetIdTagGroupContainer");

	Params::DCDataBlueprintLibrary_GetIdTagGroupContainer Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetIdTagText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InIdTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetIdTagText(const struct FGameplayTag& InIdTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetIdTagText");

	Params::DCDataBlueprintLibrary_GetIdTagText Parms{};

	Parms.InIdTag = std::move(InIdTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemAccessoryTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetItemAccessoryTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemAccessoryTypeTextMap");

	Params::DCDataBlueprintLibrary_GetItemAccessoryTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemActorClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemActor>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AItemActor> UDCDataBlueprintLibrary::GetItemActorClass(class AActor* OwnerActor, const struct FItemData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemActorClass");

	Params::DCDataBlueprintLibrary_GetItemActorClass Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.ItemData = std::move(ItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemArmorTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetItemArmorTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemArmorTypeTextMap");

	Params::DCDataBlueprintLibrary_GetItemArmorTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemArtData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UArtDataItem*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArtDataItem* UDCDataBlueprintLibrary::GetItemArtData(const struct FItemData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemArtData");

	Params::DCDataBlueprintLibrary_GetItemArtData Parms{};

	Parms.ItemData = std::move(ItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemAvailableCount
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCItemInfo                      ItemInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCDataBlueprintLibrary::GetItemAvailableCount(const struct FDCItemInfo& ItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemAvailableCount");

	Params::DCDataBlueprintLibrary_GetItemAvailableCount Parms{};

	Parms.ItemInfo = std::move(ItemInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCItemInfo                      ItemInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FItemData UDCDataBlueprintLibrary::GetItemData(const struct FDCItemInfo& ItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemData");

	Params::DCDataBlueprintLibrary_GetItemData Parms{};

	Parms.ItemInfo = std::move(ItemInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemDataEx
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCItemInfo                      ItemInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDCInventoryId                          Inventory                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FItemData UDCDataBlueprintLibrary::GetItemDataEx(const struct FDCItemInfo& ItemInfo, const EDCInventoryId Inventory, const int32 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemDataEx");

	Params::DCDataBlueprintLibrary_GetItemDataEx Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.Inventory = Inventory;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemEffectDefaultFormatTagContainer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UDCDataBlueprintLibrary::GetItemEffectDefaultFormatTagContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemEffectDefaultFormatTagContainer");

	Params::DCDataBlueprintLibrary_GetItemEffectDefaultFormatTagContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemEffectPercentFormatTagContainer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UDCDataBlueprintLibrary::GetItemEffectPercentFormatTagContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemEffectPercentFormatTagContainer");

	Params::DCDataBlueprintLibrary_GetItemEffectPercentFormatTagContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemEffectTimeFormatTagContainer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UDCDataBlueprintLibrary::GetItemEffectTimeFormatTagContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemEffectTimeFormatTagContainer");

	Params::DCDataBlueprintLibrary_GetItemEffectTimeFormatTagContainer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemEffectValueText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InItemEffectTypeTag                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemEffectValueText(const struct FGameplayTag& InItemEffectTypeTag, const int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemEffectValueText");

	Params::DCDataBlueprintLibrary_GetItemEffectValueText Parms{};

	Parms.InItemEffectTypeTag = std::move(InItemEffectTypeTag);
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemHandTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetItemHandTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemHandTypeTextMap");

	Params::DCDataBlueprintLibrary_GetItemHandTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemIdTagText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InIdTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemIdTagText(const struct FGameplayTag& InIdTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemIdTagText");

	Params::DCDataBlueprintLibrary_GetItemIdTagText Parms{};

	Parms.InIdTag = std::move(InIdTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemLootStateText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDCItemLootState                        InLootState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemLootStateText(EDCItemLootState InLootState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemLootStateText");

	Params::DCDataBlueprintLibrary_GetItemLootStateText Parms{};

	Parms.InLootState = InLootState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemMiscTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetItemMiscTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemMiscTypeTextMap");

	Params::DCDataBlueprintLibrary_GetItemMiscTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyItemTooltipText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InItemPropertyTypeTag                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InValueString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPriamary                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemPropertyItemTooltipText(const struct FGameplayTag& InItemPropertyTypeTag, const class FString& InValueString, const bool bIsPriamary)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemPropertyItemTooltipText");

	Params::DCDataBlueprintLibrary_GetItemPropertyItemTooltipText Parms{};

	Parms.InItemPropertyTypeTag = std::move(InItemPropertyTypeTag);
	Parms.InValueString = std::move(InValueString);
	Parms.bIsPriamary = bIsPriamary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyTypeId_Unidentified
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDCDataBlueprintLibrary::GetItemPropertyTypeId_Unidentified()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemPropertyTypeId_Unidentified");

	Params::DCDataBlueprintLibrary_GetItemPropertyTypeId_Unidentified Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyTypeText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InItemPropertyTypeTag                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemPropertyTypeText(const struct FGameplayTag& InItemPropertyTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemPropertyTypeText");

	Params::DCDataBlueprintLibrary_GetItemPropertyTypeText Parms{};

	Parms.InItemPropertyTypeTag = std::move(InItemPropertyTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyTypeTextFromAsset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InItemPropertyTypeId                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemPropertyTypeTextFromAsset(const struct FPrimaryAssetId& InItemPropertyTypeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemPropertyTypeTextFromAsset");

	Params::DCDataBlueprintLibrary_GetItemPropertyTypeTextFromAsset Parms{};

	Parms.InItemPropertyTypeId = std::move(InItemPropertyTypeId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetItemPropertyTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemPropertyTypeTextMap");

	Params::DCDataBlueprintLibrary_GetItemPropertyTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemRarityByGameplayTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InItemRarityTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDCItemRarity                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCItemRarity UDCDataBlueprintLibrary::GetItemRarityByGameplayTag(const struct FGameplayTag& InItemRarityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemRarityByGameplayTag");

	Params::DCDataBlueprintLibrary_GetItemRarityByGameplayTag Parms{};

	Parms.InItemRarityTag = std::move(InItemRarityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemRarityLimit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InWorldContextObject                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UDCDataBlueprintLibrary::GetItemRarityLimit(const class UObject* InWorldContextObject, EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemRarityLimit");

	Params::DCDataBlueprintLibrary_GetItemRarityLimit Parms{};

	Parms.InWorldContextObject = InWorldContextObject;
	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemRarityText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InItemRarityTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemRarityText(const struct FGameplayTag& InItemRarityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemRarityText");

	Params::DCDataBlueprintLibrary_GetItemRarityText Parms{};

	Parms.InItemRarityTag = std::move(InItemRarityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemRarityTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetItemRarityTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemRarityTypeTextMap");

	Params::DCDataBlueprintLibrary_GetItemRarityTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemSkinIdArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          OutItemSkinIdArray                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetItemSkinIdArray(TArray<struct FPrimaryAssetId>* OutItemSkinIdArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemSkinIdArray");

	Params::DCDataBlueprintLibrary_GetItemSkinIdArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemSkinIdArray != nullptr)
		*OutItemSkinIdArray = std::move(Parms.OutItemSkinIdArray);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemSlotText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InItemSlotTag                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemSlotText(const struct FGameplayTag& InItemSlotTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemSlotText");

	Params::DCDataBlueprintLibrary_GetItemSlotText Parms{};

	Parms.InItemSlotTag = std::move(InItemSlotTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemSlotTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetItemSlotTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemSlotTypeTextMap");

	Params::DCDataBlueprintLibrary_GetItemSlotTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemTypeCategoryText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EItemType                               ItemType                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemTypeCategoryText(const EItemType& ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemTypeCategoryText");

	Params::DCDataBlueprintLibrary_GetItemTypeCategoryText Parms{};

	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemTypeChatFilterTagContainerMaps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDCChatRoomDataAsset*             InChatRoomData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, struct FGameplayTagContainer>OutTypeIdTagChatFilterTagContainerMap                  (Parm, OutParm, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, struct FGameplayTagContainer>OutTypeRarityChatFilterTagContainerMap                 (Parm, OutParm, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, struct FGameplayTagContainer>OutTypeSlotChatFilterTagContainerMap                   (Parm, OutParm, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, struct FGameplayTagContainer>OutPropertyChatFilterTagContainerMap                   (Parm, OutParm, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, struct FGameplayTagContainer>OutPlayerCharacterChatFilterTagContainerMap            (Parm, OutParm, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetItemTypeChatFilterTagContainerMaps(const class UDCChatRoomDataAsset* InChatRoomData, TMap<struct FGameplayTag, struct FGameplayTagContainer>* OutTypeIdTagChatFilterTagContainerMap, TMap<struct FGameplayTag, struct FGameplayTagContainer>* OutTypeRarityChatFilterTagContainerMap, TMap<struct FGameplayTag, struct FGameplayTagContainer>* OutTypeSlotChatFilterTagContainerMap, TMap<struct FGameplayTag, struct FGameplayTagContainer>* OutPropertyChatFilterTagContainerMap, TMap<struct FGameplayTag, struct FGameplayTagContainer>* OutPlayerCharacterChatFilterTagContainerMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemTypeChatFilterTagContainerMaps");

	Params::DCDataBlueprintLibrary_GetItemTypeChatFilterTagContainerMaps Parms{};

	Parms.InChatRoomData = InChatRoomData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTypeIdTagChatFilterTagContainerMap != nullptr)
		*OutTypeIdTagChatFilterTagContainerMap = std::move(Parms.OutTypeIdTagChatFilterTagContainerMap);

	if (OutTypeRarityChatFilterTagContainerMap != nullptr)
		*OutTypeRarityChatFilterTagContainerMap = std::move(Parms.OutTypeRarityChatFilterTagContainerMap);

	if (OutTypeSlotChatFilterTagContainerMap != nullptr)
		*OutTypeSlotChatFilterTagContainerMap = std::move(Parms.OutTypeSlotChatFilterTagContainerMap);

	if (OutPropertyChatFilterTagContainerMap != nullptr)
		*OutPropertyChatFilterTagContainerMap = std::move(Parms.OutPropertyChatFilterTagContainerMap);

	if (OutPlayerCharacterChatFilterTagContainerMap != nullptr)
		*OutPlayerCharacterChatFilterTagContainerMap = std::move(Parms.OutPlayerCharacterChatFilterTagContainerMap);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemTypeText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InTypeTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemTypeText(const struct FGameplayTag& InTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemTypeText");

	Params::DCDataBlueprintLibrary_GetItemTypeText Parms{};

	Parms.InTypeTag = std::move(InTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemTypeTextByCategory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDCItemDataAsset*                 ItemDataAsset                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FormatString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetItemTypeTextByCategory(const class UDCItemDataAsset* ItemDataAsset, const class FString& FormatString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemTypeTextByCategory");

	Params::DCDataBlueprintLibrary_GetItemTypeTextByCategory Parms{};

	Parms.ItemDataAsset = ItemDataAsset;
	Parms.FormatString = std::move(FormatString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemUtilityTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetItemUtilityTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemUtilityTypeTextMap");

	Params::DCDataBlueprintLibrary_GetItemUtilityTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetItemWeaponTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetItemWeaponTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetItemWeaponTypeTextMap");

	Params::DCDataBlueprintLibrary_GetItemWeaponTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetLobbyEmoteIdArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          OutLobbyEmoteIdArray                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::GetLobbyEmoteIdArray(TArray<struct FPrimaryAssetId>* OutLobbyEmoteIdArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetLobbyEmoteIdArray");

	Params::DCDataBlueprintLibrary_GetLobbyEmoteIdArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLobbyEmoteIdArray != nullptr)
		*OutLobbyEmoteIdArray = std::move(Parms.OutLobbyEmoteIdArray);
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetLogEventTypeText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EDCLogEventType                         InLogEventType                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetLogEventTypeText(const EDCLogEventType& InLogEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetLogEventTypeText");

	Params::DCDataBlueprintLibrary_GetLogEventTypeText Parms{};

	Parms.InLogEventType = InLogEventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetMatchModeText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMatchMode                              InMatchMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetMatchModeText(EMatchMode InMatchMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetMatchModeText");

	Params::DCDataBlueprintLibrary_GetMatchModeText Parms{};

	Parms.InMatchMode = InMatchMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetMonsterIdTagText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InIdTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetMonsterIdTagText(const struct FGameplayTag& InIdTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetMonsterIdTagText");

	Params::DCDataBlueprintLibrary_GetMonsterIdTagText Parms{};

	Parms.InIdTag = std::move(InIdTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetNormalGameType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameType UDCDataBlueprintLibrary::GetNormalGameType(EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetNormalGameType");

	Params::DCDataBlueprintLibrary_GetNormalGameType Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetPlatformName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDCPlatform                             InPlatform                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetPlatformName(EDCPlatform InPlatform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetPlatformName");

	Params::DCDataBlueprintLibrary_GetPlatformName Parms{};

	Parms.InPlatform = InPlatform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetPrimaryAssetSync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimaryDataAsset*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimaryDataAsset* UDCDataBlueprintLibrary::GetPrimaryAssetSync(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetPrimaryAssetSync");

	Params::DCDataBlueprintLibrary_GetPrimaryAssetSync Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetPropsIdTagText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InIdTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetPropsIdTagText(const struct FGameplayTag& InIdTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetPropsIdTagText");

	Params::DCDataBlueprintLibrary_GetPropsIdTagText Parms{};

	Parms.InIdTag = std::move(InIdTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetRandomDesignDataItemId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FPrimaryAssetId            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FPrimaryAssetId UDCDataBlueprintLibrary::GetRandomDesignDataItemId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetRandomDesignDataItemId");

	Params::DCDataBlueprintLibrary_GetRandomDesignDataItemId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetSetByCallerTagText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InSetByCallerTag                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetSetByCallerTagText(const struct FGameplayTag& InSetByCallerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetSetByCallerTagText");

	Params::DCDataBlueprintLibrary_GetSetByCallerTagText Parms{};

	Parms.InSetByCallerTag = std::move(InSetByCallerTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetSetByCallerTagTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetSetByCallerTagTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetSetByCallerTagTextMap");

	Params::DCDataBlueprintLibrary_GetSetByCallerTagTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetShapeShiftData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  InId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDCShapeShiftDataAsset*     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDCShapeShiftDataAsset* UDCDataBlueprintLibrary::GetShapeShiftData(const struct FPrimaryAssetId& InId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetShapeShiftData");

	Params::DCDataBlueprintLibrary_GetShapeShiftData Parms{};

	Parms.InId = std::move(InId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetShapeShiftDataByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCShapeShiftDataAsset*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCShapeShiftDataAsset* UDCDataBlueprintLibrary::GetShapeShiftDataByTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetShapeShiftDataByTag");

	Params::DCDataBlueprintLibrary_GetShapeShiftDataByTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetShapeShiftDatas
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UDCShapeShiftDataAsset*>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDCShapeShiftDataAsset*> UDCDataBlueprintLibrary::GetShapeShiftDatas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetShapeShiftDatas");

	Params::DCDataBlueprintLibrary_GetShapeShiftDatas Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetStatisticsTypeText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EStatisticsType                         InStatisticsType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetStatisticsTypeText(EStatisticsType InStatisticsType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetStatisticsTypeText");

	Params::DCDataBlueprintLibrary_GetStatisticsTypeText Parms{};

	Parms.InStatisticsType = InStatisticsType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetTypeTagText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InTypeTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCDataBlueprintLibrary::GetTypeTagText(const struct FGameplayTag& InTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetTypeTagText");

	Params::DCDataBlueprintLibrary_GetTypeTagText Parms{};

	Parms.InTypeTag = std::move(InTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetTypeTextMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, class FText>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<struct FGameplayTag, class FText> UDCDataBlueprintLibrary::GetTypeTextMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetTypeTextMap");

	Params::DCDataBlueprintLibrary_GetTypeTextMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetViewNickname
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNickname                        Nickname                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDCDataBlueprintLibrary::GetViewNickname(const struct FNickname& Nickname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetViewNickname");

	Params::DCDataBlueprintLibrary_GetViewNickname Parms{};

	Parms.Nickname = std::move(Nickname);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.GetViewNicknameColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FNickname                        Nickname                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UDCDataBlueprintLibrary::GetViewNicknameColor(const struct FNickname& Nickname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "GetViewNicknameColor");

	Params::DCDataBlueprintLibrary_GetViewNicknameColor Parms{};

	Parms.Nickname = std::move(Nickname);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsArenaGameType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsArenaGameType(EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsArenaGameType");

	Params::DCDataBlueprintLibrary_IsArenaGameType Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsArenaSelected
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsArenaSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsArenaSelected");

	Params::DCDataBlueprintLibrary_IsArenaSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsAvailableInteraction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCPlayerCharacterBase*           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DstActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   OutDistance                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsAvailableInteraction(class ADCPlayerCharacterBase* Interacter, class AActor* DstActor, const struct FHitResult& InHitResult, float* OutDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsAvailableInteraction");

	Params::DCDataBlueprintLibrary_IsAvailableInteraction Parms{};

	Parms.Interacter = Interacter;
	Parms.DstActor = DstActor;
	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDistance != nullptr)
		*OutDistance = Parms.OutDistance;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsAvailableInteractionWithPhysicalTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCPlayerCharacterBase*           Interacter                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DstActor                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutXYDistance                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsAvailableInteractionWithPhysicalTarget(class ADCPlayerCharacterBase* Interacter, class AActor* DstActor, float* OutXYDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsAvailableInteractionWithPhysicalTarget");

	Params::DCDataBlueprintLibrary_IsAvailableInteractionWithPhysicalTarget Parms{};

	Parms.Interacter = Interacter;
	Parms.DstActor = DstActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutXYDistance != nullptr)
		*OutXYDistance = Parms.OutXYDistance;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsDungeonGameType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsDungeonGameType(EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsDungeonGameType");

	Params::DCDataBlueprintLibrary_IsDungeonGameType Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsDuoGameType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsDuoGameType(EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsDuoGameType");

	Params::DCDataBlueprintLibrary_IsDuoGameType Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsHighRoller
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsHighRoller(EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsHighRoller");

	Params::DCDataBlueprintLibrary_IsHighRoller Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsItemWearableByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InOwnerActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemActor*                       InItemActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsItemWearableByClass(class AActor* InOwnerActor, const class AItemActor* InItemActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsItemWearableByClass");

	Params::DCDataBlueprintLibrary_IsItemWearableByClass Parms{};

	Parms.InOwnerActor = InOwnerActor;
	Parms.InItemActor = InItemActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsLowViolenceMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsLowViolenceMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsLowViolenceMode");

	Params::DCDataBlueprintLibrary_IsLowViolenceMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsSoloGameType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsSoloGameType(EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsSoloGameType");

	Params::DCDataBlueprintLibrary_IsSoloGameType Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsStreamingMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsStreamingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsStreamingMode");

	Params::DCDataBlueprintLibrary_IsStreamingMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsTrioGameType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsTrioGameType(EGameType InGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsTrioGameType");

	Params::DCDataBlueprintLibrary_IsTrioGameType Parms{};

	Parms.InGameType = InGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.IsUtilityItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCItemInfo                      ItemInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDataBlueprintLibrary::IsUtilityItem(const struct FDCItemInfo& ItemInfo, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "IsUtilityItem");

	Params::DCDataBlueprintLibrary_IsUtilityItem Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.ItemIdToInteger
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCItemId                        Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UDCDataBlueprintLibrary::ItemIdToInteger(const struct FDCItemId& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "ItemIdToInteger");

	Params::DCDataBlueprintLibrary_ItemIdToInteger Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.LoadObjectLibrary
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              ObjectClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UDCDataBlueprintLibrary::LoadObjectLibrary(const class FString& Path, TSubclassOf<class UObject> ObjectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "LoadObjectLibrary");

	Params::DCDataBlueprintLibrary_LoadObjectLibrary Parms{};

	Parms.Path = std::move(Path);
	Parms.ObjectClass = ObjectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.LoadPrimaryAsset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InPrimaryAssetId                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UObject* InObjectLoaded)>InOnComplete                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCDataBlueprintLibrary::LoadPrimaryAsset(const struct FPrimaryAssetId& InPrimaryAssetId, const TDelegate<void(class UObject* InObjectLoaded)>& InOnComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "LoadPrimaryAsset");

	Params::DCDataBlueprintLibrary_LoadPrimaryAsset Parms{};

	Parms.InPrimaryAssetId = std::move(InPrimaryAssetId);
	Parms.InOnComplete = InOnComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.MakePrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           PrimaryAssetIdStr                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDCDataBlueprintLibrary::MakePrimaryAssetId(const class FString& PrimaryAssetIdStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "MakePrimaryAssetId");

	Params::DCDataBlueprintLibrary_MakePrimaryAssetId Parms{};

	Parms.PrimaryAssetIdStr = std::move(PrimaryAssetIdStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.MakePrimaryAssetIdStr
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDCDataBlueprintLibrary::MakePrimaryAssetIdStr(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "MakePrimaryAssetIdStr");

	Params::DCDataBlueprintLibrary_MakePrimaryAssetIdStr Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.MakeUniqueId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UDCDataBlueprintLibrary::MakeUniqueId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "MakeUniqueId");

	Params::DCDataBlueprintLibrary_MakeUniqueId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.PartyIdToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDCPartyId                       Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDCDataBlueprintLibrary::PartyIdToString(const struct FDCPartyId& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "PartyIdToString");

	Params::DCDataBlueprintLibrary_PartyIdToString Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.SpawnItemActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemActor*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemActor* UDCDataBlueprintLibrary::SpawnItemActor(class AActor* OwnerActor, const struct FItemData& ItemData, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "SpawnItemActor");

	Params::DCDataBlueprintLibrary_SpawnItemActor Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.ItemData = std::move(ItemData);
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.SpawnItemHolderActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Spawner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AItemHolderActorBase*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemHolderActorBase* UDCDataBlueprintLibrary::SpawnItemHolderActor(class AActor* Spawner, const struct FItemData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "SpawnItemHolderActor");

	Params::DCDataBlueprintLibrary_SpawnItemHolderActor Parms{};

	Parms.Spawner = Spawner;
	Parms.ItemData = std::move(ItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDataBlueprintLibrary.SpawnItemHolderActorWithItemHolderActorClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Spawner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class AItemHolderActorBase> ItemHolderActorClass                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemHolderActorBase*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemHolderActorBase* UDCDataBlueprintLibrary::SpawnItemHolderActorWithItemHolderActorClass(class AActor* Spawner, const struct FItemData& ItemData, const TSubclassOf<class AItemHolderActorBase> ItemHolderActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCDataBlueprintLibrary", "SpawnItemHolderActorWithItemHolderActorClass");

	Params::DCDataBlueprintLibrary_SpawnItemHolderActorWithItemHolderActorClass Parms{};

	Parms.Spawner = Spawner;
	Parms.ItemData = std::move(ItemData);
	Parms.ItemHolderActorClass = ItemHolderActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDeathCamWidget.GetProgress
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCDeathCamWidget::GetProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDeathCamWidget", "GetProgress");

	Params::DCDeathCamWidget_GetProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDeathCamWidget.IsEnded
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDeathCamWidget::IsEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDeathCamWidget", "IsEnded");

	Params::DCDeathCamWidget_IsEnded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDeathCamWidget.IsPlaying
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCDeathCamWidget::IsPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDeathCamWidget", "IsPlaying");

	Params::DCDeathCamWidget_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCDrawbridgeWheel.OnRep_WheelInteractData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCWheelInteractData             InOldWheelInteractData                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADCDrawbridgeWheel::OnRep_WheelInteractData(const struct FDCWheelInteractData& InOldWheelInteractData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDrawbridgeWheel", "OnRep_WheelInteractData");

	Params::DCDrawbridgeWheel_OnRep_WheelInteractData Parms{};

	Parms.InOldWheelInteractData = std::move(InOldWheelInteractData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemDataAsset.GetEquipType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCItemEquipType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCItemEquipType UDCItemDataAsset::GetEquipType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemDataAsset", "GetEquipType");

	Params::DCItemDataAsset_GetEquipType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemDataAsset.IsSoulHeart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCItemDataAsset::IsSoulHeart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemDataAsset", "IsSoulHeart");

	Params::DCItemDataAsset_IsSoulHeart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_MusicGrantingAbilityBase.OnTargetActorOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class AActor*>                   TargetActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_MusicGrantingAbilityBase::OnTargetActorOverlap(const TArray<class AActor*>& TargetActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicGrantingAbilityBase", "OnTargetActorOverlap");

	Params::GA_MusicGrantingAbilityBase_OnTargetActorOverlap Parms{};

	Parms.TargetActors = std::move(TargetActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDungeonGameState.OnRep_bPauseServerUpdate
// (Final, Native, Private)
// Parameters:
// bool                                    bOldPauseServerUpdate                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCDungeonGameState::OnRep_bPauseServerUpdate(bool bOldPauseServerUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonGameState", "OnRep_bPauseServerUpdate");

	Params::DCDungeonGameState_OnRep_bPauseServerUpdate Parms{};

	Parms.bOldPauseServerUpdate = bOldPauseServerUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCDungeonGameState.OnRep_NumPlayers
// (Final, Native, Private)
// Parameters:
// int32                                   OldNumPlayers                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCDungeonGameState::OnRep_NumPlayers(const int32 OldNumPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCDungeonGameState", "OnRep_NumPlayers");

	Params::DCDungeonGameState_OnRep_NumPlayers Parms{};

	Parms.OldNumPlayers = OldNumPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCStateButtonWidgetBase.OnCommonButtonClickedInternal
// (Final, Native, Private)

void UDCStateButtonWidgetBase::OnCommonButtonClickedInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCStateButtonWidgetBase", "OnCommonButtonClickedInternal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCStateButtonWidgetBase.SetActive
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCStateButtonWidgetBase::SetActive(bool bState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCStateButtonWidgetBase", "SetActive");

	Params::DCStateButtonWidgetBase_SetActive Parms{};

	Parms.bState = bState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCItemSkinWidget.GetTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCItemSkinWidget::GetTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemSkinWidget", "GetTooltipWidget");

	Params::DCItemSkinWidget_GetTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemSkinListEntryWidget.OnRightClicked
// (Native, Public)

void UDCItemSkinListEntryWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemSkinListEntryWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemTooltipWidget.OnItemData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FItemData                        NewItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FItemData                        OldItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemTooltipWidget::OnItemData(const struct FItemData& NewItemData, const struct FItemData& OldItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTooltipWidget", "OnItemData");

	Params::ItemTooltipWidget_OnItemData Parms{};

	Parms.NewItemData = std::move(NewItemData);
	Parms.OldItemData = std::move(OldItemData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ItemTooltipWidget.OnRefreshItemName
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UItemTooltipWidget::OnRefreshItemName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTooltipWidget", "OnRefreshItemName");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ItemTooltipWidget.SetItemData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FItemData                        NewItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemTooltipWidget::SetItemData(const struct FItemData& NewItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTooltipWidget", "SetItemData");

	Params::ItemTooltipWidget_SetItemData Parms{};

	Parms.NewItemData = std::move(NewItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEmoteWidget.GetTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCEmoteWidget::GetTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEmoteWidget", "GetTooltipWidget");

	Params::DCEmoteWidget_GetTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEmoteListEntryWidget.GetSelectedVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCEmoteListEntryWidget::GetSelectedVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEmoteListEntryWidget", "GetSelectedVisibility");

	Params::DCEmoteListEntryWidget_GetSelectedVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEmoteListEntryWidget.OnRightClicked
// (Native, Public)

void UDCEmoteListEntryWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEmoteListEntryWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.AddPlayerMappableConfigByTagContainer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            InputConfigTags                                        (Parm, NativeAccessSpecifierPublic)

void UDCEnhancedInputLibrary::AddPlayerMappableConfigByTagContainer(const class UObject* WorldContextObject, const struct FGameplayTagContainer& InputConfigTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "AddPlayerMappableConfigByTagContainer");

	Params::DCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InputConfigTags = std::move(InputConfigTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.GetActionBoolByTags
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InputConfigTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCEnhancedInputLibrary::GetActionBoolByTags(const class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag, const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "GetActionBoolByTags");

	Params::DCEnhancedInputLibrary_GetActionBoolByTags Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InputConfigTag = std::move(InputConfigTag);
	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.GetActionBoolWithController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     Action                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCEnhancedInputLibrary::GetActionBoolWithController(const class UObject* WorldContextObject, const class UInputAction* Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "GetActionBoolWithController");

	Params::DCEnhancedInputLibrary_GetActionBoolWithController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.GetActionValueByTags
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InputConfigTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputActionValue                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInputActionValue UDCEnhancedInputLibrary::GetActionValueByTags(const class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag, const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "GetActionValueByTags");

	Params::DCEnhancedInputLibrary_GetActionValueByTags Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InputConfigTag = std::move(InputConfigTag);
	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.GetActionValueWithController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     Action                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputActionValue                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInputActionValue UDCEnhancedInputLibrary::GetActionValueWithController(const class UObject* WorldContextObject, const class UInputAction* Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "GetActionValueWithController");

	Params::DCEnhancedInputLibrary_GetActionValueWithController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.GetDCEnhancedInputLocalPlayerSubSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCEnhancedInputLocalPlayerSubsystem*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCEnhancedInputLocalPlayerSubsystem* UDCEnhancedInputLibrary::GetDCEnhancedInputLocalPlayerSubSystem(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "GetDCEnhancedInputLocalPlayerSubSystem");

	Params::DCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.GetEnhancedPlayerInput
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEnhancedPlayerInput*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEnhancedPlayerInput* UDCEnhancedInputLibrary::GetEnhancedPlayerInput(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "GetEnhancedPlayerInput");

	Params::DCEnhancedInputLibrary_GetEnhancedPlayerInput Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.GetFirstMappedKeyFromRegisteredInputToAction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     Action                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey UDCEnhancedInputLibrary::GetFirstMappedKeyFromRegisteredInputToAction(const class UObject* WorldContextObject, const class UInputAction* Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "GetFirstMappedKeyFromRegisteredInputToAction");

	Params::DCEnhancedInputLibrary_GetFirstMappedKeyFromRegisteredInputToAction Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.GetInputAction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InputConfigTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* UDCEnhancedInputLibrary::GetInputAction(const class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag, const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "GetInputAction");

	Params::DCEnhancedInputLibrary_GetInputAction Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InputConfigTag = std::move(InputConfigTag);
	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.GetInputConfigByTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InputConfigTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDCInputConfig*             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDCInputConfig* UDCEnhancedInputLibrary::GetInputConfigByTag(const class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "GetInputConfigByTag");

	Params::DCEnhancedInputLibrary_GetInputConfigByTag Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InputConfigTag = std::move(InputConfigTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.GetKeysMappedToAction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     Action                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FKey> UDCEnhancedInputLibrary::GetKeysMappedToAction(const class UObject* WorldContextObject, const class UInputAction* Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "GetKeysMappedToAction");

	Params::DCEnhancedInputLibrary_GetKeysMappedToAction Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.InjectInputForAction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     Action                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputActionValue                RawValue                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class UInputModifier*>           Modifiers                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UInputTrigger*>            Triggers                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCEnhancedInputLibrary::InjectInputForAction(const class UObject* WorldContextObject, const class UInputAction* Action, const struct FInputActionValue& RawValue, const TArray<class UInputModifier*>& Modifiers, const TArray<class UInputTrigger*>& Triggers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "InjectInputForAction");

	Params::DCEnhancedInputLibrary_InjectInputForAction Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Action = Action;
	Parms.RawValue = std::move(RawValue);
	Parms.Modifiers = std::move(Modifiers);
	Parms.Triggers = std::move(Triggers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.InjectInputVectorForAction
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     Action                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UInputModifier*>           Modifiers                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UInputTrigger*>            Triggers                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCEnhancedInputLibrary::InjectInputVectorForAction(const class UObject* WorldContextObject, const class UInputAction* Action, const struct FVector& Value, const TArray<class UInputModifier*>& Modifiers, const TArray<class UInputTrigger*>& Triggers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "InjectInputVectorForAction");

	Params::DCEnhancedInputLibrary_InjectInputVectorForAction Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Action = Action;
	Parms.Value = std::move(Value);
	Parms.Modifiers = std::move(Modifiers);
	Parms.Triggers = std::move(Triggers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEnhancedInputLibrary.RemovePlayerMappableConfigByTagContainer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            InputConfigTags                                        (Parm, NativeAccessSpecifierPublic)

void UDCEnhancedInputLibrary::RemovePlayerMappableConfigByTagContainer(const class UObject* WorldContextObject, const struct FGameplayTagContainer& InputConfigTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCEnhancedInputLibrary", "RemovePlayerMappableConfigByTagContainer");

	Params::DCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InputConfigTags = std::move(InputConfigTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCQuestProgressSlotWidget.OnQuestProgressInfoSet
// (Event, Protected, BlueprintEvent)

void UDCQuestProgressSlotWidget::OnQuestProgressInfoSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestProgressSlotWidget", "OnQuestProgressInfoSet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCQuestProgressSlotWidget.GetQuestIndexText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCQuestProgressSlotWidget::GetQuestIndexText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestProgressSlotWidget", "GetQuestIndexText");

	Params::DCQuestProgressSlotWidget_GetQuestIndexText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEquipAbility.ApplyEquip
// (Final, Native, Private)

void UDCEquipAbility::ApplyEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipAbility", "ApplyEquip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEquipAbility.OnEquipApplied
// (Final, Native, Private)

void UDCEquipAbility::OnEquipApplied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipAbility", "OnEquipApplied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEquipAbility.OnInterrupt
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UDCEquipAbility::OnInterrupt(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipAbility", "OnInterrupt");

	Params::DCEquipAbility_OnInterrupt Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEquipAbility.OnPrepared
// (Final, Native, Private)

void UDCEquipAbility::OnPrepared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipAbility", "OnPrepared");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEquipmentComponent.OnRep_EquipAnimData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCEquipAnimData                 OldEquipAnimData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCEquipmentComponent::OnRep_EquipAnimData(const struct FDCEquipAnimData& OldEquipAnimData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "OnRep_EquipAnimData");

	Params::DCEquipmentComponent_OnRep_EquipAnimData Parms{};

	Parms.OldEquipAnimData = std::move(OldEquipAnimData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEquipmentComponent.OnRep_EquipArmorInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCEquipArmorInfo                OldEquipArmorInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCEquipmentComponent::OnRep_EquipArmorInfo(const struct FDCEquipArmorInfo& OldEquipArmorInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "OnRep_EquipArmorInfo");

	Params::DCEquipmentComponent_OnRep_EquipArmorInfo Parms{};

	Parms.OldEquipArmorInfo = std::move(OldEquipArmorInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEquipmentComponent.OnRep_EquipHoldableInfos
// (Final, Native, Private)
// Parameters:
// TArray<struct FDCEquipHoldableInfo>     OldEquipHoldableInfo                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCEquipmentComponent::OnRep_EquipHoldableInfos(const TArray<struct FDCEquipHoldableInfo>& OldEquipHoldableInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "OnRep_EquipHoldableInfos");

	Params::DCEquipmentComponent_OnRep_EquipHoldableInfos Parms{};

	Parms.OldEquipHoldableInfo = std::move(OldEquipHoldableInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEquipmentComponent.OnRep_EquipHoldInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCEquipHoldInfo                 OldEquipHoldInfo                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCEquipmentComponent::OnRep_EquipHoldInfo(const struct FDCEquipHoldInfo& OldEquipHoldInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "OnRep_EquipHoldInfo");

	Params::DCEquipmentComponent_OnRep_EquipHoldInfo Parms{};

	Parms.OldEquipHoldInfo = std::move(OldEquipHoldInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEquipmentComponent.GetEquipHoldInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDCEquipHoldInfo           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDCEquipHoldInfo UDCEquipmentComponent::GetEquipHoldInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "GetEquipHoldInfo");

	Params::DCEquipmentComponent_GetEquipHoldInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEquipmentComponent.GetEquippedItemActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AItemActor*>               OutItemActors                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCEquipmentComponent::GetEquippedItemActors(TArray<class AItemActor*>* OutItemActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "GetEquippedItemActors");

	Params::DCEquipmentComponent_GetEquippedItemActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemActors != nullptr)
		*OutItemActors = std::move(Parms.OutItemActors);
}


// Function DungeonCrawler.DCEquipmentComponent.GetEquippedItemInfos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FDCItemInfo>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDCItemInfo> UDCEquipmentComponent::GetEquippedItemInfos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "GetEquippedItemInfos");

	Params::DCEquipmentComponent_GetEquippedItemInfos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEquipmentComponent.GetHoldingItemActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AItemActor*>               OutItemActors                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCEquipmentComponent::GetHoldingItemActors(TArray<class AItemActor*>* OutItemActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "GetHoldingItemActors");

	Params::DCEquipmentComponent_GetHoldingItemActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemActors != nullptr)
		*OutItemActors = std::move(Parms.OutItemActors);
}


// Function DungeonCrawler.DCEquipmentComponent.GetItemActorById
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDCItemId                        ItemId                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemActor*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemActor* UDCEquipmentComponent::GetItemActorById(const struct FDCItemId& ItemId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "GetItemActorById");

	Params::DCEquipmentComponent_GetItemActorById Parms{};

	Parms.ItemId = std::move(ItemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEquipmentComponent.GetItemActorBySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCEquipmentSlotIndex                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemActor*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemActor* UDCEquipmentComponent::GetItemActorBySlot(EDCEquipmentSlotIndex Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "GetItemActorBySlot");

	Params::DCEquipmentComponent_GetItemActorBySlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEquipmentComponent.GetItemInfoBySlot
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCEquipmentSlotIndex                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCItemInfo                      OutItemInfo                                            (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCEquipmentComponent::GetItemInfoBySlot(EDCEquipmentSlotIndex Slot, struct FDCItemInfo* OutItemInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentComponent", "GetItemInfoBySlot");

	Params::DCEquipmentComponent_GetItemInfoBySlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemInfo != nullptr)
		*OutItemInfo = std::move(Parms.OutItemInfo);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemSkinComponent.AddDataForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UDCItemSkinDataAsset*             InData                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCItemSkinComponent::AddDataForDebug_Server(const class UDCItemSkinDataAsset* InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemSkinComponent", "AddDataForDebug_Server");

	Params::DCItemSkinComponent_AddDataForDebug_Server Parms{};

	Parms.InData = InData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemSkinComponent.OnRep_Datas
// (Final, Native, Private)
// Parameters:
// TArray<class UDCItemSkinDataAsset*>     OldDatas                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCItemSkinComponent::OnRep_Datas(const TArray<class UDCItemSkinDataAsset*>& OldDatas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemSkinComponent", "OnRep_Datas");

	Params::DCItemSkinComponent_OnRep_Datas Parms{};

	Parms.OldDatas = std::move(OldDatas);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemSkinComponent.RemoveDataForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// struct FPrimaryAssetId                  ID                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCItemSkinComponent::RemoveDataForDebug_Server(const struct FPrimaryAssetId& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemSkinComponent", "RemoveDataForDebug_Server");

	Params::DCItemSkinComponent_RemoveDataForDebug_Server Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCEquipmentSlotWidget.GetEquipElapsedSeconds
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCEquipmentSlotWidget::GetEquipElapsedSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentSlotWidget", "GetEquipElapsedSeconds");

	Params::DCEquipmentSlotWidget_GetEquipElapsedSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEquipmentSlotWidget.GetEquipRemainSeconds
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCEquipmentSlotWidget::GetEquipRemainSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentSlotWidget", "GetEquipRemainSeconds");

	Params::DCEquipmentSlotWidget_GetEquipRemainSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEquipmentSlotWidget.IsPairSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCEquipmentSlotWidget::IsPairSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentSlotWidget", "IsPairSlot");

	Params::DCEquipmentSlotWidget_IsPairSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEquipmentSlotWidget.IsTwoHandedWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCEquipmentSlotWidget::IsTwoHandedWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentSlotWidget", "IsTwoHandedWeapon");

	Params::DCEquipmentSlotWidget_IsTwoHandedWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEquipmentSlotWidget.IsWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCEquipmentSlotWidget::IsWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentSlotWidget", "IsWeapon");

	Params::DCEquipmentSlotWidget_IsWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCEquipmentWidget.GetSlotWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCEquipmentSlotIndex                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCEquipmentSlotWidget*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCEquipmentSlotWidget* UDCEquipmentWidget::GetSlotWidget(EDCEquipmentSlotIndex Param_Index) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCEquipmentWidget", "GetSlotWidget");

	Params::DCEquipmentWidget_GetSlotWidget Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_ShapeShiftBase.AbilityActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_ShapeShiftBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ShapeShiftBase", "AbilityActivated");

	Params::GA_ShapeShiftBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ShapeShiftBase.OnShapeShiftBuffTagRemoved
// (Final, Native, Protected)
// Parameters:
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_ShapeShiftBase::OnShapeShiftBuffTagRemoved(int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ShapeShiftBase", "OnShapeShiftBuffTagRemoved");

	Params::GA_ShapeShiftBase_OnShapeShiftBuffTagRemoved Parms{};

	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCExpressmanStorageWidget.OnCalculationTotalPrice
// (Final, Native, Private)

void UDCExpressmanStorageWidget::OnCalculationTotalPrice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCExpressmanStorageWidget", "OnCalculationTotalPrice");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCFeatureUnlockRemainTimeWidget.OnAccountStatusUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDCAccountStatus                        InAccountStatus                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCFeatureUnlockRemainTimeWidget::OnAccountStatusUpdated(const EDCAccountStatus InAccountStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCFeatureUnlockRemainTimeWidget", "OnAccountStatusUpdated");

	Params::DCFeatureUnlockRemainTimeWidget_OnAccountStatusUpdated Parms{};

	Parms.InAccountStatus = InAccountStatus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCFeatureUnlockRemainTimeWidget.SetRemainTime
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimespan                        InRemainTime                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCFeatureUnlockRemainTimeWidget::SetRemainTime(const struct FTimespan& InRemainTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCFeatureUnlockRemainTimeWidget", "SetRemainTime");

	Params::DCFeatureUnlockRemainTimeWidget_SetRemainTime Parms{};

	Parms.InRemainTime = std::move(InRemainTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellBase.AbilityActivated_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    bIsSocketSightBlocked                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_SpellBase::AbilityActivated_BP(const struct FGameplayEventData& TriggerEventData, bool bIsSocketSightBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "AbilityActivated_BP");

	Params::GA_SpellBase_AbilityActivated_BP Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);
	Parms.bIsSocketSightBlocked = bIsSocketSightBlocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_SpellBase.CastToSelf
// (Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     OptionalEffectContainerTag                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_SpellBase::CastToSelf(const struct FGameplayTag& OptionalEffectContainerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "CastToSelf");

	Params::GA_SpellBase_CastToSelf Parms{};

	Parms.OptionalEffectContainerTag = std::move(OptionalEffectContainerTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellBase.CastToTarget
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OptionalEffectContainerTag                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGA_SpellBase::CastToTarget(const struct FHitResult& HitResult, const struct FGameplayTag& OptionalEffectContainerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "CastToTarget");

	Params::GA_SpellBase_CastToTarget Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.OptionalEffectContainerTag = std::move(OptionalEffectContainerTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_SpellBase.ExecuteSpellCastFireCue
// (Final, Native, Protected, BlueprintCallable)

void UGA_SpellBase::ExecuteSpellCastFireCue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "ExecuteSpellCastFireCue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellBase.FireProjectile
// (Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class AProjectileActor>     ProjectileActorClass                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProjectileActor*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AProjectileActor* UGA_SpellBase::FireProjectile(const struct FHitResult& HitResult, TSubclassOf<class AProjectileActor> ProjectileActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "FireProjectile");

	Params::GA_SpellBase_FireProjectile Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.ProjectileActorClass = ProjectileActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_SpellBase.OnCasted
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_SpellBase::OnCasted(class AActor* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "OnCasted");

	Params::GA_SpellBase_OnCasted Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellBase.GetAimRadius
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGA_SpellBase::GetAimRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "GetAimRadius");

	Params::GA_SpellBase_GetAimRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_SpellBase.GetAreaRadius
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGA_SpellBase::GetAreaRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "GetAreaRadius");

	Params::GA_SpellBase_GetAreaRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_SpellBase.GetDesignDataSpell
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDesignDataSpell                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataSpell UGA_SpellBase::GetDesignDataSpell() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "GetDesignDataSpell");

	Params::GA_SpellBase_GetDesignDataSpell Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_SpellBase.GetRange
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGA_SpellBase::GetRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "GetRange");

	Params::GA_SpellBase_GetRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_SpellBase.IsAreaInstall
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGA_SpellBase::IsAreaInstall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "IsAreaInstall");

	Params::GA_SpellBase_IsAreaInstall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_SpellBase.IsSightBlocked
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGA_SpellBase::IsSightBlocked(const struct FHitResult& HitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "IsSightBlocked");

	Params::GA_SpellBase_IsSightBlocked Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_SpellBase.IsSocketSightBlocked
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGA_SpellBase::IsSocketSightBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellBase", "IsSocketSightBlocked");

	Params::GA_SpellBase_IsSocketSightBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemTooltipRequirementWidget.IsEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCItemTooltipRequirementWidget::IsEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemTooltipRequirementWidget", "IsEmpty");

	Params::DCItemTooltipRequirementWidget_IsEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCFriendItemRecoveryPopup.OnOkButtonClicked
// (Final, Native, Private)

void UDCFriendItemRecoveryPopup::OnOkButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCFriendItemRecoveryPopup", "OnOkButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPortraitMessagePopupBase.OnOkButtonClicked
// (Final, Native, Private)

void UDCPortraitMessagePopupBase::OnOkButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPortraitMessagePopupBase", "OnOkButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCFriendItemRecoveryReceivePopup.OnDungeonRecoveryShortcutButtonClicked
// (Final, Native, Private)

void UDCFriendItemRecoveryReceivePopup::OnDungeonRecoveryShortcutButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCFriendItemRecoveryReceivePopup", "OnDungeonRecoveryShortcutButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ChangeIdle.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_ChangeIdle::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ChangeIdle", "AbilityActivated");

	Params::GA_ChangeIdle_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ChangeIdle.OnBlendOut
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ChangeIdle::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ChangeIdle", "OnBlendOut");

	Params::GA_ChangeIdle_OnBlendOut Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ChangeIdle.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ChangeIdle::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ChangeIdle", "OnCompleted");

	Params::GA_ChangeIdle_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TimerWidgetBase.OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgAccountLinkAccountDataReplicationNotifyInMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTimerWidgetBase::OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint(const struct FMsgAccountLinkAccountDataReplicationNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerWidgetBase", "OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint");

	Params::TimerWidgetBase_OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TimerWidgetBase.OnLeftHour
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimerWidgetBase::OnLeftHour(int32 NewValue, int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerWidgetBase", "OnLeftHour");

	Params::TimerWidgetBase_OnLeftHour Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.TimerWidgetBase.OnLeftMinute
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimerWidgetBase::OnLeftMinute(int32 NewValue, int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerWidgetBase", "OnLeftMinute");

	Params::TimerWidgetBase_OnLeftMinute Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.TimerWidgetBase.OnLeftSecond
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimerWidgetBase::OnLeftSecond(int32 NewValue, int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerWidgetBase", "OnLeftSecond");

	Params::TimerWidgetBase_OnLeftSecond Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.TimerWidgetBase.OnProgress
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimerWidgetBase::OnProgress(float NewValue, float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerWidgetBase", "OnProgress");

	Params::TimerWidgetBase_OnProgress Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.TimerWidgetBase.StartTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InEndServerWorldTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimerWidgetBase::StartTimer(float InEndServerWorldTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerWidgetBase", "StartTimer");

	Params::TimerWidgetBase_StartTimer Parms{};

	Parms.InEndServerWorldTime = InEndServerWorldTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameInstance.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameInstance::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameInstance", "BroadcastMsgBlueprint");

	Params::DCGameInstance_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameInstance.OnPostLoadMapWithWorld
// (Final, Native, Private)
// Parameters:
// class UWorld*                           LoadedWorld                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameInstance::OnPostLoadMapWithWorld(class UWorld* LoadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameInstance", "OnPostLoadMapWithWorld");

	Params::DCGameInstance_OnPostLoadMapWithWorld Parms{};

	Parms.LoadedWorld = LoadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameInstance.OnPreLoadMap
// (Final, Native, Private)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameInstance::OnPreLoadMap(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameInstance", "OnPreLoadMap");

	Params::DCGameInstance_OnPreLoadMap Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameInstance.TerminateBase
// (Native, Public)

void UDCGameInstance::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameInstance", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameInstance.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameInstance::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameInstance", "UnbindMsg");

	Params::DCGameInstance_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameInstance.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameInstance::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameInstance", "UnbindMsgAll");

	Params::DCGameInstance_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_DrawbridgeWheel.AbilityActivated
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_DrawbridgeWheel::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_DrawbridgeWheel", "AbilityActivated");

	Params::GA_DrawbridgeWheel_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_DrawbridgeWheel.OnBlendOut
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_DrawbridgeWheel::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_DrawbridgeWheel", "OnBlendOut");

	Params::GA_DrawbridgeWheel_OnBlendOut Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_DrawbridgeWheel.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_DrawbridgeWheel::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_DrawbridgeWheel", "OnCompleted");

	Params::GA_DrawbridgeWheel_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameObjectLinkComponent.BroadcastGlobalEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FObjectLinkGlobalEvent           InGlobalEvent                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDCGameObjectLinkComponent::BroadcastGlobalEvent(const struct FObjectLinkGlobalEvent& InGlobalEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameObjectLinkComponent", "BroadcastGlobalEvent");

	Params::DCGameObjectLinkComponent_BroadcastGlobalEvent Parms{};

	Parms.InGlobalEvent = std::move(InGlobalEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameObjectLinkComponent.IsLinkerSet
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCGameObjectLinkComponent::IsLinkerSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameObjectLinkComponent", "IsLinkerSet");

	Params::DCGameObjectLinkComponent_IsLinkerSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameObjectLinkComponent.RequestToLinkers
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FObjectLinkRequestEvent          ObjectLinkRequestEvent                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FObjectLinkResponeEvent>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FObjectLinkResponeEvent> UDCGameObjectLinkComponent::RequestToLinkers(struct FObjectLinkRequestEvent& ObjectLinkRequestEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameObjectLinkComponent", "RequestToLinkers");

	Params::DCGameObjectLinkComponent_RequestToLinkers Parms{};

	Parms.ObjectLinkRequestEvent = std::move(ObjectLinkRequestEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ObjectLinkRequestEvent = std::move(Parms.ObjectLinkRequestEvent);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCUIFadeEffectWidget.FindParentActivatableWidget
// (Final, Native, Private)
// Parameters:
// class UDCCommonActivatableWidgetBase*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCCommonActivatableWidgetBase* UDCUIFadeEffectWidget::FindParentActivatableWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCUIFadeEffectWidget", "FindParentActivatableWidget");

	Params::DCUIFadeEffectWidget_FindParentActivatableWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCUIFadeEffectWidget.OnActiveEffectPanelVisibilityChanged
// (Final, Native, Private)
// Parameters:
// ESlateVisibility                        NewVisibility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCUIFadeEffectWidget::OnActiveEffectPanelVisibilityChanged(ESlateVisibility NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCUIFadeEffectWidget", "OnActiveEffectPanelVisibilityChanged");

	Params::DCUIFadeEffectWidget_OnActiveEffectPanelVisibilityChanged Parms{};

	Parms.NewVisibility = NewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayTagCollider.OnOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADCGameplayTagCollider::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayTagCollider", "OnOverlapBegin");

	Params::DCGameplayTagCollider_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayTagCollider.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameplayTagCollider::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayTagCollider", "OnOverlapEnd");

	Params::DCGameplayTagCollider_OnOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayTagCollider.OnOverlapping
// (Final, Native, Private)

void ADCGameplayTagCollider::OnOverlapping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayTagCollider", "OnOverlapping");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameplayTagCollider.OnRep_TargetAccountId
// (Final, Native, Private)
// Parameters:
// class FString                           InOldTargetAccountId                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCGameplayTagCollider::OnRep_TargetAccountId(const class FString& InOldTargetAccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameplayTagCollider", "OnRep_TargetAccountId");

	Params::DCGameplayTagCollider_OnRep_TargetAccountId Parms{};

	Parms.InOldTargetAccountId = std::move(InOldTargetAccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DescData.GetDescription
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDescDataParam*                   InDescDataParam                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FText>                     OutDescTextArray                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDescData::GetDescription(const class UDescDataParam* InDescDataParam, TArray<class FText>* OutDescTextArray) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescData", "GetDescription");

	Params::DescData_GetDescription Parms{};

	Parms.InDescDataParam = InDescDataParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDescTextArray != nullptr)
		*OutDescTextArray = std::move(Parms.OutDescTextArray);
}


// Function DungeonCrawler.DescData.GetExecImpactPower
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDescDataParam*                   InDescDataParam                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDescData::GetExecImpactPower(const class UDescDataParam* InDescDataParam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DescData", "GetExecImpactPower");

	Params::DescData_GetExecImpactPower Parms{};

	Parms.InDescDataParam = InDescDataParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCGameSpawnableComponent.OnRep_bCastShadows
// (Final, Native, Private)
// Parameters:
// bool                                    bOldCastShadows                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCGameSpawnableComponent::OnRep_bCastShadows(bool bOldCastShadows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSpawnableComponent", "OnRep_bCastShadows");

	Params::DCGameSpawnableComponent_OnRep_bCastShadows Parms{};

	Parms.bOldCastShadows = bOldCastShadows;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameSpawnerGroup.OnRep_ClientDestroyActorNameArray
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class FString>                   OldClientDestroyActorNameArray                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADCGameSpawnerGroup::OnRep_ClientDestroyActorNameArray(const TArray<class FString>& OldClientDestroyActorNameArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameSpawnerGroup", "OnRep_ClientDestroyActorNameArray");

	Params::DCGameSpawnerGroup_OnRep_ClientDestroyActorNameArray Parms{};

	Parms.OldClientDestroyActorNameArray = std::move(OldClientDestroyActorNameArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCGameUserSettings.GetInputConfigByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ConfigName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UPlayerMappableInputConfig* ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UPlayerMappableInputConfig* UDCGameUserSettings::GetInputConfigByName(class FName ConfigName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGameUserSettings", "GetInputConfigByName");

	Params::DCGameUserSettings_GetInputConfigByName Parms{};

	Parms.ConfigName = ConfigName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCSkeletalMeshComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSkeletalMeshComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSkeletalMeshComponent", "BroadcastMsgBlueprint");

	Params::DCSkeletalMeshComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSkeletalMeshComponent.SetAffectNavigation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bRelevant                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSkeletalMeshComponent::SetAffectNavigation(bool bRelevant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSkeletalMeshComponent", "SetAffectNavigation");

	Params::DCSkeletalMeshComponent_SetAffectNavigation Parms{};

	Parms.bRelevant = bRelevant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSkeletalMeshComponent.TerminateBase
// (Native, Public)

void UDCSkeletalMeshComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSkeletalMeshComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSkeletalMeshComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSkeletalMeshComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSkeletalMeshComponent", "UnbindMsg");

	Params::DCSkeletalMeshComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSkeletalMeshComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSkeletalMeshComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSkeletalMeshComponent", "UnbindMsgAll");

	Params::DCSkeletalMeshComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionConvetCompletePopup.OnConfirmButtonClicked
// (Final, Native, Private)

void UDCReligionConvetCompletePopup::OnConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionConvetCompletePopup", "OnConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionConvetCompletePopup.SetReligionImageEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FSlateBrush                      Bursh                                                  (Parm, NativeAccessSpecifierPublic)

void UDCReligionConvetCompletePopup::SetReligionImageEvent(const struct FSlateBrush& Bursh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionConvetCompletePopup", "SetReligionImageEvent");

	Params::DCReligionConvetCompletePopup_SetReligionImageEvent Parms{};

	Parms.Bursh = std::move(Bursh);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCGiftCodeRewardPopupBase.OnConfirmButtonClicked
// (Final, Native, Private)

void UDCGiftCodeRewardPopupBase::OnConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCGiftCodeRewardPopupBase", "OnConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionOfferingCompletePopup.OnConfirmButtonClicked
// (Final, Native, Private)

void UDCReligionOfferingCompletePopup::OnConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionOfferingCompletePopup", "OnConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInGameQuestLog.OnQuestLogVisibilityChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsEmpty                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCInGameQuestLog::OnQuestLogVisibilityChange(bool bIsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInGameQuestLog", "OnQuestLogVisibilityChange");

	Params::DCInGameQuestLog_OnQuestLogVisibilityChange Parms{};

	Parms.bIsEmpty = bIsEmpty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCTradePhaseConfirmWidget.OnBeginTradeConfirm
// (Event, Protected, BlueprintEvent)

void UDCTradePhaseConfirmWidget::OnBeginTradeConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradePhaseConfirmWidget", "OnBeginTradeConfirm");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCTradePhaseConfirmWidget.OnCancelTradeButtonClicked
// (Final, Native, Private)

void UDCTradePhaseConfirmWidget::OnCancelTradeButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradePhaseConfirmWidget", "OnCancelTradeButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTradePhaseConfirmWidget.OnLocalTraderCheckBoxStateChanged
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    bIsChecked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCTradePhaseConfirmWidget::OnLocalTraderCheckBoxStateChanged(bool bIsChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradePhaseConfirmWidget", "OnLocalTraderCheckBoxStateChanged");

	Params::DCTradePhaseConfirmWidget_OnLocalTraderCheckBoxStateChanged Parms{};

	Parms.bIsChecked = bIsChecked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTradePhaseConfirmWidget.OnResponseLocalTraderConfirmRequestResult
// (Final, Native, Private)
// Parameters:
// bool                                    bRequestSucceed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCTradePhaseConfirmWidget::OnResponseLocalTraderConfirmRequestResult(bool bRequestSucceed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradePhaseConfirmWidget", "OnResponseLocalTraderConfirmRequestResult");

	Params::DCTradePhaseConfirmWidget_OnResponseLocalTraderConfirmRequestResult Parms{};

	Parms.bRequestSucceed = bRequestSucceed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInputNumberWidget.ManualClick
// (Final, Native, Protected, BlueprintCallable)

void UDCInputNumberWidget::ManualClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInputNumberWidget", "ManualClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInputNumberWidget.OnAccepted
// (Final, Native, Private)

void UDCInputNumberWidget::OnAccepted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInputNumberWidget", "OnAccepted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInputNumberWidget.OnCancelled
// (Final, Native, Private)

void UDCInputNumberWidget::OnCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInputNumberWidget", "OnCancelled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInputNumberWidget.IsValidText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCInputNumberWidget::IsValidText(const class FText& Text) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInputNumberWidget", "IsValidText");

	Params::DCInputNumberWidget_IsValidText Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCTrainingOptionSlotWidgetBase.OnActive
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Delay                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCTrainingOptionSlotWidgetBase::OnActive(const float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingOptionSlotWidgetBase", "OnActive");

	Params::DCTrainingOptionSlotWidgetBase_OnActive Parms{};

	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCTrainingOptionSlotWidgetBase.OnAnyOptionSelected
// (Event, Public, BlueprintEvent)

void UDCTrainingOptionSlotWidgetBase::OnAnyOptionSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingOptionSlotWidgetBase", "OnAnyOptionSelected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCTrainingOptionSlotWidgetBase.OnClear
// (Event, Protected, BlueprintEvent)

void UDCTrainingOptionSlotWidgetBase::OnClear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingOptionSlotWidgetBase", "OnClear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCTrainingOptionSlotWidgetBase.OnClicked
// (Final, Native, Protected)

void UDCTrainingOptionSlotWidgetBase::OnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingOptionSlotWidgetBase", "OnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryComponent.AddItemData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCInventoryComponent::AddItemData(const struct FItemData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryComponent", "AddItemData");

	Params::DCInventoryComponent_AddItemData Parms{};

	Parms.ItemData = std::move(ItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCInventoryComponent.AddItemDatas
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EDCInventoryId                          InventoryId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FItemData>                ItemDatas                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCInventoryComponent::AddItemDatas(EDCInventoryId InventoryId, const TArray<struct FItemData>& ItemDatas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryComponent", "AddItemDatas");

	Params::DCInventoryComponent_AddItemDatas Parms{};

	Parms.InventoryId = InventoryId;
	Parms.ItemDatas = std::move(ItemDatas);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCInventoryComponent.AddItemDataToInventory
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EDCInventoryId                          InventoryId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCInventoryComponent::AddItemDataToInventory(EDCInventoryId InventoryId, const struct FItemData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryComponent", "AddItemDataToInventory");

	Params::DCInventoryComponent_AddItemDataToInventory Parms{};

	Parms.InventoryId = InventoryId;
	Parms.ItemData = std::move(ItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCInventoryComponent.ClearInventoryItems
// (Final, Native, Public, BlueprintCallable)

void UDCInventoryComponent::ClearInventoryItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryComponent", "ClearInventoryItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryComponent.InitExpandableBox
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EDCInventoryId                          InventoryId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FItemData>                ItemDatas                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCInventoryComponent::InitExpandableBox(EDCInventoryId InventoryId, const TArray<struct FItemData>& ItemDatas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryComponent", "InitExpandableBox");

	Params::DCInventoryComponent_InitExpandableBox Parms{};

	Parms.InventoryId = InventoryId;
	Parms.ItemDatas = std::move(ItemDatas);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCInventoryComponent.AddSoulHeart_Temp
// (Final, Native, Public, BlueprintCallable, Const)

void UDCInventoryComponent::AddSoulHeart_Temp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryComponent", "AddSoulHeart_Temp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryComponent.PlayItemSoundClient
// (Net, NetReliable, Native, Event, Public, NetClient, Const)
// Parameters:
// struct FDCItemInfo                      Item                                                   (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCInventoryComponent::PlayItemSoundClient(const struct FDCItemInfo& Item, const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryComponent", "PlayItemSoundClient");

	Params::DCInventoryComponent_PlayItemSoundClient Parms{};

	Parms.Item = std::move(Item);
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryComponent.PlayItemSoundNetMulticast
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, Const)
// Parameters:
// struct FDCItemInfo                      Item                                                   (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCInventoryComponent::PlayItemSoundNetMulticast(const struct FDCItemInfo& Item, const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryComponent", "PlayItemSoundNetMulticast");

	Params::DCInventoryComponent_PlayItemSoundNetMulticast Parms{};

	Parms.Item = std::move(Item);
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventoryComponent.PlayItemSoundServer
// (Net, NetReliable, Native, Event, Public, NetServer, Const)
// Parameters:
// struct FDCItemInfo                      Item                                                   (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCInventoryComponent::PlayItemSoundServer(const struct FDCItemInfo& Item, const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryComponent", "PlayItemSoundServer");

	Params::DCInventoryComponent_PlayItemSoundServer Parms{};

	Parms.Item = std::move(Item);
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCInventorySetWidget.OnPurchaseConfirm
// (Event, Protected, BlueprintEvent)

void UDCInventorySetWidget::OnPurchaseConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventorySetWidget", "OnPurchaseConfirm");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCShowingKeyWidgetBase.HandleInputMethodChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// ECommonInputType                        InInputType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCShowingKeyWidgetBase::HandleInputMethodChanged(ECommonInputType InInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShowingKeyWidgetBase", "HandleInputMethodChanged");

	Params::DCShowingKeyWidgetBase_HandleInputMethodChanged Parms{};

	Parms.InInputType = InInputType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCShowingKeyWidgetBase.OnInputBindChanged
// (Event, Protected, BlueprintEvent)

void UDCShowingKeyWidgetBase::OnInputBindChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShowingKeyWidgetBase", "OnInputBindChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCItemActorBase.OnRep_ArtData
// (Final, Native, Protected)
// Parameters:
// class UArtDataItem*                     OldArtData                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCItemActorBase::OnRep_ArtData(class UArtDataItem* OldArtData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "OnRep_ArtData");

	Params::DCItemActorBase_OnRep_ArtData Parms{};

	Parms.OldArtData = OldArtData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemActorBase.OnRep_ItemInfo
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FDCItemInfo                      OldItemInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCItemActorBase::OnRep_ItemInfo(const struct FDCItemInfo& OldItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "OnRep_ItemInfo");

	Params::DCItemActorBase_OnRep_ItemInfo Parms{};

	Parms.OldItemInfo = std::move(OldItemInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemActorBase.GetIdTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ADCItemActorBase::GetIdTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "GetIdTag");

	Params::DCItemActorBase_GetIdTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.GetItemArtData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   WaitAsyncLoadingSeconds                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArtDataItem*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArtDataItem* ADCItemActorBase::GetItemArtData(const float WaitAsyncLoadingSeconds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "GetItemArtData");

	Params::DCItemActorBase_GetItemArtData Parms{};

	Parms.WaitAsyncLoadingSeconds = WaitAsyncLoadingSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.GetItemInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDCItemInfo                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FDCItemInfo ADCItemActorBase::GetItemInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "GetItemInfo");

	Params::DCItemActorBase_GetItemInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.GetItemUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 ADCItemActorBase::GetItemUniqueId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "GetItemUniqueId");

	Params::DCItemActorBase_GetItemUniqueId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.GetRarity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ADCItemActorBase::GetRarity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "GetRarity");

	Params::DCItemActorBase_GetRarity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.GetSlotType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ADCItemActorBase::GetSlotType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "GetSlotType");

	Params::DCItemActorBase_GetSlotType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.GetUtilityType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ADCItemActorBase::GetUtilityType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "GetUtilityType");

	Params::DCItemActorBase_GetUtilityType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.GetWeaponTypes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> ADCItemActorBase::GetWeaponTypes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "GetWeaponTypes");

	Params::DCItemActorBase_GetWeaponTypes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.IsShield
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCItemActorBase::IsShield() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "IsShield");

	Params::DCItemActorBase_IsShield Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.IsSoulHeart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCItemActorBase::IsSoulHeart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "IsSoulHeart");

	Params::DCItemActorBase_IsSoulHeart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.IsUtility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCItemActorBase::IsUtility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "IsUtility");

	Params::DCItemActorBase_IsUtility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.IsWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCItemActorBase::IsWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "IsWeapon");

	Params::DCItemActorBase_IsWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemActorBase.IsWeaponSlotEquippable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCItemActorBase::IsWeaponSlotEquippable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemActorBase", "IsWeaponSlotEquippable");

	Params::DCItemActorBase_IsWeaponSlotEquippable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameEmoteSlotWidget.OnReset
// (Event, Protected, BlueprintEvent)

void UGameEmoteSlotWidget::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEmoteSlotWidget", "OnReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameEmoteSlotWidget.OnSelectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEmoteSlotWidget::OnSelectionChanged(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEmoteSlotWidget", "OnSelectionChanged");

	Params::GameEmoteSlotWidget_OnSelectionChanged Parms{};

	Parms.bIsSelected = bIsSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameEmoteSlotWidget.OnSetEmoteArtData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UArtDataEmote*                    InArtEmoteData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEmoteSlotWidget::OnSetEmoteArtData(const class UArtDataEmote* InArtEmoteData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEmoteSlotWidget", "OnSetEmoteArtData");

	Params::GameEmoteSlotWidget_OnSetEmoteArtData Parms{};

	Parms.InArtEmoteData = InArtEmoteData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameEmoteSlotWidget.Reset
// (Final, Native, Public)

void UGameEmoteSlotWidget::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEmoteSlotWidget", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameEmoteSlotWidget.SelectionChange
// (Final, Native, Public)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEmoteSlotWidget::SelectionChange(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEmoteSlotWidget", "SelectionChange");

	Params::GameEmoteSlotWidget_SelectionChange Parms{};

	Parms.bIsSelected = bIsSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameEmoteSlotWidget.SetEmoteData
// (Final, Native, Public)
// Parameters:
// class UDCEmoteDataAsset*                InDesignDataEmote                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEmoteSlotWidget::SetEmoteData(const class UDCEmoteDataAsset* InDesignDataEmote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEmoteSlotWidget", "SetEmoteData");

	Params::GameEmoteSlotWidget_SetEmoteData Parms{};

	Parms.InDesignDataEmote = InDesignDataEmote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameInventoryGroupWidget.OnItemDrop
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FItemData                        ItemData                                               (Parm, NativeAccessSpecifierPublic)
// class AActor*                           OldOwnerActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInventoryGroupWidget::OnItemDrop(const struct FItemData& ItemData, class AActor* OldOwnerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInventoryGroupWidget", "OnItemDrop");

	Params::GameInventoryGroupWidget_OnItemDrop Parms{};

	Parms.ItemData = std::move(ItemData);
	Parms.OldOwnerActor = OldOwnerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameInventoryGroupWidget.OnItemDropOne
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FItemData                        ItemData                                               (Parm, NativeAccessSpecifierPublic)
// class AActor*                           OldOwnerActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInventoryGroupWidget::OnItemDropOne(const struct FItemData& ItemData, class AActor* OldOwnerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInventoryGroupWidget", "OnItemDropOne");

	Params::GameInventoryGroupWidget_OnItemDropOne Parms{};

	Parms.ItemData = std::move(ItemData);
	Parms.OldOwnerActor = OldOwnerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameInventoryGroupWidget.OnPopItemSelectWidget
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FItemData                        ItemData                                               (Parm, NativeAccessSpecifierPublic)
// class AActor*                           OldOwnerActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInventoryGroupWidget::OnPopItemSelectWidget(const struct FItemData& ItemData, class AActor* OldOwnerActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInventoryGroupWidget", "OnPopItemSelectWidget");

	Params::GameInventoryGroupWidget_OnPopItemSelectWidget Parms{};

	Parms.ItemData = std::move(ItemData);
	Parms.OldOwnerActor = OldOwnerActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemSwitchAbilityBase.OnCharacterMontageEventReceived
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UDCItemSwitchAbilityBase::OnCharacterMontageEventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemSwitchAbilityBase", "OnCharacterMontageEventReceived");

	Params::DCItemSwitchAbilityBase_OnCharacterMontageEventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemSwitchAbilityBase.OnCharacterMontageFinished
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UDCItemSwitchAbilityBase::OnCharacterMontageFinished(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemSwitchAbilityBase", "OnCharacterMontageFinished");

	Params::DCItemSwitchAbilityBase_OnCharacterMontageFinished Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemSwitchAbilityBase.OnCharacterMontageInterrupted
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UDCItemSwitchAbilityBase::OnCharacterMontageInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemSwitchAbilityBase", "OnCharacterMontageInterrupted");

	Params::DCItemSwitchAbilityBase_OnCharacterMontageInterrupted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemTooltipStatWidget.IsEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCItemTooltipStatWidget::IsEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemTooltipStatWidget", "IsEmpty");

	Params::DCItemTooltipStatWidget_IsEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemTooltipAbilityWidget.IsEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCItemTooltipAbilityWidget::IsEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemTooltipAbilityWidget", "IsEmpty");

	Params::DCItemTooltipAbilityWidget_IsEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemTooltipRequiredAttributeEntryWidget.CanEquipByRequiredAttribute
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCItemTooltipRequiredAttributeEntryWidget::CanEquipByRequiredAttribute() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemTooltipRequiredAttributeEntryWidget", "CanEquipByRequiredAttribute");

	Params::DCItemTooltipRequiredAttributeEntryWidget_CanEquipByRequiredAttribute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemTooltipRequiredAttributeEntryWidget.GetRequiredAttributeType
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemRequirementType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EItemRequirementType UDCItemTooltipRequiredAttributeEntryWidget::GetRequiredAttributeType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemTooltipRequiredAttributeEntryWidget", "GetRequiredAttributeType");

	Params::DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCItemTooltipRequiredAttributeEntryWidget.GetRequiredAttributeValue
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCItemTooltipRequiredAttributeEntryWidget::GetRequiredAttributeValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemTooltipRequiredAttributeEntryWidget", "GetRequiredAttributeValue");

	Params::DCItemTooltipRequiredAttributeEntryWidget_GetRequiredAttributeValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCSpawnPoolComponent.Rent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APropsActorBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APropsActorBase* UDCSpawnPoolComponent::Rent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSpawnPoolComponent", "Rent");

	Params::DCSpawnPoolComponent_Rent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCSpawnPoolComponent.Return
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APropsActorBase*                  RentedPropActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSpawnPoolComponent::Return(class APropsActorBase* RentedPropActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSpawnPoolComponent", "Return");

	Params::DCSpawnPoolComponent_Return Parms{};

	Parms.RentedPropActor = RentedPropActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSpellWidgetBase.GetSpellTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCSpellWidgetBase::GetSpellTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSpellWidgetBase", "GetSpellTooltipWidget");

	Params::DCSpellWidgetBase_GetSpellTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCSpellWidgetBase.OnArtDataSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UArtDataSpell*                    ArtData                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSpellWidgetBase::OnArtDataSet(const class UArtDataSpell* ArtData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSpellWidgetBase", "OnArtDataSet");

	Params::DCSpellWidgetBase_OnArtDataSet Parms{};

	Parms.ArtData = ArtData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCSpellWidgetBase.OnReset
// (Event, Protected, BlueprintEvent)

void UDCSpellWidgetBase::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSpellWidgetBase", "OnReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCTabListWidgetBase.ActivateFirstSelectableTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCTabListWidgetBase::ActivateFirstSelectableTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTabListWidgetBase", "ActivateFirstSelectableTab");

	Params::DCTabListWidgetBase_ActivateFirstSelectableTab Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCTabListWidgetBase.OnTabButtonSelected
// (Final, Native, Private)
// Parameters:
// class FName                             TabId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCTabListWidgetBase::OnTabButtonSelected(class FName TabId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTabListWidgetBase", "OnTabButtonSelected");

	Params::DCTabListWidgetBase_OnTabButtonSelected Parms{};

	Parms.TabId = TabId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTargetType.GetTargets
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class AActor*                           TargetingOwnerActor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetingAvatarActor                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHitResults                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDCTargetType::GetTargets(class AActor* TargetingOwnerActor, class AActor* TargetingAvatarActor, const struct FGameplayEventData& EventData, TArray<struct FHitResult>* OutHitResults, TArray<class AActor*>* OutActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTargetType", "GetTargets");

	Params::DCTargetType_GetTargets Parms{};

	Parms.TargetingOwnerActor = TargetingOwnerActor;
	Parms.TargetingAvatarActor = TargetingAvatarActor;
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResults != nullptr)
		*OutHitResults = std::move(Parms.OutHitResults);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function DungeonCrawler.DCKillLogItemWidgetBase.OnSetAnnounce
// (Event, Protected, BlueprintEvent)

void UDCKillLogItemWidgetBase::OnSetAnnounce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCKillLogItemWidgetBase", "OnSetAnnounce");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCKillLogItemWidgetBase.OnSetFloorLog
// (Event, Protected, BlueprintEvent)

void UDCKillLogItemWidgetBase::OnSetFloorLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCKillLogItemWidgetBase", "OnSetFloorLog");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCKillLogItemWidgetBase.OnSetKillLog
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsHitHead                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCKillLogItemWidgetBase::OnSetKillLog(bool bIsHitHead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCKillLogItemWidgetBase", "OnSetKillLog");

	Params::DCKillLogItemWidgetBase_OnSetKillLog Parms{};

	Parms.bIsHitHead = bIsHitHead;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.EmoteComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmoteComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "BroadcastMsgBlueprint");

	Params::EmoteComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EmoteComponent.OnRep_EmoteSlotInfoArray
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FDCEmoteSlotInfo>         OldEmoteSlotInfoArray                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UEmoteComponent::OnRep_EmoteSlotInfoArray(const TArray<struct FDCEmoteSlotInfo>& OldEmoteSlotInfoArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "OnRep_EmoteSlotInfoArray");

	Params::EmoteComponent_OnRep_EmoteSlotInfoArray Parms{};

	Parms.OldEmoteSlotInfoArray = std::move(OldEmoteSlotInfoArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EmoteComponent.TerminateBase
// (Native, Public)

void UEmoteComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EmoteComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmoteComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "UnbindMsg");

	Params::EmoteComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EmoteComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmoteComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "UnbindMsgAll");

	Params::EmoteComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCKnightLinkWidgetBase.OnClickedKnightLink
// (Final, Native, Protected, BlueprintCallable)

void UDCKnightLinkWidgetBase::OnClickedKnightLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCKnightLinkWidgetBase", "OnClickedKnightLink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCKnightLinkWidgetBase.OnGameUserSettingControlsChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameUserSettingControls         InGameUserSettingControls                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameUserSettingControls         InOldGameUserSettingControls                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCKnightLinkWidgetBase::OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCKnightLinkWidgetBase", "OnGameUserSettingControlsChanged");

	Params::DCKnightLinkWidgetBase_OnGameUserSettingControlsChanged Parms{};

	Parms.InGameUserSettingControls = std::move(InGameUserSettingControls);
	Parms.InOldGameUserSettingControls = std::move(InOldGameUserSettingControls);
	Parms.bInForce = bInForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryComponent.AddContainingItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FItemData                        ItemData                                               (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryComponent::AddContainingItem(const struct FItemData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "AddContainingItem");

	Params::InventoryComponent_AddContainingItem Parms{};

	Parms.ItemData = std::move(ItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InventoryComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "BroadcastMsgBlueprint");

	Params::InventoryComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryComponent.ClientShowMessage
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// class FText                             OutputMessage                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UInventoryComponent::ClientShowMessage(const class FText& OutputMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "ClientShowMessage");

	Params::InventoryComponent_ClientShowMessage Parms{};

	Parms.OutputMessage = std::move(OutputMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryComponent.OnRep_ContainingItems
// (Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FItemData>                OldContainingItems                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInventoryComponent::OnRep_ContainingItems(const TArray<struct FItemData>& OldContainingItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "OnRep_ContainingItems");

	Params::InventoryComponent_OnRep_ContainingItems Parms{};

	Parms.OldContainingItems = std::move(OldContainingItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryComponent.OnRep_TotalGoldCount
// (Native, Protected)
// Parameters:
// int64                                   OldTotalGoldCount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::OnRep_TotalGoldCount(int64 OldTotalGoldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "OnRep_TotalGoldCount");

	Params::InventoryComponent_OnRep_TotalGoldCount Parms{};

	Parms.OldTotalGoldCount = OldTotalGoldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryComponent.TerminateBase
// (Native, Public)

void UInventoryComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "UnbindMsg");

	Params::InventoryComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "UnbindMsgAll");

	Params::InventoryComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryComponent.GetInventoryType
// (Final, Native, Public, Const)
// Parameters:
// EInventoryType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInventoryType UInventoryComponent::GetInventoryType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetInventoryType");

	Params::InventoryComponent_GetInventoryType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InventoryComponent.GetItemByItemUniqueId
// (Final, Native, Public, Const)
// Parameters:
// int64                                   InItemUniqueId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItem*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItem* UInventoryComponent::GetItemByItemUniqueId(int64 InItemUniqueId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryComponent", "GetItemByItemUniqueId");

	Params::InventoryComponent_GetItemByItemUniqueId Parms{};

	Parms.InItemUniqueId = InItemUniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLeaderboardDataAsset.GetNextLeaderboardRankData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDCLeaderboardRankDataAsset*      InLeaderboardRankData                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDCLeaderboardRankDataAsset*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDCLeaderboardRankDataAsset* UDCLeaderboardDataAsset::GetNextLeaderboardRankData(const class UDCLeaderboardRankDataAsset* InLeaderboardRankData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLeaderboardDataAsset", "GetNextLeaderboardRankData");

	Params::DCLeaderboardDataAsset_GetNextLeaderboardRankData Parms{};

	Parms.InLeaderboardRankData = InLeaderboardRankData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.FloorRuleInterface.BindFloorRuleDataDelegate
// (Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGameFloorRuleData& InFloorRuleData)>InBindDelegate                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFloorRuleInterface::BindFloorRuleDataDelegate(TDelegate<void(struct FGameFloorRuleData& InFloorRuleData)> InBindDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FloorRuleInterface", "BindFloorRuleDataDelegate");

	Params::FloorRuleInterface_BindFloorRuleDataDelegate Parms{};

	Parms.InBindDelegate = InBindDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.FloorRuleInterface.BindFloorRuleFinishedDelegate
// (Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       InBindDelegate                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFloorRuleInterface::BindFloorRuleFinishedDelegate(TDelegate<void()> InBindDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FloorRuleInterface", "BindFloorRuleFinishedDelegate");

	Params::FloorRuleInterface_BindFloorRuleFinishedDelegate Parms{};

	Parms.InBindDelegate = InBindDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.FloorRuleInterface.UnbindFloorRuleDataDelegate
// (Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InBoundObject                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFloorRuleInterface::UnbindFloorRuleDataDelegate(class UObject* InBoundObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FloorRuleInterface", "UnbindFloorRuleDataDelegate");

	Params::FloorRuleInterface_UnbindFloorRuleDataDelegate Parms{};

	Parms.InBoundObject = InBoundObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.FloorRuleInterface.GetFloorRuleData
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameFloorRuleData               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameFloorRuleData IFloorRuleInterface::GetFloorRuleData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FloorRuleInterface", "GetFloorRuleData");

	Params::FloorRuleInterface_GetFloorRuleData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.FloorRuleInterface.LogHandleFloorRuleData
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          InHandler                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameFloorRuleData               InFloorRuleData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IFloorRuleInterface::LogHandleFloorRuleData(const class UObject* InHandler, const struct FGameFloorRuleData& InFloorRuleData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FloorRuleInterface", "LogHandleFloorRuleData");

	Params::FloorRuleInterface_LogHandleFloorRuleData Parms{};

	Parms.InHandler = InHandler;
	Parms.InFloorRuleData = std::move(InFloorRuleData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLearningTokensWidgetBase.OnCharacterTileViewSelectionChanged
// (Final, Native, Private)
// Parameters:
// class UObject*                          Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCLearningTokensWidgetBase::OnCharacterTileViewSelectionChanged(class UObject* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLearningTokensWidgetBase", "OnCharacterTileViewSelectionChanged");

	Params::DCLearningTokensWidgetBase_OnCharacterTileViewSelectionChanged Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLearningTokensWidgetBase.OnClickRedeemButton
// (Final, Native, Private)

void UDCLearningTokensWidgetBase::OnClickRedeemButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLearningTokensWidgetBase", "OnClickRedeemButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLearningTokensWidgetBase.GetSelectedCharacterNickname
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FNickname                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNickname UDCLearningTokensWidgetBase::GetSelectedCharacterNickname() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLearningTokensWidgetBase", "GetSelectedCharacterNickname");

	Params::DCLearningTokensWidgetBase_GetSelectedCharacterNickname Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLearningTokensWidgetBase.GetSelectedClassText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCLearningTokensWidgetBase::GetSelectedClassText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLearningTokensWidgetBase", "GetSelectedClassText");

	Params::DCLearningTokensWidgetBase_GetSelectedClassText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLearningTokensWidgetBase.IsMasterSelected
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCLearningTokensWidgetBase::IsMasterSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLearningTokensWidgetBase", "IsMasterSelected");

	Params::DCLearningTokensWidgetBase_IsMasterSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLegendaryStatusPopup.Close
// (Final, Native, Private)

void UDCLegendaryStatusPopup::Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLegendaryStatusPopup", "Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLegendaryStatusPopup.OnSetAccountStatus
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// EDCAccountStatus                        InAccountStatus                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCLegendaryStatusPopup::OnSetAccountStatus(const EDCAccountStatus& InAccountStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLegendaryStatusPopup", "OnSetAccountStatus");

	Params::DCLegendaryStatusPopup_OnSetAccountStatus Parms{};

	Parms.InAccountStatus = InAccountStatus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCLegendaryStatusPopup.OnSetAccountStatusUpgradeShopInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDCAccountStatusUpgradeShopInfo  InShopInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCLegendaryStatusPopup::OnSetAccountStatusUpgradeShopInfo(const struct FDCAccountStatusUpgradeShopInfo& InShopInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLegendaryStatusPopup", "OnSetAccountStatusUpgradeShopInfo");

	Params::DCLegendaryStatusPopup_OnSetAccountStatusUpgradeShopInfo Parms{};

	Parms.InShopInfo = std::move(InShopInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCLegendaryStatusPopup.OnSetContentsBlockHours
// (Event, Protected, BlueprintEvent)
// Parameters:
// EServicePolicyType                      InPolicyType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InBlockHours                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCLegendaryStatusPopup::OnSetContentsBlockHours(const EServicePolicyType InPolicyType, const int32 InBlockHours)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLegendaryStatusPopup", "OnSetContentsBlockHours");

	Params::DCLegendaryStatusPopup_OnSetContentsBlockHours Parms{};

	Parms.InPolicyType = InPolicyType;
	Parms.InBlockHours = InBlockHours;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCLegendaryStatusPopup.OnShopShortcutButtonClicked
// (Final, Native, Private)

void UDCLegendaryStatusPopup::OnShopShortcutButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLegendaryStatusPopup", "OnShopShortcutButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLevelSequenceActor.ProcessSequence
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InEventTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCLevelSequenceActor::ProcessSequence(const struct FGameplayTag& InEventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLevelSequenceActor", "ProcessSequence");

	Params::DCLevelSequenceActor_ProcessSequence Parms{};

	Parms.InEventTag = std::move(InEventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameActorStatusSlotWidget.OnActorStatusData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FActorStatusData                 NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActorStatusData                 OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameActorStatusSlotWidget::OnActorStatusData(const struct FActorStatusData& NewValue, const struct FActorStatusData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameActorStatusSlotWidget", "OnActorStatusData");

	Params::GameActorStatusSlotWidget_OnActorStatusData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCLoadingScreenWidget.OnUpdated
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UTexture2D*                       InLoadingImage                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InDescText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCLoadingScreenWidget::OnUpdated(class UTexture2D* InLoadingImage, const class FText& InDescText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLoadingScreenWidget", "OnUpdated");

	Params::DCLoadingScreenWidget_OnUpdated Parms{};

	Parms.InLoadingImage = InLoadingImage;
	Parms.InDescText = std::move(InDescText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCLoadoutPageWidget.GetFame
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCLoadoutPageWidget::GetFame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLoadoutPageWidget", "GetFame");

	Params::DCLoadoutPageWidget_GetFame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLoadoutPageWidget.GetLevel
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCLoadoutPageWidget::GetLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLoadoutPageWidget", "GetLevel");

	Params::DCLoadoutPageWidget_GetLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPurchaseConfirmPopupData.GetMessage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText UDCPurchaseConfirmPopupData::GetMessage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPurchaseConfirmPopupData", "GetMessage");

	Params::DCPurchaseConfirmPopupData_GetMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPurchaseConfirmPopupData.GetPrice
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDCPrice                   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FDCPrice UDCPurchaseConfirmPopupData::GetPrice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPurchaseConfirmPopupData", "GetPrice");

	Params::DCPurchaseConfirmPopupData_GetPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLobbyCaptureViewerActor.InitActorRotation
// (Final, Native, Protected, BlueprintCallable)

void ADCLobbyCaptureViewerActor::InitActorRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyCaptureViewerActor", "InitActorRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLobbyCaptureViewerActor.SetActorRotation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InYaw                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCLobbyCaptureViewerActor::SetActorRotation(float InYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyCaptureViewerActor", "SetActorRotation");

	Params::DCLobbyCaptureViewerActor_SetActorRotation Parms{};

	Parms.InYaw = InYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLobbyCaptureViewerActor.SetMeshRotationSpeedMultiplier
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCLobbyCaptureViewerActor::SetMeshRotationSpeedMultiplier(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyCaptureViewerActor", "SetMeshRotationSpeedMultiplier");

	Params::DCLobbyCaptureViewerActor_SetMeshRotationSpeedMultiplier Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLobbyCaptureViewerActor.SetStartRotateLocation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InStartPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCLobbyCaptureViewerActor::SetStartRotateLocation(float InStartPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyCaptureViewerActor", "SetStartRotateLocation");

	Params::DCLobbyCaptureViewerActor_SetStartRotateLocation Parms{};

	Parms.InStartPosition = InStartPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnAddCharacterTypeChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnAddCharacterTypeChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnAddCharacterTypeChatFilterTag");

	Params::TradeChannelChatWidget_OnAddCharacterTypeChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnAddIdTagChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnAddIdTagChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnAddIdTagChatFilterTag");

	Params::TradeChannelChatWidget_OnAddIdTagChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnAddPropertyChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnAddPropertyChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnAddPropertyChatFilterTag");

	Params::TradeChannelChatWidget_OnAddPropertyChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnAddRarityChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnAddRarityChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnAddRarityChatFilterTag");

	Params::TradeChannelChatWidget_OnAddRarityChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnAddSlotChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnAddSlotChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnAddSlotChatFilterTag");

	Params::TradeChannelChatWidget_OnAddSlotChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnAddTypeChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnAddTypeChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnAddTypeChatFilterTag");

	Params::TradeChannelChatWidget_OnAddTypeChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnCharacterTypeChatFilterReset
// (Final, Native, Private)

void UTradeChannelChatWidget::OnCharacterTypeChatFilterReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnCharacterTypeChatFilterReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnIdTagChatFilterReset
// (Final, Native, Private)

void UTradeChannelChatWidget::OnIdTagChatFilterReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnIdTagChatFilterReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnPropertyChatFilterReset
// (Final, Native, Private)

void UTradeChannelChatWidget::OnPropertyChatFilterReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnPropertyChatFilterReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnRarityChatFilterReset
// (Final, Native, Private)

void UTradeChannelChatWidget::OnRarityChatFilterReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnRarityChatFilterReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnReadRulesButtonClicked
// (Final, Native, Private)

void UTradeChannelChatWidget::OnReadRulesButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnReadRulesButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnRemoveCharacterTypeChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnRemoveCharacterTypeChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnRemoveCharacterTypeChatFilterTag");

	Params::TradeChannelChatWidget_OnRemoveCharacterTypeChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnRemoveIdTagChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnRemoveIdTagChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnRemoveIdTagChatFilterTag");

	Params::TradeChannelChatWidget_OnRemoveIdTagChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnRemovePropertyChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnRemovePropertyChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnRemovePropertyChatFilterTag");

	Params::TradeChannelChatWidget_OnRemovePropertyChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnRemoveRarityChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnRemoveRarityChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnRemoveRarityChatFilterTag");

	Params::TradeChannelChatWidget_OnRemoveRarityChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnRemoveSlotChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnRemoveSlotChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnRemoveSlotChatFilterTag");

	Params::TradeChannelChatWidget_OnRemoveSlotChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnRemoveTypeChatFilterTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChatFilterTag                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelChatWidget::OnRemoveTypeChatFilterTag(const struct FGameplayTag& InChatFilterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnRemoveTypeChatFilterTag");

	Params::TradeChannelChatWidget_OnRemoveTypeChatFilterTag Parms{};

	Parms.InChatFilterTag = std::move(InChatFilterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnSlotChatFilterReset
// (Final, Native, Private)

void UTradeChannelChatWidget::OnSlotChatFilterReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnSlotChatFilterReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelChatWidget.OnTypeChatFilterReset
// (Final, Native, Private)

void UTradeChannelChatWidget::OnTypeChatFilterReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelChatWidget", "OnTypeChatFilterReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLobbyEmoteGroupWidgetBase.GetVisibilityBySelectedEmote
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCLobbyEmoteGroupWidgetBase::GetVisibilityBySelectedEmote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteGroupWidgetBase", "GetVisibilityBySelectedEmote");

	Params::DCLobbyEmoteGroupWidgetBase_GetVisibilityBySelectedEmote Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLobbyEmoteGroupWidgetBase.OnEmoteSelectClose
// (Event, Protected, BlueprintEvent)

void UDCLobbyEmoteGroupWidgetBase::OnEmoteSelectClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteGroupWidgetBase", "OnEmoteSelectClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCLobbyEmoteGroupWidgetBase.OnEmoteSelectPopup
// (Event, Protected, BlueprintEvent)

void UDCLobbyEmoteGroupWidgetBase::OnEmoteSelectPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteGroupWidgetBase", "OnEmoteSelectPopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCLobbyEmoteGroupWidgetBase.OnSelectedEmoteIndexChanged
// (Final, Native, Protected, BlueprintCallable)

void UDCLobbyEmoteGroupWidgetBase::OnSelectedEmoteIndexChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteGroupWidgetBase", "OnSelectedEmoteIndexChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLobbyEmoteWidget.GetTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCLobbyEmoteWidget::GetTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteWidget", "GetTooltipWidget");

	Params::DCLobbyEmoteWidget_GetTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLobbyEmoteListEntryWidget.GetSelectedVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCLobbyEmoteListEntryWidget::GetSelectedVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteListEntryWidget", "GetSelectedVisibility");

	Params::DCLobbyEmoteListEntryWidget_GetSelectedVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLobbyEmoteListEntryWidget.OnRightClicked
// (Native, Public)

void UDCLobbyEmoteListEntryWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteListEntryWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLobbyEmoteSlotWidget.GetLobbyEmoteIconVisibility
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UDCLobbyEmoteSlotWidget::GetLobbyEmoteIconVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteSlotWidget", "GetLobbyEmoteIconVisibility");

	Params::DCLobbyEmoteSlotWidget_GetLobbyEmoteIconVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLobbyEmoteSlotWidget.OnSelectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCLobbyEmoteSlotWidget::OnSelectionChanged(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteSlotWidget", "OnSelectionChanged");

	Params::DCLobbyEmoteSlotWidget_OnSelectionChanged Parms{};

	Parms.bIsSelected = bIsSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCLobbyEmoteSlotWidget.Reset
// (Final, Native, Public)

void UDCLobbyEmoteSlotWidget::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteSlotWidget", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLobbyEmoteSlotWidget.SelectionChange
// (Final, Native, Public)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCLobbyEmoteSlotWidget::SelectionChange(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteSlotWidget", "SelectionChange");

	Params::DCLobbyEmoteSlotWidget_SelectionChange Parms{};

	Parms.bIsSelected = bIsSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLobbyEmoteSlotWidget.SetLobbyEmoteData
// (Final, Native, Public)
// Parameters:
// class UDCLobbyEmoteDataAsset*           InDesignDataLobbyEmote                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCLobbyEmoteSlotWidget::SetLobbyEmoteData(const class UDCLobbyEmoteDataAsset* InDesignDataLobbyEmote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyEmoteSlotWidget", "SetLobbyEmoteData");

	Params::DCLobbyEmoteSlotWidget_SetLobbyEmoteData Parms{};

	Parms.InDesignDataLobbyEmote = InDesignDataLobbyEmote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLobbyTabButton.SetTabType
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDCWidgetLobbyTabType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCLobbyTabButton::SetTabType(EDCWidgetLobbyTabType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLobbyTabButton", "SetTabType");

	Params::DCLobbyTabButton_SetTabType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerHighRollerWidget.CanReport
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCReportPlayerHighRollerWidget::CanReport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerHighRollerWidget", "CanReport");

	Params::DCReportPlayerHighRollerWidget_CanReport Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCReportPlayerHighRollerWidget.HandleCheckStatedChanged
// (Final, Native, Private)
// Parameters:
// EDCReportPlayerCategory                 InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbNewChecked                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCReportPlayerHighRollerWidget::HandleCheckStatedChanged(EDCReportPlayerCategory InCategory, bool InbNewChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerHighRollerWidget", "HandleCheckStatedChanged");

	Params::DCReportPlayerHighRollerWidget_HandleCheckStatedChanged Parms{};

	Parms.InCategory = InCategory;
	Parms.InbNewChecked = InbNewChecked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerHighRollerWidget.OnCancelClicked
// (Final, Native, Protected, BlueprintCallable)

void UDCReportPlayerHighRollerWidget::OnCancelClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerHighRollerWidget", "OnCancelClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerHighRollerWidget.OnPlayerListComboBoxItemSelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCReportPlayerHighRollerWidget::OnPlayerListComboBoxItemSelected(class UObject* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerHighRollerWidget", "OnPlayerListComboBoxItemSelected");

	Params::DCReportPlayerHighRollerWidget_OnPlayerListComboBoxItemSelected Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerHighRollerWidget.OnReportClicked
// (Final, Native, Protected, BlueprintCallable)

void UDCReportPlayerHighRollerWidget::OnReportClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerHighRollerWidget", "OnReportClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerHighRollerWidget.OnSelectionChanged
// (Event, Protected, BlueprintEvent)

void UDCReportPlayerHighRollerWidget::OnSelectionChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerHighRollerWidget", "OnSelectionChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCLocalLoginWidget.OnLoginButtonClicked
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           IpAddress                                              (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Nickname                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCLocalLoginWidget::OnLoginButtonClicked(const class FString& IpAddress, const class FString& Nickname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLocalLoginWidget", "OnLoginButtonClicked");

	Params::DCLocalLoginWidget_OnLoginButtonClicked Parms{};

	Parms.IpAddress = std::move(IpAddress);
	Parms.Nickname = std::move(Nickname);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportTicketButtonWidget.OnClickReportButton
// (Final, Native, Protected, BlueprintCallable)

void UDCReportTicketButtonWidget::OnClickReportButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportTicketButtonWidget", "OnClickReportButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.VoipPartySettingWidget.OnbVoipGlobal
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoipPartySettingWidget::OnbVoipGlobal(bool NewValue, bool OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipPartySettingWidget", "OnbVoipGlobal");

	Params::VoipPartySettingWidget_OnbVoipGlobal Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.VoipPartySettingWidget.OnVoipGlobalSet
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InbVoipGlobal                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoipPartySettingWidget::OnVoipGlobalSet(bool InbVoipGlobal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoipPartySettingWidget", "OnVoipGlobalSet");

	Params::VoipPartySettingWidget_OnVoipGlobalSet Parms{};

	Parms.InbVoipGlobal = InbVoipGlobal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLootAbilityV2.OnOufOfRange
// (Final, Native, Private)

void UDCLootAbilityV2::OnOufOfRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLootAbilityV2", "OnOufOfRange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLootComponent.ClearLootTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCLootComponent::ClearLootTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLootComponent", "ClearLootTarget");

	Params::DCLootComponent_ClearLootTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCLootComponent.ClearLootTarget_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void UDCLootComponent::ClearLootTarget_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLootComponent", "ClearLootTarget_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLootComponent.OnRep_TargetActor
// (Final, Native, Private)
// Parameters:
// class AActor*                           OldTargetActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCLootComponent::OnRep_TargetActor(class AActor* OldTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLootComponent", "OnRep_TargetActor");

	Params::DCLootComponent_OnRep_TargetActor Parms{};

	Parms.OldTargetActor = OldTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCLootComponent.SetLootTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCLootComponent::SetLootTarget(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCLootComponent", "SetLootTarget");

	Params::DCLootComponent_SetLootTarget Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceButtonBase.OnMarketplaceButtonClicked
// (Final, Native, Private)

void UDCMarketplaceButtonBase::OnMarketplaceButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceButtonBase", "OnMarketplaceButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceButtonBase.OnMarketplaceEnterSucceed
// (Final, Native, Private)

void UDCMarketplaceButtonBase::OnMarketplaceEnterSucceed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceButtonBase", "OnMarketplaceEnterSucceed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRopeBase.ActiveRope
// (Final, Native, Protected, BlueprintCallable)

void ADCRopeBase::ActiveRope()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRopeBase", "ActiveRope");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRopeBase.OnRep_RopeMoveData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCRopeMoveData                  InOldRopeMoveData                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADCRopeBase::OnRep_RopeMoveData(const struct FDCRopeMoveData& InOldRopeMoveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRopeBase", "OnRep_RopeMoveData");

	Params::DCRopeBase_OnRep_RopeMoveData Parms{};

	Parms.InOldRopeMoveData = std::move(InOldRopeMoveData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRopeBase.RopeArriveMinimumHeight
// (Native, Event, Protected, BlueprintEvent)

void ADCRopeBase::RopeArriveMinimumHeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRopeBase", "RopeArriveMinimumHeight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRopeBase.RopeBeginDown
// (Native, Event, Protected, BlueprintEvent)

void ADCRopeBase::RopeBeginDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRopeBase", "RopeBeginDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRopeBase.RopeEscapeComplete
// (Native, Event, Protected, BlueprintEvent)

void ADCRopeBase::RopeEscapeComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRopeBase", "RopeEscapeComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRopeBase.RopeInteractSucceed
// (Native, Event, Protected, BlueprintEvent)

void ADCRopeBase::RopeInteractSucceed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRopeBase", "RopeInteractSucceed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRopeBase.SetInteractMeshCollision
// (Native, Event, Protected, BlueprintEvent)

void ADCRopeBase::SetInteractMeshCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRopeBase", "SetInteractMeshCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceGroupWidgetBase.OnButtonBack
// (Final, Native, Private)

void UDCMarketplaceGroupWidgetBase::OnButtonBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceGroupWidgetBase", "OnButtonBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceGroupWidgetBase.OnHasAnySoldItem
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bHasAny                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMarketplaceGroupWidgetBase::OnHasAnySoldItem(bool bHasAny)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceGroupWidgetBase", "OnHasAnySoldItem");

	Params::DCMarketplaceGroupWidgetBase_OnHasAnySoldItem Parms{};

	Parms.bHasAny = bHasAny;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMarketplaceGroupWidgetBase.OnTabSelected
// (Final, Native, Private)
// Parameters:
// class FName                             InTabButtonId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMarketplaceGroupWidgetBase::OnTabSelected(class FName InTabButtonId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceGroupWidgetBase", "OnTabSelected");

	Params::DCMarketplaceGroupWidgetBase_OnTabSelected Parms{};

	Parms.InTabButtonId = InTabButtonId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceItemInfoWidgetBase.GetItemTooltipWidget
// (Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDCItemTooltipWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCItemTooltipWidget* UDCMarketplaceItemInfoWidgetBase::GetItemTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemInfoWidgetBase", "GetItemTooltipWidget");

	Params::DCMarketplaceItemInfoWidgetBase_GetItemTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemInfoWidgetBase.GetCount
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMarketplaceItemInfoWidgetBase::GetCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemInfoWidgetBase", "GetCount");

	Params::DCMarketplaceItemInfoWidgetBase_GetCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemInfoWidgetBase.IsExpiredItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMarketplaceItemInfoWidgetBase::IsExpiredItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemInfoWidgetBase", "IsExpiredItem");

	Params::DCMarketplaceItemInfoWidgetBase_IsExpiredItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.OnButtonCancelListingClicked
// (Final, Native, Private)

void UDCMarketplaceItemManageWidgetBase::OnButtonCancelListingClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "OnButtonCancelListingClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.OnButtonListingClicked
// (Final, Native, Private)

void UDCMarketplaceItemManageWidgetBase::OnButtonListingClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "OnButtonListingClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.OnButtonRetrieveClicked
// (Final, Native, Private)

void UDCMarketplaceItemManageWidgetBase::OnButtonRetrieveClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "OnButtonRetrieveClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.OnFeatureLockTimerRunsOut
// (Final, Native, Private)

void UDCMarketplaceItemManageWidgetBase::OnFeatureLockTimerRunsOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "OnFeatureLockTimerRunsOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.OnPriceTextChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCMarketplaceItemManageWidgetBase::OnPriceTextChanged(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "OnPriceTextChanged");

	Params::DCMarketplaceItemManageWidgetBase_OnPriceTextChanged Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.OnTargetItemClickEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCItemId                        ItemId                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bIsLocked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsItemReadOnly                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMarketplaceItemManageWidgetBase::OnTargetItemClickEvent(const struct FDCItemId& ItemId, const struct FPointerEvent& MouseEvent, bool bIsLocked, bool bIsItemReadOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "OnTargetItemClickEvent");

	Params::DCMarketplaceItemManageWidgetBase_OnTargetItemClickEvent Parms{};

	Parms.ItemId = std::move(ItemId);
	Parms.MouseEvent = std::move(MouseEvent);
	Parms.bIsLocked = bIsLocked;
	Parms.bIsItemReadOnly = bIsItemReadOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.CannotListingItem
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMarketplaceItemManageWidgetBase::CannotListingItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "CannotListingItem");

	Params::DCMarketplaceItemManageWidgetBase_CannotListingItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetFixedListingFee
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMarketplaceItemManageWidgetBase::GetFixedListingFee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "GetFixedListingFee");

	Params::DCMarketplaceItemManageWidgetBase_GetFixedListingFee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetListingExpiredDays
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMarketplaceItemManageWidgetBase::GetListingExpiredDays() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "GetListingExpiredDays");

	Params::DCMarketplaceItemManageWidgetBase_GetListingExpiredDays Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetListingFee
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMarketplaceItemManageWidgetBase::GetListingFee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "GetListingFee");

	Params::DCMarketplaceItemManageWidgetBase_GetListingFee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetListItemState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCMarketplaceMyListState               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCMarketplaceMyListState UDCMarketplaceItemManageWidgetBase::GetListItemState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "GetListItemState");

	Params::DCMarketplaceItemManageWidgetBase_GetListItemState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetPriceLimit
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMarketplaceItemManageWidgetBase::GetPriceLimit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "GetPriceLimit");

	Params::DCMarketplaceItemManageWidgetBase_GetPriceLimit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetVariableListingFee
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMarketplaceItemManageWidgetBase::GetVariableListingFee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "GetVariableListingFee");

	Params::DCMarketplaceItemManageWidgetBase_GetVariableListingFee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.GetVariableListingFeeRate
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMarketplaceItemManageWidgetBase::GetVariableListingFeeRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "GetVariableListingFeeRate");

	Params::DCMarketplaceItemManageWidgetBase_GetVariableListingFeeRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.IsListingPriceSet
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMarketplaceItemManageWidgetBase::IsListingPriceSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "IsListingPriceSet");

	Params::DCMarketplaceItemManageWidgetBase_IsListingPriceSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemManageWidgetBase.OnItemStateChanged
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// EDCMarketplaceMyListState               State                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMarketplaceItemManageWidgetBase::OnItemStateChanged(const EDCMarketplaceMyListState& State) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemManageWidgetBase", "OnItemStateChanged");

	Params::DCMarketplaceItemManageWidgetBase_OnItemStateChanged Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMarketplaceItemWidget.GetItemTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDCItemTooltipWidget*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCItemTooltipWidget* UDCMarketplaceItemWidget::GetItemTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemWidget", "GetItemTooltipWidget");

	Params::DCMarketplaceItemWidget_GetItemTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceItemWidget.IsItemSet
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMarketplaceItemWidget::IsItemSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceItemWidget", "IsItemSet");

	Params::DCMarketplaceItemWidget_IsItemSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceListEntryWidgetBase.OnButtonBuyClicked
// (Final, Native, Private)

void UDCMarketplaceListEntryWidgetBase::OnButtonBuyClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListEntryWidgetBase", "OnButtonBuyClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceListEntryWidgetBase.GetRandomAttributeValue
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCMarketplaceListEntryWidgetBase::GetRandomAttributeValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListEntryWidgetBase", "GetRandomAttributeValue");

	Params::DCMarketplaceListEntryWidgetBase_GetRandomAttributeValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceListEntryWidgetBase.GetStaticAttributeValue
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCMarketplaceListEntryWidgetBase::GetStaticAttributeValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListEntryWidgetBase", "GetStaticAttributeValue");

	Params::DCMarketplaceListEntryWidgetBase_GetStaticAttributeValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.CheckSortButtonSortable
// (Final, Native, Protected, BlueprintCallable)

void UDCMarketplaceListWidgetBase::CheckSortButtonSortable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "CheckSortButtonSortable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnComboBoxItemSelectionAddition
// (Final, Native, Private)
// Parameters:
// class UObject*                          SelectedItem                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMarketplaceListWidgetBase::OnComboBoxItemSelectionAddition(class UObject* SelectedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "OnComboBoxItemSelectionAddition");

	Params::DCMarketplaceListWidgetBase_OnComboBoxItemSelectionAddition Parms{};

	Parms.SelectedItem = SelectedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnComboBoxItemSelectionChanged
// (Final, Native, Private)
// Parameters:
// class UObject*                          SelectedItem                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMarketplaceListWidgetBase::OnComboBoxItemSelectionChanged(class UObject* SelectedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "OnComboBoxItemSelectionChanged");

	Params::DCMarketplaceListWidgetBase_OnComboBoxItemSelectionChanged Parms{};

	Parms.SelectedItem = SelectedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnComboBoxItemSelectionCleared
// (Final, Native, Private)
// Parameters:
// class UObject*                          SelectedItem                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMarketplaceListWidgetBase::OnComboBoxItemSelectionCleared(class UObject* SelectedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "OnComboBoxItemSelectionCleared");

	Params::DCMarketplaceListWidgetBase_OnComboBoxItemSelectionCleared Parms{};

	Parms.SelectedItem = SelectedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnNextPageButtonClicked
// (Final, Native, Private)

void UDCMarketplaceListWidgetBase::OnNextPageButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "OnNextPageButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnPrevPageButtonClicked
// (Final, Native, Private)

void UDCMarketplaceListWidgetBase::OnPrevPageButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "OnPrevPageButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnResetFilterButtonClicked
// (Final, Native, Private)

void UDCMarketplaceListWidgetBase::OnResetFilterButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "OnResetFilterButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnSearchButtonClicked
// (Final, Native, Private)

void UDCMarketplaceListWidgetBase::OnSearchButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "OnSearchButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.OnSortButtonClicked
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDCSortButtonState                      State                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMarketplaceListWidgetBase::OnSortButtonClicked(const class FName& Target, const EDCSortButtonState& State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "OnSortButtonClicked");

	Params::DCMarketplaceListWidgetBase_OnSortButtonClicked Parms{};

	Parms.Target = Target;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.UpdatePageButton
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInRecent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMarketplaceListWidgetBase::UpdatePageButton(bool bInRecent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "UpdatePageButton");

	Params::DCMarketplaceListWidgetBase_UpdatePageButton Parms{};

	Parms.bInRecent = bInRecent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMarketplaceListWidgetBase.IsAnyFilterSelected
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMarketplaceListWidgetBase::IsAnyFilterSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceListWidgetBase", "IsAnyFilterSelected");

	Params::DCMarketplaceListWidgetBase_IsAnyFilterSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceMyListEntryWidgetBase.OnMarketplaceMyItemInfoUpdate
// (Event, Public, BlueprintEvent)

void UDCMarketplaceMyListEntryWidgetBase::OnMarketplaceMyItemInfoUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceMyListEntryWidgetBase", "OnMarketplaceMyItemInfoUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCMarketplaceMyListEntryWidgetBase.GetListState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCMarketplaceMyListState               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCMarketplaceMyListState UDCMarketplaceMyListEntryWidgetBase::GetListState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceMyListEntryWidgetBase", "GetListState");

	Params::DCMarketplaceMyListEntryWidgetBase_GetListState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceMyListEntryWidgetBase.IsListing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMarketplaceMyListEntryWidgetBase::IsListing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceMyListEntryWidgetBase", "IsListing");

	Params::DCMarketplaceMyListEntryWidgetBase_IsListing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplaceMyListWidgetBase.OnTargetItemWidgetClicked
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCItemId                        ItemId                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMarketplaceMyListWidgetBase::OnTargetItemWidgetClicked(const struct FDCItemId& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplaceMyListWidgetBase", "OnTargetItemWidgetClicked");

	Params::DCMarketplaceMyListWidgetBase_OnTargetItemWidgetClicked Parms{};

	Parms.ItemId = std::move(ItemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplacePaymentTransferWidgetBase.OnCloseListingButtonClicked
// (Final, Native, Private)

void UDCMarketplacePaymentTransferWidgetBase::OnCloseListingButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePaymentTransferWidgetBase", "OnCloseListingButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplacePaymentTransferWidgetBase.OnMarketplaceMyItemInfoUpdated
// (Event, Protected, BlueprintEvent)

void UDCMarketplacePaymentTransferWidgetBase::OnMarketplaceMyItemInfoUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePaymentTransferWidgetBase", "OnMarketplaceMyItemInfoUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCMarketplacePaymentTransferWidgetBase.OnPaymentsDestroyed
// (Event, Protected, BlueprintEvent)

void UDCMarketplacePaymentTransferWidgetBase::OnPaymentsDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePaymentTransferWidgetBase", "OnPaymentsDestroyed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCMarketplacePaymentTransferWidgetBase.OnTransferButtonClicked
// (Final, Native, Private)

void UDCMarketplacePaymentTransferWidgetBase::OnTransferButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePaymentTransferWidgetBase", "OnTransferButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplacePaymentTransferWidgetBase.GetPirce
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMarketplacePaymentTransferWidgetBase::GetPirce() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePaymentTransferWidgetBase", "GetPirce");

	Params::DCMarketplacePaymentTransferWidgetBase_GetPirce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplacePaymentTransferWidgetBase.IsDestoryed
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMarketplacePaymentTransferWidgetBase::IsDestoryed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePaymentTransferWidgetBase", "IsDestoryed");

	Params::DCMarketplacePaymentTransferWidgetBase_IsDestoryed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplacePurchaseGroupWidgetBase.OnButtonBack
// (Final, Native, Private)

void UDCMarketplacePurchaseGroupWidgetBase::OnButtonBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePurchaseGroupWidgetBase", "OnButtonBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplacePurchaseGroupWidgetBase.OnButtonDeal
// (Final, Native, Private)

void UDCMarketplacePurchaseGroupWidgetBase::OnButtonDeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePurchaseGroupWidgetBase", "OnButtonDeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplacePurchaseGroupWidgetBase.OnButtonFill
// (Final, Native, Private)

void UDCMarketplacePurchaseGroupWidgetBase::OnButtonFill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePurchaseGroupWidgetBase", "OnButtonFill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMarketplacePurchaseGroupWidgetBase.GetCounterTotalPayment
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMarketplacePurchaseGroupWidgetBase::GetCounterTotalPayment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePurchaseGroupWidgetBase", "GetCounterTotalPayment");

	Params::DCMarketplacePurchaseGroupWidgetBase_GetCounterTotalPayment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMarketplacePurchaseGroupWidgetBase.OnAnyItemFilled
// (Event, Protected, BlueprintEvent, Const)

void UDCMarketplacePurchaseGroupWidgetBase::OnAnyItemFilled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMarketplacePurchaseGroupWidgetBase", "OnAnyItemFilled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DungeonSelectButtonWidget.CheckDungeonSelect
// (Event, Protected, BlueprintEvent)

void UDungeonSelectButtonWidget::CheckDungeonSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectButtonWidget", "CheckDungeonSelect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DungeonSelectButtonWidget.OnbMatching
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectButtonWidget::OnbMatching(bool NewValue, bool OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectButtonWidget", "OnbMatching");

	Params::DungeonSelectButtonWidget_OnbMatching Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DungeonSelectButtonWidget.OnDungeonRotationItemInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDungeonRotationItemInfo         NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDungeonRotationItemInfo         OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDungeonSelectButtonWidget::OnDungeonRotationItemInfo(const struct FDungeonRotationItemInfo& NewValue, const struct FDungeonRotationItemInfo& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectButtonWidget", "OnDungeonRotationItemInfo");

	Params::DungeonSelectButtonWidget_OnDungeonRotationItemInfo Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DungeonSelectButtonWidget.OnDungeonRotationTimerData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FDungeonRotationTimerData        NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDungeonRotationTimerData        OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDungeonSelectButtonWidget::OnDungeonRotationTimerData(const struct FDungeonRotationTimerData& NewValue, const struct FDungeonRotationTimerData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectButtonWidget", "OnDungeonRotationTimerData");

	Params::DungeonSelectButtonWidget_OnDungeonRotationTimerData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DungeonSelectButtonWidget.OnGameType
// (Event, Protected, BlueprintEvent)
// Parameters:
// EGameType                               NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameType                               OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectButtonWidget::OnGameType(EGameType NewValue, EGameType OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectButtonWidget", "OnGameType");

	Params::DungeonSelectButtonWidget_OnGameType Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DungeonSelectButtonWidget.OnGameUserSettingControlsChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameUserSettingControls         InGameUserSettingControls                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameUserSettingControls         InOldGameUserSettingControls                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectButtonWidget::OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectButtonWidget", "OnGameUserSettingControlsChanged");

	Params::DungeonSelectButtonWidget_OnGameUserSettingControlsChanged Parms{};

	Parms.InGameUserSettingControls = std::move(InGameUserSettingControls);
	Parms.InOldGameUserSettingControls = std::move(InOldGameUserSettingControls);
	Parms.bInForce = bInForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DungeonSelectButtonWidget.OnMatchMode
// (Event, Protected, BlueprintEvent)
// Parameters:
// EMatchMode                              NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMatchMode                              OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectButtonWidget::OnMatchMode(EMatchMode NewValue, EMatchMode OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectButtonWidget", "OnMatchMode");

	Params::DungeonSelectButtonWidget_OnMatchMode Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMaterialInterface.RemoveOverrideMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// EDCMaterialType                         InMaterialType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDCMaterialInterface::RemoveOverrideMaterial(EDCMaterialType InMaterialType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMaterialInterface", "RemoveOverrideMaterial");

	Params::DCMaterialInterface_RemoveOverrideMaterial Parms{};

	Parms.InMaterialType = InMaterialType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMaterialInterface.ResetBaseMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   InMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDCMaterialInterface::ResetBaseMaterial(class UMeshComponent* InMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMaterialInterface", "ResetBaseMaterial");

	Params::DCMaterialInterface_ResetBaseMaterial Parms{};

	Parms.InMeshComponent = InMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMaterialInterface.SetBaseMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   InMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InElementIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               InMaterialInterface                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDCMaterialInterface::SetBaseMaterial(class UMeshComponent* InMeshComponent, int32 InElementIndex, class UMaterialInterface* InMaterialInterface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMaterialInterface", "SetBaseMaterial");

	Params::DCMaterialInterface_SetBaseMaterial Parms{};

	Parms.InMeshComponent = InMeshComponent;
	Parms.InElementIndex = InElementIndex;
	Parms.InMaterialInterface = InMaterialInterface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMaterialInterface.SetBaseMaterialBySlotName
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   InMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MaterialSlotName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               InMaterialInterface                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDCMaterialInterface::SetBaseMaterialBySlotName(class UMeshComponent* InMeshComponent, class FName MaterialSlotName, class UMaterialInterface* InMaterialInterface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMaterialInterface", "SetBaseMaterialBySlotName");

	Params::DCMaterialInterface_SetBaseMaterialBySlotName Parms{};

	Parms.InMeshComponent = InMeshComponent;
	Parms.MaterialSlotName = MaterialSlotName;
	Parms.InMaterialInterface = InMaterialInterface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMaterialInterface.SetOverrideMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// EDCMaterialType                         InMaterialType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               InMaterialInterface                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInSetRenderingPriority                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDCMaterialInterface::SetOverrideMaterial(EDCMaterialType InMaterialType, class UMaterialInterface* InMaterialInterface, bool bInSetRenderingPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMaterialInterface", "SetOverrideMaterial");

	Params::DCMaterialInterface_SetOverrideMaterial Parms{};

	Parms.InMaterialType = InMaterialType;
	Parms.InMaterialInterface = InMaterialInterface;
	Parms.bInSetRenderingPriority = bInSetRenderingPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMaterialInterface.SetOverrideMaterialValue
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EDCMaterialType                         InMaterialType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InKey                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDCMaterialInterface::SetOverrideMaterialValue(EDCMaterialType InMaterialType, const class FName& InKey, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMaterialInterface", "SetOverrideMaterialValue");

	Params::DCMaterialInterface_SetOverrideMaterialValue Parms{};

	Parms.InMaterialType = InMaterialType;
	Parms.InKey = InKey;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayUserInfoWidget.OnLocationUpdate
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsReady                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MetaLocationIndex                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPlayUserInfoWidget::OnLocationUpdate(const bool bIsReady, const int32 MetaLocationIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayUserInfoWidget", "OnLocationUpdate");

	Params::DCPlayUserInfoWidget_OnLocationUpdate Parms{};

	Parms.bIsReady = bIsReady;
	Parms.MetaLocationIndex = MetaLocationIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCPlayUserInfoWidget.OnPlayPartyUserState
// (Event, Protected, BlueprintEvent)
// Parameters:
// EWidgetPlayUserPartyState               InPartyMemberState                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPlayUserInfoWidget::OnPlayPartyUserState(const EWidgetPlayUserPartyState InPartyMemberState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayUserInfoWidget", "OnPlayPartyUserState");

	Params::DCPlayUserInfoWidget_OnPlayPartyUserState Parms{};

	Parms.InPartyMemberState = InPartyMemberState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCPlayUserInfoWidget.OnPlayUserInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPlayPartyUserInfo               InPlaypartyUserInfo                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPlayUserInfoWidget::OnPlayUserInfo(const struct FPlayPartyUserInfo& InPlaypartyUserInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayUserInfoWidget", "OnPlayUserInfo");

	Params::DCPlayUserInfoWidget_OnPlayUserInfo Parms{};

	Parms.InPlaypartyUserInfo = std::move(InPlaypartyUserInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayUserInfoWidget.OnUpdateLobbyCharacterInfo
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLobbyCharacterInfo              InLobbyCharacterInfo                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCPlayUserInfoWidget::OnUpdateLobbyCharacterInfo(const struct FLobbyCharacterInfo& InLobbyCharacterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayUserInfoWidget", "OnUpdateLobbyCharacterInfo");

	Params::DCPlayUserInfoWidget_OnUpdateLobbyCharacterInfo Parms{};

	Parms.InLobbyCharacterInfo = std::move(InLobbyCharacterInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantBaseGearWidget.OnButtonEquip
// (Final, Native, Private)

void UDCMerchantBaseGearWidget::OnButtonEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantBaseGearWidget", "OnButtonEquip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantBaseGearWidget.OnButtonSet
// (Final, Native, Private)

void UDCMerchantBaseGearWidget::OnButtonSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantBaseGearWidget", "OnButtonSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantDealTablePurchaseWidget.OnButtonDeal
// (Final, Native, Private)

void UDCMerchantDealTablePurchaseWidget::OnButtonDeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTablePurchaseWidget", "OnButtonDeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantDealTablePurchaseWidget.OnButtonFill
// (Final, Native, Private)

void UDCMerchantDealTablePurchaseWidget::OnButtonFill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTablePurchaseWidget", "OnButtonFill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantDealTablePurchaseWidget.IsRequiredItemsFilled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMerchantDealTablePurchaseWidget::IsRequiredItemsFilled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTablePurchaseWidget", "IsRequiredItemsFilled");

	Params::DCMerchantDealTablePurchaseWidget_IsRequiredItemsFilled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantDealTablePurchaseWidget.IsTargetItemSet
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMerchantDealTablePurchaseWidget::IsTargetItemSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTablePurchaseWidget", "IsTargetItemSet");

	Params::DCMerchantDealTablePurchaseWidget_IsTargetItemSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantDealTableQuestWidget.OnButtonAccept
// (Final, Native, Private)

void UDCMerchantDealTableQuestWidget::OnButtonAccept()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTableQuestWidget", "OnButtonAccept");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantDealTableQuestWidget.OnButtonComplete
// (Final, Native, Private)

void UDCMerchantDealTableQuestWidget::OnButtonComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTableQuestWidget", "OnButtonComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantDealTableQuestWidget.OnButtonItemDeliver
// (Final, Native, Private)

void UDCMerchantDealTableQuestWidget::OnButtonItemDeliver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTableQuestWidget", "OnButtonItemDeliver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantDealTableQuestWidget.OnQuestInfoUpdated
// (Event, Protected, BlueprintEvent)

void UDCMerchantDealTableQuestWidget::OnQuestInfoUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTableQuestWidget", "OnQuestInfoUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCMerchantDealTableQuestWidget.GetQuestState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCQuestState                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCQuestState UDCMerchantDealTableQuestWidget::GetQuestState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTableQuestWidget", "GetQuestState");

	Params::DCMerchantDealTableQuestWidget_GetQuestState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantDealTableSellWidget.OnButtonDeal
// (Final, Native, Private)

void UDCMerchantDealTableSellWidget::OnButtonDeal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTableSellWidget", "OnButtonDeal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantDealTableSellWidget.OnInventoryUpdated
// (Final, Native, Private)

void UDCMerchantDealTableSellWidget::OnInventoryUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTableSellWidget", "OnInventoryUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantDealTableSellWidget.GetPrice
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMerchantDealTableSellWidget::GetPrice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTableSellWidget", "GetPrice");

	Params::DCMerchantDealTableSellWidget_GetPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantDealTableSellWidget.IsSellEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMerchantDealTableSellWidget::IsSellEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantDealTableSellWidget", "IsSellEnabled");

	Params::DCMerchantDealTableSellWidget_IsSellEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantInfoWidget.SetInGameMode
// (Final, Native, Public, BlueprintCallable)

void UDCMerchantInfoWidget::SetInGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantInfoWidget", "SetInGameMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantItemWidget.GetMerchantItemTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCMerchantItemWidget::GetMerchantItemTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantItemWidget", "GetMerchantItemTooltipWidget");

	Params::DCMerchantItemWidget_GetMerchantItemTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantListEntryWidget.IsOnNewAlram
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMerchantListEntryWidget::IsOnNewAlram() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantListEntryWidget", "IsOnNewAlram");

	Params::DCMerchantListEntryWidget_IsOnNewAlram Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantListEntryWidget.IsOnSuccesAlram
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMerchantListEntryWidget::IsOnSuccesAlram() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantListEntryWidget", "IsOnSuccesAlram");

	Params::DCMerchantListEntryWidget_IsOnSuccesAlram Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantListPageWidget.OnSetCompletedTileView
// (Event, Public, BlueprintEvent)

void UDCMerchantListPageWidget::OnSetCompletedTileView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantListPageWidget", "OnSetCompletedTileView");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCMerchantMindwipeWidget.OnButtonForget
// (Final, Native, Private)

void UDCMerchantMindwipeWidget::OnButtonForget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantMindwipeWidget", "OnButtonForget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantMindwipeWidget.GetCanMindwipe
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDCMerchantMindwipeWidget::GetCanMindwipe() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantMindwipeWidget", "GetCanMindwipe");

	Params::DCMerchantMindwipeWidget_GetCanMindwipe Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantPageWidget.OnButtonBack
// (Final, Native, Private)

void UDCMerchantPageWidget::OnButtonBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantPageWidget", "OnButtonBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantPageWidget.OnCategoryTabSelected
// (Final, Native, Private)
// Parameters:
// class FName                             TabId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMerchantPageWidget::OnCategoryTabSelected(class FName TabId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantPageWidget", "OnCategoryTabSelected");

	Params::DCMerchantPageWidget_OnCategoryTabSelected Parms{};

	Parms.TabId = TabId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantPageWidget.OnComboBoxItemSelectionChanged
// (Final, Native, Private)
// Parameters:
// class UObject*                          SelectedItem                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMerchantPageWidget::OnComboBoxItemSelectionChanged(class UObject* SelectedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantPageWidget", "OnComboBoxItemSelectionChanged");

	Params::DCMerchantPageWidget_OnComboBoxItemSelectionChanged Parms{};

	Parms.SelectedItem = SelectedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantPageWidget.OnComboBoxItemSelectionCleared
// (Final, Native, Private)
// Parameters:
// class UObject*                          SelectedItem                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMerchantPageWidget::OnComboBoxItemSelectionCleared(class UObject* SelectedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantPageWidget", "OnComboBoxItemSelectionCleared");

	Params::DCMerchantPageWidget_OnComboBoxItemSelectionCleared Parms{};

	Parms.SelectedItem = SelectedItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantPageWidget.OnServiceTabSelected
// (Final, Native, Private)
// Parameters:
// class FName                             TabId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMerchantPageWidget::OnServiceTabSelected(class FName TabId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantPageWidget", "OnServiceTabSelected");

	Params::DCMerchantPageWidget_OnServiceTabSelected Parms{};

	Parms.TabId = TabId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantPageWidget.OnServiceTypeChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EDCMerchantServiceType                  ServiceType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMerchantPageWidget::OnServiceTypeChanged(EDCMerchantServiceType ServiceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantPageWidget", "OnServiceTypeChanged");

	Params::DCMerchantPageWidget_OnServiceTypeChanged Parms{};

	Parms.ServiceType = ServiceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionKillPopup.OnConfirmButtonClicked
// (Final, Native, Private)

void UDCReligionKillPopup::OnConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionKillPopup", "OnConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantQuickPrepareWidget.OnButtonStashAll
// (Final, Native, Private)

void UDCMerchantQuickPrepareWidget::OnButtonStashAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantQuickPrepareWidget", "OnButtonStashAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantQuickPrepareWidget.HasAnyTargetItem
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMerchantQuickPrepareWidget::HasAnyTargetItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantQuickPrepareWidget", "HasAnyTargetItem");

	Params::DCMerchantQuickPrepareWidget_HasAnyTargetItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantRequiredEntryWidget.GetCurrentStack
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMerchantRequiredEntryWidget::GetCurrentStack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantRequiredEntryWidget", "GetCurrentStack");

	Params::DCMerchantRequiredEntryWidget_GetCurrentStack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantRequiredEntryWidget.GetMaxStack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMerchantRequiredEntryWidget::GetMaxStack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantRequiredEntryWidget", "GetMaxStack");

	Params::DCMerchantRequiredEntryWidget_GetMaxStack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantRequiredEntryWidget.GetRequireData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UDCMerchantRequiredEntryWidget::GetRequireData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantRequiredEntryWidget", "GetRequireData");

	Params::DCMerchantRequiredEntryWidget_GetRequireData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantRequiredEntryWidget.IsEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMerchantRequiredEntryWidget::IsEmpty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantRequiredEntryWidget", "IsEmpty");

	Params::DCMerchantRequiredEntryWidget_IsEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMerchantRequiredEntryWidget.IsFilled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMerchantRequiredEntryWidget::IsFilled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantRequiredEntryWidget", "IsFilled");

	Params::DCMerchantRequiredEntryWidget_IsFilled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCReligionOfferingWidget.ChangeActivateOfferState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsActiavte                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCReligionOfferingWidget::ChangeActivateOfferState(bool bIsActiavte)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionOfferingWidget", "ChangeActivateOfferState");

	Params::DCReligionOfferingWidget_ChangeActivateOfferState Parms{};

	Parms.bIsActiavte = bIsActiavte;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCReligionOfferingWidget.DeactivateAcceptBtn
// (Event, Public, BlueprintEvent)

void UDCReligionOfferingWidget::DeactivateAcceptBtn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionOfferingWidget", "DeactivateAcceptBtn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCReligionOfferingWidget.ResetOfferingCount
// (Final, Native, Public, BlueprintCallable)

void UDCReligionOfferingWidget::ResetOfferingCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionOfferingWidget", "ResetOfferingCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionOfferingWidget.SetCurrencySource
// (Final, Native, Public, BlueprintCallable)

void UDCReligionOfferingWidget::SetCurrencySource()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionOfferingWidget", "SetCurrencySource");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantShortcutPopupBase.OnBaseGearShortcutButtonClicked
// (Final, Native, Private)

void UDCMerchantShortcutPopupBase::OnBaseGearShortcutButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantShortcutPopupBase", "OnBaseGearShortcutButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantShortcutPopupBase.OnCancelButtonClicked
// (Final, Native, Private)

void UDCMerchantShortcutPopupBase::OnCancelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantShortcutPopupBase", "OnCancelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantShortcutPopupBase.OnOkButtonClicked
// (Final, Native, Private)

void UDCMerchantShortcutPopupBase::OnOkButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantShortcutPopupBase", "OnOkButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantShortcutPopupBase.OnQuickPrepareShortcutButtonClicked
// (Final, Native, Private)

void UDCMerchantShortcutPopupBase::OnQuickPrepareShortcutButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantShortcutPopupBase", "OnQuickPrepareShortcutButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMerchantShortcutPopupBase.OnSetMerchantShortcutPopupData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDCMerchantShortcutPopupData*     PopupData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMerchantShortcutPopupBase::OnSetMerchantShortcutPopupData(class UDCMerchantShortcutPopupData* PopupData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMerchantShortcutPopupBase", "OnSetMerchantShortcutPopupData");

	Params::DCMerchantShortcutPopupBase_OnSetMerchantShortcutPopupData Parms{};

	Parms.PopupData = PopupData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCPlayerController.AckPlayerCharacterLocation_Client
// (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient)
// Parameters:
// struct FDCAccountId                     InAccountId                                            (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InPlayerPawnLocation                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InPlayerPawnRotation                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ADCPlayerController::AckPlayerCharacterLocation_Client(const struct FDCAccountId& InAccountId, const struct FVector& InPlayerPawnLocation, const struct FRotator& InPlayerPawnRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "AckPlayerCharacterLocation_Client");

	Params::DCPlayerController_AckPlayerCharacterLocation_Client Parms{};

	Parms.InAccountId = std::move(InAccountId);
	Parms.InPlayerPawnLocation = std::move(InPlayerPawnLocation);
	Parms.InPlayerPawnRotation = std::move(InPlayerPawnRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.Announce_Client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FGameAnnounceData                AnnounceData                                           (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::Announce_Client(const struct FGameAnnounceData& AnnounceData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "Announce_Client");

	Params::DCPlayerController_Announce_Client Parms{};

	Parms.AnnounceData = std::move(AnnounceData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ArenaNextPhaseForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::ArenaNextPhaseForDebug_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ArenaNextPhaseForDebug_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ArenaPrepareStartPointForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::ArenaPrepareStartPointForDebug_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ArenaPrepareStartPointForDebug_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "BroadcastMsgBlueprint");

	Params::DCPlayerController_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ChangeParty_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FDCPartyId                       InPartyId                                              (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::ChangeParty_Server(const struct FDCPartyId& InPartyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ChangeParty_Server");

	Params::DCPlayerController_ChangeParty_Server Parms{};

	Parms.InPartyId = std::move(InPartyId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.EscapeForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::EscapeForDebug_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "EscapeForDebug_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ExitUser
// (Final, Native, Private)
// Parameters:
// EDCExitType                             ExitType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::ExitUser(const EDCExitType ExitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ExitUser");

	Params::DCPlayerController_ExitUser Parms{};

	Parms.ExitType = ExitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ExitUser_Server
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// EDCExitType                             ExitType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::ExitUser_Server(const EDCExitType ExitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ExitUser_Server");

	Params::DCPlayerController_ExitUser_Server Parms{};

	Parms.ExitType = ExitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.GetDebugFaceTargetActor
// (Final, Native, Private)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ADCPlayerController::GetDebugFaceTargetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "GetDebugFaceTargetActor");

	Params::DCPlayerController_GetDebugFaceTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerController.Gm
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           InCmd                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::Gm(const class FString& InCmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "Gm");

	Params::DCPlayerController_Gm Parms{};

	Parms.InCmd = std::move(InCmd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.GmServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InCmd                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::GmServer(const class FString& InKey, const class FString& InCmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "GmServer");

	Params::DCPlayerController_GmServer Parms{};

	Parms.InKey = std::move(InKey);
	Parms.InCmd = std::move(InCmd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.IsTargetAccountSelf
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCPlayerController::IsTargetAccountSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "IsTargetAccountSelf");

	Params::DCPlayerController_IsTargetAccountSelf Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerController.LogClientAliveToServiceReceive
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::LogClientAliveToServiceReceive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "LogClientAliveToServiceReceive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.LogClientAliveToServiceSend
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::LogClientAliveToServiceSend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "LogClientAliveToServiceSend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.NextFloorRuleForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::NextFloorRuleForDebug_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "NextFloorRuleForDebug_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.NotifySystemMessage_Client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FText                             SystemMessage                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::NotifySystemMessage_Client(const class FText& SystemMessage, const float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "NotifySystemMessage_Client");

	Params::DCPlayerController_NotifySystemMessage_Client Parms{};

	Parms.SystemMessage = std::move(SystemMessage);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnAnyPlayerDied
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCPlayerInfo                    InPlayerInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::OnAnyPlayerDied(const struct FDCPlayerInfo& InPlayerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnAnyPlayerDied");

	Params::DCPlayerController_OnAnyPlayerDied Parms{};

	Parms.InPlayerInfo = std::move(InPlayerInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnBackToLobbyConfirmed
// (Final, Native, Private)
// Parameters:
// EPopupResult                            PopupResult                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::OnBackToLobbyConfirmed(const EPopupResult PopupResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnBackToLobbyConfirmed");

	Params::DCPlayerController_OnBackToLobbyConfirmed Parms{};

	Parms.PopupResult = PopupResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnClientCall
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FCallData                        CallData                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::OnClientCall(const struct FCallData& CallData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnClientCall");

	Params::DCPlayerController_OnClientCall Parms{};

	Parms.CallData = std::move(CallData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnDungeonDownOverlapped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADCPlayerCharacterBase*           InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCPlayerController::OnDungeonDownOverlapped(class ADCPlayerCharacterBase* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnDungeonDownOverlapped");

	Params::DCPlayerController_OnDungeonDownOverlapped Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerController.OnDungeonEscapeOverlapped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADCPlayerCharacterBase*           InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCPlayerController::OnDungeonEscapeOverlapped(class ADCPlayerCharacterBase* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnDungeonEscapeOverlapped");

	Params::DCPlayerController_OnDungeonEscapeOverlapped Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerController.OnExitClicked
// (Final, Native, Public, BlueprintCallable)

void ADCPlayerController::OnExitClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnExitClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnExitConfirmed
// (Final, Native, Private)
// Parameters:
// EPopupResult                            PopupResult                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::OnExitConfirmed(const EPopupResult PopupResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnExitConfirmed");

	Params::DCPlayerController_OnExitConfirmed Parms{};

	Parms.PopupResult = PopupResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnFMsgGameAnnounceNotifyClient
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FGameAnnounceData                InGameAnnounceData                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::OnFMsgGameAnnounceNotifyClient(const struct FGameAnnounceData& InGameAnnounceData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnFMsgGameAnnounceNotifyClient");

	Params::DCPlayerController_OnFMsgGameAnnounceNotifyClient Parms{};

	Parms.InGameAnnounceData = std::move(InGameAnnounceData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnFMsgGameFloorLogNotify_Client
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameFloorLogNotify           Msg                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::OnFMsgGameFloorLogNotify_Client(const struct FMsgGameFloorLogNotify& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnFMsgGameFloorLogNotify_Client");

	Params::DCPlayerController_OnFMsgGameFloorLogNotify_Client Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnFMsgGameKillLogNotify_Client
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// struct FMsgGameKillLogNotify            Msg                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::OnFMsgGameKillLogNotify_Client(const struct FMsgGameKillLogNotify& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnFMsgGameKillLogNotify_Client");

	Params::DCPlayerController_OnFMsgGameKillLogNotify_Client Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnGameStateNotify
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameStateData                   InGameStateData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADCPlayerController::OnGameStateNotify(const struct FGameStateData& InGameStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnGameStateNotify");

	Params::DCPlayerController_OnGameStateNotify Parms{};

	Parms.InGameStateData = std::move(InGameStateData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCPlayerController.OnKilledByUser_Client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FDCAccountId                     Killer                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::OnKilledByUser_Client(const struct FDCAccountId& Killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnKilledByUser_Client");

	Params::DCPlayerController_OnKilledByUser_Client Parms{};

	Parms.Killer = std::move(Killer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnLobbyClicked
// (Final, Native, Public, BlueprintCallable)

void ADCPlayerController::OnLobbyClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnLobbyClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnPartyChat
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FChatData                        InChatData                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::OnPartyChat(const struct FChatData& InChatData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnPartyChat");

	Params::DCPlayerController_OnPartyChat Parms{};

	Parms.InChatData = std::move(InChatData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnPawnChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            InOldPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            InNewPawn                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::OnPawnChanged(class APawn* InOldPawn, class APawn* InNewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnPawnChanged");

	Params::DCPlayerController_OnPawnChanged Parms{};

	Parms.InOldPawn = InOldPawn;
	Parms.InNewPawn = InNewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnPortalScrollOverlapped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFloorPortalScrollBase*           Portal                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCPlayerCharacterBase*           InCharacter                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::OnPortalScrollOverlapped(class AFloorPortalScrollBase* Portal, class ADCPlayerCharacterBase* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnPortalScrollOverlapped");

	Params::DCPlayerController_OnPortalScrollOverlapped Parms{};

	Parms.Portal = Portal;
	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnRep_AccountId
// (Final, Native, Private)
// Parameters:
// class FString                           OldId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::OnRep_AccountId(const class FString& OldId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnRep_AccountId");

	Params::DCPlayerController_OnRep_AccountId Parms{};

	Parms.OldId = std::move(OldId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnRep_InspectTarget
// (Final, Native, Private)
// Parameters:
// class ADCCharacterBase*                 OldInspectTarget                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::OnRep_InspectTarget(class ADCCharacterBase* OldInspectTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnRep_InspectTarget");

	Params::DCPlayerController_OnRep_InspectTarget Parms{};

	Parms.OldInspectTarget = OldInspectTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnRep_PersonalPlayerInfo
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCPersonalPlayerInfo            OldPlayerInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::OnRep_PersonalPlayerInfo(const struct FDCPersonalPlayerInfo& OldPlayerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnRep_PersonalPlayerInfo");

	Params::DCPlayerController_OnRep_PersonalPlayerInfo Parms{};

	Parms.OldPlayerInfo = std::move(OldPlayerInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnRep_ReportedInfoArray
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FDCReportedInfo>          InOldReportedInfoArray                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::OnRep_ReportedInfoArray(const TArray<struct FDCReportedInfo>& InOldReportedInfoArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnRep_ReportedInfoArray");

	Params::DCPlayerController_OnRep_ReportedInfoArray Parms{};

	Parms.InOldReportedInfoArray = std::move(InOldReportedInfoArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnServerCall
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FCallData                        CallData                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::OnServerCall(const struct FCallData& CallData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnServerCall");

	Params::DCPlayerController_OnServerCall Parms{};

	Parms.CallData = std::move(CallData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnServerNotify
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FNotifyData                      NotifyData                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::OnServerNotify(const struct FNotifyData& NotifyData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnServerNotify");

	Params::DCPlayerController_OnServerNotify Parms{};

	Parms.NotifyData = std::move(NotifyData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnSpectateTarget
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FDCAccountId                     SpectateAccountId                                      (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::OnSpectateTarget(const struct FDCAccountId& SpectateAccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnSpectateTarget");

	Params::DCPlayerController_OnSpectateTarget Parms{};

	Parms.SpectateAccountId = std::move(SpectateAccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.OnUnmuted
// (Event, Protected, BlueprintEvent)

void ADCPlayerController::OnUnmuted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnUnmuted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCPlayerController.OnUserExited_Client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EDCExitType                             ExitType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::OnUserExited_Client(const EDCExitType ExitType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnUserExited_Client");

	Params::DCPlayerController_OnUserExited_Client Parms{};

	Parms.ExitType = ExitType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.PauseFloorRuleForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::PauseFloorRuleForDebug_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "PauseFloorRuleForDebug_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ReportPlayer_Server
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FDCReportPlayerInfo              InReportPlayerInfo                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::ReportPlayer_Server(const struct FDCReportPlayerInfo& InReportPlayerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ReportPlayer_Server");

	Params::DCPlayerController_ReportPlayer_Server Parms{};

	Parms.InReportPlayerInfo = std::move(InReportPlayerInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.RequestPartyChatServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FChatData                        InChatData                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::RequestPartyChatServer(const struct FChatData& InChatData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "RequestPartyChatServer");

	Params::DCPlayerController_RequestPartyChatServer Parms{};

	Parms.InChatData = std::move(InChatData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.RequestPlayerCharacterLocation_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FDCAccountId                     InAccountId                                            (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::RequestPlayerCharacterLocation_Server(const struct FDCAccountId& InAccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "RequestPlayerCharacterLocation_Server");

	Params::DCPlayerController_RequestPlayerCharacterLocation_Server Parms{};

	Parms.InAccountId = std::move(InAccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ResumeFloorRuleForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::ResumeFloorRuleForDebug_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ResumeFloorRuleForDebug_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ServerDebugGiveGameplayEffectToTarget
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// class FString                           InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  GameplayEffectAssetId                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::ServerDebugGiveGameplayEffectToTarget(const class FString& InKey, class AActor* TargetActor, const struct FPrimaryAssetId& GameplayEffectAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ServerDebugGiveGameplayEffectToTarget");

	Params::DCPlayerController_ServerDebugGiveGameplayEffectToTarget Parms{};

	Parms.InKey = std::move(InKey);
	Parms.TargetActor = TargetActor;
	Parms.GameplayEffectAssetId = std::move(GameplayEffectAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ServerDebugInjectItemToTarget
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// TArray<struct FItemData>                InItemDataArray                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EInventoryType                          TargetInventoryType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::ServerDebugInjectItemToTarget(const TArray<struct FItemData>& InItemDataArray, EInventoryType TargetInventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ServerDebugInjectItemToTarget");

	Params::DCPlayerController_ServerDebugInjectItemToTarget Parms{};

	Parms.InItemDataArray = std::move(InItemDataArray);
	Parms.TargetInventoryType = TargetInventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ServerDebugSetupTagToTarget
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class FString                           InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TagOptionString                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::ServerDebugSetupTagToTarget(const class FString& InKey, class AActor* TargetActor, const class FString& TagOptionString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ServerDebugSetupTagToTarget");

	Params::DCPlayerController_ServerDebugSetupTagToTarget Parms{};

	Parms.InKey = std::move(InKey);
	Parms.TargetActor = TargetActor;
	Parms.TagOptionString = std::move(TagOptionString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ServerDebugSpawnItem
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// class FString                           InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  SpawnItemAssetId                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::ServerDebugSpawnItem(const class FString& InKey, class AActor* SpawnActor, const struct FPrimaryAssetId& SpawnItemAssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ServerDebugSpawnItem");

	Params::DCPlayerController_ServerDebugSpawnItem Parms{};

	Parms.InKey = std::move(InKey);
	Parms.SpawnActor = SpawnActor;
	Parms.SpawnItemAssetId = std::move(SpawnItemAssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ServerEventBroadcastTriggered
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EDCServerTriggeredEventType             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ServerFrame                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::ServerEventBroadcastTriggered(EDCServerTriggeredEventType EventType, int64 ServerFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ServerEventBroadcastTriggered");

	Params::DCPlayerController_ServerEventBroadcastTriggered Parms{};

	Parms.EventType = EventType;
	Parms.ServerFrame = ServerFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ServerToggleAnim
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::ServerToggleAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ServerToggleAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.SetClientReady_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::SetClientReady_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "SetClientReady_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.SetInspectTarget_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ADCCharacterBase*                 InInspectTarget                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::SetInspectTarget_Server(class ADCCharacterBase* InInspectTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "SetInspectTarget_Server");

	Params::DCPlayerController_SetInspectTarget_Server Parms{};

	Parms.InInspectTarget = InInspectTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.SetMerchnatListToQuestInterface
// (Final, Native, Private, BlueprintCallable)

void ADCPlayerController::SetMerchnatListToQuestInterface()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "SetMerchnatListToQuestInterface");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.SetQuestLogListToQuestInterface
// (Final, Native, Private, BlueprintCallable)

void ADCPlayerController::SetQuestLogListToQuestInterface()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "SetQuestLogListToQuestInterface");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.SpawnResurrectionCharacterForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FDCAccountId                     InAccountId                                            (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecoverItem                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LifeSpan                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::SpawnResurrectionCharacterForDebug_Server(const struct FDCAccountId& InAccountId, const bool bRecoverItem, const int32 LifeSpan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "SpawnResurrectionCharacterForDebug_Server");

	Params::DCPlayerController_SpawnResurrectionCharacterForDebug_Server Parms{};

	Parms.InAccountId = std::move(InAccountId);
	Parms.bRecoverItem = bRecoverItem;
	Parms.LifeSpan = LifeSpan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.StartToWearItem_Client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FItemData                        InWearingItemData                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           InWearingActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InDescription                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerController::StartToWearItem_Client(const struct FItemData& InWearingItemData, class AActor* InWearingActor, float InDuration, const class FText& InDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "StartToWearItem_Client");

	Params::DCPlayerController_StartToWearItem_Client Parms{};

	Parms.InWearingItemData = std::move(InWearingItemData);
	Parms.InWearingActor = InWearingActor;
	Parms.InDuration = InDuration;
	Parms.InDescription = std::move(InDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.StatServer
// (Final, Exec, Native, Public)

void ADCPlayerController::StatServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "StatServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.TerminateBase
// (Native, Public)

void ADCPlayerController::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.ToggleAnimBP
// (Final, Exec, Native, Public)

void ADCPlayerController::ToggleAnimBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "ToggleAnimBP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.TravelFloorMatchmaking_Client
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FDCGameLiftSessionId             SessionId                                              (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Address                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ServiceUrl                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::TravelFloorMatchmaking_Client(const struct FDCGameLiftSessionId& SessionId, const class FString& Address, const class FString& ServiceUrl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "TravelFloorMatchmaking_Client");

	Params::DCPlayerController_TravelFloorMatchmaking_Client Parms{};

	Parms.SessionId = std::move(SessionId);
	Parms.Address = std::move(Address);
	Parms.ServiceUrl = std::move(ServiceUrl);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "UnbindMsg");

	Params::DCPlayerController_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerController::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "UnbindMsgAll");

	Params::DCPlayerController_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.VerifyReconnection_Server
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADCPlayerController::VerifyReconnection_Server()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "VerifyReconnection_Server");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerController.GetAccountSessionData
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAccountSessionData        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FAccountSessionData ADCPlayerController::GetAccountSessionData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "GetAccountSessionData");

	Params::DCPlayerController_GetAccountSessionData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerController.GetExpressmanComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDCExpressmanComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCExpressmanComponent* ADCPlayerController::GetExpressmanComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "GetExpressmanComponent");

	Params::DCPlayerController_GetExpressmanComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerController.GetLootComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDCLootComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCLootComponent* ADCPlayerController::GetLootComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "GetLootComponent");

	Params::DCPlayerController_GetLootComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerController.GetPersonalPlayerInfo
// (Final, Native, Public, Const)
// Parameters:
// const struct FDCPersonalPlayerInfo      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDCPersonalPlayerInfo ADCPlayerController::GetPersonalPlayerInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "GetPersonalPlayerInfo");

	Params::DCPlayerController_GetPersonalPlayerInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerController.IsDungeonResultShowResult
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCPlayerController::IsDungeonResultShowResult() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "IsDungeonResultShowResult");

	Params::DCPlayerController_IsDungeonResultShowResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerController.OnLastQuestUpdate
// (Final, Native, Public, BlueprintCallable, Const)

void ADCPlayerController::OnLastQuestUpdate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerController", "OnLastQuestUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMetaPlayerController.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMetaPlayerController::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMetaPlayerController", "BroadcastMsgBlueprint");

	Params::DCMetaPlayerController_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMetaPlayerController.GetAccountSessionData
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FAccountSessionData        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FAccountSessionData ADCMetaPlayerController::GetAccountSessionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMetaPlayerController", "GetAccountSessionData");

	Params::DCMetaPlayerController_GetAccountSessionData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMetaPlayerController.Gm
// (Final, Exec, Native, Protected)
// Parameters:
// class FString                           InCmd                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMetaPlayerController::Gm(const class FString& InCmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMetaPlayerController", "Gm");

	Params::DCMetaPlayerController_Gm Parms{};

	Parms.InCmd = std::move(InCmd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMetaPlayerController.OnExitClicked
// (Final, Native, Public, BlueprintCallable)

void ADCMetaPlayerController::OnExitClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMetaPlayerController", "OnExitClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMetaPlayerController.OnExitConfirmed
// (Final, Native, Protected)
// Parameters:
// EPopupResult                            PopupResult                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMetaPlayerController::OnExitConfirmed(const EPopupResult PopupResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMetaPlayerController", "OnExitConfirmed");

	Params::DCMetaPlayerController_OnExitConfirmed Parms{};

	Parms.PopupResult = PopupResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMetaPlayerController.TerminateBase
// (Native, Public)

void ADCMetaPlayerController::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMetaPlayerController", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMetaPlayerController.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMetaPlayerController::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMetaPlayerController", "UnbindMsg");

	Params::DCMetaPlayerController_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMetaPlayerController.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMetaPlayerController::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMetaPlayerController", "UnbindMsgAll");

	Params::DCMetaPlayerController_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMetaPlayerController.UpdateGameState
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameStateData                   InGameStateData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADCMetaPlayerController::UpdateGameState(const struct FGameStateData& InGameStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMetaPlayerController", "UpdateGameState");

	Params::DCMetaPlayerController_UpdateGameState Parms{};

	Parms.InGameStateData = std::move(InGameStateData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTradePhaseDealWidget.OnCancelTradeButtonClicked
// (Final, Native, Private)

void UDCTradePhaseDealWidget::OnCancelTradeButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradePhaseDealWidget", "OnCancelTradeButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTradePhaseDealWidget.OnLocalTraderCheckBoxStateChanged
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    bIsChecked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCTradePhaseDealWidget::OnLocalTraderCheckBoxStateChanged(bool bIsChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradePhaseDealWidget", "OnLocalTraderCheckBoxStateChanged");

	Params::DCTradePhaseDealWidget_OnLocalTraderCheckBoxStateChanged Parms{};

	Parms.bIsChecked = bIsChecked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTradePhaseDealWidget.OnResponseLocalTraderRequestRequestResult
// (Final, Native, Private)
// Parameters:
// bool                                    bRequestSucceed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCTradePhaseDealWidget::OnResponseLocalTraderRequestRequestResult(bool bRequestSucceed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradePhaseDealWidget", "OnResponseLocalTraderRequestRequestResult");

	Params::DCTradePhaseDealWidget_OnResponseLocalTraderRequestRequestResult Parms{};

	Parms.bRequestSucceed = bRequestSucceed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MetaComponentBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetaComponentBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetaComponentBase", "BroadcastMsgBlueprint");

	Params::MetaComponentBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MetaComponentBase.TerminateBase
// (Native, Public)

void UMetaComponentBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetaComponentBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MetaComponentBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetaComponentBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetaComponentBase", "UnbindMsg");

	Params::MetaComponentBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MetaComponentBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetaComponentBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetaComponentBase", "UnbindMsgAll");

	Params::MetaComponentBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMetaTradeComponent.UpdateResetTimer
// (Final, Native, Private)

void UDCMetaTradeComponent::UpdateResetTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMetaTradeComponent", "UpdateResetTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTrainingCharacterSlotWidgetBase.IsSetMaster
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCTrainingCharacterSlotWidgetBase::IsSetMaster() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingCharacterSlotWidgetBase", "IsSetMaster");

	Params::DCTrainingCharacterSlotWidgetBase_IsSetMaster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAIController.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterAIController::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterAIController", "BroadcastMsgBlueprint");

	Params::DCMonsterAIController_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterAIController.ForceSightAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterAIController::ForceSightAll(bool bIsForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterAIController", "ForceSightAll");

	Params::DCMonsterAIController_ForceSightAll Parms{};

	Parms.bIsForce = bIsForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterAIController.OnPerceptionUpdated
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   UpdatedActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADCMonsterAIController::OnPerceptionUpdated(const TArray<class AActor*>& UpdatedActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterAIController", "OnPerceptionUpdated");

	Params::DCMonsterAIController_OnPerceptionUpdated Parms{};

	Parms.UpdatedActors = std::move(UpdatedActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterAIController.OnTargetPerceptionInfoUpdated
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FActorPerceptionUpdateInfo       UpdateInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADCMonsterAIController::OnTargetPerceptionInfoUpdated(const struct FActorPerceptionUpdateInfo& UpdateInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterAIController", "OnTargetPerceptionInfoUpdated");

	Params::DCMonsterAIController_OnTargetPerceptionInfoUpdated Parms{};

	Parms.UpdateInfo = std::move(UpdateInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterAIController.OnTargetPerceptionUpdated
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ADCMonsterAIController::OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterAIController", "OnTargetPerceptionUpdated");

	Params::DCMonsterAIController_OnTargetPerceptionUpdated Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterAIController.TerminateBase
// (Native, Public)

void ADCMonsterAIController::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterAIController", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterAIController.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterAIController::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterAIController", "UnbindMsg");

	Params::DCMonsterAIController_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterAIController.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterAIController::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterAIController", "UnbindMsgAll");

	Params::DCMonsterAIController_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.AddAggro
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 Target                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::AddAggro(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target, float Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "AddAggro");

	Params::DCMonsterAISystemBlueprintLibrary_AddAggro Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.Target = Target;
	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	Target = Parms.Target;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.ExcludeSummonerAndPartyMembers
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCMonsterAISystemBlueprintLibrary::ExcludeSummonerAndPartyMembers(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "ExcludeSummonerAndPartyMembers");

	Params::DCMonsterAISystemBlueprintLibrary_ExcludeSummonerAndPartyMembers Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterMonsterTargets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCMonsterAISystemBlueprintLibrary::FilterMonsterTargets(TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterMonsterTargets");

	Params::DCMonsterAISystemBlueprintLibrary_FilterMonsterTargets Parms{};

	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterMonsterTargetsByID
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ID                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterMonsterTargetsByID(TArray<class ADCCharacterBase*>& TargetArray, const struct FPrimaryAssetId& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterMonsterTargetsByID");

	Params::DCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterPlayerCharacterTargets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCMonsterAISystemBlueprintLibrary::FilterPlayerCharacterTargets(TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterPlayerCharacterTargets");

	Params::DCMonsterAISystemBlueprintLibrary_FilterPlayerCharacterTargets Parms{};

	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTagedTargets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterTagedTargets(TArray<class ADCCharacterBase*>& TargetArray, const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterTagedTargets");

	Params::DCMonsterAISystemBlueprintLibrary_FilterTagedTargets Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterTargetsOverDistance(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterTargetsOverDistance");

	Params::DCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverXYRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   XYRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterTargetsOverXYRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float XYRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterTargetsOverXYRange");

	Params::DCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.XYRange = XYRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverZRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ZRange                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterTargetsOverZRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float ZRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterTargetsOverZRange");

	Params::DCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.ZRange = ZRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDirectionAngleAndAllowedAngle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DirectionalAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AllowedAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterTargetsWithinDirectionAngleAndAllowedAngle(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float DirectionalAngle, float AllowedAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterTargetsWithinDirectionAngleAndAllowedAngle");

	Params::DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.DirectionalAngle = DirectionalAngle;
	Parms.AllowedAngle = AllowedAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterTargetsWithinDistance(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterTargetsWithinDistance");

	Params::DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DirectionalAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AllowedAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float Distance, float DirectionalAngle, float AllowedAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle");

	Params::DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.Distance = Distance;
	Parms.DirectionalAngle = DirectionalAngle;
	Parms.AllowedAngle = AllowedAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinXYRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   XYRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterTargetsWithinXYRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float XYRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterTargetsWithinXYRange");

	Params::DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.XYRange = XYRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   XYRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ZRange                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DirectionalAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AllowedAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float XYRange, float ZRange, float DirectionalAngle, float AllowedAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle");

	Params::DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.XYRange = XYRange;
	Parms.ZRange = ZRange;
	Parms.DirectionalAngle = DirectionalAngle;
	Parms.AllowedAngle = AllowedAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinZRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ZRange                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterTargetsWithinZRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, float ZRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterTargetsWithinZRange");

	Params::DCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.ZRange = ZRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterUnTagedTargets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::FilterUnTagedTargets(TArray<class ADCCharacterBase*>& TargetArray, const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "FilterUnTagedTargets");

	Params::DCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAggroMonster
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCMonsterBase*>           TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::GetAggroMonster(class ADCCharacterBase* DCCharacterBase, TArray<class ADCMonsterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "GetAggroMonster");

	Params::DCMonsterAISystemBlueprintLibrary_GetAggroMonster Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAggroPoint
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 Target                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccessfully                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCMonsterAISystemBlueprintLibrary::GetAggroPoint(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target, bool* bSuccessfully)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "GetAggroPoint");

	Params::DCMonsterAISystemBlueprintLibrary_GetAggroPoint Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	Target = Parms.Target;

	if (bSuccessfully != nullptr)
		*bSuccessfully = Parms.bSuccessfully;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAllTargetArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::GetAllTargetArray(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "GetAllTargetArray");

	Params::DCMonsterAISystemBlueprintLibrary_GetAllTargetArray Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetBaseAttributeValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               GameplayAttribute                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccessfully                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCMonsterAISystemBlueprintLibrary::GetBaseAttributeValue(class ADCCharacterBase*& DCCharacterBase, const struct FGameplayAttribute& GameplayAttribute, bool* bSuccessfully)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "GetBaseAttributeValue");

	Params::DCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.GameplayAttribute = std::move(GameplayAttribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;

	if (bSuccessfully != nullptr)
		*bSuccessfully = Parms.bSuccessfully;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetCurrentAttributeValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               GameplayAttribute                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccessfully                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCMonsterAISystemBlueprintLibrary::GetCurrentAttributeValue(class ADCCharacterBase*& DCCharacterBase, const struct FGameplayAttribute& GameplayAttribute, bool* bSuccessfully)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "GetCurrentAttributeValue");

	Params::DCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.GameplayAttribute = std::move(GameplayAttribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;

	if (bSuccessfully != nullptr)
		*bSuccessfully = Parms.bSuccessfully;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetDamageTargetArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::GetDamageTargetArray(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "GetDamageTargetArray");

	Params::DCMonsterAISystemBlueprintLibrary_GetDamageTargetArray Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetHearingTargetArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::GetHearingTargetArray(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "GetHearingTargetArray");

	Params::DCMonsterAISystemBlueprintLibrary_GetHearingTargetArray Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetMinionCount
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCMonsterAISystemBlueprintLibrary::GetMinionCount(class ADCMonsterBase*& DCMonsterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "GetMinionCount");

	Params::DCMonsterAISystemBlueprintLibrary_GetMinionCount Parms{};

	Parms.DCMonsterBase = DCMonsterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetSightTargetArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::GetSightTargetArray(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "GetSightTargetArray");

	Params::DCMonsterAISystemBlueprintLibrary_GetSightTargetArray Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetSummoner
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::GetSummoner(class ADCMonsterBase* DCMonsterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "GetSummoner");

	Params::DCMonsterAISystemBlueprintLibrary_GetSummoner Parms{};

	Parms.DCMonsterBase = DCMonsterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.IsAvailablePath
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DstLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::IsAvailablePath(class ADCMonsterBase*& DCMonsterBase, const struct FVector& DstLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "IsAvailablePath");

	Params::DCMonsterAISystemBlueprintLibrary_IsAvailablePath Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.DstLocation = std::move(DstLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.JumpToActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DstActor                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFavorHighArc                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::JumpToActor(class ADCCharacterBase*& DCCharacterBase, class AActor*& DstActor, float Power, bool bFavorHighArc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "JumpToActor");

	Params::DCMonsterAISystemBlueprintLibrary_JumpToActor Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.DstActor = DstActor;
	Parms.Power = Power;
	Parms.bFavorHighArc = bFavorHighArc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;
	DstActor = Parms.DstActor;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.JumpToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DstLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFavorHighArc                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::JumpToLocation(class ADCCharacterBase*& DCCharacterBase, const struct FVector& DstLocation, float Power, bool bFavorHighArc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "JumpToLocation");

	Params::DCMonsterAISystemBlueprintLibrary_JumpToLocation Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.DstLocation = std::move(DstLocation);
	Parms.Power = Power;
	Parms.bFavorHighArc = bFavorHighArc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.MulAggro
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 Target                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::MulAggro(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target, float Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "MulAggro");

	Params::DCMonsterAISystemBlueprintLibrary_MulAggro Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.Target = Target;
	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	Target = Parms.Target;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickRandomTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::PickRandomTarget(TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "PickRandomTarget");

	Params::DCMonsterAISystemBlueprintLibrary_PickRandomTarget Parms{};

	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::PickTarget(TArray<class ADCCharacterBase*>& TargetArray, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "PickTarget");

	Params::DCMonsterAISystemBlueprintLibrary_PickTarget Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickTopAggroTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::PickTopAggroTarget(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "PickTopAggroTarget");

	Params::DCMonsterAISystemBlueprintLibrary_PickTopAggroTarget Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.RemoveAggro
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 Target                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::RemoveAggro(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "RemoveAggro");

	Params::DCMonsterAISystemBlueprintLibrary_RemoveAggro Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	Target = Parms.Target;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.RemoveAggroAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::RemoveAggroAll(class ADCCharacterBase* DCCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "RemoveAggroAll");

	Params::DCMonsterAISystemBlueprintLibrary_RemoveAggroAll Parms{};

	Parms.DCCharacterBase = DCCharacterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SetAggro
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 Target                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::SetAggro(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target, float Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "SetAggro");

	Params::DCMonsterAISystemBlueprintLibrary_SetAggro Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.Target = Target;
	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	Target = Parms.Target;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SetAggroRate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::SetAggroRate(class ADCCharacterBase*& DCCharacterBase, float Time, float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "SetAggroRate");

	Params::DCMonsterAISystemBlueprintLibrary_SetAggroRate Parms{};

	Parms.DCCharacterBase = DCCharacterBase;
	Parms.Time = Time;
	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCCharacterBase = Parms.DCCharacterBase;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByAggro
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EMonsterFilterSortingType               MonsterFilterSortingType                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::SortTargetsByAggro(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, EMonsterFilterSortingType MonsterFilterSortingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "SortTargetsByAggro");

	Params::DCMonsterAISystemBlueprintLibrary_SortTargetsByAggro Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.MonsterFilterSortingType = MonsterFilterSortingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EMonsterFilterSortingType               MonsterFilterSortingType                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::SortTargetsByDistance(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, EMonsterFilterSortingType MonsterFilterSortingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "SortTargetsByDistance");

	Params::DCMonsterAISystemBlueprintLibrary_SortTargetsByDistance Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.MonsterFilterSortingType = MonsterFilterSortingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByDistanceAndPickTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EMonsterFilterSortingType               MonsterFilterSortingType                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::SortTargetsByDistanceAndPickTarget(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, EMonsterFilterSortingType MonsterFilterSortingType, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "SortTargetsByDistanceAndPickTarget");

	Params::DCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.MonsterFilterSortingType = MonsterFilterSortingType;
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByXYRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EMonsterFilterSortingType               MonsterFilterSortingType                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::SortTargetsByXYRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, EMonsterFilterSortingType MonsterFilterSortingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "SortTargetsByXYRange");

	Params::DCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.MonsterFilterSortingType = MonsterFilterSortingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByZRange
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADCCharacterBase*>         TargetArray                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EMonsterFilterSortingType               MonsterFilterSortingType                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::SortTargetsByZRange(class ADCMonsterBase*& DCMonsterBase, TArray<class ADCCharacterBase*>& TargetArray, EMonsterFilterSortingType MonsterFilterSortingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "SortTargetsByZRange");

	Params::DCMonsterAISystemBlueprintLibrary_SortTargetsByZRange Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.TargetArray = std::move(TargetArray);
	Parms.MonsterFilterSortingType = MonsterFilterSortingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	TargetArray = std::move(Parms.TargetArray);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SpawnMinion
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ADCMonsterBase>       MinionClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   XYRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccessfully                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::SpawnMinion(class ADCMonsterBase*& DCMonsterBase, TSubclassOf<class ADCMonsterBase> MinionClass, float XYRange, bool* bSuccessfully)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "SpawnMinion");

	Params::DCMonsterAISystemBlueprintLibrary_SpawnMinion Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.MinionClass = MinionClass;
	Parms.XYRange = XYRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;

	if (bSuccessfully != nullptr)
		*bSuccessfully = Parms.bSuccessfully;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SubAggro
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADCMonsterBase*                   DCMonsterBase                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCCharacterBase*                 Target                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMonsterAISystemBlueprintLibrary::SubAggro(class ADCMonsterBase*& DCMonsterBase, class ADCCharacterBase*& Target, float Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCMonsterAISystemBlueprintLibrary", "SubAggro");

	Params::DCMonsterAISystemBlueprintLibrary_SubAggro Parms{};

	Parms.DCMonsterBase = DCMonsterBase;
	Parms.Target = Target;
	Parms.Point = Point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DCMonsterBase = Parms.DCMonsterBase;
	Target = Parms.Target;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.BeforeDeath
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::BeforeDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "BeforeDeath");

	Params::DCMonsterBase_BeforeDeath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.Burrow
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::Burrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "Burrow");

	Params::DCMonsterBase_Burrow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.ChangeOrientRotationToMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::ChangeOrientRotationToMovement(const uint8 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "ChangeOrientRotationToMovement");

	Params::DCMonsterBase_ChangeOrientRotationToMovement Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.ChangePauseAnims
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::ChangePauseAnims(const uint8 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "ChangePauseAnims");

	Params::DCMonsterBase_ChangePauseAnims Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.CheckClassType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InClassTypeTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::CheckClassType(const struct FGameplayTag& InClassTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "CheckClassType");

	Params::DCMonsterBase_CheckClassType Parms{};

	Parms.InClassTypeTag = std::move(InClassTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.CheckGradeType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InGradeTypeTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::CheckGradeType(const struct FGameplayTag& InGradeTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "CheckGradeType");

	Params::DCMonsterBase_CheckGradeType Parms{};

	Parms.InGradeTypeTag = std::move(InGradeTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.Death
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::Death()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "Death");

	Params::DCMonsterBase_Death Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.Fly
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::Fly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "Fly");

	Params::DCMonsterBase_Fly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.GetDesignDataMonster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FDesignDataMonster         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDesignDataMonster ADCMonsterBase::GetDesignDataMonster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "GetDesignDataMonster");

	Params::DCMonsterBase_GetDesignDataMonster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.GetMonsterId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FPrimaryAssetId            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FPrimaryAssetId ADCMonsterBase::GetMonsterId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "GetMonsterId");

	Params::DCMonsterBase_GetMonsterId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.Interactable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::Interactable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "Interactable");

	Params::DCMonsterBase_Interactable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.InteractableOnly
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::InteractableOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "InteractableOnly");

	Params::DCMonsterBase_InteractableOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.InteractableWithoutHit
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::InteractableWithoutHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "InteractableWithoutHit");

	Params::DCMonsterBase_InteractableWithoutHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.Normal
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::Normal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "Normal");

	Params::DCMonsterBase_Normal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.NormalPhysics
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::NormalPhysics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "NormalPhysics");

	Params::DCMonsterBase_NormalPhysics Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterBase.OnAfterDeath
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ADCMonsterBase::OnAfterDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnAfterDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCMonsterBase.OnAsyncInitialized
// (Event, Protected, BlueprintEvent)

void ADCMonsterBase::OnAsyncInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnAsyncInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCMonsterBase.OnBeforeDeath
// (Native, Event, Protected, BlueprintEvent)

void ADCMonsterBase::OnBeforeDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnBeforeDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.OnDamaged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADCCharacterBase*                 DCCharacterBase                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnDamaged(class ADCCharacterBase* DCCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnDamaged");

	Params::DCMonsterBase_OnDamaged Parms{};

	Parms.DCCharacterBase = DCCharacterBase;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMonsterBase.OnFMsgGASAttributeNotifyBlueprint
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgGASAttributeNotify           InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnFMsgGASAttributeNotifyBlueprint(const struct FMsgGASAttributeNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnFMsgGASAttributeNotifyBlueprint");

	Params::DCMonsterBase_OnFMsgGASAttributeNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.OnLostTarget
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADCCharacterBase*                 InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnLostTarget(class ADCCharacterBase* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnLostTarget");

	Params::DCMonsterBase_OnLostTarget Parms{};

	Parms.InTarget = InTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMonsterBase.OnNewTarget
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADCCharacterBase*                 InTarget                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnNewTarget(class ADCCharacterBase* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnNewTarget");

	Params::DCMonsterBase_OnNewTarget Parms{};

	Parms.InTarget = InTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMonsterBase.OnOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnOverlapBegin");

	Params::DCMonsterBase_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnOverlapEnd");

	Params::DCMonsterBase_OnOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.OnRep_bIsRepRootMotionActive
// (Final, Native, Private)
// Parameters:
// bool                                    InOldbIsRepRootMotionActive                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnRep_bIsRepRootMotionActive(bool InOldbIsRepRootMotionActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnRep_bIsRepRootMotionActive");

	Params::DCMonsterBase_OnRep_bIsRepRootMotionActive Parms{};

	Parms.InOldbIsRepRootMotionActive = InOldbIsRepRootMotionActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.OnRep_MonsterCollisionProfile
// (Final, Native, Private, HasOutParams)
// Parameters:
// uint8                                   OldMonsterCollisionProfile                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnRep_MonsterCollisionProfile(const uint8& OldMonsterCollisionProfile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnRep_MonsterCollisionProfile");

	Params::DCMonsterBase_OnRep_MonsterCollisionProfile Parms{};

	Parms.OldMonsterCollisionProfile = OldMonsterCollisionProfile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.OnRep_MonsterId
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FPrimaryAssetId                  InOldMonsterId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnRep_MonsterId(const struct FPrimaryAssetId& InOldMonsterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnRep_MonsterId");

	Params::DCMonsterBase_OnRep_MonsterId Parms{};

	Parms.InOldMonsterId = std::move(InOldMonsterId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.OnRep_OrientRotationToMovement
// (Final, Native, Private, HasOutParams)
// Parameters:
// uint8                                   OldOrientRotationToMovement                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnRep_OrientRotationToMovement(const uint8& OldOrientRotationToMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnRep_OrientRotationToMovement");

	Params::DCMonsterBase_OnRep_OrientRotationToMovement Parms{};

	Parms.OldOrientRotationToMovement = OldOrientRotationToMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.OnRep_PauseAnims
// (Final, Native, Private, HasOutParams)
// Parameters:
// uint8                                   OldPauseAnims                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnRep_PauseAnims(const uint8& OldPauseAnims)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnRep_PauseAnims");

	Params::DCMonsterBase_OnRep_PauseAnims Parms{};

	Parms.OldPauseAnims = OldPauseAnims;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.OnSetAI
// (Event, Protected, BlueprintEvent)

void ADCMonsterBase::OnSetAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnSetAI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCMonsterBase.OnStuckByShield
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADCCharacterBase*                 InInstigator                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InEffectCauser                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::OnStuckByShield(class ADCCharacterBase* InInstigator, class AActor* InEffectCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "OnStuckByShield");

	Params::DCMonsterBase_OnStuckByShield Parms{};

	Parms.InInstigator = InInstigator;
	Parms.InEffectCauser = InEffectCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMonsterBase.SetDelayDeathStatus
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bStatus                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::SetDelayDeathStatus(bool bStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "SetDelayDeathStatus");

	Params::DCMonsterBase_SetDelayDeathStatus Parms{};

	Parms.bStatus = bStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.SetMonsterId
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InMonsterId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterBase::SetMonsterId(const struct FPrimaryAssetId& InMonsterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "SetMonsterId");

	Params::DCMonsterBase_SetMonsterId Parms{};

	Parms.InMonsterId = std::move(InMonsterId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterBase.GetDelayDeathStatus
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCMonsterBase::GetDelayDeathStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterBase", "GetDelayDeathStatus");

	Params::DCMonsterBase_GetDelayDeathStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCTrainingOptionWidgetBase.OnSetTrainingRewardInfo
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDCTrainingState                        TrainingState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDCTrainingClassAbilityType             ClassAbilityType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCTrainingOptionWidgetBase::OnSetTrainingRewardInfo(EDCTrainingState TrainingState, EDCTrainingClassAbilityType ClassAbilityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingOptionWidgetBase", "OnSetTrainingRewardInfo");

	Params::DCTrainingOptionWidgetBase_OnSetTrainingRewardInfo Parms{};

	Parms.TrainingState = TrainingState;
	Parms.ClassAbilityType = ClassAbilityType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMonsterGameplayAbilityBase.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UDCMonsterGameplayAbilityBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterGameplayAbilityBase", "AbilityActivated");

	Params::DCMonsterGameplayAbilityBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMonsterSpawner.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterSpawner::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterSpawner", "BroadcastMsgBlueprint");

	Params::DCMonsterSpawner_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterSpawner.Spawns
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ADCMonsterBase*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADCMonsterBase*> ADCMonsterSpawner::Spawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterSpawner", "Spawns");

	Params::DCMonsterSpawner_Spawns Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMonsterSpawner.TerminateBase
// (Native, Public)

void ADCMonsterSpawner::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterSpawner", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterSpawner.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterSpawner::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterSpawner", "UnbindMsg");

	Params::DCMonsterSpawner_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterSpawner.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCMonsterSpawner::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterSpawner", "UnbindMsgAll");

	Params::DCMonsterSpawner_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMonsterSpawner.UpdateGameState
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameStateData                   InGameStateData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADCMonsterSpawner::UpdateGameState(const struct FGameStateData& InGameStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMonsterSpawner", "UpdateGameState");

	Params::DCMonsterSpawner_UpdateGameState Parms{};

	Parms.InGameStateData = std::move(InGameStateData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCInventoryMoveAbility.OnMoveApplied
// (Final, Native, Private)

void UDCInventoryMoveAbility::OnMoveApplied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCInventoryMoveAbility", "OnMoveApplied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChatWidget.OnReadRulesButtonClicked
// (Final, Native, Private)

void UTradeChatWidget::OnReadRulesButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChatWidget", "OnReadRulesButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMovementModeInterface.SetLadderMode
// (Native, Public, BlueprintCallable)
// Parameters:
// class UBoxComponent*                    InLadderBoxComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDCMovementModeInterface::SetLadderMode(class UBoxComponent* InLadderBoxComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMovementModeInterface", "SetLadderMode");

	Params::DCMovementModeInterface_SetLadderMode Parms{};

	Parms.InLadderBoxComponent = InLadderBoxComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMovementModeInterface.SetWalkingMode
// (Native, Public, BlueprintCallable)

void IDCMovementModeInterface::SetWalkingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMovementModeInterface", "SetWalkingMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMovementModeInterface.IsLadderMode
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDCMovementModeInterface::IsLadderMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMovementModeInterface", "IsLadderMode");

	Params::DCMovementModeInterface_IsLadderMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMultiLineEditableTextBox.Goto
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOffset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMultiLineEditableTextBox::Goto(int32 InLineIndex, int32 InOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMultiLineEditableTextBox", "Goto");

	Params::DCMultiLineEditableTextBox_Goto Parms{};

	Parms.InLineIndex = InLineIndex;
	Parms.InOffset = InOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMultiLineEditableTextBox.AnyTextSelected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCMultiLineEditableTextBox::AnyTextSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMultiLineEditableTextBox", "AnyTextSelected");

	Params::DCMultiLineEditableTextBox_AnyTextSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMultiLineEditableTextBox.InsertTextAtCursor
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FString                           InText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMultiLineEditableTextBox::InsertTextAtCursor(const class FString& InText) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMultiLineEditableTextBox", "InsertTextAtCursor");

	Params::DCMultiLineEditableTextBox_InsertTextAtCursor Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTooltipWidget.SetTooltipData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InNameText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InDescriptionText                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCTooltipWidget::SetTooltipData(const class FText& InNameText, const class FText& InDescriptionText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTooltipWidget", "SetTooltipData");

	Params::DCTooltipWidget_SetTooltipData Parms{};

	Parms.InNameText = std::move(InNameText);
	Parms.InDescriptionText = std::move(InDescriptionText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMusicTooltipWidget.SetType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     SourceTypeTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMusicTooltipWidget::SetType(const struct FGameplayTag& SourceTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMusicTooltipWidget", "SetType");

	Params::DCMusicTooltipWidget_SetType Parms{};

	Parms.SourceTypeTag = std::move(SourceTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCMusicWidgetBase.GetMusicTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCMusicWidgetBase::GetMusicTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMusicWidgetBase", "GetMusicTooltipWidget");

	Params::DCMusicWidgetBase_GetMusicTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCMusicWidgetBase.OnArtDataSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UArtDataMusic*                    ArtData                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCMusicWidgetBase::OnArtDataSet(const class UArtDataMusic* ArtData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMusicWidgetBase", "OnArtDataSet");

	Params::DCMusicWidgetBase_OnArtDataSet Parms{};

	Parms.ArtData = ArtData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCMusicWidgetBase.OnReset
// (Event, Protected, BlueprintEvent)

void UDCMusicWidgetBase::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCMusicWidgetBase", "OnReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCNavigationSystem.FindPathToLocation
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PathStart                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PathEnd                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           PathfindingContext                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCNavigationSystem::FindPathToLocation(class UObject* WorldContextObject, const struct FVector& PathStart, const struct FVector& PathEnd, class AActor* PathfindingContext, TSubclassOf<class UNavigationQueryFilter> FilterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCNavigationSystem", "FindPathToLocation");

	Params::DCNavigationSystem_FindPathToLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PathStart = std::move(PathStart);
	Parms.PathEnd = std::move(PathEnd);
	Parms.PathfindingContext = PathfindingContext;
	Parms.FilterClass = FilterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShapeShiftWidgetBase.GetShapeShiftTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCShapeShiftWidgetBase::GetShapeShiftTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShapeShiftWidgetBase", "GetShapeShiftTooltipWidget");

	Params::DCShapeShiftWidgetBase_GetShapeShiftTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShapeShiftWidgetBase.OnArtDataSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDCCharacterShapeShiftArtData*    ArtData                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCShapeShiftWidgetBase::OnArtDataSet(const class UDCCharacterShapeShiftArtData* ArtData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShapeShiftWidgetBase", "OnArtDataSet");

	Params::DCShapeShiftWidgetBase_OnArtDataSet Parms{};

	Parms.ArtData = ArtData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCShapeShiftWidgetBase.OnReset
// (Event, Protected, BlueprintEvent)

void UDCShapeShiftWidgetBase::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShapeShiftWidgetBase", "OnReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCNPCExpressman.Despawn
// (Final, Native, Private)

void ADCNPCExpressman::Despawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCNPCExpressman", "Despawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCNPCExpressman.ExpressReaction
// (Final, Native, Public)
// Parameters:
// bool                                    bIsReaction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCNPCExpressman::ExpressReaction(const bool bIsReaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCNPCExpressman", "ExpressReaction");

	Params::DCNPCExpressman_ExpressReaction Parms{};

	Parms.bIsReaction = bIsReaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCNPCInteractAbility.OnFinish
// (Final, Native, Private)

void UDCNPCInteractAbility::OnFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCNPCInteractAbility", "OnFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCNPCInteractAbility.OnOutOfRange
// (Final, Native, Private)

void UDCNPCInteractAbility::OnOutOfRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCNPCInteractAbility", "OnOutOfRange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPartyManager.Add
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCPartyId                       PartyId                                                (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCAccountId                     AccountId                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPartyManager::Add(const struct FDCPartyId& PartyId, const struct FDCAccountId& AccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPartyManager", "Add");

	Params::DCPartyManager_Add Parms{};

	Parms.PartyId = std::move(PartyId);
	Parms.AccountId = std::move(AccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPartyManager.DebugOnScreen
// (Final, Native, Public)

void UDCPartyManager::DebugOnScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPartyManager", "DebugOnScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPartyManager.OnPlayerAdded
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCPlayerInfo                    Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCPartyManager::OnPlayerAdded(const struct FDCPlayerInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPartyManager", "OnPlayerAdded");

	Params::DCPartyManager_OnPlayerAdded Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPartyManager.OnPlayerRemoved
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCPlayerInfo                    RemovedPlayer                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCPartyManager::OnPlayerRemoved(const struct FDCPlayerInfo& RemovedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPartyManager", "OnPlayerRemoved");

	Params::DCPartyManager_OnPlayerRemoved Parms{};

	Parms.RemovedPlayer = std::move(RemovedPlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPartyManager.OnPlayerUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCPlayerInfo                    NewInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDCPlayerInfo                    OldInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCPartyManager::OnPlayerUpdated(const struct FDCPlayerInfo& NewInfo, const struct FDCPlayerInfo& OldInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPartyManager", "OnPlayerUpdated");

	Params::DCPartyManager_OnPlayerUpdated Parms{};

	Parms.NewInfo = std::move(NewInfo);
	Parms.OldInfo = std::move(OldInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPartyManager.Remove
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCPartyId                       PartyId                                                (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCAccountId                     AccountId                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPartyManager::Remove(const struct FDCPartyId& PartyId, const struct FDCAccountId& AccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPartyManager", "Remove");

	Params::DCPartyManager_Remove Parms{};

	Parms.PartyId = std::move(PartyId);
	Parms.AccountId = std::move(AccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPartyManager.Update
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCPlayerInfo                    Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCPartyManager::Update(const struct FDCPlayerInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPartyManager", "Update");

	Params::DCPartyManager_Update Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPartyManager.GetParties
// (Final, Native, Public, Const)
// Parameters:
// TArray<struct FDCPartyId>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDCPartyId> UDCPartyManager::GetParties() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPartyManager", "GetParties");

	Params::DCPartyManager_GetParties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPedestalPortal.OnBlizzardData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameBlizzardData                InBlizzardData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPedestalPortal::OnBlizzardData(const struct FGameBlizzardData& InBlizzardData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortal", "OnBlizzardData");

	Params::DCPedestalPortal_OnBlizzardData Parms{};

	Parms.InBlizzardData = std::move(InBlizzardData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortal.OnDeathSwarmData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameDeathSwarmData              InDeathSwarmData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPedestalPortal::OnDeathSwarmData(const struct FGameDeathSwarmData& InDeathSwarmData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortal", "OnDeathSwarmData");

	Params::DCPedestalPortal_OnDeathSwarmData Parms{};

	Parms.InDeathSwarmData = std::move(InDeathSwarmData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortal.OnFloorRuleData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameFloorRuleData               InFloorRuleData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPedestalPortal::OnFloorRuleData(const struct FGameFloorRuleData& InFloorRuleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortal", "OnFloorRuleData");

	Params::DCPedestalPortal_OnFloorRuleData Parms{};

	Parms.InFloorRuleData = std::move(InFloorRuleData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortal.OnPortalEffect
// (Native, Event, Protected, BlueprintEvent)

void ADCPedestalPortal::OnPortalEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortal", "OnPortalEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortal.OnRep_ConfirmedPedestalPortalScrollType
// (Final, Native, Private, HasOutParams)
// Parameters:
// EDCPortalScrollType                     InOldConfirmedPedestalPortalScrollType                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPedestalPortal::OnRep_ConfirmedPedestalPortalScrollType(const EDCPortalScrollType& InOldConfirmedPedestalPortalScrollType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortal", "OnRep_ConfirmedPedestalPortalScrollType");

	Params::DCPedestalPortal_OnRep_ConfirmedPedestalPortalScrollType Parms{};

	Parms.InOldConfirmedPedestalPortalScrollType = InOldConfirmedPedestalPortalScrollType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortal.OnRep_IsRiseUp
// (Final, Native, Private)

void ADCPedestalPortal::OnRep_IsRiseUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortal", "OnRep_IsRiseUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortal.OnRightAfterDecidedPortalType
// (Event, Protected, BlueprintEvent)

void ADCPedestalPortal::OnRightAfterDecidedPortalType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortal", "OnRightAfterDecidedPortalType");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCPedestalPortal.RiseUpPortalHeadStone
// (Native, Event, Protected, BlueprintEvent)

void ADCPedestalPortal::RiseUpPortalHeadStone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortal", "RiseUpPortalHeadStone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortalScrollBase.BeginOverlapPortal
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndx                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADCPedestalPortalScrollBase::BeginOverlapPortal(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndx, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortalScrollBase", "BeginOverlapPortal");

	Params::DCPedestalPortalScrollBase_BeginOverlapPortal Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndx = OtherBodyIndx;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortalScrollBase.ClosePortalScroll
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADCPlayerCharacterBase*           Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPedestalPortalScrollBase::ClosePortalScroll(class ADCPlayerCharacterBase* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortalScrollBase", "ClosePortalScroll");

	Params::DCPedestalPortalScrollBase_ClosePortalScroll Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortalScrollBase.OnRep_IsOpen
// (Final, Native, Protected)

void ADCPedestalPortalScrollBase::OnRep_IsOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortalScrollBase", "OnRep_IsOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortalScrollBase.OnRep_IsRiseUp
// (Final, Native, Public)

void ADCPedestalPortalScrollBase::OnRep_IsRiseUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortalScrollBase", "OnRep_IsRiseUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortalScrollBase.PortalOpen
// (Native, Event, Protected, BlueprintEvent)

void ADCPedestalPortalScrollBase::PortalOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortalScrollBase", "PortalOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPedestalPortalScrollBase.SetPortalHeadStoneMaterial
// (Event, Public, BlueprintEvent)

void ADCPedestalPortalScrollBase::SetPortalHeadStoneMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPedestalPortalScrollBase", "SetPortalHeadStoneMaterial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCPerkDataComponent.OnRep_PerkDataIds
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FPrimaryAssetId>          OldValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDCPerkDataComponent::OnRep_PerkDataIds(const TArray<struct FPrimaryAssetId>& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPerkDataComponent", "OnRep_PerkDataIds");

	Params::DCPerkDataComponent_OnRep_PerkDataIds Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerBlueprintFunctionLibrary.GetCurrentPlayerPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UDCPlayerBlueprintFunctionLibrary::GetCurrentPlayerPawn(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCPlayerBlueprintFunctionLibrary", "GetCurrentPlayerPawn");

	Params::DCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerBlueprintFunctionLibrary.Log
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Str                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCPlayerBlueprintFunctionLibrary::Log(const class FString& Str)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCPlayerBlueprintFunctionLibrary", "Log");

	Params::DCPlayerBlueprintFunctionLibrary_Log Parms{};

	Parms.Str = std::move(Str);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRecruitChannelWidget.OnCloseInspectingInventoryClicked
// (Final, Native, Protected, BlueprintCallable)

void UDCRecruitChannelWidget::OnCloseInspectingInventoryClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRecruitChannelWidget", "OnCloseInspectingInventoryClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRecruitChannelWidget.OnLeaveClicked
// (Final, Native, Protected, BlueprintCallable)

void UDCRecruitChannelWidget::OnLeaveClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRecruitChannelWidget", "OnLeaveClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.ChangeGender_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EDCGender                               Gender                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerCharacterBase::ChangeGender_Server(const EDCGender Gender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "ChangeGender_Server");

	Params::DCPlayerCharacterBase_ChangeGender_Server Parms{};

	Parms.Gender = Gender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.ClientShowSystemMessage
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class FText                             MessageText                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerCharacterBase::ClientShowSystemMessage(const class FText& MessageText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "ClientShowSystemMessage");

	Params::DCPlayerCharacterBase_ClientShowSystemMessage Parms{};

	Parms.MessageText = std::move(MessageText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.GetFootstepLocationWithGameplayTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InFootstepTag                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADCPlayerCharacterBase::GetFootstepLocationWithGameplayTag(const class UObject* WorldContextObject, const struct FGameplayTag& InFootstepTag, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "GetFootstepLocationWithGameplayTag");

	Params::DCPlayerCharacterBase_GetFootstepLocationWithGameplayTag Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InFootstepTag = std::move(InFootstepTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerCharacterBase.GetHoldingItemActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class AItemActor*>               OutItemActors                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ADCPlayerCharacterBase::GetHoldingItemActors(TArray<class AItemActor*>* OutItemActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "GetHoldingItemActors");

	Params::DCPlayerCharacterBase_GetHoldingItemActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemActors != nullptr)
		*OutItemActors = std::move(Parms.OutItemActors);
}


// Function DungeonCrawler.DCPlayerCharacterBase.OnActionSkinChanged
// (Final, Native, Private)
// Parameters:
// class UDCActionSkinDataAsset*           ActionSkinData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsEquipped                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerCharacterBase::OnActionSkinChanged(const class UDCActionSkinDataAsset* ActionSkinData, const bool bIsEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "OnActionSkinChanged");

	Params::DCPlayerCharacterBase_OnActionSkinChanged Parms{};

	Parms.ActionSkinData = ActionSkinData;
	Parms.bIsEquipped = bIsEquipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.OnRep_CharacterKey
// (Final, Native, Private)
// Parameters:
// struct FDCPlayerCharacterKey            Old                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerCharacterBase::OnRep_CharacterKey(const struct FDCPlayerCharacterKey& Old)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "OnRep_CharacterKey");

	Params::DCPlayerCharacterBase_OnRep_CharacterKey Parms{};

	Parms.Old = std::move(Old);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.OnRep_ItemBoneModifies
// (Final, Native, Private)

void ADCPlayerCharacterBase::OnRep_ItemBoneModifies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "OnRep_ItemBoneModifies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.OnRep_OwnedSkillIdArray
// (Final, Native, Private)

void ADCPlayerCharacterBase::OnRep_OwnedSkillIdArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "OnRep_OwnedSkillIdArray");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.ResetDungeonModuleData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDCDungeonModuleDataAsset*        InDungeonModuleData                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerCharacterBase::ResetDungeonModuleData(const class UDCDungeonModuleDataAsset* InDungeonModuleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "ResetDungeonModuleData");

	Params::DCPlayerCharacterBase_ResetDungeonModuleData Parms{};

	Parms.InDungeonModuleData = InDungeonModuleData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.SetDungeonModuleData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDCDungeonModuleDataAsset*        InDungeonModuleData                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerCharacterBase::SetDungeonModuleData(const class UDCDungeonModuleDataAsset* InDungeonModuleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "SetDungeonModuleData");

	Params::DCPlayerCharacterBase_SetDungeonModuleData Parms{};

	Parms.InDungeonModuleData = InDungeonModuleData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.SetWindforceToMovement
// (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient)
// Parameters:
// struct FVector                          WindVector                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerCharacterBase::SetWindforceToMovement(const struct FVector& WindVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "SetWindforceToMovement");

	Params::DCPlayerCharacterBase_SetWindforceToMovement Parms{};

	Parms.WindVector = std::move(WindVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.SetWindforceVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WindforceVec                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerCharacterBase::SetWindforceVector(const struct FVector& WindforceVec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "SetWindforceVector");

	Params::DCPlayerCharacterBase_SetWindforceVector Parms{};

	Parms.WindforceVec = std::move(WindforceVec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterBase.GetEquipmentComponentV2
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDCEquipmentComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCEquipmentComponent* ADCPlayerCharacterBase::GetEquipmentComponentV2() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "GetEquipmentComponentV2");

	Params::DCPlayerCharacterBase_GetEquipmentComponentV2 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerCharacterBase.GetGender
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCGender                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCGender ADCPlayerCharacterBase::GetGender() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "GetGender");

	Params::DCPlayerCharacterBase_GetGender Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerCharacterBase.GetPerkDataComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDCPerkDataComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCPerkDataComponent* ADCPlayerCharacterBase::GetPerkDataComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "GetPerkDataComponent");

	Params::DCPlayerCharacterBase_GetPerkDataComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCPlayerCharacterBase.ShowHitDirectionUIMessage
// (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient, Const)
// Parameters:
// class AActor*                           SourceActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADCPlayerCharacterBase::ShowHitDirectionUIMessage(const class AActor* SourceActor, const struct FVector& HitDirection) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterBase", "ShowHitDirectionUIMessage");

	Params::DCPlayerCharacterBase_ShowHitDirectionUIMessage Parms{};

	Parms.SourceActor = SourceActor;
	Parms.HitDirection = std::move(HitDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCPlayerCharacterInterface.GetPartHeadMeshAsset
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* IDCPlayerCharacterInterface::GetPartHeadMeshAsset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerCharacterInterface", "GetPartHeadMeshAsset");

	Params::DCPlayerCharacterInterface_GetPartHeadMeshAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCRedeemRewardTokenCheckPopup.OnCancelButtonClicked
// (Final, Native, Private)

void UDCRedeemRewardTokenCheckPopup::OnCancelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRedeemRewardTokenCheckPopup", "OnCancelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRedeemRewardTokenCheckPopup.OnRedeemButtonClicked
// (Final, Native, Private)

void UDCRedeemRewardTokenCheckPopup::OnRedeemButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRedeemRewardTokenCheckPopup", "OnRedeemButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionBlessingLevelWidget.SetBlessingWidgetInfo
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    bIsActivate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             BlessingName                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   BlessingLevel                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             BlessingDesc                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCReligionBlessingLevelWidget::SetBlessingWidgetInfo(bool bIsActivate, const class FText& BlessingName, const int32 BlessingLevel, const class FText& BlessingDesc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionBlessingLevelWidget", "SetBlessingWidgetInfo");

	Params::DCReligionBlessingLevelWidget_SetBlessingWidgetInfo Parms{};

	Parms.bIsActivate = bIsActivate;
	Parms.BlessingName = std::move(BlessingName);
	Parms.BlessingLevel = BlessingLevel;
	Parms.BlessingDesc = std::move(BlessingDesc);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCPlayerInfoHolder.OnRep_PlayerInfo
// (Final, Native, Private, HasOutParams, Const)
// Parameters:
// struct FDCPlayerInfo                    OldPlayerInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADCPlayerInfoHolder::OnRep_PlayerInfo(const struct FDCPlayerInfo& OldPlayerInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCPlayerInfoHolder", "OnRep_PlayerInfo");

	Params::DCPlayerInfoHolder_OnRep_PlayerInfo Parms{};

	Parms.OldPlayerInfo = std::move(OldPlayerInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCQuestCompleteResultPopup.OnConfirmButtonClicked
// (Final, Native, Private)

void UDCQuestCompleteResultPopup::OnConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestCompleteResultPopup", "OnConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCQuestListEntryWidget.IsSelected
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCQuestListEntryWidget::IsSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestListEntryWidget", "IsSelected");

	Params::DCQuestListEntryWidget_IsSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCQuestLogContentsListEntry.IsSelected
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCQuestLogContentsListEntry::IsSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogContentsListEntry", "IsSelected");

	Params::DCQuestLogContentsListEntry_IsSelected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCQuestLogWidgetBase.OnAcceptAllButtonEnable
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCQuestLogWidgetBase::OnAcceptAllButtonEnable(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogWidgetBase", "OnAcceptAllButtonEnable");

	Params::DCQuestLogWidgetBase_OnAcceptAllButtonEnable Parms{};

	Parms.IsEnable = IsEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCQuestLogWidgetBase.OnQuestAcceptAll
// (Final, Native, Protected)

void UDCQuestLogWidgetBase::OnQuestAcceptAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogWidgetBase", "OnQuestAcceptAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCQuestLogWidgetBase.OnQuestAcceptAllSoundEvent
// (Event, Protected, BlueprintEvent)

void UDCQuestLogWidgetBase::OnQuestAcceptAllSoundEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogWidgetBase", "OnQuestAcceptAllSoundEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCQuestLogWidgetBase.OnQuestLogVisibilityChange
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsEmpty                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCQuestLogWidgetBase::OnQuestLogVisibilityChange(bool bIsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogWidgetBase", "OnQuestLogVisibilityChange");

	Params::DCQuestLogWidgetBase_OnQuestLogVisibilityChange Parms{};

	Parms.bIsEmpty = bIsEmpty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCQuestLogWidgetBase.SetIsActivated
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bIsActivate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCQuestLogWidgetBase::SetIsActivated(bool bIsActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCQuestLogWidgetBase", "SetIsActivated");

	Params::DCQuestLogWidgetBase_SetIsActivated Parms{};

	Parms.bIsActivate = bIsActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCRecruitChannelListEntryWidget.OnClicked
// (Final, Native, Protected, BlueprintCallable)

void UDCRecruitChannelListEntryWidget::OnClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRecruitChannelListEntryWidget", "OnClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionBurfPopup.OnConfirmButtonClicked
// (Final, Native, Private)

void UDCReligionBurfPopup::OnConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionBurfPopup", "OnConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReligionBurfPopup.SetBlessingLevel
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCReligionBurfPopup::SetBlessingLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionBurfPopup", "SetBlessingLevel");

	Params::DCReligionBurfPopup_SetBlessingLevel Parms{};

	Parms.Level = Level;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCReligionBurfPopup.SetReligionTimer
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FReligionRankTimerInfo           Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDCReligionBurfPopup::SetReligionTimer(const struct FReligionRankTimerInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionBurfPopup", "SetReligionTimer");

	Params::DCReligionBurfPopup_SetReligionTimer Parms{};

	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCReligionRankEntryMine.OnFMsgWidgetStreamingModeNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetStreamingModeNotify    InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCReligionRankEntryMine::OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionRankEntryMine", "OnFMsgWidgetStreamingModeNotifyBlueprint");

	Params::DCReligionRankEntryMine_OnFMsgWidgetStreamingModeNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCReligionRankEntryMine.OnReligionRankRecordMineData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FReligionRankRecordMineData      NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FReligionRankRecordMineData      OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCReligionRankEntryMine::OnReligionRankRecordMineData(const struct FReligionRankRecordMineData& NewValue, const struct FReligionRankRecordMineData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionRankEntryMine", "OnReligionRankRecordMineData");

	Params::DCReligionRankEntryMine_OnReligionRankRecordMineData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCReligionRankEntryMine.SetOfferCountToWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   Count                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCReligionRankEntryMine::SetOfferCountToWidget(const int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReligionRankEntryMine", "SetOfferCountToWidget");

	Params::DCReligionRankEntryMine_SetOfferCountToWidget Parms{};

	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCReportPlayerResultPopup.HandleConfirmButtonClicked
// (Final, Native, Protected)

void UDCReportPlayerResultPopup::HandleConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerResultPopup", "HandleConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCReportPlayerResultPopup.GetPermanentBanListText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText UDCReportPlayerResultPopup::GetPermanentBanListText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerResultPopup", "GetPermanentBanListText");

	Params::DCReportPlayerResultPopup_GetPermanentBanListText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCReportPlayerResultPopup.GetTemporaryBanListText
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText UDCReportPlayerResultPopup::GetTemporaryBanListText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCReportPlayerResultPopup", "GetTemporaryBanListText");

	Params::DCReportPlayerResultPopup_GetTemporaryBanListText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCRewardPopupBase.OnConfirmButtonClicked
// (Final, Native, Private)

void UDCRewardPopupBase::OnConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCRewardPopupBase", "OnConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopCurrencyTypeSlotWidgetBase.HasNotEnoughCurrency
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCShopCurrencyTypeSlotWidgetBase::HasNotEnoughCurrency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopCurrencyTypeSlotWidgetBase", "HasNotEnoughCurrency");

	Params::DCShopCurrencyTypeSlotWidgetBase_HasNotEnoughCurrency Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopCurrencyTypeSlotWidgetBase.IsBluestoneShardType
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCShopCurrencyTypeSlotWidgetBase::IsBluestoneShardType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopCurrencyTypeSlotWidgetBase", "IsBluestoneShardType");

	Params::DCShopCurrencyTypeSlotWidgetBase_IsBluestoneShardType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopCurrencyTypeSlotWidgetBase.IsRedstoneShardType
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCShopCurrencyTypeSlotWidgetBase::IsRedstoneShardType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopCurrencyTypeSlotWidgetBase", "IsRedstoneShardType");

	Params::DCShopCurrencyTypeSlotWidgetBase_IsRedstoneShardType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopCurrencyTypeSlotWidgetBase.OnChangedCheckState
// (Final, Native, Private)
// Parameters:
// bool                                    bNewState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCShopCurrencyTypeSlotWidgetBase::OnChangedCheckState(bool bNewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopCurrencyTypeSlotWidgetBase", "OnChangedCheckState");

	Params::DCShopCurrencyTypeSlotWidgetBase_OnChangedCheckState Parms{};

	Parms.bNewState = bNewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopItemSlotWidget.GetShopItemState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// EDCShopItemState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCShopItemState UDCShopItemSlotWidget::GetShopItemState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopItemSlotWidget", "GetShopItemState");

	Params::DCShopItemSlotWidget_GetShopItemState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopItemSlotWidget.GetTooltipWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDCShopItemSlotWidget::GetTooltipWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopItemSlotWidget", "GetTooltipWidget");

	Params::DCShopItemSlotWidget_GetTooltipWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopWidgetBase.OnButtonBuyClicked
// (Final, Native, Private)

void UDCShopWidgetBase::OnButtonBuyClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "OnButtonBuyClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopWidgetBase.OnButtonEnterCodeClicked
// (Final, Native, Private)

void UDCShopWidgetBase::OnButtonEnterCodeClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "OnButtonEnterCodeClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopWidgetBase.OnButtonRedstoneShardBuyClicked
// (Final, Native, Private)

void UDCShopWidgetBase::OnButtonRedstoneShardBuyClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "OnButtonRedstoneShardBuyClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopWidgetBase.OnNextPage
// (Final, Native, Private)

void UDCShopWidgetBase::OnNextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "OnNextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopWidgetBase.OnPreviewSwitched
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDCShopItemType                         ItemType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCShopWidgetBase::OnPreviewSwitched(const EDCShopItemType ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "OnPreviewSwitched");

	Params::DCShopWidgetBase_OnPreviewSwitched Parms{};

	Parms.ItemType = ItemType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.DCShopWidgetBase.OnPrevPage
// (Final, Native, Private)

void UDCShopWidgetBase::OnPrevPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "OnPrevPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopWidgetBase.OnSelectedShopCategoryTabChanged
// (Final, Native, Private)
// Parameters:
// class FName                             SelectedTabId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCShopWidgetBase::OnSelectedShopCategoryTabChanged(class FName SelectedTabId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "OnSelectedShopCategoryTabChanged");

	Params::DCShopWidgetBase_OnSelectedShopCategoryTabChanged Parms{};

	Parms.SelectedTabId = SelectedTabId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopWidgetBase.OnTriumphLevelAndExp
// (Event, Protected, BlueprintEvent)

void UDCShopWidgetBase::OnTriumphLevelAndExp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "OnTriumphLevelAndExp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.DCShopWidgetBase.OnWidgetClose
// (Final, Native, Protected, BlueprintCallable)

void UDCShopWidgetBase::OnWidgetClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "OnWidgetClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopWidgetBase.OnWidgetOpen
// (Final, Native, Protected, BlueprintCallable)

void UDCShopWidgetBase::OnWidgetOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "OnWidgetOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCShopWidgetBase.CanPurchase
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCShopWidgetBase::CanPurchase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "CanPurchase");

	Params::DCShopWidgetBase_CanPurchase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopWidgetBase.GetDiscountRate
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCShopWidgetBase::GetDiscountRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "GetDiscountRate");

	Params::DCShopWidgetBase_GetDiscountRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopWidgetBase.HasSelectedShopItemAnyPrice
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCShopWidgetBase::HasSelectedShopItemAnyPrice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "HasSelectedShopItemAnyPrice");

	Params::DCShopWidgetBase_HasSelectedShopItemAnyPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopWidgetBase.HasSelectedShopItemBluestoneShardPrice
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCShopWidgetBase::HasSelectedShopItemBluestoneShardPrice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "HasSelectedShopItemBluestoneShardPrice");

	Params::DCShopWidgetBase_HasSelectedShopItemBluestoneShardPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCShopWidgetBase.HasSelectedShopItemRedstoneShardPrice
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCShopWidgetBase::HasSelectedShopItemRedstoneShardPrice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCShopWidgetBase", "HasSelectedShopItemRedstoneShardPrice");

	Params::DCShopWidgetBase_HasSelectedShopItemRedstoneShardPrice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCSimpleTooltipWidget.GetTooltipColor
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateColor                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateColor UDCSimpleTooltipWidget::GetTooltipColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSimpleTooltipWidget", "GetTooltipColor");

	Params::DCSimpleTooltipWidget_GetTooltipColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCSimpleTooltipWidget.SetTooltipData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSlateColor                      TextColor                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDCSimpleTooltipWidget::SetTooltipData(const class FText& Text, const struct FSlateColor& TextColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSimpleTooltipWidget", "SetTooltipData");

	Params::DCSimpleTooltipWidget_SetTooltipData Parms{};

	Parms.Text = std::move(Text);
	Parms.TextColor = std::move(TextColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSortButtonWidget.GetCurrentSortStateIcon
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UTexture2D*                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UTexture2D* UDCSortButtonWidget::GetCurrentSortStateIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSortButtonWidget", "GetCurrentSortStateIcon");

	Params::DCSortButtonWidget_GetCurrentSortStateIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCSortButtonWidget.IsSortable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCSortButtonWidget::IsSortable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSortButtonWidget", "IsSortable");

	Params::DCSortButtonWidget_IsSortable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCSpellBeamSpringArmComponent.OnRep_SpellRange
// (Final, Native, Private)
// Parameters:
// float                                   OldSpellRange                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSpellBeamSpringArmComponent::OnRep_SpellRange(float OldSpellRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSpellBeamSpringArmComponent", "OnRep_SpellRange");

	Params::DCSpellBeamSpringArmComponent_OnRep_SpellRange Parms{};

	Parms.OldSpellRange = OldSpellRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCSpellBeamSpringArmComponent.SetSpellRange
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InSpellRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCSpellBeamSpringArmComponent::SetSpellRange(float InSpellRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCSpellBeamSpringArmComponent", "SetSpellRange");

	Params::DCSpellBeamSpringArmComponent_SetSpellRange Parms{};

	Parms.InSpellRange = InSpellRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCStaticMeshComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCStaticMeshComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCStaticMeshComponent", "BroadcastMsgBlueprint");

	Params::DCStaticMeshComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCStaticMeshComponent.TerminateBase
// (Native, Public)

void UDCStaticMeshComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCStaticMeshComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCStaticMeshComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCStaticMeshComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCStaticMeshComponent", "UnbindMsg");

	Params::DCStaticMeshComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCStaticMeshComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCStaticMeshComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCStaticMeshComponent", "UnbindMsgAll");

	Params::DCStaticMeshComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTabButtonWidgetBase.OnSelectedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bInIsSelected                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCTabButtonWidgetBase::OnSelectedChanged(bool bInIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTabButtonWidgetBase", "OnSelectedChanged");

	Params::DCTabButtonWidgetBase_OnSelectedChanged Parms{};

	Parms.bInIsSelected = bInIsSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTradeBoxWidget.IsEnableCheckBox
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCTradeBoxWidget::IsEnableCheckBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradeBoxWidget", "IsEnableCheckBox");

	Params::DCTradeBoxWidget_IsEnableCheckBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCTradeBoxWidget.SetReady
// (Final, Native, Public)
// Parameters:
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCTradeBoxWidget::SetReady(bool bState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradeBoxWidget", "SetReady");

	Params::DCTradeBoxWidget_SetReady Parms{};

	Parms.bState = bState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTradeSubscriptionPopup.CloseSelf
// (Final, Native, Private)

void UDCTradeSubscriptionPopup::CloseSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradeSubscriptionPopup", "CloseSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTradeSubscriptionPopup.OnClikedButtonDone
// (Final, Native, Private)

void UDCTradeSubscriptionPopup::OnClikedButtonDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradeSubscriptionPopup", "OnClikedButtonDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTradeSubscriptionPopup.SendMsgWidgetTradeSubscriptionButtonClicked
// (Final, Native, Private)

void UDCTradeSubscriptionPopup::SendMsgWidgetTradeSubscriptionButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTradeSubscriptionPopup", "SendMsgWidgetTradeSubscriptionButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTrainingReceiveCheckPopup.OnCancelButtonClicked
// (Final, Native, Private)

void UDCTrainingReceiveCheckPopup::OnCancelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingReceiveCheckPopup", "OnCancelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCTrainingReceiveCheckPopup.OnReceiveButtonClicked
// (Final, Native, Private)

void UDCTrainingReceiveCheckPopup::OnReceiveButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCTrainingReceiveCheckPopup", "OnReceiveButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCUpdateRateOptimizeManagerComponent.SetFreezeIdle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInFreezeIdle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCUpdateRateOptimizeManagerComponent::SetFreezeIdle(bool bInFreezeIdle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCUpdateRateOptimizeManagerComponent", "SetFreezeIdle");

	Params::DCUpdateRateOptimizeManagerComponent_SetFreezeIdle Parms{};

	Parms.bInFreezeIdle = bInFreezeIdle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCUpdateRateOptimizeManagerComponent.SetNeverOptimize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInNeverOptimize                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCUpdateRateOptimizeManagerComponent::SetNeverOptimize(bool bInNeverOptimize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCUpdateRateOptimizeManagerComponent", "SetNeverOptimize");

	Params::DCUpdateRateOptimizeManagerComponent_SetNeverOptimize Parms{};

	Parms.bInNeverOptimize = bInNeverOptimize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCVoipComponent.InitVoip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVoipAkComponent*                 InSendVoipAkComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCVoipComponent::InitVoip(class UVoipAkComponent* InSendVoipAkComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCVoipComponent", "InitVoip");

	Params::DCVoipComponent_InitVoip Parms{};

	Parms.InSendVoipAkComponent = InSendVoipAkComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.BroadcastCommonOneButtonSPopup
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutputMessage                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInIsBackHandler                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCWidgetBlueprintLibrary::BroadcastCommonOneButtonSPopup(class APlayerController* InPlayer, const class FText& OutputMessage, bool bInIsBackHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "BroadcastCommonOneButtonSPopup");

	Params::DCWidgetBlueprintLibrary_BroadcastCommonOneButtonSPopup Parms{};

	Parms.InPlayer = InPlayer;
	Parms.OutputMessage = std::move(OutputMessage);
	Parms.bInIsBackHandler = bInIsBackHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.BroadcastSystemMessageNotify
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutputMessage                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCWidgetBlueprintLibrary::BroadcastSystemMessageNotify(class APlayerController* InPlayer, const class FText& OutputMessage, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "BroadcastSystemMessageNotify");

	Params::DCWidgetBlueprintLibrary_BroadcastSystemMessageNotify Parms{};

	Parms.InPlayer = InPlayer;
	Parms.OutputMessage = std::move(OutputMessage);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.ConvertLocalTimeToUtc
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        LocalTime                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UDCWidgetBlueprintLibrary::ConvertLocalTimeToUtc(const struct FDateTime& LocalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "ConvertLocalTimeToUtc");

	Params::DCWidgetBlueprintLibrary_ConvertLocalTimeToUtc Parms{};

	Parms.LocalTime = std::move(LocalTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.FormatQuestRichText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EDCQuestRichTextFormatType              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDCWidgetBlueprintLibrary::FormatQuestRichText(EDCQuestRichTextFormatType Type, const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "FormatQuestRichText");

	Params::DCWidgetBlueprintLibrary_FormatQuestRichText Parms{};

	Parms.Type = Type;
	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.GetArenaNumMaxRounds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDCWidgetBlueprintLibrary::GetArenaNumMaxRounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "GetArenaNumMaxRounds");

	Params::DCWidgetBlueprintLibrary_GetArenaNumMaxRounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.GetForceExitRemainSeconds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDCWidgetBlueprintLibrary::GetForceExitRemainSeconds(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "GetForceExitRemainSeconds");

	Params::DCWidgetBlueprintLibrary_GetForceExitRemainSeconds Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.GetMatchElapsedTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UDCWidgetBlueprintLibrary::GetMatchElapsedTime(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "GetMatchElapsedTime");

	Params::DCWidgetBlueprintLibrary_GetMatchElapsedTime Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.GetVoipStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoipUserData                    InVoipUserData                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EVoipStatus                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVoipStatus UDCWidgetBlueprintLibrary::GetVoipStatus(const struct FVoipUserData& InVoipUserData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "GetVoipStatus");

	Params::DCWidgetBlueprintLibrary_GetVoipStatus Parms{};

	Parms.InVoipUserData = std::move(InVoipUserData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsArenaEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCWidgetBlueprintLibrary::IsArenaEnabled(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "IsArenaEnabled");

	Params::DCWidgetBlueprintLibrary_IsArenaEnabled Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsArenaFirstRound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCWidgetBlueprintLibrary::IsArenaFirstRound(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "IsArenaFirstRound");

	Params::DCWidgetBlueprintLibrary_IsArenaFirstRound Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsCurrentPlayerWaitingNextFloor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCWidgetBlueprintLibrary::IsCurrentPlayerWaitingNextFloor(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "IsCurrentPlayerWaitingNextFloor");

	Params::DCWidgetBlueprintLibrary_IsCurrentPlayerWaitingNextFloor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsDeathCamAvailable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCWidgetBlueprintLibrary::IsDeathCamAvailable(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "IsDeathCamAvailable");

	Params::DCWidgetBlueprintLibrary_IsDeathCamAvailable Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsDeathCamOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCWidgetBlueprintLibrary::IsDeathCamOn(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "IsDeathCamOn");

	Params::DCWidgetBlueprintLibrary_IsDeathCamOn Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsFreeSpectatingEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCWidgetBlueprintLibrary::IsFreeSpectatingEnabled(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "IsFreeSpectatingEnabled");

	Params::DCWidgetBlueprintLibrary_IsFreeSpectatingEnabled Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsHighRoller
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCWidgetBlueprintLibrary::IsHighRoller(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "IsHighRoller");

	Params::DCWidgetBlueprintLibrary_IsHighRoller Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.IsUsingArena
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDCWidgetBlueprintLibrary::IsUsingArena(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "IsUsingArena");

	Params::DCWidgetBlueprintLibrary_IsUsingArena Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.MakePopupDataSWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPopupButtonType                        PopupButtonType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DescMessage                                            (Parm, NativeAccessSpecifierPublic)
// class UPopupDataSWidget*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPopupDataSWidget* UDCWidgetBlueprintLibrary::MakePopupDataSWidget(EPopupButtonType PopupButtonType, const class FText& DescMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "MakePopupDataSWidget");

	Params::DCWidgetBlueprintLibrary_MakePopupDataSWidget Parms{};

	Parms.PopupButtonType = PopupButtonType;
	Parms.DescMessage = std::move(DescMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.MakePopupMessageReqeust
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDCCommonActivatableWidgetBase>WidgetClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPopupDataBase*                   PopupData                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsBackHandler                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMsgWidgetPopupMessageRequest    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMsgWidgetPopupMessageRequest UDCWidgetBlueprintLibrary::MakePopupMessageReqeust(TSubclassOf<class UDCCommonActivatableWidgetBase> WidgetClass, class UPopupDataBase* PopupData, bool bInIsBackHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "MakePopupMessageReqeust");

	Params::DCWidgetBlueprintLibrary_MakePopupMessageReqeust Parms{};

	Parms.WidgetClass = WidgetClass;
	Parms.PopupData = PopupData;
	Parms.bInIsBackHandler = bInIsBackHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.PopupMessageSWidgetNotify
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDCCommonActivatableWidgetBase>WidgetClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DescMessage                                            (Parm, NativeAccessSpecifierPublic)
// EPopupButtonType                        ButtonType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsBackHandler                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCWidgetBlueprintLibrary::PopupMessageSWidgetNotify(class APlayerController* InPlayer, TSubclassOf<class UDCCommonActivatableWidgetBase> WidgetClass, const class FText& DescMessage, EPopupButtonType ButtonType, bool bInIsBackHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "PopupMessageSWidgetNotify");

	Params::DCWidgetBlueprintLibrary_PopupMessageSWidgetNotify Parms{};

	Parms.InPlayer = InPlayer;
	Parms.WidgetClass = WidgetClass;
	Parms.DescMessage = std::move(DescMessage);
	Parms.ButtonType = ButtonType;
	Parms.bInIsBackHandler = bInIsBackHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.SetPlayerCursorCenter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCWidgetBlueprintLibrary::SetPlayerCursorCenter(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "SetPlayerCursorCenter");

	Params::DCWidgetBlueprintLibrary_SetPlayerCursorCenter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCWidgetBlueprintLibrary.StringToAccountId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InAccountIdStr                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDCAccountId                     ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDCAccountId UDCWidgetBlueprintLibrary::StringToAccountId(const class FString& InAccountIdStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCWidgetBlueprintLibrary", "StringToAccountId");

	Params::DCWidgetBlueprintLibrary_StringToAccountId Parms{};

	Parms.InAccountIdStr = std::move(InAccountIdStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DeathSwarmBase.OnRep_GameDeathSwarmData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameDeathSwarmData              InOldGameDeathSwarmData                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADeathSwarmBase::OnRep_GameDeathSwarmData(const struct FGameDeathSwarmData& InOldGameDeathSwarmData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathSwarmBase", "OnRep_GameDeathSwarmData");

	Params::DeathSwarmBase_OnRep_GameDeathSwarmData Parms{};

	Parms.InOldGameDeathSwarmData = std::move(InOldGameDeathSwarmData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DeathSwarmBase.OnRep_GameFloorRuleData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameFloorRuleData               InOldGameFloorRuleData                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADeathSwarmBase::OnRep_GameFloorRuleData(const struct FGameFloorRuleData& InOldGameFloorRuleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathSwarmBase", "OnRep_GameFloorRuleData");

	Params::DeathSwarmBase_OnRep_GameFloorRuleData Parms{};

	Parms.InOldGameFloorRuleData = std::move(InOldGameFloorRuleData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DeathSwarmInterface.BindDeathSwarmDataDelegate
// (Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGameDeathSwarmData& InDeathSwarmData)>InBindDelegate                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDeathSwarmInterface::BindDeathSwarmDataDelegate(TDelegate<void(struct FGameDeathSwarmData& InDeathSwarmData)> InBindDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathSwarmInterface", "BindDeathSwarmDataDelegate");

	Params::DeathSwarmInterface_BindDeathSwarmDataDelegate Parms{};

	Parms.InBindDelegate = InBindDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DeathSwarmInterface.UnbindDeathSwarmDataDelegate
// (Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InBoundObject                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDeathSwarmInterface::UnbindDeathSwarmDataDelegate(class UObject* InBoundObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathSwarmInterface", "UnbindDeathSwarmDataDelegate");

	Params::DeathSwarmInterface_UnbindDeathSwarmDataDelegate Parms{};

	Parms.InBoundObject = InBoundObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DeathSwarmInterface.GetDeathSwarmData
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameDeathSwarmData              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameDeathSwarmData IDeathSwarmInterface::GetDeathSwarmData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathSwarmInterface", "GetDeathSwarmData");

	Params::DeathSwarmInterface_GetDeathSwarmData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DeathSwarmInterface.LogHandleDeathSwarmData
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          InHandler                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameDeathSwarmData              InDeathSwarmData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IDeathSwarmInterface::LogHandleDeathSwarmData(const class UObject* InHandler, const struct FGameDeathSwarmData& InDeathSwarmData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathSwarmInterface", "LogHandleDeathSwarmData");

	Params::DeathSwarmInterface_LogHandleDeathSwarmData Parms{};

	Parms.InHandler = InHandler;
	Parms.InDeathSwarmData = std::move(InDeathSwarmData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DesignDataAssetItemBundleInfo.GetBundleArtAssetByCount
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ItemCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UDesignDataAssetItemBundleInfo::GetBundleArtAssetByCount(int32 ItemCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DesignDataAssetItemBundleInfo", "GetBundleArtAssetByCount");

	Params::DesignDataAssetItemBundleInfo_GetBundleArtAssetByCount Parms{};

	Parms.ItemCount = ItemCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DungeonSelectSlotWidget.OnGameUserSettingControlsChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameUserSettingControls         InGameUserSettingControls                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameUserSettingControls         InOldGameUserSettingControls                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectSlotWidget::OnGameUserSettingControlsChanged(const struct FGameUserSettingControls& InGameUserSettingControls, const struct FGameUserSettingControls& InOldGameUserSettingControls, bool bInForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectSlotWidget", "OnGameUserSettingControlsChanged");

	Params::DungeonSelectSlotWidget_OnGameUserSettingControlsChanged Parms{};

	Parms.InGameUserSettingControls = std::move(InGameUserSettingControls);
	Parms.InOldGameUserSettingControls = std::move(InOldGameUserSettingControls);
	Parms.bInForce = bInForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DungeonSelectSlotWidget.OnHighRollerButtonClicked
// (Final, Native, Protected)

void UDungeonSelectSlotWidget::OnHighRollerButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectSlotWidget", "OnHighRollerButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DungeonSelectSlotWidget.OnNormalButtonClicked
// (Final, Native, Protected)

void UDungeonSelectSlotWidget::OnNormalButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectSlotWidget", "OnNormalButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DungeonSelectSlotWidget.SetSelectedMatchMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMatchMode                              InMatchMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDungeonSelectSlotWidget::SetSelectedMatchMode(EMatchMode InMatchMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectSlotWidget", "SetSelectedMatchMode");

	Params::DungeonSelectSlotWidget_SetSelectedMatchMode Parms{};

	Parms.InMatchMode = InMatchMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DungeonSelectSlotWidget.UpdateDungeonSelectSlot
// (Event, Protected, BlueprintEvent)

void UDungeonSelectSlotWidget::UpdateDungeonSelectSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DungeonSelectSlotWidget", "UpdateDungeonSelectSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.EquipmentSlotWidget.CheckAndSetActiveHoverImage
// (Final, Native, Protected, BlueprintCallable)

void UEquipmentSlotWidget::CheckAndSetActiveHoverImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlotWidget", "CheckAndSetActiveHoverImage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentSlotWidget.OnFinishedItemDataSet
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FItemData                        InItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     HandType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     SlotType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemInventorySize               InventorySize                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UEquipmentSlotWidget::OnFinishedItemDataSet(const struct FItemData& InItemData, const struct FGameplayTag& HandType, const struct FGameplayTag& SlotType, const struct FItemInventorySize& InventorySize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlotWidget", "OnFinishedItemDataSet");

	Params::EquipmentSlotWidget_OnFinishedItemDataSet Parms{};

	Parms.InItemData = std::move(InItemData);
	Parms.HandType = std::move(HandType);
	Parms.SlotType = std::move(SlotType);
	Parms.InventorySize = std::move(InventorySize);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.EquipmentSlotWidget.OnLeaveItemWidget
// (Event, Public, BlueprintEvent)

void UEquipmentSlotWidget::OnLeaveItemWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlotWidget", "OnLeaveItemWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.EquipmentSlotWidget.OnOverlapItemWidget
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FPrimaryAssetId                  ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValidSlot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanEquip                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentSlotWidget::OnOverlapItemWidget(const struct FPrimaryAssetId& ItemId, bool bValidSlot, bool bCanEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlotWidget", "OnOverlapItemWidget");

	Params::EquipmentSlotWidget_OnOverlapItemWidget Parms{};

	Parms.ItemId = std::move(ItemId);
	Parms.bValidSlot = bValidSlot;
	Parms.bCanEquip = bCanEquip;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.EquipmentSlotWidget.OnRemoveItem
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FItemData                        InItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEquipmentSlotWidget::OnRemoveItem(const struct FItemData& InItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlotWidget", "OnRemoveItem");

	Params::EquipmentSlotWidget_OnRemoveItem Parms{};

	Parms.InItemData = std::move(InItemData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentSlotWidget.RemovePreviewItemWidget
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSetItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentSlotWidget::RemovePreviewItemWidget(bool bSetItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlotWidget", "RemovePreviewItemWidget");

	Params::EquipmentSlotWidget_RemovePreviewItemWidget Parms{};

	Parms.bSetItem = bSetItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentSlotWidget.SetActiveHoverImage
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentSlotWidget::SetActiveHoverImage(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlotWidget", "SetActiveHoverImage");

	Params::EquipmentSlotWidget_SetActiveHoverImage Parms{};

	Parms.bActivate = bActivate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.EquipmentSlotWidget.SetPreviewItemWidget
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentSlotWidget::SetPreviewItemWidget(const struct FPrimaryAssetId& ItemId, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlotWidget", "SetPreviewItemWidget");

	Params::EquipmentSlotWidget_SetPreviewItemWidget Parms{};

	Parms.ItemId = std::move(ItemId);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentSlotWidget.GetEquipmentSlotIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDCEquipmentSlotIndex                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDCEquipmentSlotIndex UEquipmentSlotWidget::GetEquipmentSlotIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentSlotWidget", "GetEquipmentSlotIndex");

	Params::EquipmentSlotWidget_GetEquipmentSlotIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.EquipmentWeaponSlotSetWidget.CheckAndSetActiveHoverImageBySlot
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UWidget*                          SlotUnderPointerPosition                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentWeaponSlotSetWidget::CheckAndSetActiveHoverImageBySlot(class UWidget* SlotUnderPointerPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentWeaponSlotSetWidget", "CheckAndSetActiveHoverImageBySlot");

	Params::EquipmentWeaponSlotSetWidget_CheckAndSetActiveHoverImageBySlot Parms{};

	Parms.SlotUnderPointerPosition = SlotUnderPointerPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.EquipmentWeaponSlotSetWidget.SetActivePrimaryHoverImage
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentWeaponSlotSetWidget::SetActivePrimaryHoverImage(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentWeaponSlotSetWidget", "SetActivePrimaryHoverImage");

	Params::EquipmentWeaponSlotSetWidget_SetActivePrimaryHoverImage Parms{};

	Parms.bActivate = bActivate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.EquipmentWeaponSlotSetWidget.SetActiveSecondaryHoverImage
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentWeaponSlotSetWidget::SetActiveSecondaryHoverImage(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentWeaponSlotSetWidget", "SetActiveSecondaryHoverImage");

	Params::EquipmentWeaponSlotSetWidget_SetActiveSecondaryHoverImage Parms{};

	Parms.bActivate = bActivate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ExpandableInventoryComponent.SetExpandable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanExpand                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExpandableInventoryComponent::SetExpandable(bool bCanExpand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExpandableInventoryComponent", "SetExpandable");

	Params::ExpandableInventoryComponent_SetExpandable Parms{};

	Parms.bCanExpand = bCanExpand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.FloorPortalBase.OnFloorRuleFired
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameFloorRuleData               InFloorRuleData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AFloorPortalBase::OnFloorRuleFired(const struct FGameFloorRuleData& InFloorRuleData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FloorPortalBase", "OnFloorRuleFired");

	Params::FloorPortalBase_OnFloorRuleFired Parms{};

	Parms.InFloorRuleData = std::move(InFloorRuleData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.FriendSlotWidget.OnRightClicked
// (Native, Protected)

void UFriendSlotWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendSlotWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameAlivePlayerCountWidget.OnAlivePlayerCount
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameAlivePlayerCountWidget::OnAlivePlayerCount(int32 NewValue, int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameAlivePlayerCountWidget", "OnAlivePlayerCount");

	Params::GameAlivePlayerCountWidget_OnAlivePlayerCount Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameAlivePlayerCountWidget.OnTotalPlayerCount
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameAlivePlayerCountWidget::OnTotalPlayerCount(int32 NewValue, int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameAlivePlayerCountWidget", "OnTotalPlayerCount");

	Params::GameAlivePlayerCountWidget_OnTotalPlayerCount Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameCrossHairWidget.OnActivateSpellCrossHair
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsActivate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCrossHairWidget::OnActivateSpellCrossHair(bool IsActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCrossHairWidget", "OnActivateSpellCrossHair");

	Params::GameCrossHairWidget_OnActivateSpellCrossHair Parms{};

	Parms.IsActivate = IsActivate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameCrossHairWidget.OnChangeCrossHairInfo
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     WeaponTypeTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ChangeAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPinPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotateTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCrossHairWidget::OnChangeCrossHairInfo(const struct FGameplayTag& WeaponTypeTag, float ChangeAngle, bool IsPinPoint, float RotateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCrossHairWidget", "OnChangeCrossHairInfo");

	Params::GameCrossHairWidget_OnChangeCrossHairInfo Parms{};

	Parms.WeaponTypeTag = std::move(WeaponTypeTag);
	Parms.ChangeAngle = ChangeAngle;
	Parms.IsPinPoint = IsPinPoint;
	Parms.RotateTime = RotateTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameCrossHairWidget.OnChangeToRangeCrossHairAndPullAction
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     WeaponTypeTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ItemUtilityTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCrossHairWidget::OnChangeToRangeCrossHairAndPullAction(const struct FGameplayTag& WeaponTypeTag, const struct FGameplayTag& ItemUtilityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCrossHairWidget", "OnChangeToRangeCrossHairAndPullAction");

	Params::GameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction Parms{};

	Parms.WeaponTypeTag = std::move(WeaponTypeTag);
	Parms.ItemUtilityTag = std::move(ItemUtilityTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameCrossHairWidget.OnChangeWeaponCrossHair
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     WeaponTypeTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ItemUtilityTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ItemSlotTypeTags                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAttackEnable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCrossHairWidget::OnChangeWeaponCrossHair(const struct FGameplayTag& WeaponTypeTag, const struct FGameplayTag& ItemUtilityTag, const struct FGameplayTag& ItemSlotTypeTags, bool IsAttackEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCrossHairWidget", "OnChangeWeaponCrossHair");

	Params::GameCrossHairWidget_OnChangeWeaponCrossHair Parms{};

	Parms.WeaponTypeTag = std::move(WeaponTypeTag);
	Parms.ItemUtilityTag = std::move(ItemUtilityTag);
	Parms.ItemSlotTypeTags = std::move(ItemSlotTypeTags);
	Parms.IsAttackEnable = IsAttackEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameCrossHairWidget.OnCrossHairChangeEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class AItemActor*>               EquipItemActors                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGameCrossHairWidget::OnCrossHairChangeEvent(const TArray<class AItemActor*>& EquipItemActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCrossHairWidget", "OnCrossHairChangeEvent");

	Params::GameCrossHairWidget_OnCrossHairChangeEvent Parms{};

	Parms.EquipItemActors = std::move(EquipItemActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameCrossHairWidget.OnCrossHairVisability
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsVisablile                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SetDefault                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCrossHairWidget::OnCrossHairVisability(bool IsVisablile, bool SetDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCrossHairWidget", "OnCrossHairVisability");

	Params::GameCrossHairWidget_OnCrossHairVisability Parms{};

	Parms.IsVisablile = IsVisablile;
	Parms.SetDefault = SetDefault;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameCrossHairWidget.OnInitCrossHair
// (Event, Protected, BlueprintEvent)

void UGameCrossHairWidget::OnInitCrossHair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCrossHairWidget", "OnInitCrossHair");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameCrossHairWidget.OnPlayPullingCrossHair
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCrossHairWidget::OnPlayPullingCrossHair(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCrossHairWidget", "OnPlayPullingCrossHair");

	Params::GameCrossHairWidget_OnPlayPullingCrossHair Parms{};

	Parms.Rate = Rate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameCrossHairWidget.OnPlayShootCrossHair
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameCrossHairWidget::OnPlayShootCrossHair(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameCrossHairWidget", "OnPlayShootCrossHair");

	Params::GameCrossHairWidget_OnPlayShootCrossHair Parms{};

	Parms.Rate = Rate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameEmoteSelectGroupWidget.OnCurrentEmoteSlotChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameEmoteSelectGroupWidget::OnCurrentEmoteSlotChanged(const class FText& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEmoteSelectGroupWidget", "OnCurrentEmoteSlotChanged");

	Params::GameEmoteSelectGroupWidget_OnCurrentEmoteSlotChanged Parms{};

	Parms.InName = std::move(InName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameEmoteSelectGroupWidget.OnEmoteSelectClose
// (Event, Protected, BlueprintEvent)

void UGameEmoteSelectGroupWidget::OnEmoteSelectClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEmoteSelectGroupWidget", "OnEmoteSelectClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameEmoteSelectGroupWidget.OnEmoteSelectPopup
// (Event, Protected, BlueprintEvent)

void UGameEmoteSelectGroupWidget::OnEmoteSelectPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEmoteSelectGroupWidget", "OnEmoteSelectPopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameEmoteSelectGroupWidget.OnSelectedEmoteIndexChanged
// (Final, Native, Protected, BlueprintCallable)

void UGameEmoteSelectGroupWidget::OnSelectedEmoteIndexChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEmoteSelectGroupWidget", "OnSelectedEmoteIndexChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameHeadupAccountWidget.OnRefreshNickname
// (Event, Protected, BlueprintEvent)

void UGameHeadupAccountWidget::OnRefreshNickname()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameHeadupAccountWidget", "OnRefreshNickname");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameHeadupWidgetComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameHeadupWidgetComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameHeadupWidgetComponent", "BroadcastMsgBlueprint");

	Params::GameHeadupWidgetComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameHeadupWidgetComponent.TerminateBase
// (Native, Public)

void UGameHeadupWidgetComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameHeadupWidgetComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameHeadupWidgetComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameHeadupWidgetComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameHeadupWidgetComponent", "UnbindMsg");

	Params::GameHeadupWidgetComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameHeadupWidgetComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameHeadupWidgetComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameHeadupWidgetComponent", "UnbindMsgAll");

	Params::GameHeadupWidgetComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameHitDirectionWidget.OnAnimation
// (Event, Protected, BlueprintEvent)

void UGameHitDirectionWidget::OnAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameHitDirectionWidget", "OnAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameHitDirectionWidget.SetHitDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameHitDirectionWidget::SetHitDirection(const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameHitDirectionWidget", "SetHitDirection");

	Params::GameHitDirectionWidget_SetHitDirection Parms{};

	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameInteractionDescriptionWidget.OnInputType
// (Event, Protected, BlueprintEvent)
// Parameters:
// ECommonInputType                        NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommonInputType                        OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInteractionDescriptionWidget::OnInputType(ECommonInputType NewValue, ECommonInputType OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInteractionDescriptionWidget", "OnInputType");

	Params::GameInteractionDescriptionWidget_OnInputType Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameInteractionDescriptionWidget.OnInteractableDataByStateMap
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TMap<struct FGameplayTag, struct FInteractionData>NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, struct FInteractionData>OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameInteractionDescriptionWidget::OnInteractableDataByStateMap(const TMap<struct FGameplayTag, struct FInteractionData>& NewValue, const TMap<struct FGameplayTag, struct FInteractionData>& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInteractionDescriptionWidget", "OnInteractableDataByStateMap");

	Params::GameInteractionDescriptionWidget_OnInteractableDataByStateMap Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameInteractionDescriptionWidget.OnInteractTargetData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FInteractTargetData              NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FInteractTargetData              OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameInteractionDescriptionWidget::OnInteractTargetData(const struct FInteractTargetData& NewValue, const struct FInteractTargetData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInteractionDescriptionWidget", "OnInteractTargetData");

	Params::GameInteractionDescriptionWidget_OnInteractTargetData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameInteractionSkillCheckWidget.OnInteractSkillCheckEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// ESkillCheckResult                       SkillCheckResult                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInteractionSkillCheckWidget::OnInteractSkillCheckEnd(ESkillCheckResult SkillCheckResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInteractionSkillCheckWidget", "OnInteractSkillCheckEnd");

	Params::GameInteractionSkillCheckWidget_OnInteractSkillCheckEnd Parms{};

	Parms.SkillCheckResult = SkillCheckResult;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameInteractionSkillCheckWidget.OnInteractSkillCheckStart
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSkillCheckData                  SkillCheckData                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameInteractionSkillCheckWidget::OnInteractSkillCheckStart(const struct FSkillCheckData& SkillCheckData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInteractionSkillCheckWidget", "OnInteractSkillCheckStart");

	Params::GameInteractionSkillCheckWidget_OnInteractSkillCheckStart Parms{};

	Parms.SkillCheckData = std::move(SkillCheckData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMiniMapWidget.OnDeathSwarmData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameDeathSwarmData              DeathSwarmData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameMiniMapWidget::OnDeathSwarmData(const struct FGameDeathSwarmData& DeathSwarmData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMiniMapWidget", "OnDeathSwarmData");

	Params::GameMiniMapWidget_OnDeathSwarmData Parms{};

	Parms.DeathSwarmData = std::move(DeathSwarmData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMiniMapWidget.OnDungeonModuleName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameMiniMapWidget::OnDungeonModuleName(const class FText& NewValue, const class FText& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMiniMapWidget", "OnDungeonModuleName");

	Params::GameMiniMapWidget_OnDungeonModuleName Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMiniMapWidget.OnFloorRuleActorRegistered
// (Final, Native, Private)
// Parameters:
// class AActor*                           InFloorRuleActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMiniMapWidget::OnFloorRuleActorRegistered(class AActor* InFloorRuleActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMiniMapWidget", "OnFloorRuleActorRegistered");

	Params::GameMiniMapWidget_OnFloorRuleActorRegistered Parms{};

	Parms.InFloorRuleActor = InFloorRuleActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMiniMapWidget.OnMiniMapDeathSwarmData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMiniMapDeathSwarmData           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FMiniMapDeathSwarmData           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameMiniMapWidget::OnMiniMapDeathSwarmData(const struct FMiniMapDeathSwarmData& NewValue, const struct FMiniMapDeathSwarmData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMiniMapWidget", "OnMiniMapDeathSwarmData");

	Params::GameMiniMapWidget_OnMiniMapDeathSwarmData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMiniMapWidget.OnMiniMapName
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           NewMiniMapName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OldMiniMapName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMiniMapWidget::OnMiniMapName(const class FString& NewMiniMapName, const class FString& OldMiniMapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMiniMapWidget", "OnMiniMapName");

	Params::GameMiniMapWidget_OnMiniMapName Parms{};

	Parms.NewMiniMapName = std::move(NewMiniMapName);
	Parms.OldMiniMapName = std::move(OldMiniMapName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuOptionPopupWidget.HandleLeftButtonClicked
// (Final, Native, Protected)

void UGameMenuOptionPopupWidget::HandleLeftButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionPopupWidget", "HandleLeftButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionPopupWidget.HandleRightButtonClicked
// (Final, Native, Protected)

void UGameMenuOptionPopupWidget::HandleRightButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionPopupWidget", "HandleRightButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionPopupWidget.SetButtonText
// (Final, Native, Public)
// Parameters:
// class FText                             InLeftText                                             (Parm, NativeAccessSpecifierPublic)
// class FText                             InRightText                                            (Parm, NativeAccessSpecifierPublic)

void UGameMenuOptionPopupWidget::SetButtonText(const class FText& InLeftText, const class FText& InRightText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionPopupWidget", "SetButtonText");

	Params::GameMenuOptionPopupWidget_SetButtonText Parms{};

	Parms.InLeftText = std::move(InLeftText);
	Parms.InRightText = std::move(InRightText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionPopupWidget.SetDetailText
// (Final, Native, Public)
// Parameters:
// class FText                             InDetailText                                           (Parm, NativeAccessSpecifierPublic)

void UGameMenuOptionPopupWidget::SetDetailText(const class FText& InDetailText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionPopupWidget", "SetDetailText");

	Params::GameMenuOptionPopupWidget_SetDetailText Parms{};

	Parms.InDetailText = std::move(InDetailText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionPopupWidget.UpdateButtonText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InLeftText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             InRightText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameMenuOptionPopupWidget::UpdateButtonText(const class FText& InLeftText, const class FText& InRightText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionPopupWidget", "UpdateButtonText");

	Params::GameMenuOptionPopupWidget_UpdateButtonText Parms{};

	Parms.InLeftText = std::move(InLeftText);
	Parms.InRightText = std::move(InRightText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuOptionPopupWidget.UpdateDetailText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InDetailText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameMenuOptionPopupWidget::UpdateDetailText(const class FText& InDetailText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionPopupWidget", "UpdateDetailText");

	Params::GameMenuOptionPopupWidget_UpdateDetailText Parms{};

	Parms.InDetailText = std::move(InDetailText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnAppActivateStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsAppActivateChange                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnAppActivateStateChanged(bool IsAppActivateChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnAppActivateStateChanged");

	Params::GameMenuOptionsAudioWidget_OnAppActivateStateChanged Parms{};

	Parms.IsAppActivateChange = IsAppActivateChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnApplyButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsAudioWidget::OnApplyButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnApplyButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnBackgroundMusicChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsToggle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnBackgroundMusicChanged(bool IsToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnBackgroundMusicChanged");

	Params::GameMenuOptionsAudioWidget_OnBackgroundMusicChanged Parms{};

	Parms.IsToggle = IsToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnEffectVolumeValueChanged
// (Final, Native, Private)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnEffectVolumeValueChanged(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnEffectVolumeValueChanged");

	Params::GameMenuOptionsAudioWidget_OnEffectVolumeValueChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnGameUserSettingAudiosChanged
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameUserSettingAudios           InGameUserSettingAudios                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameUserSettingAudios           InOldGameUserSettingAudios                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnGameUserSettingAudiosChanged(const struct FGameUserSettingAudios& InGameUserSettingAudios, const struct FGameUserSettingAudios& InOldGameUserSettingAudios, bool bInForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnGameUserSettingAudiosChanged");

	Params::GameMenuOptionsAudioWidget_OnGameUserSettingAudiosChanged Parms{};

	Parms.InGameUserSettingAudios = std::move(InGameUserSettingAudios);
	Parms.InOldGameUserSettingAudios = std::move(InOldGameUserSettingAudios);
	Parms.bInForce = bInForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnMusicVolumeValueChanged
// (Final, Native, Private)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnMusicVolumeValueChanged(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnMusicVolumeValueChanged");

	Params::GameMenuOptionsAudioWidget_OnMusicVolumeValueChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnResetButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsAudioWidget::OnResetButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnResetButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnTotalVolumeValueChanged
// (Final, Native, Private)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnTotalVolumeValueChanged(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnTotalVolumeValueChanged");

	Params::GameMenuOptionsAudioWidget_OnTotalVolumeValueChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnVoipInputVolumeValueChanged
// (Final, Native, Private)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnVoipInputVolumeValueChanged(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnVoipInputVolumeValueChanged");

	Params::GameMenuOptionsAudioWidget_OnVoipInputVolumeValueChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnVoipModeChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsToggle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnVoipModeChanged(bool IsToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnVoipModeChanged");

	Params::GameMenuOptionsAudioWidget_OnVoipModeChanged Parms{};

	Parms.IsToggle = IsToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnVoipOnOffChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsToggle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnVoipOnOffChanged(bool IsToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnVoipOnOffChanged");

	Params::GameMenuOptionsAudioWidget_OnVoipOnOffChanged Parms{};

	Parms.IsToggle = IsToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnVoipOutputVolumeValueChanged
// (Final, Native, Private)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnVoipOutputVolumeValueChanged(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnVoipOutputVolumeValueChanged");

	Params::GameMenuOptionsAudioWidget_OnVoipOutputVolumeValueChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.OnVoipSendModeChanged
// (Final, Native, Private)
// Parameters:
// bool                                    IsToggle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::OnVoipSendModeChanged(bool IsToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "OnVoipSendModeChanged");

	Params::GameMenuOptionsAudioWidget_OnVoipSendModeChanged Parms{};

	Parms.IsToggle = IsToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsAudioWidget.UpdateWindowFocusChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsFocus                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsBackgroundOption                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalVolume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsAudioWidget::UpdateWindowFocusChanged(bool IsFocus, bool IsBackgroundOption, float TotalVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsAudioWidget", "UpdateWindowFocusChanged");

	Params::GameMenuOptionsAudioWidget_UpdateWindowFocusChanged Parms{};

	Parms.IsFocus = IsFocus;
	Parms.IsBackgroundOption = IsBackgroundOption;
	Parms.TotalVolume = TotalVolume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnApplyButtonClicked
// (Final, Native, Private)

void UGameMenuOptionsControlsWidget::OnApplyButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnApplyButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnGameUserSettingControls
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameUserSettingControls         NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameUserSettingControls         OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::OnGameUserSettingControls(const struct FGameUserSettingControls& NewValue, const struct FGameUserSettingControls& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnGameUserSettingControls");

	Params::GameMenuOptionsControlsWidget_OnGameUserSettingControls Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnInvertMouseHorizontalAxisClicked
// (Final, Native, Private)
// Parameters:
// bool                                    IsClick                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::OnInvertMouseHorizontalAxisClicked(bool IsClick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnInvertMouseHorizontalAxisClicked");

	Params::GameMenuOptionsControlsWidget_OnInvertMouseHorizontalAxisClicked Parms{};

	Parms.IsClick = IsClick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnInvertMouseVerticalAxisClicked
// (Final, Native, Private)
// Parameters:
// bool                                    IsClick                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::OnInvertMouseVerticalAxisClicked(bool IsClick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnInvertMouseVerticalAxisClicked");

	Params::GameMenuOptionsControlsWidget_OnInvertMouseVerticalAxisClicked Parms{};

	Parms.IsClick = IsClick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnKnightLinkClicked
// (Final, Native, Private)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::OnKnightLinkClicked(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnKnightLinkClicked");

	Params::GameMenuOptionsControlsWidget_OnKnightLinkClicked Parms{};

	Parms.bIsVisible = bIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnLowViolenceModeWidgetClicked
// (Final, Native, Private)
// Parameters:
// bool                                    bIsClick                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::OnLowViolenceModeWidgetClicked(bool bIsClick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnLowViolenceModeWidgetClicked");

	Params::GameMenuOptionsControlsWidget_OnLowViolenceModeWidgetClicked Parms{};

	Parms.bIsClick = bIsClick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnMouseSensitivitySliderValueChanged
// (Final, Native, Private)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::OnMouseSensitivitySliderValueChanged(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnMouseSensitivitySliderValueChanged");

	Params::GameMenuOptionsControlsWidget_OnMouseSensitivitySliderValueChanged Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnResetButtonClicked
// (Final, Native, Private)

void UGameMenuOptionsControlsWidget::OnResetButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnResetButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnSetLanguageComboBox
// (Final, Native, Private)

void UGameMenuOptionsControlsWidget::OnSetLanguageComboBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnSetLanguageComboBox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnStreamingModeClicked
// (Final, Native, Private)
// Parameters:
// bool                                    IsClick                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::OnStreamingModeClicked(bool IsClick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnStreamingModeClicked");

	Params::GameMenuOptionsControlsWidget_OnStreamingModeClicked Parms{};

	Parms.IsClick = IsClick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnWhisperAllButtonClicked
// (Final, Native, Private)

void UGameMenuOptionsControlsWidget::OnWhisperAllButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnWhisperAllButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnWhisperBlockButtonClicked
// (Final, Native, Private)

void UGameMenuOptionsControlsWidget::OnWhisperBlockButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnWhisperBlockButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.OnWhisperFriendButtonClicked
// (Final, Native, Private)

void UGameMenuOptionsControlsWidget::OnWhisperFriendButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "OnWhisperFriendButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.SetAutoFillUtilitySlot
// (Final, Native, Private)
// Parameters:
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::SetAutoFillUtilitySlot(bool bState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "SetAutoFillUtilitySlot");

	Params::GameMenuOptionsControlsWidget_SetAutoFillUtilitySlot Parms{};

	Parms.bState = bState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.SetAutoNextUtilitySlot
// (Final, Native, Private)
// Parameters:
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::SetAutoNextUtilitySlot(bool bState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "SetAutoNextUtilitySlot");

	Params::GameMenuOptionsControlsWidget_SetAutoNextUtilitySlot Parms{};

	Parms.bState = bState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.SetDeathCam
// (Final, Native, Private)
// Parameters:
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::SetDeathCam(bool bState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "SetDeathCam");

	Params::GameMenuOptionsControlsWidget_SetDeathCam Parms{};

	Parms.bState = bState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsControlsWidget.SetLanguageSelected
// (Final, Native, Private)
// Parameters:
// class FString                           SelectedString                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsControlsWidget::SetLanguageSelected(const class FString& SelectedString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsControlsWidget", "SetLanguageSelected");

	Params::GameMenuOptionsControlsWidget_SetLanguageSelected Parms{};

	Parms.SelectedString = std::move(SelectedString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.ChangeBinding
// (Final, Native, Protected)
// Parameters:
// int32                                   InKeyBindSlot                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             InKey                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsInputBindSlotWidget::ChangeBinding(int32 InKeyBindSlot, const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputBindSlotWidget", "ChangeBinding");

	Params::GameMenuOptionsInputBindSlotWidget_ChangeBinding Parms{};

	Parms.InKeyBindSlot = InKeyBindSlot;
	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.GetPrimaryGamepadFocusWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UGameMenuOptionsInputBindSlotWidget::GetPrimaryGamepadFocusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputBindSlotWidget", "GetPrimaryGamepadFocusWidget");

	Params::GameMenuOptionsInputBindSlotWidget_GetPrimaryGamepadFocusWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.HandlePrimaryKeyPressed
// (Final, Native, Protected)
// Parameters:
// struct FKey                             InKey                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsInputBindSlotWidget::HandlePrimaryKeyPressed(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputBindSlotWidget", "HandlePrimaryKeyPressed");

	Params::GameMenuOptionsInputBindSlotWidget_HandlePrimaryKeyPressed Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.HandleSecondaryKeyPressed
// (Final, Native, Protected)
// Parameters:
// struct FKey                             InKey                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsInputBindSlotWidget::HandleSecondaryKeyPressed(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputBindSlotWidget", "HandleSecondaryKeyPressed");

	Params::GameMenuOptionsInputBindSlotWidget_HandleSecondaryKeyPressed Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.OnClearButtonClicked
// (Final, Native, Protected)

void UGameMenuOptionsInputBindSlotWidget::OnClearButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputBindSlotWidget", "OnClearButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.OnPrimaryKeyBindButtonClicked
// (Final, Native, Protected)

void UGameMenuOptionsInputBindSlotWidget::OnPrimaryKeyBindButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputBindSlotWidget", "OnPrimaryKeyBindButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.OnSecondaryKeyBindButtonClicked
// (Final, Native, Protected)

void UGameMenuOptionsInputBindSlotWidget::OnSecondaryKeyBindButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputBindSlotWidget", "OnSecondaryKeyBindButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsInputSlotWidget.GetPrimaryGamepadFocusWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UGameMenuOptionsInputSlotWidget::GetPrimaryGamepadFocusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputSlotWidget", "GetPrimaryGamepadFocusWidget");

	Params::GameMenuOptionsInputSlotWidget_GetPrimaryGamepadFocusWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionsInputWidget.OnApplyButtonClicked
// (Final, Native, Private)

void UGameMenuOptionsInputWidget::OnApplyButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputWidget", "OnApplyButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsInputWidget.OnInputBindPendingChange
// (Final, Native, Private)

void UGameMenuOptionsInputWidget::OnInputBindPendingChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputWidget", "OnInputBindPendingChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsInputWidget.OnResetButtonClicked
// (Final, Native, Private)

void UGameMenuOptionsInputWidget::OnResetButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputWidget", "OnResetButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsInputWidget.RefreshWidget
// (Final, Native, Private)

void UGameMenuOptionsInputWidget::RefreshWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsInputWidget", "RefreshWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.ExtractOnlyNumberics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Message                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsInteger                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameMenuOptionSliderWidget::ExtractOnlyNumberics(const class FString& Message, bool IsInteger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameMenuOptionSliderWidget", "ExtractOnlyNumberics");

	Params::GameMenuOptionSliderWidget_ExtractOnlyNumberics Parms{};

	Parms.Message = std::move(Message);
	Parms.IsInteger = IsInteger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.GetCurrentOptionValue
// (Event, Public, BlueprintEvent)

void UGameMenuOptionSliderWidget::GetCurrentOptionValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSliderWidget", "GetCurrentOptionValue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.GetCurrentOptionValueByPercent
// (Event, Public, BlueprintEvent)

void UGameMenuOptionSliderWidget::GetCurrentOptionValueByPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSliderWidget", "GetCurrentOptionValueByPercent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.GetOptionValue
// (Final, Native, Public)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameMenuOptionSliderWidget::GetOptionValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSliderWidget", "GetOptionValue");

	Params::GameMenuOptionSliderWidget_GetOptionValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.GetOptionValuePercent
// (Final, Native, Public)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameMenuOptionSliderWidget::GetOptionValuePercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSliderWidget", "GetOptionValuePercent");

	Params::GameMenuOptionSliderWidget_GetOptionValuePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.GetPrimaryGamepadFocusWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UGameMenuOptionSliderWidget::GetPrimaryGamepadFocusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSliderWidget", "GetPrimaryGamepadFocusWidget");

	Params::GameMenuOptionSliderWidget_GetPrimaryGamepadFocusWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.SetOptionValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionSliderWidget::SetOptionValue(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSliderWidget", "SetOptionValue");

	Params::GameMenuOptionSliderWidget_SetOptionValue Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.SetSliderMinMaxValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMinValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InStepSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionSliderWidget::SetSliderMinMaxValue(float InMinValue, float InMaxValue, float InStepSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSliderWidget", "SetSliderMinMaxValue");

	Params::GameMenuOptionSliderWidget_SetSliderMinMaxValue Parms{};

	Parms.InMinValue = InMinValue;
	Parms.InMaxValue = InMaxValue;
	Parms.InStepSize = InStepSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.SetTitle
// (Final, Native, Public)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UGameMenuOptionSliderWidget::SetTitle(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSliderWidget", "SetTitle");

	Params::GameMenuOptionSliderWidget_SetTitle Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.UpdateSliderMinMaxValue
// (Event, Public, BlueprintEvent)

void UGameMenuOptionSliderWidget::UpdateSliderMinMaxValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSliderWidget", "UpdateSliderMinMaxValue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMenuOptionSliderWidget.UpdateSliderValue
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionSliderWidget::UpdateSliderValue(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSliderWidget", "UpdateSliderValue");

	Params::GameMenuOptionSliderWidget_UpdateSliderValue Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuOptionSlotWidget.OnSelectedSlotIdx
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   NewValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionSlotWidget::OnSelectedSlotIdx(const int32& NewValue, const int32& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSlotWidget", "OnSelectedSlotIdx");

	Params::GameMenuOptionSlotWidget_OnSelectedSlotIdx Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuOptionSlotWidget.SetSelectedSlotIdx
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InSlotIdx                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionSlotWidget::SetSelectedSlotIdx(int32 InSlotIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionSlotWidget", "SetSelectedSlotIdx");

	Params::GameMenuOptionSlotWidget_SetSelectedSlotIdx Parms{};

	Parms.InSlotIdx = InSlotIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsPlatformWidget.CopyLinkCode
// (Final, Native, Private)

void UGameMenuOptionsPlatformWidget::CopyLinkCode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsPlatformWidget", "CopyLinkCode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsPlatformWidget.GetLinkCode
// (Final, Native, Private)

void UGameMenuOptionsPlatformWidget::GetLinkCode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsPlatformWidget", "GetLinkCode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsPlatformWidget.OnLinkCodeWidgetCheckStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bIsChecked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsPlatformWidget::OnLinkCodeWidgetCheckStateChanged(bool bIsChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsPlatformWidget", "OnLinkCodeWidgetCheckStateChanged");

	Params::GameMenuOptionsPlatformWidget_OnLinkCodeWidgetCheckStateChanged Parms{};

	Parms.bIsChecked = bIsChecked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideoWidget.OnApplyButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideoWidget::OnApplyButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideoWidget", "OnApplyButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideoWidget.OnApplyDisplayOption
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideoWidget::OnApplyDisplayOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideoWidget", "OnApplyDisplayOption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideoWidget.OnBrightnessChanged
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideoWidget::OnBrightnessChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideoWidget", "OnBrightnessChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideoWidget.OnDisplayOptionChangePopup
// (Event, Protected, BlueprintEvent)

void UGameMenuOptionsVideoWidget::OnDisplayOptionChangePopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideoWidget", "OnDisplayOptionChangePopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMenuOptionsVideoWidget.OnResetButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideoWidget::OnResetButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideoWidget", "OnResetButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideoWidget.OnRevertDisplayOption
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideoWidget::OnRevertDisplayOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideoWidget", "OnRevertDisplayOption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideoWidget.UpdateAntiAliasingSuperResolution
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   InSlotIdx                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsVideoWidget::UpdateAntiAliasingSuperResolution(int32 InSlotIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideoWidget", "UpdateAntiAliasingSuperResolution");

	Params::GameMenuOptionsVideoWidget_UpdateAntiAliasingSuperResolution Parms{};

	Parms.InSlotIdx = InSlotIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsVideoWidget.UpdateDisplayMode
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionsVideoWidget::UpdateDisplayMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsVideoWidget", "UpdateDisplayMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsWidget.OnToggled
// (Final, Native, Private)
// Parameters:
// ESlateVisibility                        Invisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsWidget::OnToggled(ESlateVisibility Invisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsWidget", "OnToggled");

	Params::GameMenuOptionsWidget_OnToggled Parms{};

	Parms.Invisibility = Invisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionsWidget.OnWidgetToggleNotify
// (Event, Protected, BlueprintEvent)
// Parameters:
// ESlateVisibility                        Invisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionsWidget::OnWidgetToggleNotify(ESlateVisibility Invisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionsWidget", "OnWidgetToggleNotify");

	Params::GameMenuOptionsWidget_OnWidgetToggleNotify Parms{};

	Parms.Invisibility = Invisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.GetPrimaryGamepadFocusWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UGameMenuOptionToggleSwitchWidget::GetPrimaryGamepadFocusWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionToggleSwitchWidget", "GetPrimaryGamepadFocusWidget");

	Params::GameMenuOptionToggleSwitchWidget_GetPrimaryGamepadFocusWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.GetToggleSwitch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameMenuOptionToggleSwitchWidget::GetToggleSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionToggleSwitchWidget", "GetToggleSwitch");

	Params::GameMenuOptionToggleSwitchWidget_GetToggleSwitch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.OffToggleSwitchClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionToggleSwitchWidget::OffToggleSwitchClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionToggleSwitchWidget", "OffToggleSwitchClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.OnToggleSwitch
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    InSwitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionToggleSwitchWidget::OnToggleSwitch(bool InSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionToggleSwitchWidget", "OnToggleSwitch");

	Params::GameMenuOptionToggleSwitchWidget_OnToggleSwitch Parms{};

	Parms.InSwitch = InSwitch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.OnToggleSwitchClicked
// (Final, Native, Protected, BlueprintCallable)

void UGameMenuOptionToggleSwitchWidget::OnToggleSwitchClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionToggleSwitchWidget", "OnToggleSwitchClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetButtonText
// (Final, Native, Public)
// Parameters:
// class FText                             LeftText                                               (Parm, NativeAccessSpecifierPublic)
// class FText                             RightText                                              (Parm, NativeAccessSpecifierPublic)

void UGameMenuOptionToggleSwitchWidget::SetButtonText(const class FText& LeftText, const class FText& RightText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionToggleSwitchWidget", "SetButtonText");

	Params::GameMenuOptionToggleSwitchWidget_SetButtonText Parms{};

	Parms.LeftText = std::move(LeftText);
	Parms.RightText = std::move(RightText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetTitle
// (Final, Native, Public)
// Parameters:
// class FText                             InTitle                                                (Parm, NativeAccessSpecifierPublic)

void UGameMenuOptionToggleSwitchWidget::SetTitle(const class FText& InTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionToggleSwitchWidget", "SetTitle");

	Params::GameMenuOptionToggleSwitchWidget_SetTitle Parms{};

	Parms.InTitle = std::move(InTitle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetToggleSwitch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InSwitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuOptionToggleSwitchWidget::SetToggleSwitch(bool InSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionToggleSwitchWidget", "SetToggleSwitch");

	Params::GameMenuOptionToggleSwitchWidget_SetToggleSwitch Parms{};

	Parms.InSwitch = InSwitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.UpdateButtonText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             LeftText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             RightText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameMenuOptionToggleSwitchWidget::UpdateButtonText(const class FText& LeftText, const class FText& RightText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuOptionToggleSwitchWidget", "UpdateButtonText");

	Params::GameMenuOptionToggleSwitchWidget_UpdateButtonText Parms{};

	Parms.LeftText = std::move(LeftText);
	Parms.RightText = std::move(RightText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuWidget.OnCharacterSelectClicked
// (Final, Native, Private)

void UGameMenuWidget::OnCharacterSelectClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "OnCharacterSelectClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuWidget.OnContinueButtonClicked
// (Final, Native, Private)

void UGameMenuWidget::OnContinueButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "OnContinueButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuWidget.OnDeselectedSubMenuButtons
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UGameMenuWidget::OnDeselectedSubMenuButtons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "OnDeselectedSubMenuButtons");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMenuWidget.OnDisplayOptionApplyPopup
// (Event, Protected, BlueprintEvent)

void UGameMenuWidget::OnDisplayOptionApplyPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "OnDisplayOptionApplyPopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMenuWidget.OnDisplayTotalPlaytime
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FTimespan                        CurrentTotalPlayTime                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuWidget::OnDisplayTotalPlaytime(const struct FTimespan& CurrentTotalPlayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "OnDisplayTotalPlaytime");

	Params::GameMenuWidget_OnDisplayTotalPlaytime Parms{};

	Parms.CurrentTotalPlayTime = std::move(CurrentTotalPlayTime);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuWidget.OnExitButtonClicked
// (Final, Native, Private)

void UGameMenuWidget::OnExitButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "OnExitButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuWidget.OnLobbyButtonClicked
// (Final, Native, Private)

void UGameMenuWidget::OnLobbyButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "OnLobbyButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuWidget.OnMenuPop
// (Event, Protected, BlueprintEvent)

void UGameMenuWidget::OnMenuPop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "OnMenuPop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMenuWidget.OnOptionsButtonClicked
// (Final, Native, Private)

void UGameMenuWidget::OnOptionsButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "OnOptionsButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMenuWidget.OnVisibleReportButton
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuWidget::OnVisibleReportButton(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "OnVisibleReportButton");

	Params::GameMenuWidget_OnVisibleReportButton Parms{};

	Parms.bIsVisible = bIsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMenuWidget.IsLobby
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UGameMenuWidget::IsLobby() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "IsLobby");

	Params::GameMenuWidget_IsLobby Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameMusicCurrentSlotWidget.OnMusicDataChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMusicData                       InMusicData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDesignDataMusic                 InDesignDataMusic                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameMusicCurrentSlotWidget::OnMusicDataChanged(const struct FMusicData& InMusicData, const struct FDesignDataMusic& InDesignDataMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicCurrentSlotWidget", "OnMusicDataChanged");

	Params::GameMusicCurrentSlotWidget_OnMusicDataChanged Parms{};

	Parms.InMusicData = std::move(InMusicData);
	Parms.InDesignDataMusic = std::move(InDesignDataMusic);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMusicCurrentSlotWidget.SetMusicData
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FMusicData                       InMusicData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDesignDataMusic                 InDesignDataMusic                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameMusicCurrentSlotWidget::SetMusicData(const struct FMusicData& InMusicData, const struct FDesignDataMusic& InDesignDataMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicCurrentSlotWidget", "SetMusicData");

	Params::GameMusicCurrentSlotWidget_SetMusicData Parms{};

	Parms.InMusicData = std::move(InMusicData);
	Parms.InDesignDataMusic = std::move(InDesignDataMusic);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameMusicPlayBarWidget.OnMusicChannelingEnd
// (Event, Protected, BlueprintEvent)

void UGameMusicPlayBarWidget::OnMusicChannelingEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicPlayBarWidget", "OnMusicChannelingEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMusicPlayBarWidget.OnMusicChannelingStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// EMusicPlaySectionJudgement              Judge                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMusicPlayBarWidget::OnMusicChannelingStart(EMusicPlaySectionJudgement Judge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicPlayBarWidget", "OnMusicChannelingStart");

	Params::GameMusicPlayBarWidget_OnMusicChannelingStart Parms{};

	Parms.Judge = Judge;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMusicPlayBarWidget.OnMusicJudgeNotify
// (Event, Protected, BlueprintEvent)
// Parameters:
// EMusicPlaySectionJudgement              Judge                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PastSectionRatio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NextSectionRatio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   JudgePositionRatio                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMusicPlayBarWidget::OnMusicJudgeNotify(EMusicPlaySectionJudgement Judge, float PastSectionRatio, float NextSectionRatio, float JudgePositionRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicPlayBarWidget", "OnMusicJudgeNotify");

	Params::GameMusicPlayBarWidget_OnMusicJudgeNotify Parms{};

	Parms.Judge = Judge;
	Parms.PastSectionRatio = PastSectionRatio;
	Parms.NextSectionRatio = NextSectionRatio;
	Parms.JudgePositionRatio = JudgePositionRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMusicPlayBarWidget.OnMusicPlayEnd
// (Event, Protected, BlueprintEvent)

void UGameMusicPlayBarWidget::OnMusicPlayEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicPlayBarWidget", "OnMusicPlayEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMusicPlayBarWidget.OnMusicPlayStart
// (Event, Protected, BlueprintEvent)

void UGameMusicPlayBarWidget::OnMusicPlayStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicPlayBarWidget", "OnMusicPlayStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameMusicPlayBarWidget.OnMusicPlaySucceed
// (Event, Protected, BlueprintEvent)
// Parameters:
// EMusicPlaySectionJudgement              Judge                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMusicPlayBarWidget::OnMusicPlaySucceed(EMusicPlaySectionJudgement Judge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicPlayBarWidget", "OnMusicPlaySucceed");

	Params::GameMusicPlayBarWidget_OnMusicPlaySucceed Parms{};

	Parms.Judge = Judge;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMusicSlotWidget.OnSelectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMusicSlotWidget::OnSelectionChanged(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicSlotWidget", "OnSelectionChanged");

	Params::GameMusicSlotWidget_OnSelectionChanged Parms{};

	Parms.bIsSelected = bIsSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameMusicSlotWidget.SelectionChange
// (Final, Native, Public)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMusicSlotWidget::SelectionChange(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMusicSlotWidget", "SelectionChange");

	Params::GameMusicSlotWidget_SelectionChange Parms{};

	Parms.bIsSelected = bIsSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GamePartyManagePartyMemberWidget.OnAccountDataReplication
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccountDataReplication          NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAccountDataReplication          OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGamePartyManagePartyMemberWidget::OnAccountDataReplication(const struct FAccountDataReplication& NewValue, const struct FAccountDataReplication& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamePartyManagePartyMemberWidget", "OnAccountDataReplication");

	Params::GamePartyManagePartyMemberWidget_OnAccountDataReplication Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GamePartyManagePartyWidget.OnPartyData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPartyData                       NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPartyData                       OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGamePartyManagePartyWidget::OnPartyData(const struct FPartyData& NewValue, const struct FPartyData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamePartyManagePartyWidget", "OnPartyData");

	Params::GamePartyManagePartyWidget_OnPartyData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GamePartyManagePartyWidget.PartyJoin
// (Final, Native, Private)

void UGamePartyManagePartyWidget::PartyJoin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamePartyManagePartyWidget", "PartyJoin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GamePartyMemberWidget.OnPortraitRenderTargetUpdated
// (Event, Protected, BlueprintEvent)

void UGamePartyMemberWidget::OnPortraitRenderTargetUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamePartyMemberWidget", "OnPortraitRenderTargetUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GamePartyMemberWidget.OnRefreshNickname
// (Event, Protected, BlueprintEvent)

void UGamePartyMemberWidget::OnRefreshNickname()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamePartyMemberWidget", "OnRefreshNickname");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GamePlayerCharacterWidget.OnCampfireChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInCampfire                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGamePlayerCharacterWidget::OnCampfireChanged(bool bInCampfire)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamePlayerCharacterWidget", "OnCampfireChanged");

	Params::GamePlayerCharacterWidget_OnCampfireChanged Parms{};

	Parms.bInCampfire = bInCampfire;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GamePlayerCharacterWidget.OnCharacterClass
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDCCharacterClass                       InCharacterClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGamePlayerCharacterWidget::OnCharacterClass(EDCCharacterClass InCharacterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamePlayerCharacterWidget", "OnCharacterClass");

	Params::GamePlayerCharacterWidget_OnCharacterClass Parms{};

	Parms.InCharacterClass = InCharacterClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GamePlayerCharacterWidget.OnCurrentActiveSlot
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UEquipmentSlotWidget*             CurrentActiveWidget                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGamePlayerCharacterWidget::OnCurrentActiveSlot(const class UEquipmentSlotWidget* CurrentActiveWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamePlayerCharacterWidget", "OnCurrentActiveSlot");

	Params::GamePlayerCharacterWidget_OnCurrentActiveSlot Parms{};

	Parms.CurrentActiveWidget = CurrentActiveWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GamePlayerCharacterWidget.OnRecoveryHealing
// (Event, Protected, BlueprintEvent)

void UGamePlayerCharacterWidget::OnRecoveryHealing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamePlayerCharacterWidget", "OnRecoveryHealing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GamePlayerEquipSlotWidget.OnQuickSlotDataChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEquipmentQuickSlotType                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGamePlayerEquipSlotWidget::OnQuickSlotDataChanged(EEquipmentQuickSlotType Type, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamePlayerEquipSlotWidget", "OnQuickSlotDataChanged");

	Params::GamePlayerEquipSlotWidget_OnQuickSlotDataChanged Parms{};

	Parms.Type = Type;
	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameProgressBarWidget.OnPercentUpdated
// (Event, Protected, BlueprintEvent)

void UGameProgressBarWidget::OnPercentUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameProgressBarWidget", "OnPercentUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameShapeShiftSelectGroupWidget.OnCurrentShapeShiftSlotChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UGameShapeShiftSlotWidget*        InSelectedSlot                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameShapeShiftSelectGroupWidget::OnCurrentShapeShiftSlotChanged(class UGameShapeShiftSlotWidget* InSelectedSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameShapeShiftSelectGroupWidget", "OnCurrentShapeShiftSlotChanged");

	Params::GameShapeShiftSelectGroupWidget_OnCurrentShapeShiftSlotChanged Parms{};

	Parms.InSelectedSlot = InSelectedSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameShapeShiftSelectGroupWidget.OnSelectedShapeShiftIndexChanged
// (Final, Native, Protected, BlueprintCallable)

void UGameShapeShiftSelectGroupWidget::OnSelectedShapeShiftIndexChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameShapeShiftSelectGroupWidget", "OnSelectedShapeShiftIndexChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameShapeShiftSelectGroupWidget.OnShapeShiftSelectClose
// (Event, Protected, BlueprintEvent)

void UGameShapeShiftSelectGroupWidget::OnShapeShiftSelectClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameShapeShiftSelectGroupWidget", "OnShapeShiftSelectClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameShapeShiftSelectGroupWidget.OnShapeShiftSelectPopup
// (Event, Protected, BlueprintEvent)

void UGameShapeShiftSelectGroupWidget::OnShapeShiftSelectPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameShapeShiftSelectGroupWidget", "OnShapeShiftSelectPopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameShapeShiftSlotWidget.OnSelectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameShapeShiftSlotWidget::OnSelectionChanged(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameShapeShiftSlotWidget", "OnSelectionChanged");

	Params::GameShapeShiftSlotWidget_OnSelectionChanged Parms{};

	Parms.bIsSelected = bIsSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameShapeShiftSlotWidget.SelectionChange
// (Final, Native, Public)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameShapeShiftSlotWidget::SelectionChange(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameShapeShiftSlotWidget", "SelectionChange");

	Params::GameShapeShiftSlotWidget_SelectionChange Parms{};

	Parms.bIsSelected = bIsSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameSkillSlotWidget.GetSkillSlotCooldownDuration
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSkillSlotWidget::GetSkillSlotCooldownDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "GetSkillSlotCooldownDuration");

	Params::GameSkillSlotWidget_GetSkillSlotCooldownDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameSkillSlotWidget.GetSkillSlotCooldownPercent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSkillSlotWidget::GetSkillSlotCooldownPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "GetSkillSlotCooldownPercent");

	Params::GameSkillSlotWidget_GetSkillSlotCooldownPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameSkillSlotWidget.OnLinkedPawnDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSkillSlotWidget::OnLinkedPawnDestroyed(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "OnLinkedPawnDestroyed");

	Params::GameSkillSlotWidget_OnLinkedPawnDestroyed Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameSkillSlotWidget.OnResetSkillCooldownUI
// (Event, Protected, BlueprintEvent)

void UGameSkillSlotWidget::OnResetSkillCooldownUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "OnResetSkillCooldownUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSkillSlotWidget.OnResetSkillDesc
// (Event, Protected, BlueprintEvent)

void UGameSkillSlotWidget::OnResetSkillDesc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "OnResetSkillDesc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSkillSlotWidget.OnSkillCooldownEnd
// (Event, Protected, BlueprintEvent)

void UGameSkillSlotWidget::OnSkillCooldownEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "OnSkillCooldownEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSkillSlotWidget.OnSkillFailedSystemMessage
// (Event, Protected, BlueprintEvent)

void UGameSkillSlotWidget::OnSkillFailedSystemMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "OnSkillFailedSystemMessage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillArtData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UArtDataSkill*                    SkillArtData                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSkillSlotWidget::OnUpdateSkillArtData(class UArtDataSkill* SkillArtData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "OnUpdateSkillArtData");

	Params::GameSkillSlotWidget_OnUpdateSkillArtData Parms{};

	Parms.SkillArtData = SkillArtData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSkillData                       InSkillData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDesignDataSkill                 InDesignDataSkill                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameSkillSlotWidget::OnUpdateSkillData(const struct FSkillData& InSkillData, const struct FDesignDataSkill& InDesignDataSkill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "OnUpdateSkillData");

	Params::GameSkillSlotWidget_OnUpdateSkillData Parms{};

	Parms.InSkillData = std::move(InSkillData);
	Parms.InDesignDataSkill = std::move(InDesignDataSkill);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillDesc
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             SkillName                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             SkillDesc                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameSkillSlotWidget::OnUpdateSkillDesc(const class FText& SkillName, const class FText& SkillDesc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "OnUpdateSkillDesc");

	Params::GameSkillSlotWidget_OnUpdateSkillDesc Parms{};

	Parms.SkillName = std::move(SkillName);
	Parms.SkillDesc = std::move(SkillDesc);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillSlot
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     SkillTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSkillSlotWidget::OnUpdateSkillSlot(const struct FGameplayTag& SkillTag, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "OnUpdateSkillSlot");

	Params::GameSkillSlotWidget_OnUpdateSkillSlot Parms{};

	Parms.SkillTag = std::move(SkillTag);
	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillSlotVisible
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSkillSlotWidget::OnUpdateSkillSlotVisible(bool IsVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "OnUpdateSkillSlotVisible");

	Params::GameSkillSlotWidget_OnUpdateSkillSlotVisible Parms{};

	Parms.IsVisibility = IsVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillCooldownUI
// (Event, Protected, BlueprintEvent)

void UGameSkillSlotWidget::UpdateSkillCooldownUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "UpdateSkillCooldownUI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSkillSlotWidget.GetSkillChargedPercent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSkillSlotWidget::GetSkillChargedPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSkillSlotWidget", "GetSkillChargedPercent");

	Params::GameSkillSlotWidget_GetSkillChargedPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellCastEnd
// (Event, Protected, BlueprintEvent)

void UGameSpellCastingBarWidget::OnSpellCastEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellCastingBarWidget", "OnSpellCastEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellCastStart
// (Event, Protected, BlueprintEvent)

void UGameSpellCastingBarWidget::OnSpellCastStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellCastingBarWidget", "OnSpellCastStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellCastSucceed
// (Event, Protected, BlueprintEvent)

void UGameSpellCastingBarWidget::OnSpellCastSucceed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellCastingBarWidget", "OnSpellCastSucceed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellChannelingEnd
// (Event, Protected, BlueprintEvent)

void UGameSpellCastingBarWidget::OnSpellChannelingEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellCastingBarWidget", "OnSpellChannelingEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellChannelingStart
// (Event, Protected, BlueprintEvent)

void UGameSpellCastingBarWidget::OnSpellChannelingStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellCastingBarWidget", "OnSpellChannelingStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSpellSelectGroupWidget.OnCurrentSpellSlotChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UGameSpellSlotWidget*             InSelectedSlot                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSpellSelectGroupWidget::OnCurrentSpellSlotChanged(class UGameSpellSlotWidget* InSelectedSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellSelectGroupWidget", "OnCurrentSpellSlotChanged");

	Params::GameSpellSelectGroupWidget_OnCurrentSpellSlotChanged Parms{};

	Parms.InSelectedSlot = InSelectedSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameSpellSelectGroupWidget.OnSelectedSpellIndexChanged
// (Final, Native, Protected, BlueprintCallable)

void UGameSpellSelectGroupWidget::OnSelectedSpellIndexChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellSelectGroupWidget", "OnSelectedSpellIndexChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameSpellSelectGroupWidget.OnSpellSelectClose
// (Event, Protected, BlueprintEvent)

void UGameSpellSelectGroupWidget::OnSpellSelectClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellSelectGroupWidget", "OnSpellSelectClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSpellSelectGroupWidget.OnSpellSelectPopup
// (Event, Protected, BlueprintEvent)

void UGameSpellSelectGroupWidget::OnSpellSelectPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellSelectGroupWidget", "OnSpellSelectPopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GameSpellSlotWidget.GetSpellHealthCost
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSpellSlotWidget::GetSpellHealthCost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellSlotWidget", "GetSpellHealthCost");

	Params::GameSpellSlotWidget_GetSpellHealthCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameSpellSlotWidget.OnSelectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSpellSlotWidget::OnSelectionChanged(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellSlotWidget", "OnSelectionChanged");

	Params::GameSpellSlotWidget_OnSelectionChanged Parms{};

	Parms.bIsSelected = bIsSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameSpellSlotWidget.SelectionChange
// (Final, Native, Public)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSpellSlotWidget::SelectionChange(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellSlotWidget", "SelectionChange");

	Params::GameSpellSlotWidget_SelectionChange Parms{};

	Parms.bIsSelected = bIsSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GameSpellSlotWidget.GetSpellChargedPercent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSpellSlotWidget::GetSpellChargedPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSpellSlotWidget", "GetSpellChargedPercent");

	Params::GameSpellSlotWidget_GetSpellChargedPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GameTavernStartTimerWidget.OnPlayerCount
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameTavernStartTimerWidget::OnPlayerCount(int32 NewValue, int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTavernStartTimerWidget", "OnPlayerCount");

	Params::GameTavernStartTimerWidget_OnPlayerCount Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameTavernStartTimerWidget.OnPlayerLimit
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameTavernStartTimerWidget::OnPlayerLimit(int32 NewValue, int32 OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTavernStartTimerWidget", "OnPlayerLimit");

	Params::GameTavernStartTimerWidget_OnPlayerLimit Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GameTavernStartTimerWidget.OnUpdated
// (Event, Protected, BlueprintEvent)

void UGameTavernStartTimerWidget::OnUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameTavernStartTimerWidget", "OnUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_ActivateItemBase.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_ActivateItemBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ActivateItemBase", "AbilityActivated");

	Params::GA_ActivateItemBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ActivateItemBase.EventReceived
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ActivateItemBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ActivateItemBase", "EventReceived");

	Params::GA_ActivateItemBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ActivateItemBase.OnCancelled
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ActivateItemBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ActivateItemBase", "OnCancelled");

	Params::GA_ActivateItemBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ActivateItemBase.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ActivateItemBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ActivateItemBase", "OnCompleted");

	Params::GA_ActivateItemBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ActivateItemBase.OtherHandIACompleted
// (Final, Native, Protected)

void UGA_ActivateItemBase::OtherHandIACompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ActivateItemBase", "OtherHandIACompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ActivateItemBase.OtherHandIAStarted
// (Final, Native, Protected)

void UGA_ActivateItemBase::OtherHandIAStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ActivateItemBase", "OtherHandIAStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ActivateItemBase.ReceivedEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ActivateItemBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ActivateItemBase", "ReceivedEvent");

	Params::GA_ActivateItemBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_AuraBase.AbilityActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_AuraBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_AuraBase", "AbilityActivated");

	Params::GA_AuraBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_AuraBase.AbilityEnded
// (Event, Public, BlueprintEvent)

void UGA_AuraBase::AbilityEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_AuraBase", "AbilityEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_AuraBase.OnAntiAuraOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGA_AuraBase::OnAntiAuraOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_AuraBase", "OnAntiAuraOverlapBegin");

	Params::GA_AuraBase_OnAntiAuraOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_AuraBase.OnAntiAuraOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_AuraBase::OnAntiAuraOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_AuraBase", "OnAntiAuraOverlapEnd");

	Params::GA_AuraBase_OnAntiAuraOverlapEnd Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_AuraBase.OnAuraOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGA_AuraBase::OnAuraOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_AuraBase", "OnAuraOverlapBegin");

	Params::GA_AuraBase_OnAuraOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_AuraBase.OnAuraOverlapBeginEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_AuraBase::OnAuraOverlapBeginEvent(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_AuraBase", "OnAuraOverlapBeginEvent");

	Params::GA_AuraBase_OnAuraOverlapBeginEvent Parms{};

	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_AuraBase.OnAuraOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_AuraBase::OnAuraOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_AuraBase", "OnAuraOverlapEnd");

	Params::GA_AuraBase_OnAuraOverlapEnd Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_AuraBase.OnAuraOverlapEndEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_AuraBase::OnAuraOverlapEndEvent(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_AuraBase", "OnAuraOverlapEndEvent");

	Params::GA_AuraBase_OnAuraOverlapEndEvent Parms{};

	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_AuraBase.OnAuraTargetGameplayTag
// (Final, Native, Private, HasOutParams)
// Parameters:
// class AActor*                           InTargetActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_AuraBase::OnAuraTargetGameplayTag(class AActor* InTargetActor, const struct FGameplayTag& InGameplayTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_AuraBase", "OnAuraTargetGameplayTag");

	Params::GA_AuraBase_OnAuraTargetGameplayTag Parms{};

	Parms.InTargetActor = InTargetActor;
	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_BowQuickShotBase.InputActionCompleted
// (Final, Native, Protected)

void UGA_BowQuickShotBase::InputActionCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_BowQuickShotBase", "InputActionCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_BowQuickShotBase.InputActionStarted
// (Final, Native, Protected)

void UGA_BowQuickShotBase::InputActionStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_BowQuickShotBase", "InputActionStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_CaveCollapseBase.ServerOnCaveCollapseApplyEffect
// (Final, Native, Private)

void UGA_CaveCollapseBase::ServerOnCaveCollapseApplyEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_CaveCollapseBase", "ServerOnCaveCollapseApplyEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_CaveCollapseBase.ServerOnCaveCollapseStart
// (Final, Native, Private)

void UGA_CaveCollapseBase::ServerOnCaveCollapseStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_CaveCollapseBase", "ServerOnCaveCollapseStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_CharacterJump.EventReceived
// (Final, Native, Private)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_CharacterJump::EventReceived(const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_CharacterJump", "EventReceived");

	Params::GA_CharacterJump_EventReceived Parms{};

	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_CharacterJump.OnMovementModeChange
// (Final, Native, Private)
// Parameters:
// EMovementMode                           MovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_CharacterJump::OnMovementModeChange(EMovementMode MovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_CharacterJump", "OnMovementModeChange");

	Params::GA_CharacterJump_OnMovementModeChange Parms{};

	Parms.MovementMode = MovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Drawbridge.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_Drawbridge::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Drawbridge", "AbilityActivated");

	Params::GA_Drawbridge_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_Drawbridge.FinishTickTask
// (Final, Native, Private)

void UGA_Drawbridge::FinishTickTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Drawbridge", "FinishTickTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Drawbridge.OnBlendOut
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_Drawbridge::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Drawbridge", "OnBlendOut");

	Params::GA_Drawbridge_OnBlendOut Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Drawbridge.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_Drawbridge::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Drawbridge", "OnCompleted");

	Params::GA_Drawbridge_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Drawbridge.UpdatePlayCurrentTime
// (Final, Native, Private)

void UGA_Drawbridge::UpdatePlayCurrentTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Drawbridge", "UpdatePlayCurrentTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Drop.OnEndSync
// (Final, Native, Private)

void UGA_Drop::OnEndSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Drop", "OnEndSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_PlayMontageAndWaitForEvent::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayMontageAndWaitForEvent", "AbilityActivated");

	Params::GA_PlayMontageAndWaitForEvent_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.EventReceived
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayMontageAndWaitForEvent::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayMontageAndWaitForEvent", "EventReceived");

	Params::GA_PlayMontageAndWaitForEvent_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.OnCancelled
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayMontageAndWaitForEvent::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayMontageAndWaitForEvent", "OnCancelled");

	Params::GA_PlayMontageAndWaitForEvent_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayMontageAndWaitForEvent::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayMontageAndWaitForEvent", "OnCompleted");

	Params::GA_PlayMontageAndWaitForEvent_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.ReceivedEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayMontageAndWaitForEvent::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayMontageAndWaitForEvent", "ReceivedEvent");

	Params::GA_PlayMontageAndWaitForEvent_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_EmoteBase.HitKnockBackAttack
// (Final, Native, Protected)

void UGA_EmoteBase::HitKnockBackAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_EmoteBase", "HitKnockBackAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_EmoteRandom.HitKnockBackAttack
// (Final, Native, Protected)

void UGA_EmoteRandom::HitKnockBackAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_EmoteRandom", "HitKnockBackAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Equip.OnMontageEventReceived
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_Equip::OnMontageEventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Equip", "OnMontageEventReceived");

	Params::GA_Equip_OnMontageEventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_Equip.OnMontageFinished
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_Equip::OnMontageFinished(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Equip", "OnMontageFinished");

	Params::GA_Equip_OnMontageFinished Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_HuntingTrapDisarmPassiveBase.ClearDisarmTarget
// (Final, Native, Protected)

void UGA_HuntingTrapDisarmPassiveBase::ClearDisarmTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_HuntingTrapDisarmPassiveBase", "ClearDisarmTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_HuntingTrapDisarmPassiveBase.OnTargetGameplayTagChange
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_HuntingTrapDisarmPassiveBase::OnTargetGameplayTagChange(const struct FGameplayTag& InGameplayTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_HuntingTrapDisarmPassiveBase", "OnTargetGameplayTagChange");

	Params::GA_HuntingTrapDisarmPassiveBase_OnTargetGameplayTagChange Parms{};

	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_HuntingTrapDisarmPassiveBase.ReceivedEvent
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_HuntingTrapDisarmPassiveBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_HuntingTrapDisarmPassiveBase", "ReceivedEvent");

	Params::GA_HuntingTrapDisarmPassiveBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_HuntingTrapDisarmPassiveBase.SetDisarmTarget
// (Final, Native, Protected)
// Parameters:
// class APropsActorBase*                  TargetHuntingTrap                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_HuntingTrapDisarmPassiveBase::SetDisarmTarget(class APropsActorBase* TargetHuntingTrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_HuntingTrapDisarmPassiveBase", "SetDisarmTarget");

	Params::GA_HuntingTrapDisarmPassiveBase_SetDisarmTarget Parms{};

	Parms.TargetHuntingTrap = TargetHuntingTrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemActivateBase.Activated
// (Event, Protected, BlueprintEvent)

void UGA_ItemActivateBase::Activated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemActivateBase", "Activated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_ItemActivateBase.Deactivated
// (Event, Protected, BlueprintEvent)

void UGA_ItemActivateBase::Deactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemActivateBase", "Deactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_ItemActivateBase.EventReceived
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ItemActivateBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemActivateBase", "EventReceived");

	Params::GA_ItemActivateBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemActivateBase.ReceivedEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ItemActivateBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemActivateBase", "ReceivedEvent");

	Params::GA_ItemActivateBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ItemConsumeBase.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_ItemConsumeBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemConsumeBase", "AbilityActivated");

	Params::GA_ItemConsumeBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ItemConsumeBase.ConsumeEventReceived
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ItemConsumeBase::ConsumeEventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemConsumeBase", "ConsumeEventReceived");

	Params::GA_ItemConsumeBase_ConsumeEventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemConsumeBase.EventReceived
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ItemConsumeBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemConsumeBase", "EventReceived");

	Params::GA_ItemConsumeBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeEndEventReceived
// (Event, Protected, BlueprintEvent)

void UGA_ItemConsumeBase::OnConsumeEndEventReceived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemConsumeBase", "OnConsumeEndEventReceived");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeMontageCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ItemConsumeBase::OnConsumeMontageCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemConsumeBase", "OnConsumeMontageCompleted");

	Params::GA_ItemConsumeBase_OnConsumeMontageCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeStartEventReceived
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   ConsumeDuration                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_ItemConsumeBase::OnConsumeStartEventReceived(const float ConsumeDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemConsumeBase", "OnConsumeStartEventReceived");

	Params::GA_ItemConsumeBase_OnConsumeStartEventReceived Parms{};

	Parms.ConsumeDuration = ConsumeDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeSucceed
// (Event, Protected, BlueprintEvent)

void UGA_ItemConsumeBase::OnConsumeSucceed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemConsumeBase", "OnConsumeSucceed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_ItemConsumeBase.OnEndSync
// (Final, Native, Protected)

void UGA_ItemConsumeBase::OnEndSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemConsumeBase", "OnEndSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemConsumeBase.OnFinish
// (Final, Native, Protected)

void UGA_ItemConsumeBase::OnFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemConsumeBase", "OnFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ItemConsumeBase.OnStartSync
// (Final, Native, Protected)

void UGA_ItemConsumeBase::OnStartSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ItemConsumeBase", "OnStartSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MultiShotBase.InputActionCompleted
// (Final, Native, Protected)

void UGA_MultiShotBase::InputActionCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultiShotBase", "InputActionCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MultiShotBase.InputActionStarted
// (Final, Native, Protected)

void UGA_MultiShotBase::InputActionStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultiShotBase", "InputActionStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_MusicInstantBase.OnTargetActorOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<class AActor*>                   InTargetActors                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_MusicInstantBase::OnTargetActorOverlap(const TArray<class AActor*>& InTargetActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MusicInstantBase", "OnTargetActorOverlap");

	Params::GA_MusicInstantBase_OnTargetActorOverlap Parms{};

	Parms.InTargetActors = std::move(InTargetActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PaviseInstall.AbilityActivated
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PaviseInstall::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PaviseInstall", "AbilityActivated");

	Params::GA_PaviseInstall_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PaviseInstall.EventReceived
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PaviseInstall::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PaviseInstall", "EventReceived");

	Params::GA_PaviseInstall_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PaviseInstall.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PaviseInstall::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PaviseInstall", "OnCompleted");

	Params::GA_PaviseInstall_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PaviseInstall.OnInterrupted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PaviseInstall::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PaviseInstall", "OnInterrupted");

	Params::GA_PaviseInstall_OnInterrupted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PaviseInstall.OnVelocityChange
// (Final, Native, Private)

void UGA_PaviseInstall::OnVelocityChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PaviseInstall", "OnVelocityChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PaviseInstall.ReceivedEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PaviseInstall::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PaviseInstall", "ReceivedEvent");

	Params::GA_PaviseInstall_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.ComboIACompleted
// (Final, Native, Protected)

void UGA_PlayerCharMeleeAttackBase::ComboIACompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerCharMeleeAttackBase", "ComboIACompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.ComboIAStarted
// (Final, Native, Protected)

void UGA_PlayerCharMeleeAttackBase::ComboIAStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerCharMeleeAttackBase", "ComboIAStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.OnReceiveTargetDataEnd
// (Final, Native, Private)

void UGA_PlayerCharMeleeAttackBase::OnReceiveTargetDataEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerCharMeleeAttackBase", "OnReceiveTargetDataEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.OnReceiveTargetDataStart
// (Final, Native, Private)

void UGA_PlayerCharMeleeAttackBase::OnReceiveTargetDataStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerCharMeleeAttackBase", "OnReceiveTargetDataStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.OtherHandIACompleted
// (Final, Native, Protected)

void UGA_PlayerCharMeleeAttackBase::OtherHandIACompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerCharMeleeAttackBase", "OtherHandIACompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.OtherHandIAStarted
// (Final, Native, Protected)

void UGA_PlayerCharMeleeAttackBase::OtherHandIAStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerCharMeleeAttackBase", "OtherHandIAStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.ReceivedServerTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerCharMeleeAttackBase::ReceivedServerTargetData(const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerCharMeleeAttackBase", "ReceivedServerTargetData");

	Params::GA_PlayerCharMeleeAttackBase_ReceivedServerTargetData Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "AbilityActivated");

	Params::GA_PlayerMagicWandUseBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.ClientReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     InEffectTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InChannelTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::ClientReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "ClientReceivedTargetData");

	Params::GA_PlayerMagicWandUseBase_ClientReceivedTargetData Parms{};

	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InChannelTag = std::move(InChannelTag);
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.EventReceived
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "EventReceived");

	Params::GA_PlayerMagicWandUseBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnBlendOut
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnBlendOut");

	Params::GA_PlayerMagicWandUseBase_OnBlendOut Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnCancelled
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnCancelled");

	Params::GA_PlayerMagicWandUseBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnChannelingAction
// (Final, Native, Protected)
// Parameters:
// int32                                   ActionCounter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::OnChannelingAction(int32 ActionCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnChannelingAction");

	Params::GA_PlayerMagicWandUseBase_OnChannelingAction Parms{};

	Parms.ActionCounter = ActionCounter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnCompleted
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnCompleted");

	Params::GA_PlayerMagicWandUseBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnFire
// (Final, Native, Protected)

void UGA_PlayerMagicWandUseBase::OnFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnInterrupted
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnInterrupted");

	Params::GA_PlayerMagicWandUseBase_OnInterrupted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnInterruptFinish
// (Final, Native, Protected)

void UGA_PlayerMagicWandUseBase::OnInterruptFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnInterruptFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnRelease
// (Final, Native, Protected)

void UGA_PlayerMagicWandUseBase::OnRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnStuck
// (Final, Native, Protected)

void UGA_PlayerMagicWandUseBase::OnStuck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnStuck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnStuckFinish
// (Final, Native, Protected)

void UGA_PlayerMagicWandUseBase::OnStuckFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnStuckFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.OnVelocityChange
// (Final, Native, Protected)

void UGA_PlayerMagicWandUseBase::OnVelocityChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "OnVelocityChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.ReceivedEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "ReceivedEvent");

	Params::GA_PlayerMagicWandUseBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.ReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "ReceivedTargetData");

	Params::GA_PlayerMagicWandUseBase_ReceivedTargetData Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMagicWandUseBase.ServerReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     InEffectTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InChannelTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerMagicWandUseBase::ServerReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMagicWandUseBase", "ServerReceivedTargetData");

	Params::GA_PlayerMagicWandUseBase_ServerReceivedTargetData Parms{};

	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InChannelTag = std::move(InChannelTag);
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.AbilityActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_PlayerMusicPlayBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "AbilityActivated");

	Params::GA_PlayerMusicPlayBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.EventReceived
// (Final, Native, Public)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerMusicPlayBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "EventReceived");

	Params::GA_PlayerMusicPlayBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnBad
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnBad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnBad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnChannelingAction
// (Final, Native, Private)
// Parameters:
// int32                                   ActionCounter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerMusicPlayBase::OnChannelingAction(int32 ActionCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnChannelingAction");

	Params::GA_PlayerMusicPlayBase_OnChannelingAction Parms{};

	Parms.ActionCounter = ActionCounter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnChannelingFinish
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnChannelingFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnChannelingFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnChannelingSectionFinish
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnChannelingSectionFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnChannelingSectionFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnChannelingStartSync
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnChannelingStartSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnChannelingStartSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnCompleted
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnGood
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnGood()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnGood");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnMiss
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnMiss()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnMiss");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnPerfect
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnPerfect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnPerfect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnPlayFinish
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnPlayFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnPlayFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnPlayFinishFailed
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnPlayFinishFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnPlayFinishFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.OnPlayFinishSucceed
// (Final, Native, Private)

void UGA_PlayerMusicPlayBase::OnPlayFinishSucceed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "OnPlayFinishSucceed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerMusicPlayBase.ReceivedEvent
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerMusicPlayBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerMusicPlayBase", "ReceivedEvent");

	Params::GA_PlayerMusicPlayBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.StatisticsPopup.OnSeasonComboBoxSelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatisticsPopup::OnSeasonComboBoxSelected(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatisticsPopup", "OnSeasonComboBoxSelected");

	Params::StatisticsPopup_OnSeasonComboBoxSelected Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.StatisticsPopup.OnSheetComboBoxSelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatisticsPopup::OnSheetComboBoxSelected(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatisticsPopup", "OnSheetComboBoxSelected");

	Params::StatisticsPopup_OnSheetComboBoxSelected Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftSpellCastBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "AbilityActivated");

	Params::GA_PlayerShapeShiftSpellCastBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.ClientReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     InEffectTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InChannelTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftSpellCastBase::ClientReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "ClientReceivedTargetData");

	Params::GA_PlayerShapeShiftSpellCastBase_ClientReceivedTargetData Parms{};

	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InChannelTag = std::move(InChannelTag);
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.EventReceived
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftSpellCastBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "EventReceived");

	Params::GA_PlayerShapeShiftSpellCastBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnBlendOut
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftSpellCastBase::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnBlendOut");

	Params::GA_PlayerShapeShiftSpellCastBase_OnBlendOut Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnCancelled
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftSpellCastBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnCancelled");

	Params::GA_PlayerShapeShiftSpellCastBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnCastTriggerSync
// (Final, Native, Protected)

void UGA_PlayerShapeShiftSpellCastBase::OnCastTriggerSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnCastTriggerSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnCompleted
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftSpellCastBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnCompleted");

	Params::GA_PlayerShapeShiftSpellCastBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnFinish
// (Final, Native, Protected)

void UGA_PlayerShapeShiftSpellCastBase::OnFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnFinishSync
// (Final, Native, Protected)

void UGA_PlayerShapeShiftSpellCastBase::OnFinishSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnFinishSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnFire
// (Final, Native, Protected)

void UGA_PlayerShapeShiftSpellCastBase::OnFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnInterrupted
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftSpellCastBase::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnInterrupted");

	Params::GA_PlayerShapeShiftSpellCastBase_OnInterrupted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnInterruptFinish
// (Final, Native, Protected)

void UGA_PlayerShapeShiftSpellCastBase::OnInterruptFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnInterruptFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnRelease
// (Final, Native, Protected)

void UGA_PlayerShapeShiftSpellCastBase::OnRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnStartSync
// (Final, Native, Protected)

void UGA_PlayerShapeShiftSpellCastBase::OnStartSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnStartSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnStuck
// (Final, Native, Protected)

void UGA_PlayerShapeShiftSpellCastBase::OnStuck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnStuck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.OnStuckFinish
// (Final, Native, Protected)

void UGA_PlayerShapeShiftSpellCastBase::OnStuckFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "OnStuckFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.ReceivedEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftSpellCastBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "ReceivedEvent");

	Params::GA_PlayerShapeShiftSpellCastBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.ReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftSpellCastBase::ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "ReceivedTargetData");

	Params::GA_PlayerShapeShiftSpellCastBase_ReceivedTargetData Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerShapeShiftSpellCastBase.ServerReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     InEffectTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InChannelTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerShapeShiftSpellCastBase::ServerReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerShapeShiftSpellCastBase", "ServerReceivedTargetData");

	Params::GA_PlayerShapeShiftSpellCastBase_ServerReceivedTargetData Parms{};

	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InChannelTag = std::move(InChannelTag);
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillChannelingBase.OnChannelingFinish
// (Final, Native, Public)

void UGA_PlayerSkillChannelingBase::OnChannelingFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillChannelingBase", "OnChannelingFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillChannelingBase.OnChannelingFinishSync
// (Final, Native, Public)

void UGA_PlayerSkillChannelingBase::OnChannelingFinishSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillChannelingBase", "OnChannelingFinishSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillChannelingBase.OnChannelingStartSync
// (Final, Native, Public)

void UGA_PlayerSkillChannelingBase::OnChannelingStartSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillChannelingBase", "OnChannelingStartSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillChannelingBase.OnVelocityChange
// (Final, Native, Public)

void UGA_PlayerSkillChannelingBase::OnVelocityChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillChannelingBase", "OnVelocityChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillChannelingBase.ServerOnChannelingAction
// (Final, Native, Public)
// Parameters:
// int32                                   ActionCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSkillChannelingBase::ServerOnChannelingAction(int32 ActionCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillChannelingBase", "ServerOnChannelingAction");

	Params::GA_PlayerSkillChannelingBase_ServerOnChannelingAction Parms{};

	Parms.ActionCount = ActionCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillChannelingBase.ServerOnChannelingAction_BP
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           CueParams                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   ActionCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSkillChannelingBase::ServerOnChannelingAction_BP(const struct FGameplayEventData& EventData, const struct FGameplayCueParameters& CueParams, int32 ActionCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillChannelingBase", "ServerOnChannelingAction_BP");

	Params::GA_PlayerSkillChannelingBase_ServerOnChannelingAction_BP Parms{};

	Parms.EventData = std::move(EventData);
	Parms.CueParams = std::move(CueParams);
	Parms.ActionCount = ActionCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayerSkillChannelingBase.ServerOnChannelingStart
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           CueParams                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGA_PlayerSkillChannelingBase::ServerOnChannelingStart(const struct FGameplayEventData& EventData, const struct FGameplayCueParameters& CueParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillChannelingBase", "ServerOnChannelingStart");

	Params::GA_PlayerSkillChannelingBase_ServerOnChannelingStart Parms{};

	Parms.EventData = std::move(EventData);
	Parms.CueParams = std::move(CueParams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayerSkillInstantAndWaitForEndBase.ConsumeBuff
// (Final, Native, Protected, BlueprintCallable)

void UGA_PlayerSkillInstantAndWaitForEndBase::ConsumeBuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillInstantAndWaitForEndBase", "ConsumeBuff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillInstantAndWaitForEndBase.OnSkillBuffTagRemoved
// (Final, Native, Protected)
// Parameters:
// int32                                   NewCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSkillInstantAndWaitForEndBase::OnSkillBuffTagRemoved(int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillInstantAndWaitForEndBase", "OnSkillBuffTagRemoved");

	Params::GA_PlayerSkillInstantAndWaitForEndBase_OnSkillBuffTagRemoved Parms{};

	Parms.NewCount = NewCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSkillInstantAndWaitForEndBase.ServerBuffRemoved
// (Event, Protected, BlueprintEvent)

void UGA_PlayerSkillInstantAndWaitForEndBase::ServerBuffRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSkillInstantAndWaitForEndBase", "ServerBuffRemoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.AbilityActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "AbilityActivated");

	Params::GA_PlayerSpellCastBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.ClientReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     InEffectTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InChannelTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::ClientReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "ClientReceivedTargetData");

	Params::GA_PlayerSpellCastBase_ClientReceivedTargetData Parms{};

	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InChannelTag = std::move(InChannelTag);
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.EventReceived
// (Native, Public)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "EventReceived");

	Params::GA_PlayerSpellCastBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnBlendOut
// (Native, Public)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnBlendOut");

	Params::GA_PlayerSpellCastBase_OnBlendOut Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnCancelled
// (Native, Public)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnCancelled");

	Params::GA_PlayerSpellCastBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnCastTriggerSync
// (Final, Native, Public)

void UGA_PlayerSpellCastBase::OnCastTriggerSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnCastTriggerSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingAction
// (Final, Native, Public)
// Parameters:
// int32                                   ActionCounter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::OnChannelingAction(int32 ActionCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnChannelingAction");

	Params::GA_PlayerSpellCastBase_OnChannelingAction Parms{};

	Parms.ActionCounter = ActionCounter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingFinish
// (Final, Native, Public)

void UGA_PlayerSpellCastBase::OnChannelingFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnChannelingFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingFinishSync
// (Final, Native, Public)

void UGA_PlayerSpellCastBase::OnChannelingFinishSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnChannelingFinishSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingTriggerSync
// (Final, Native, Public)

void UGA_PlayerSpellCastBase::OnChannelingTriggerSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnChannelingTriggerSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingWithoutInterval
// (Final, Native, Public)
// Parameters:
// int32                                   ActionCounter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::OnChannelingWithoutInterval(int32 ActionCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnChannelingWithoutInterval");

	Params::GA_PlayerSpellCastBase_OnChannelingWithoutInterval Parms{};

	Parms.ActionCounter = ActionCounter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnCompleted
// (Native, Public)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnCompleted");

	Params::GA_PlayerSpellCastBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnFinish
// (Final, Native, Public)

void UGA_PlayerSpellCastBase::OnFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnFinishSync
// (Final, Native, Public)

void UGA_PlayerSpellCastBase::OnFinishSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnFinishSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnFire
// (Final, Native, Public)

void UGA_PlayerSpellCastBase::OnFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnInterrupted
// (Native, Public)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnInterrupted");

	Params::GA_PlayerSpellCastBase_OnInterrupted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnInterruptFinish
// (Final, Native, Protected)

void UGA_PlayerSpellCastBase::OnInterruptFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnInterruptFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnRelease
// (Final, Native, Public)

void UGA_PlayerSpellCastBase::OnRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnStartSync
// (Final, Native, Public)

void UGA_PlayerSpellCastBase::OnStartSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnStartSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnStuck
// (Final, Native, Protected)

void UGA_PlayerSpellCastBase::OnStuck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnStuck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnStuckFinish
// (Final, Native, Protected)

void UGA_PlayerSpellCastBase::OnStuckFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnStuckFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.OnVelocityChange
// (Final, Native, Public)

void UGA_PlayerSpellCastBase::OnVelocityChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "OnVelocityChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.ReceivedAreaTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::ReceivedAreaTargetData(const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "ReceivedAreaTargetData");

	Params::GA_PlayerSpellCastBase_ReceivedAreaTargetData Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.ReceivedEvent
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "ReceivedEvent");

	Params::GA_PlayerSpellCastBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.ReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "ReceivedTargetData");

	Params::GA_PlayerSpellCastBase_ReceivedTargetData Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.SendActivateSpellCrossHairNotify
// (Final, Native, Public)
// Parameters:
// bool                                    IsActivate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::SendActivateSpellCrossHairNotify(bool IsActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "SendActivateSpellCrossHairNotify");

	Params::GA_PlayerSpellCastBase_SendActivateSpellCrossHairNotify Parms{};

	Parms.IsActivate = IsActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_PlayerSpellCastBase.ServerReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     InEffectTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InChannelTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle InData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_PlayerSpellCastBase::ServerReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_PlayerSpellCastBase", "ServerReceivedTargetData");

	Params::GA_PlayerSpellCastBase_ServerReceivedTargetData Parms{};

	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InChannelTag = std::move(InChannelTag);
	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ProjectileCollision.AbilityActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_ProjectileCollision::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ProjectileCollision", "AbilityActivated");

	Params::GA_ProjectileCollision_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ProjectileCollision.ReceivedTargetData
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_ProjectileCollision::ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ProjectileCollision", "ReceivedTargetData");

	Params::GA_ProjectileCollision_ReceivedTargetData Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ProjectileCollision.TargetDataReceived
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGA_ProjectileCollision::TargetDataReceived(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ProjectileCollision", "TargetDataReceived");

	Params::GA_ProjectileCollision_TargetDataReceived Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ProjectileCollision.UpdateIgnoreActors
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           InCheckActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_ProjectileCollision::UpdateIgnoreActors(class AActor* InCheckActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ProjectileCollision", "UpdateIgnoreActors");

	Params::GA_ProjectileCollision_UpdateIgnoreActors Parms{};

	Parms.InCheckActor = InCheckActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ReloadAmmoBase.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_ReloadAmmoBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ReloadAmmoBase", "AbilityActivated");

	Params::GA_ReloadAmmoBase_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ReloadAmmoBase.ActivateCrossHairPullAnimationByCrossbow
// (Final, Native, Protected)
// Parameters:
// float                                   ActionSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_ReloadAmmoBase::ActivateCrossHairPullAnimationByCrossbow(float ActionSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ReloadAmmoBase", "ActivateCrossHairPullAnimationByCrossbow");

	Params::GA_ReloadAmmoBase_ActivateCrossHairPullAnimationByCrossbow Parms{};

	Parms.ActionSpeed = ActionSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ReloadAmmoBase.CancelReloadByCrossHairAim
// (Final, Native, Protected)

void UGA_ReloadAmmoBase::CancelReloadByCrossHairAim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ReloadAmmoBase", "CancelReloadByCrossHairAim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ReloadAmmoBase.EventReceived
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ReloadAmmoBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ReloadAmmoBase", "EventReceived");

	Params::GA_ReloadAmmoBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ReloadAmmoBase.OnCancelled
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ReloadAmmoBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ReloadAmmoBase", "OnCancelled");

	Params::GA_ReloadAmmoBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ReloadAmmoBase.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ReloadAmmoBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ReloadAmmoBase", "OnCompleted");

	Params::GA_ReloadAmmoBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ReloadAmmoBase.ReceivedEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ReloadAmmoBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ReloadAmmoBase", "ReceivedEvent");

	Params::GA_ReloadAmmoBase_ReceivedEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ReversibleChangeIdle.AbilityActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               TriggerEventData                                       (ConstParm, Parm, NativeAccessSpecifierPublic)

void UGA_ReversibleChangeIdle::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ReversibleChangeIdle", "AbilityActivated");

	Params::GA_ReversibleChangeIdle_AbilityActivated Parms{};

	Parms.TriggerEventData = std::move(TriggerEventData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_ReversibleChangeIdle.OnBlendOut
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ReversibleChangeIdle::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ReversibleChangeIdle", "OnBlendOut");

	Params::GA_ReversibleChangeIdle_OnBlendOut Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ReversibleChangeIdle.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ReversibleChangeIdle::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ReversibleChangeIdle", "OnCompleted");

	Params::GA_ReversibleChangeIdle_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SequenceDamageBase.EventReceived
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_SequenceDamageBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SequenceDamageBase", "EventReceived");

	Params::GA_SequenceDamageBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SequenceDamageBase.OnDamageEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_SequenceDamageBase::OnDamageEvent(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SequenceDamageBase", "OnDamageEvent");

	Params::GA_SequenceDamageBase_OnDamageEvent Parms{};

	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_SequenceDamageBase.OnDamageOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGA_SequenceDamageBase::OnDamageOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SequenceDamageBase", "OnDamageOverlapBegin");

	Params::GA_SequenceDamageBase_OnDamageOverlapBegin Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SequenceDamageBase.OnDamageOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_SequenceDamageBase::OnDamageOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SequenceDamageBase", "OnDamageOverlapEnd");

	Params::GA_SequenceDamageBase_OnDamageOverlapEnd Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ShapeShiftEndBase.OnCancelled
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ShapeShiftEndBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ShapeShiftEndBase", "OnCancelled");

	Params::GA_ShapeShiftEndBase_OnCancelled Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_ShapeShiftEndBase.OnCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_ShapeShiftEndBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ShapeShiftEndBase", "OnCompleted");

	Params::GA_ShapeShiftEndBase_OnCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellCastingAndInstallBase.ActivateInstalledSpell
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     OptionalEffectContainerTag                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_SpellCastingAndInstallBase::ActivateInstalledSpell(const struct FGameplayTag& OptionalEffectContainerTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellCastingAndInstallBase", "ActivateInstalledSpell");

	Params::GA_SpellCastingAndInstallBase_ActivateInstalledSpell Parms{};

	Parms.OptionalEffectContainerTag = std::move(OptionalEffectContainerTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellCastingAndInstallBase.ExecuteBlastGameplayCue
// (Final, Native, Public, BlueprintCallable)

void UGA_SpellCastingAndInstallBase::ExecuteBlastGameplayCue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellCastingAndInstallBase", "ExecuteBlastGameplayCue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellCastingAndInstallBase.InstallOnGround
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGA_SpellCastingAndInstallBase::InstallOnGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellCastingAndInstallBase", "InstallOnGround");

	Params::GA_SpellCastingAndInstallBase_InstallOnGround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.GA_SpellCastingAndInstallBase.OnSpellBlasted
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FActiveGameplayEffectHandle>EffectHandles                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_SpellCastingAndInstallBase::OnSpellBlasted(const TArray<struct FActiveGameplayEffectHandle>& EffectHandles, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellCastingAndInstallBase", "OnSpellBlasted");

	Params::GA_SpellCastingAndInstallBase_OnSpellBlasted Parms{};

	Parms.EffectHandles = std::move(EffectHandles);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellCastingAndInstallBase.OnSpellBlastFinish
// (Native, Event, Public, BlueprintEvent)

void UGA_SpellCastingAndInstallBase::OnSpellBlastFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellCastingAndInstallBase", "OnSpellBlastFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellCastingAndInstallBase.SetTargetActorFromBoxOverlapActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AActor>>       InTargetClasses                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InIgnoreActors                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGA_SpellCastingAndInstallBase::SetTargetActorFromBoxOverlapActors(const class UObject* WorldContextObject, const TArray<TSubclassOf<class AActor>>& InTargetClasses, const TArray<class AActor*>& InIgnoreActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellCastingAndInstallBase", "SetTargetActorFromBoxOverlapActors");

	Params::GA_SpellCastingAndInstallBase_SetTargetActorFromBoxOverlapActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InTargetClasses = std::move(InTargetClasses);
	Parms.InIgnoreActors = std::move(InIgnoreActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellCastingAndInstallBase.SetTargetActorFromCylinderOverlapActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AActor>>       InTargetClasses                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InIgnoreActors                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGA_SpellCastingAndInstallBase::SetTargetActorFromCylinderOverlapActors(const class UObject* WorldContextObject, const TArray<TSubclassOf<class AActor>>& InTargetClasses, const TArray<class AActor*>& InIgnoreActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellCastingAndInstallBase", "SetTargetActorFromCylinderOverlapActors");

	Params::GA_SpellCastingAndInstallBase_SetTargetActorFromCylinderOverlapActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InTargetClasses = std::move(InTargetClasses);
	Parms.InIgnoreActors = std::move(InIgnoreActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellCastingAndInstallBase.SetTargetActorFromSphereOverlapActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AActor>>       InTargetClasses                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InIgnoreActors                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGA_SpellCastingAndInstallBase::SetTargetActorFromSphereOverlapActors(const class UObject* WorldContextObject, const TArray<TSubclassOf<class AActor>>& InTargetClasses, const TArray<class AActor*>& InIgnoreActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellCastingAndInstallBase", "SetTargetActorFromSphereOverlapActors");

	Params::GA_SpellCastingAndInstallBase_SetTargetActorFromSphereOverlapActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InTargetClasses = std::move(InTargetClasses);
	Parms.InIgnoreActors = std::move(InIgnoreActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellChannelingBase.EventReceived
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_SpellChannelingBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellChannelingBase", "EventReceived");

	Params::GA_SpellChannelingBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_SpellChannelingBase.OnChannelingAction
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ChannelingActionCount                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_SpellChannelingBase::OnChannelingAction(int32 ChannelingActionCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellChannelingBase", "OnChannelingAction");

	Params::GA_SpellChannelingBase_OnChannelingAction Parms{};

	Parms.ChannelingActionCount = ChannelingActionCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.GA_SpellChannelingBase.OnChannelingCancelled
// (Event, Public, BlueprintEvent)

void UGA_SpellChannelingBase::OnChannelingCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellChannelingBase", "OnChannelingCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_SpellChannelingBase.OnServerChannelingFinish
// (Event, Public, BlueprintEvent)

void UGA_SpellChannelingBase::OnServerChannelingFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellChannelingBase", "OnServerChannelingFinish");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.GA_SpellGrantingAbilityBase.SetGrantingAbilityDatas
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InGrantingAbilityId                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGrantedAbilityTag                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_SpellGrantingAbilityBase::SetGrantingAbilityDatas(const struct FPrimaryAssetId& InGrantingAbilityId, const struct FGameplayTag& InGrantedAbilityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_SpellGrantingAbilityBase", "SetGrantingAbilityDatas");

	Params::GA_SpellGrantingAbilityBase_SetGrantingAbilityDatas Parms{};

	Parms.InGrantingAbilityId = std::move(InGrantingAbilityId);
	Parms.InGrantedAbilityTag = std::move(InGrantedAbilityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_WearBase.EventReceived
// (Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_WearBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_WearBase", "EventReceived");

	Params::GA_WearBase_EventReceived Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_WearBase.OnChangingMontageCompleted
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (Parm, NativeAccessSpecifierPublic)

void UGA_WearBase::OnChangingMontageCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_WearBase", "OnChangingMontageCompleted");

	Params::GA_WearBase_OnChangingMontageCompleted Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_WearBase.OnEndSync
// (Final, Native, Protected)

void UGA_WearBase::OnEndSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_WearBase", "OnEndSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_WearBase.OnFinish
// (Final, Native, Protected)

void UGA_WearBase::OnFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_WearBase", "OnFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_WearBase.OnLootTargetRemoved
// (Final, Native, Protected)

void UGA_WearBase::OnLootTargetRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_WearBase", "OnLootTargetRemoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.GA_WearBase.OnStartSync
// (Final, Native, Protected)

void UGA_WearBase::OnStartSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_WearBase", "OnStartSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MonsterSpawnableInterface.Spawn
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class ADCMonsterBase>       Monster                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADCMonsterBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADCMonsterBase* IMonsterSpawnableInterface::Spawn(TSubclassOf<class ADCMonsterBase> Monster)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MonsterSpawnableInterface", "Spawn");

	Params::MonsterSpawnableInterface_Spawn Parms{};

	Parms.Monster = Monster;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ImpactableComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImpactableComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactableComponent", "BroadcastMsgBlueprint");

	Params::ImpactableComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ImpactableComponent.SetImpactableQuery
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          TagQueryDatas                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UImpactableComponent::SetImpactableQuery(const TArray<struct FPrimaryAssetId>& TagQueryDatas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactableComponent", "SetImpactableQuery");

	Params::ImpactableComponent_SetImpactableQuery Parms{};

	Parms.TagQueryDatas = std::move(TagQueryDatas);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ImpactableComponent.TerminateBase
// (Native, Public)

void UImpactableComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactableComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ImpactableComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImpactableComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactableComponent", "UnbindMsg");

	Params::ImpactableComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ImpactableComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImpactableComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactableComponent", "UnbindMsgAll");

	Params::ImpactableComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ImpactableComponent.GetImpactableTagQueryArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UTagQueryData*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UTagQueryData*> UImpactableComponent::GetImpactableTagQueryArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactableComponent", "GetImpactableTagQueryArray");

	Params::ImpactableComponent_GetImpactableTagQueryArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.IMUtilBlueprintLibrary.GetProjectVersion
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           OutVersion                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIMUtilBlueprintLibrary::GetProjectVersion(class FString* OutVersion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IMUtilBlueprintLibrary", "GetProjectVersion");

	Params::IMUtilBlueprintLibrary_GetProjectVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVersion != nullptr)
		*OutVersion = std::move(Parms.OutVersion);
}


// Function DungeonCrawler.IMUtilBlueprintLibrary.GetServerWorldTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIMUtilBlueprintLibrary::GetServerWorldTimeSeconds(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IMUtilBlueprintLibrary", "GetServerWorldTimeSeconds");

	Params::IMUtilBlueprintLibrary_GetServerWorldTimeSeconds Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.IMUtilBlueprintLibrary.IsServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIMUtilBlueprintLibrary::IsServer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IMUtilBlueprintLibrary", "IsServer");

	Params::IMUtilBlueprintLibrary_IsServer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.IMUtilBlueprintLibrary.MakeTextwithParam1
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// class FText                             Param1                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UIMUtilBlueprintLibrary::MakeTextwithParam1(const class FText& Text, const class FText& Param1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IMUtilBlueprintLibrary", "MakeTextwithParam1");

	Params::IMUtilBlueprintLibrary_MakeTextwithParam1 Parms{};

	Parms.Text = std::move(Text);
	Parms.Param1 = std::move(Param1);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.IMUtilBlueprintLibrary.MakeTextwithParam2
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// class FText                             Param1                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             Param2                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UIMUtilBlueprintLibrary::MakeTextwithParam2(const class FText& Text, const class FText& Param1, const class FText& Param2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IMUtilBlueprintLibrary", "MakeTextwithParam2");

	Params::IMUtilBlueprintLibrary_MakeTextwithParam2 Parms{};

	Parms.Text = std::move(Text);
	Parms.Param1 = std::move(Param1);
	Parms.Param2 = std::move(Param2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.IMUtilBlueprintLibrary.MakeTextwithParam3
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// class FText                             Param1                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             Param2                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             Param3                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UIMUtilBlueprintLibrary::MakeTextwithParam3(const class FText& Text, const class FText& Param1, const class FText& Param2, const class FText& Param3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IMUtilBlueprintLibrary", "MakeTextwithParam3");

	Params::IMUtilBlueprintLibrary_MakeTextwithParam3 Parms{};

	Parms.Text = std::move(Text);
	Parms.Param1 = std::move(Param1);
	Parms.Param2 = std::move(Param2);
	Parms.Param3 = std::move(Param3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.IMUtilBlueprintLibrary.MakeTextwithParam4
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// class FText                             Param1                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             Param2                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             Param3                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             Param4                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UIMUtilBlueprintLibrary::MakeTextwithParam4(const class FText& Text, const class FText& Param1, const class FText& Param2, const class FText& Param3, const class FText& Param4)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IMUtilBlueprintLibrary", "MakeTextwithParam4");

	Params::IMUtilBlueprintLibrary_MakeTextwithParam4 Parms{};

	Parms.Text = std::move(Text);
	Parms.Param1 = std::move(Param1);
	Parms.Param2 = std::move(Param2);
	Parms.Param3 = std::move(Param3);
	Parms.Param4 = std::move(Param4);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.IMUtilBlueprintLibrary.MakeTextwithParam5
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// class FText                             Param1                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             Param2                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             Param3                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             Param4                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             Param5                                                 (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UIMUtilBlueprintLibrary::MakeTextwithParam5(const class FText& Text, const class FText& Param1, const class FText& Param2, const class FText& Param3, const class FText& Param4, const class FText& Param5)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IMUtilBlueprintLibrary", "MakeTextwithParam5");

	Params::IMUtilBlueprintLibrary_MakeTextwithParam5 Parms{};

	Parms.Text = std::move(Text);
	Parms.Param1 = std::move(Param1);
	Parms.Param2 = std::move(Param2);
	Parms.Param3 = std::move(Param3);
	Parms.Param4 = std::move(Param4);
	Parms.Param5 = std::move(Param5);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.InventoryLootingWidget.OnLootingPlayerSet
// (Final, Native, Private)
// Parameters:
// bool                                    bSetTargetPlayer                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TargetPlayerName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryLootingWidget::OnLootingPlayerSet(bool bSetTargetPlayer, class FName TargetPlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryLootingWidget", "OnLootingPlayerSet");

	Params::InventoryLootingWidget_OnLootingPlayerSet Parms{};

	Parms.bSetTargetPlayer = bSetTargetPlayer;
	Parms.TargetPlayerName = TargetPlayerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryLootingWidget.OnLootingTargetCountChanged
// (Final, Native, Private)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryLootingWidget::OnLootingTargetCountChanged(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryLootingWidget", "OnLootingTargetCountChanged");

	Params::InventoryLootingWidget_OnLootingTargetCountChanged Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryLootingWidget.RequestInventoryWidgetVisible
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryLootingWidget::RequestInventoryWidgetVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryLootingWidget", "RequestInventoryWidgetVisible");

	Params::InventoryLootingWidget_RequestInventoryWidgetVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.InventoryStatusWidget.OnCharacterClass
// (Event, Protected, BlueprintEvent)

void UInventoryStatusWidget::OnCharacterClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryStatusWidget", "OnCharacterClass");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.InventoryTabWidgetBase.OnChangeActiveState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryTabWidgetBase::OnChangeActiveState(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryTabWidgetBase", "OnChangeActiveState");

	Params::InventoryTabWidgetBase_OnChangeActiveState Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.InventoryTabWidgetBase.OnClickedInventoryTab
// (Final, Native, Protected)

void UInventoryTabWidgetBase::OnClickedInventoryTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryTabWidgetBase", "OnClickedInventoryTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.Item.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItem::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "BroadcastMsgBlueprint");

	Params::Item_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.Item.Initialize
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FItemData                        Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItem::Initialize(const struct FItemData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "Initialize");

	Params::Item_Initialize Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.Item.TerminateBase
// (Native, Public)

void UItem::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.Item.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItem::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "UnbindMsg");

	Params::Item_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.Item.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItem::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "UnbindMsgAll");

	Params::Item_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.Item.GetDesignDataItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDesignDataItem            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDesignDataItem UItem::GetDesignDataItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetDesignDataItem");

	Params::Item_GetDesignDataItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.Item.GetItemActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AItemActor*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AItemActor* UItem::GetItemActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetItemActor");

	Params::Item_GetItemActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.Item.GetItemData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FItemData UItem::GetItemData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetItemData");

	Params::Item_GetItemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.Item.GetItemDataUtilityTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UItem::GetItemDataUtilityTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetItemDataUtilityTag");

	Params::Item_GetItemDataUtilityTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.Item.GetItemDataWeaponTypeTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> UItem::GetItemDataWeaponTypeTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetItemDataWeaponTypeTags");

	Params::Item_GetItemDataWeaponTypeTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.Item.GetItemHandType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UItem::GetItemHandType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetItemHandType");

	Params::Item_GetItemHandType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.Item.GetItemIconTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UItem::GetItemIconTexture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetItemIconTexture");

	Params::Item_GetItemIconTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.Item.GetItemSlotType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UItem::GetItemSlotType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetItemSlotType");

	Params::Item_GetItemSlotType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.Item.GetItemWeaponTypes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> UItem::GetItemWeaponTypes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetItemWeaponTypes");

	Params::Item_GetItemWeaponTypes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.Item.IsItemWeaponType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     WeaponType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::IsItemWeaponType(const struct FGameplayTag& WeaponType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "IsItemWeaponType");

	Params::Item_IsItemWeaponType Parms{};

	Parms.WeaponType = std::move(WeaponType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ItemActor.GameplayTagUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemActor::GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "GameplayTagUpdated");

	Params::ItemActor_GameplayTagUpdated Parms{};

	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InCount = InCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ItemActor.ItemDataUpdated
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FItemData                        InItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AItemActor::ItemDataUpdated(const struct FItemData& InItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "ItemDataUpdated");

	Params::ItemActor_ItemDataUpdated Parms{};

	Parms.InItemData = std::move(InItemData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ItemActor.OnAttachedEquipSocket
// (Event, Protected, BlueprintEvent)

void AItemActor::OnAttachedEquipSocket()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "OnAttachedEquipSocket");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ItemActor.OnAttachedSheathSocket
// (Event, Protected, BlueprintEvent)

void AItemActor::OnAttachedSheathSocket()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "OnAttachedSheathSocket");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ItemActor.OnAttachmentReplication
// (Event, Protected, BlueprintEvent)

void AItemActor::OnAttachmentReplication()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "OnAttachmentReplication");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ItemActor.OnHiddenInGameStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsHidden                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemActor::OnHiddenInGameStateChanged(const bool bIsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "OnHiddenInGameStateChanged");

	Params::ItemActor_OnHiddenInGameStateChanged Parms{};

	Parms.bIsHidden = bIsHidden;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ItemActor.OnRep_AttachType
// (Final, Native, Private, HasOutParams)
// Parameters:
// EDCItemAttachType                       OldAttachType                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemActor::OnRep_AttachType(const EDCItemAttachType& OldAttachType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "OnRep_AttachType");

	Params::ItemActor_OnRep_AttachType Parms{};

	Parms.OldAttachType = OldAttachType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemActor.OnRep_ForceHide
// (Final, Native, Private)
// Parameters:
// bool                                    bOldForceHide                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemActor::OnRep_ForceHide(const bool bOldForceHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "OnRep_ForceHide");

	Params::ItemActor_OnRep_ForceHide Parms{};

	Parms.bOldForceHide = bOldForceHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemActor.OnStateActivated
// (Native, Event, Protected, BlueprintEvent)

void AItemActor::OnStateActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "OnStateActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemActor.OnStateDeactivated
// (Native, Event, Protected, BlueprintEvent)

void AItemActor::OnStateDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "OnStateDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemActor.PreReduceAmmoCount
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   ReduceCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemActor::PreReduceAmmoCount(int32 ReduceCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "PreReduceAmmoCount");

	Params::ItemActor_PreReduceAmmoCount Parms{};

	Parms.ReduceCount = ReduceCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ItemActor.SetAttachType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDCItemAttachType                       InAttachType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AItemActor::SetAttachType(EDCItemAttachType InAttachType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "SetAttachType");

	Params::ItemActor_SetAttachType Parms{};

	Parms.InAttachType = InAttachType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ItemActor.GetItemData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FItemData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FItemData AItemActor::GetItemData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemActor", "GetItemData");

	Params::ItemActor_GetItemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ItemComponentBase.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemComponentBase::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemComponentBase", "BroadcastMsgBlueprint");

	Params::ItemComponentBase_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemComponentBase.ClientWearItem
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class AActor*                           NewOwner                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemData                        WearingItemData                                        (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bReserveQuickSlotType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEquipmentQuickSlotType                 QuickSlotType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemComponentBase::ClientWearItem(class AActor* NewOwner, const struct FItemData& WearingItemData, bool bReserveQuickSlotType, EEquipmentQuickSlotType QuickSlotType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemComponentBase", "ClientWearItem");

	Params::ItemComponentBase_ClientWearItem Parms{};

	Parms.NewOwner = NewOwner;
	Parms.WearingItemData = std::move(WearingItemData);
	Parms.bReserveQuickSlotType = bReserveQuickSlotType;
	Parms.QuickSlotType = QuickSlotType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemComponentBase.TerminateBase
// (Native, Public)

void UItemComponentBase::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemComponentBase", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemComponentBase.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemComponentBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemComponentBase", "UnbindMsg");

	Params::ItemComponentBase_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemComponentBase.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemComponentBase::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemComponentBase", "UnbindMsgAll");

	Params::ItemComponentBase_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemCountSelectWidget.HandleLeftButtonClicked
// (Final, Native, Protected)

void UItemCountSelectWidget::HandleLeftButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemCountSelectWidget", "HandleLeftButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemCountSelectWidget.HandleRightButtonClicked
// (Final, Native, Protected)

void UItemCountSelectWidget::HandleRightButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemCountSelectWidget", "HandleRightButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemCountSelectWidget.OnCreatePopup
// (Event, Protected, BlueprintEvent)

void UItemCountSelectWidget::OnCreatePopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemCountSelectWidget", "OnCreatePopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ItemCountSelectWidget.OnRemovePopup
// (Event, Protected, BlueprintEvent)

void UItemCountSelectWidget::OnRemovePopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemCountSelectWidget", "OnRemovePopup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ItemCountSelectWidget.OnSliderValueChanged
// (Final, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemCountSelectWidget::OnSliderValueChanged(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemCountSelectWidget", "OnSliderValueChanged");

	Params::ItemCountSelectWidget_OnSliderValueChanged Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemCountSelectWidget.OnTextBlockCommitted
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ETextCommit                             CommitMethod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemCountSelectWidget::OnTextBlockCommitted(const class FText& Text, ETextCommit CommitMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemCountSelectWidget", "OnTextBlockCommitted");

	Params::ItemCountSelectWidget_OnTextBlockCommitted Parms{};

	Parms.Text = std::move(Text);
	Parms.CommitMethod = CommitMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemCountSelectWidget.OnTextBlockValueChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemCountSelectWidget::OnTextBlockValueChanged(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemCountSelectWidget", "OnTextBlockValueChanged");

	Params::ItemCountSelectWidget_OnTextBlockValueChanged Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemDataComponent.OnLoadData_Art
// (Final, Native, Private)
// Parameters:
// class UObject*                          InLoadedObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCItemDataComponent::OnLoadData_Art(class UObject* InLoadedObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemDataComponent", "OnLoadData_Art");

	Params::DCItemDataComponent_OnLoadData_Art Parms{};

	Parms.InLoadedObject = InLoadedObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemDataComponent.OnLoadData_Bundle
// (Final, Native, Private)
// Parameters:
// class UObject*                          InLoadedObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCItemDataComponent::OnLoadData_Bundle(class UObject* InLoadedObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemDataComponent", "OnLoadData_Bundle");

	Params::DCItemDataComponent_OnLoadData_Bundle Parms{};

	Parms.InLoadedObject = InLoadedObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCItemDataComponent.OnLoadData_Sound
// (Final, Native, Private)
// Parameters:
// class UObject*                          InLoadedObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDCItemDataComponent::OnLoadData_Sound(class UObject* InLoadedObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCItemDataComponent", "OnLoadData_Sound");

	Params::DCItemDataComponent_OnLoadData_Sound Parms{};

	Parms.InLoadedObject = InLoadedObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemGenerateInterface.GenerateItems
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   InLuck                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IItemGenerateInterface::GenerateItems(float InLuck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemGenerateInterface", "GenerateItems");

	Params::ItemGenerateInterface_GenerateItems Parms{};

	Parms.InLuck = InLuck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemMoveValidatorComponent.ClientMoveItemEnd
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// bool                                    bMoveSucceed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FItemData>                MovedItemDataArray                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UItemMoveValidatorComponent::ClientMoveItemEnd(bool bMoveSucceed, const TArray<struct FItemData>& MovedItemDataArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemMoveValidatorComponent", "ClientMoveItemEnd");

	Params::ItemMoveValidatorComponent_ClientMoveItemEnd Parms{};

	Parms.bMoveSucceed = bMoveSucceed;
	Parms.MovedItemDataArray = std::move(MovedItemDataArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemMoveValidatorComponent.ClientShowMessage
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// class FText                             OutputMessage                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemMoveValidatorComponent::ClientShowMessage(const class FText& OutputMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemMoveValidatorComponent", "ClientShowMessage");

	Params::ItemMoveValidatorComponent_ClientShowMessage Parms{};

	Parms.OutputMessage = std::move(OutputMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemMoveValidatorComponent.IsEnableMoveItem
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FItemData                        OldItemData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FItemData>                NewItemDataArray                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           OldOwner                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewOwner                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemMoveValidatorComponent::IsEnableMoveItem(const struct FItemData& OldItemData, const TArray<struct FItemData>& NewItemDataArray, class AActor* OldOwner, class AActor* NewOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemMoveValidatorComponent", "IsEnableMoveItem");

	Params::ItemMoveValidatorComponent_IsEnableMoveItem Parms{};

	Parms.OldItemData = std::move(OldItemData);
	Parms.NewItemDataArray = std::move(NewItemDataArray);
	Parms.OldOwner = OldOwner;
	Parms.NewOwner = NewOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ItemMoveValidatorComponent.ServerMoveItem
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FItemData                        OldItemData                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FItemData>                NewItemDataArray                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           OldOwner                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewOwner                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasDelay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemMoveValidatorComponent::ServerMoveItem(const struct FItemData& OldItemData, const TArray<struct FItemData>& NewItemDataArray, class AActor* OldOwner, class AActor* NewOwner, bool bHasDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemMoveValidatorComponent", "ServerMoveItem");

	Params::ItemMoveValidatorComponent_ServerMoveItem Parms{};

	Parms.OldItemData = std::move(OldItemData);
	Parms.NewItemDataArray = std::move(NewItemDataArray);
	Parms.OldOwner = OldOwner;
	Parms.NewOwner = NewOwner;
	Parms.bHasDelay = bHasDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemRandomGenerateComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemRandomGenerateComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRandomGenerateComponent", "BroadcastMsgBlueprint");

	Params::ItemRandomGenerateComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemRandomGenerateComponent.ClearAllItems
// (Final, Native, Private, BlueprintCallable)

void UItemRandomGenerateComponent::ClearAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRandomGenerateComponent", "ClearAllItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemRandomGenerateComponent.DropAllItems
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// float                                   InLuck                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemRandomGenerateComponent::DropAllItems(float InLuck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRandomGenerateComponent", "DropAllItems");

	Params::ItemRandomGenerateComponent_DropAllItems Parms{};

	Parms.InLuck = InLuck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemRandomGenerateComponent.DropItem
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int64                                   ItemUniqueId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemRandomGenerateComponent::DropItem(int64 ItemUniqueId, class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRandomGenerateComponent", "DropItem");

	Params::ItemRandomGenerateComponent_DropItem Parms{};

	Parms.ItemUniqueId = ItemUniqueId;
	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemRandomGenerateComponent.TerminateBase
// (Native, Public)

void UItemRandomGenerateComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRandomGenerateComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemRandomGenerateComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemRandomGenerateComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRandomGenerateComponent", "UnbindMsg");

	Params::ItemRandomGenerateComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemRandomGenerateComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemRandomGenerateComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRandomGenerateComponent", "UnbindMsgAll");

	Params::ItemRandomGenerateComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ItemRichTextBlockDecorator.GetItemTextBlockStyle
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     InRarityType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTextBlockStyle                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTextBlockStyle UItemRichTextBlockDecorator::GetItemTextBlockStyle(const struct FGameplayTag& InRarityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemRichTextBlockDecorator", "GetItemTextBlockStyle");

	Params::ItemRichTextBlockDecorator_GetItemTextBlockStyle Parms{};

	Parms.InRarityType = std::move(InRarityType);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ItemTooltipRequirementWidget.OnChangedRequirementStatus
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bFulfilled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemTooltipRequirementWidget::OnChangedRequirementStatus(bool bFulfilled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTooltipRequirementWidget", "OnChangedRequirementStatus");

	Params::ItemTooltipRequirementWidget_OnChangedRequirementStatus Parms{};

	Parms.bFulfilled = bFulfilled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ItemWeaponAnimInstanceBase.GameplayTagUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemWeaponAnimInstanceBase::GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemWeaponAnimInstanceBase", "GameplayTagUpdated");

	Params::ItemWeaponAnimInstanceBase_GameplayTagUpdated Parms{};

	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InCount = InCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ItemWeaponAnimInstanceBase.OnItemDataUpdated
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FItemData                        ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemWeaponAnimInstanceBase::OnItemDataUpdated(const struct FItemData& ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemWeaponAnimInstanceBase", "OnItemDataUpdated");

	Params::ItemWeaponAnimInstanceBase_OnItemDataUpdated Parms{};

	Parms.ItemData = std::move(ItemData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.KarmaMemberSlotWidgetBase.OnFMsgWidgetStreamingModeNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetStreamingModeNotify    InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UKarmaMemberSlotWidgetBase::OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KarmaMemberSlotWidgetBase", "OnFMsgWidgetStreamingModeNotifyBlueprint");

	Params::KarmaMemberSlotWidgetBase_OnFMsgWidgetStreamingModeNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardDetailPopup.OnDungeonComboBoxSelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardDetailPopup::OnDungeonComboBoxSelected(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardDetailPopup", "OnDungeonComboBoxSelected");

	Params::LeaderboardDetailPopup_OnDungeonComboBoxSelected Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LeaderboardDetailPopup.OnLeaderboardDetailPopupData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ULeaderboardDetailPopupData*      LeaderboardDetailPopupData                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardDetailPopup::OnLeaderboardDetailPopupData(const class ULeaderboardDetailPopupData* LeaderboardDetailPopupData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardDetailPopup", "OnLeaderboardDetailPopupData");

	Params::LeaderboardDetailPopup_OnLeaderboardDetailPopupData Parms{};

	Parms.LeaderboardDetailPopupData = LeaderboardDetailPopupData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardRankGuideItemWidget.GetRequireData
// (Final, Native, Public)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* ULeaderboardRankGuideItemWidget::GetRequireData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardRankGuideItemWidget", "GetRequireData");

	Params::LeaderboardRankGuideItemWidget_GetRequireData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.LeaderboardRankGuideItemWidget.OnLeaderboardRankGuideItemWidgetData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ULeaderboardRankGuideItemWidgetData*NewValue                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULeaderboardRankGuideItemWidgetData*OldValue                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardRankGuideItemWidget::OnLeaderboardRankGuideItemWidgetData(const class ULeaderboardRankGuideItemWidgetData* NewValue, const class ULeaderboardRankGuideItemWidgetData* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardRankGuideItemWidget", "OnLeaderboardRankGuideItemWidgetData");

	Params::LeaderboardRankGuideItemWidget_OnLeaderboardRankGuideItemWidgetData Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardRankGuideItemWidget.OnLeaderboardRankRewardState
// (Event, Protected, BlueprintEvent)
// Parameters:
// ELeaderboardRankRewardState             NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELeaderboardRankRewardState             OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardRankGuideItemWidget::OnLeaderboardRankRewardState(ELeaderboardRankRewardState NewValue, ELeaderboardRankRewardState OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardRankGuideItemWidget", "OnLeaderboardRankRewardState");

	Params::LeaderboardRankGuideItemWidget_OnLeaderboardRankRewardState Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardRankGuideItemWidget.OnLeaderboardState
// (Event, Protected, BlueprintEvent)
// Parameters:
// ELeaderboardState                       NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELeaderboardState                       OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardRankGuideItemWidget::OnLeaderboardState(ELeaderboardState NewValue, ELeaderboardState OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardRankGuideItemWidget", "OnLeaderboardState");

	Params::LeaderboardRankGuideItemWidget_OnLeaderboardState Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardRankGuideItemWidget.RequestReward
// (Final, Native, Protected, BlueprintCallable)

void ULeaderboardRankGuideItemWidget::RequestReward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardRankGuideItemWidget", "RequestReward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LeaderboardRankGuideItemWidget.SetRequiredItemData
// (Final, Native, Public)
// Parameters:
// class UObject*                          ListItemObject                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardRankGuideItemWidget::SetRequiredItemData(class UObject* ListItemObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardRankGuideItemWidget", "SetRequiredItemData");

	Params::LeaderboardRankGuideItemWidget_SetRequiredItemData Parms{};

	Parms.ListItemObject = ListItemObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LeaderboardRankRecordWidget.OnFMsgWidgetStreamingModeNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetStreamingModeNotify    InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULeaderboardRankRecordWidget::OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardRankRecordWidget", "OnFMsgWidgetStreamingModeNotifyBlueprint");

	Params::LeaderboardRankRecordWidget_OnFMsgWidgetStreamingModeNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardRankRecordWidget.OnLeaderboardRankRecordData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLeaderboardRankRecordData       NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLeaderboardRankRecordData       OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULeaderboardRankRecordWidget::OnLeaderboardRankRecordData(const struct FLeaderboardRankRecordData& NewValue, const struct FLeaderboardRankRecordData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardRankRecordWidget", "OnLeaderboardRankRecordData");

	Params::LeaderboardRankRecordWidget_OnLeaderboardRankRecordData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardSheetWidget.OnClassComboBoxSelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardSheetWidget::OnClassComboBoxSelected(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSheetWidget", "OnClassComboBoxSelected");

	Params::LeaderboardSheetWidget_OnClassComboBoxSelected Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LeaderboardSheetWidget.OnLeaderboardData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDCLeaderboardDataAsset*          NewValue                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCLeaderboardDataAsset*          OldValue                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardSheetWidget::OnLeaderboardData(const class UDCLeaderboardDataAsset* NewValue, const class UDCLeaderboardDataAsset* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSheetWidget", "OnLeaderboardData");

	Params::LeaderboardSheetWidget_OnLeaderboardData Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardSheetWidget.OnLeaderboardSeasonInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLeaderboardSeasonInfo           NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLeaderboardSeasonInfo           OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULeaderboardSheetWidget::OnLeaderboardSeasonInfo(const struct FLeaderboardSeasonInfo& NewValue, const struct FLeaderboardSeasonInfo& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSheetWidget", "OnLeaderboardSeasonInfo");

	Params::LeaderboardSheetWidget_OnLeaderboardSeasonInfo Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardSheetWidget.OnLeaderboardSheetData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDCLeaderboardSheetDataAsset*     NewValue                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCLeaderboardSheetDataAsset*     OldValue                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardSheetWidget::OnLeaderboardSheetData(const class UDCLeaderboardSheetDataAsset* NewValue, const class UDCLeaderboardSheetDataAsset* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSheetWidget", "OnLeaderboardSheetData");

	Params::LeaderboardSheetWidget_OnLeaderboardSheetData Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardSheetWidget.OnPlayerCharacterData
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDCPlayerCharacterDataAsset*      NewValue                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCPlayerCharacterDataAsset*      OldValue                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardSheetWidget::OnPlayerCharacterData(const class UDCPlayerCharacterDataAsset* NewValue, const class UDCPlayerCharacterDataAsset* OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSheetWidget", "OnPlayerCharacterData");

	Params::LeaderboardSheetWidget_OnPlayerCharacterData Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardSheetWidget.OnRankInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FRankInfo                        NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRankInfo                        OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULeaderboardSheetWidget::OnRankInfo(const struct FRankInfo& NewValue, const struct FRankInfo& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardSheetWidget", "OnRankInfo");

	Params::LeaderboardSheetWidget_OnRankInfo Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LeaderboardWidget.OnSeasonComboBoxSelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardWidget::OnSeasonComboBoxSelected(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardWidget", "OnSeasonComboBoxSelected");

	Params::LeaderboardWidget_OnSeasonComboBoxSelected Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LeaderboardWidget.OnSheetComboBoxSelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          InItem                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULeaderboardWidget::OnSheetComboBoxSelected(class UObject* InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LeaderboardWidget", "OnSheetComboBoxSelected");

	Params::LeaderboardWidget_OnSheetComboBoxSelected Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LobbyGroupTradeChannelWidget.OnLeaveChannelButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void ULobbyGroupTradeChannelWidget::OnLeaveChannelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyGroupTradeChannelWidget", "OnLeaveChannelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LobbyGroupTradeChannelWidget.OnReadRulesButtonClicked
// (Final, Native, Private)

void ULobbyGroupTradeChannelWidget::OnReadRulesButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyGroupTradeChannelWidget", "OnReadRulesButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LobbyWidget.OnBackButtonClicked
// (Final, Native, Private)

void ULobbyWidget::OnBackButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyWidget", "OnBackButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LobbyWidget.OnMatchingStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bMatching                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyWidget::OnMatchingStateChanged(bool bMatching)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyWidget", "OnMatchingStateChanged");

	Params::LobbyWidget_OnMatchingStateChanged Parms{};

	Parms.bMatching = bMatching;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LobbyWidget.OnPlayPartyReadyStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bMine                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLeader                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReady                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyWidget::OnPlayPartyReadyStateChanged(bool bMine, bool bLeader, bool bReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyWidget", "OnPlayPartyReadyStateChanged");

	Params::LobbyWidget_OnPlayPartyReadyStateChanged Parms{};

	Parms.bMine = bMine;
	Parms.bLeader = bLeader;
	Parms.bReady = bReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LobbyWidget.ShowLegendaryStatusPopup
// (Final, Native, Private)

void ULobbyWidget::ShowLegendaryStatusPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyWidget", "ShowLegendaryStatusPopup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LoginSecretTokenPopup.HandleConfirmButtonClicked
// (Final, Native, Protected)

void ULoginSecretTokenPopup::HandleConfirmButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginSecretTokenPopup", "HandleConfirmButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LoginSecretTokenPopup.HandleCopyToClipboardButtonClicked
// (Final, Native, Protected)

void ULoginSecretTokenPopup::HandleCopyToClipboardButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginSecretTokenPopup", "HandleCopyToClipboardButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LoginVoipInitializePopup.HandleAcceptButtonClicked
// (Final, Native, Protected)

void ULoginVoipInitializePopup::HandleAcceptButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginVoipInitializePopup", "HandleAcceptButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LoginVoipInitializePopup.SetInputBind
// (Final, Native, Protected)

void ULoginVoipInitializePopup::SetInputBind()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginVoipInitializePopup", "SetInputBind");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LoginWidget.OnAgeRatingType
// (Event, Protected, BlueprintEvent)
// Parameters:
// EAgeRatingType                          NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAgeRatingType                          OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoginWidget::OnAgeRatingType(EAgeRatingType NewValue, EAgeRatingType OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginWidget", "OnAgeRatingType");

	Params::LoginWidget_OnAgeRatingType Parms{};

	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.LoginWidget.OnLoginButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void ULoginWidget::OnLoginButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginWidget", "OnLoginButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LoginWidget.OnSelectionChanged
// (Final, Native, Private)
// Parameters:
// class FString                           SelectedItem                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESelectInfo                             SelectionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoginWidget::OnSelectionChanged(const class FString& SelectedItem, ESelectInfo SelectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginWidget", "OnSelectionChanged");

	Params::LoginWidget_OnSelectionChanged Parms{};

	Parms.SelectedItem = std::move(SelectedItem);
	Parms.SelectionType = SelectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LoginWidget.OnTextChangedLoginId
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InLoginId                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULoginWidget::OnTextChangedLoginId(const class FText& InLoginId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginWidget", "OnTextChangedLoginId");

	Params::LoginWidget_OnTextChangedLoginId Parms{};

	Parms.InLoginId = std::move(InLoginId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LoginWidget.OnTextChangedPassWord
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InPassWord                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULoginWidget::OnTextChangedPassWord(const class FText& InPassWord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginWidget", "OnTextChangedPassWord");

	Params::LoginWidget_OnTextChangedPassWord Parms{};

	Parms.InPassWord = std::move(InPassWord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LoginWidget.PlayLoginSound
// (Event, Protected, BlueprintEvent)

void ULoginWidget::PlayLoginSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginWidget", "PlayLoginSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.LoginWidget.StopLoginSound
// (Event, Protected, BlueprintEvent)

void ULoginWidget::StopLoginSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginWidget", "StopLoginSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.LoginWidget.IsUsingDevPlatform
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULoginWidget::IsUsingDevPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginWidget", "IsUsingDevPlatform");

	Params::LoginWidget_IsUsingDevPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.LoginWidget.IsUsingPlatform
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULoginWidget::IsUsingPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoginWidget", "IsUsingPlatform");

	Params::LoginWidget_IsUsingPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction DungeonCrawler.LootComponent.DCRemoveLootTargetEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void ULootComponent::DCRemoveLootTargetEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootComponent", "DCRemoveLootTargetEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.LootComponent.GetLootTargetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ULootComponent::GetLootTargetActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootComponent", "GetLootTargetActor");

	Params::LootComponent_GetLootTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.LootComponent.IsLootTargetPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULootComponent::IsLootTargetPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootComponent", "IsLootTargetPlayer");

	Params::LootComponent_IsLootTargetPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.LootComponent.OnRep_LootTargetActor
// (Final, Native, Private)
// Parameters:
// class AActor*                           OldLootTargetActor                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULootComponent::OnRep_LootTargetActor(const class AActor* OldLootTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootComponent", "OnRep_LootTargetActor");

	Params::LootComponent_OnRep_LootTargetActor Parms{};

	Parms.OldLootTargetActor = OldLootTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LootComponent.ServerClearLootingTargetContainingItems
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void ULootComponent::ServerClearLootingTargetContainingItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootComponent", "ServerClearLootingTargetContainingItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.LootComponent.ServerRemoveLootTarget
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UInventoryComponent*              InventoryComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FItemData>                InContainingItems                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULootComponent::ServerRemoveLootTarget(class UInventoryComponent* InventoryComponent, const TArray<struct FItemData>& InContainingItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LootComponent", "ServerRemoveLootTarget");

	Params::LootComponent_ServerRemoveLootTarget Parms{};

	Parms.InventoryComponent = InventoryComponent;
	Parms.InContainingItems = std::move(InContainingItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MailBoxListWidgetBase.OnPopupSWidgetInvitePartyAnswerResponse
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// EPopupResult                            PopupResult                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnAccountID                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNickname                        SenderNickname                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMailBoxListWidgetBase::OnPopupSWidgetInvitePartyAnswerResponse(EPopupResult PopupResult, const class FString& ReturnAccountID, const struct FNickname& SenderNickname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MailBoxListWidgetBase", "OnPopupSWidgetInvitePartyAnswerResponse");

	Params::MailBoxListWidgetBase_OnPopupSWidgetInvitePartyAnswerResponse Parms{};

	Parms.PopupResult = PopupResult;
	Parms.ReturnAccountID = std::move(ReturnAccountID);
	Parms.SenderNickname = std::move(SenderNickname);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MetaPlayComponent.OnRecruitBegin
// (Final, Native, Public, BlueprintCallable)

void UMetaPlayComponent::OnRecruitBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetaPlayComponent", "OnRecruitBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicActor.OnRep_MusicData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FMusicData                       OldMusicData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMusicActor::OnRep_MusicData(const struct FMusicData& OldMusicData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicActor", "OnRep_MusicData");

	Params::MusicActor_OnRep_MusicData Parms{};

	Parms.OldMusicData = std::move(OldMusicData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicActor.SetMusicData
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FMusicData                       NewMusicData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AMusicActor::SetMusicData(const struct FMusicData& NewMusicData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicActor", "SetMusicData");

	Params::MusicActor_SetMusicData Parms{};

	Parms.NewMusicData = std::move(NewMusicData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicActor.GetArtDataMusic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UArtDataMusic*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArtDataMusic* AMusicActor::GetArtDataMusic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicActor", "GetArtDataMusic");

	Params::MusicActor_GetArtDataMusic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.MusicActor.GetDesignDataMusic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDesignDataMusic                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataMusic AMusicActor::GetDesignDataMusic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicActor", "GetDesignDataMusic");

	Params::MusicActor_GetDesignDataMusic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.MusicActor.GetMusicData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMusicData                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMusicData AMusicActor::GetMusicData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicActor", "GetMusicData");

	Params::MusicActor_GetMusicData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.MusicActor.GetPlayMusicData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayMusicData*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayMusicData* AMusicActor::GetPlayMusicData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicActor", "GetPlayMusicData");

	Params::MusicActor_GetPlayMusicData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.MusicActor.GetSoundDataMusic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundData*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundData* AMusicActor::GetSoundDataMusic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicActor", "GetSoundDataMusic");

	Params::MusicActor_GetSoundDataMusic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.MusicComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicComponent", "BroadcastMsgBlueprint");

	Params::MusicComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicComponent.OnRep_CurrentMusicTag
// (Final, Native, Private)

void UMusicComponent::OnRep_CurrentMusicTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicComponent", "OnRep_CurrentMusicTag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicComponent.OnRep_MusicActors
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<class AMusicActor*>              OldAMusicActors                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UMusicComponent::OnRep_MusicActors(const TArray<class AMusicActor*>& OldAMusicActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicComponent", "OnRep_MusicActors");

	Params::MusicComponent_OnRep_MusicActors Parms{};

	Parms.OldAMusicActors = std::move(OldAMusicActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicComponent.ServerSetCurrentMusic
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FGameplayTag                     MusicTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicComponent::ServerSetCurrentMusic(const struct FGameplayTag& MusicTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicComponent", "ServerSetCurrentMusic");

	Params::MusicComponent_ServerSetCurrentMusic Parms{};

	Parms.MusicTag = std::move(MusicTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicComponent.TerminateBase
// (Native, Public)

void UMusicComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicComponent", "UnbindMsg");

	Params::MusicComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MusicComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicComponent", "UnbindMsgAll");

	Params::MusicComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.MyStatusWidget.SelectStatus
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   InRadioButtonIdx                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMyStatusWidget::SelectStatus(int32 InRadioButtonIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MyStatusWidget", "SelectStatus");

	Params::MyStatusWidget_SelectStatus Parms{};

	Parms.InRadioButtonIdx = InRadioButtonIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemEpic.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineSystemEpic::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemEpic", "BroadcastMsgBlueprint");

	Params::OnlineSystemEpic_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemEpic.TerminateBase
// (Native, Public)

void UOnlineSystemEpic::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemEpic", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemEpic.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineSystemEpic::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemEpic", "UnbindMsg");

	Params::OnlineSystemEpic_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemEpic.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineSystemEpic::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemEpic", "UnbindMsgAll");

	Params::OnlineSystemEpic_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemIronmace.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineSystemIronmace::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemIronmace", "BroadcastMsgBlueprint");

	Params::OnlineSystemIronmace_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemIronmace.TerminateBase
// (Native, Public)

void UOnlineSystemIronmace::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemIronmace", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemIronmace.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineSystemIronmace::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemIronmace", "UnbindMsg");

	Params::OnlineSystemIronmace_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemIronmace.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineSystemIronmace::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemIronmace", "UnbindMsgAll");

	Params::OnlineSystemIronmace_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemSteam.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineSystemSteam::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemSteam", "BroadcastMsgBlueprint");

	Params::OnlineSystemSteam_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemSteam.TerminateBase
// (Native, Public)

void UOnlineSystemSteam::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemSteam", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemSteam.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineSystemSteam::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemSteam", "UnbindMsg");

	Params::OnlineSystemSteam_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.OnlineSystemSteam.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineSystemSteam::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineSystemSteam", "UnbindMsgAll");

	Params::OnlineSystemSteam_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PartySession.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySession::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartySession", "BroadcastMsgBlueprint");

	Params::PartySession_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PartySession.TerminateBase
// (Native, Public)

void UPartySession::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartySession", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PartySession.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySession::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartySession", "UnbindMsg");

	Params::PartySession_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PartySession.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartySession::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartySession", "UnbindMsgAll");

	Params::PartySession_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PerkWidget.InitializePerkWidget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InPerkId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkWidget::InitializePerkWidget(const struct FPrimaryAssetId& InPerkId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkWidget", "InitializePerkWidget");

	Params::PerkWidget_InitializePerkWidget Parms{};

	Parms.InPerkId = std::move(InPerkId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PerkWidget.OnSetPerkData
// (Event, Public, BlueprintEvent)

void UPerkWidget::OnSetPerkData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkWidget", "OnSetPerkData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.PerkWidget.SetPerkData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             PerkName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             PerkDesc                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPerkWidget::SetPerkData(const class FText& PerkName, const class FText& PerkDesc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkWidget", "SetPerkData");

	Params::PerkWidget_SetPerkData Parms{};

	Parms.PerkName = std::move(PerkName);
	Parms.PerkDesc = std::move(PerkDesc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.PlayerSlotWidget.OnRightClicked
// (Native, Protected)

void UPlayerSlotWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSlotWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.GameplayTagUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileActor::GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "GameplayTagUpdated");

	Params::ProjectileActor_GameplayTagUpdated Parms{};

	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InCount = InCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ProjectileActor.GetAddEffectToGroundHit
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPrimaryAssetId> AProjectileActor::GetAddEffectToGroundHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "GetAddEffectToGroundHit");

	Params::ProjectileActor_GetAddEffectToGroundHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ProjectileActor.GetAddEffectToTargetHit
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPrimaryAssetId> AProjectileActor::GetAddEffectToTargetHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "GetAddEffectToTargetHit");

	Params::ProjectileActor_GetAddEffectToTargetHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ProjectileActor.HandleTimelineFinished
// (Final, Native, Protected)

void AProjectileActor::HandleTimelineFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "HandleTimelineFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.HandleTimelineUpdate
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileActor::HandleTimelineUpdate(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "HandleTimelineUpdate");

	Params::ProjectileActor_HandleTimelineUpdate Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.InitArrivalVelocity
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileActor::InitArrivalVelocity(const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "InitArrivalVelocity");

	Params::ProjectileActor_InitArrivalVelocity Parms{};

	Parms.Velocity = std::move(Velocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.InitialSpeed
// (Final, Native, Public)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProjectileActor::InitialSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "InitialSpeed");

	Params::ProjectileActor_InitialSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ProjectileActor.InitVelocity
// (Final, Native, Public)
// Parameters:
// float                                   FirePower                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileActor::InitVelocity(float FirePower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "InitVelocity");

	Params::ProjectileActor_InitVelocity Parms{};

	Parms.FirePower = FirePower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.LifeTimeExpired
// (Event, Protected, BlueprintEvent)

void AProjectileActor::LifeTimeExpired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "LifeTimeExpired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ProjectileActor.MatchesProjectileSourceTypeTagExact
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     CheckGameplayTag                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProjectileActor::MatchesProjectileSourceTypeTagExact(const struct FGameplayTag& CheckGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "MatchesProjectileSourceTypeTagExact");

	Params::ProjectileActor_MatchesProjectileSourceTypeTagExact Parms{};

	Parms.CheckGameplayTag = std::move(CheckGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ProjectileActor.OnHomingTargetDeath
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileActor::OnHomingTargetDeath(const struct FGameplayTag& InGameplayTag, int32 InCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "OnHomingTargetDeath");

	Params::ProjectileActor_OnHomingTargetDeath Parms{};

	Parms.InGameplayTag = std::move(InGameplayTag);
	Parms.InCount = InCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.OnLifeTimeExpired
// (Final, Native, Protected)

void AProjectileActor::OnLifeTimeExpired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "OnLifeTimeExpired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.OnRep_HomingMagnitude
// (Final, Native, Public)

void AProjectileActor::OnRep_HomingMagnitude()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "OnRep_HomingMagnitude");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.OnRep_HomingTargetComponent
// (Final, Native, Public)

void AProjectileActor::OnRep_HomingTargetComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "OnRep_HomingTargetComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.OnRep_IsHomingProjectile
// (Final, Native, Public)

void AProjectileActor::OnRep_IsHomingProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "OnRep_IsHomingProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.OnRep_ProjectileGravityScale
// (Final, Native, Public)

void AProjectileActor::OnRep_ProjectileGravityScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "OnRep_ProjectileGravityScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.OnRep_ProjectileMovementComponentLocalVelocity
// (Final, Native, Public)

void AProjectileActor::OnRep_ProjectileMovementComponentLocalVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "OnRep_ProjectileMovementComponentLocalVelocity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.OnRep_ProjectileMovementComponentVelocity
// (Final, Native, Public)

void AProjectileActor::OnRep_ProjectileMovementComponentVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "OnRep_ProjectileMovementComponentVelocity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.PlayPierce
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   SetPierceCount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SetObstaclePierce                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SetObstaclePierceDecrease                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileActor::PlayPierce(float SetPierceCount, bool SetObstaclePierce, float SetObstaclePierceDecrease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "PlayPierce");

	Params::ProjectileActor_PlayPierce Parms{};

	Parms.SetPierceCount = SetPierceCount;
	Parms.SetObstaclePierce = SetObstaclePierce;
	Parms.SetObstaclePierceDecrease = SetObstaclePierceDecrease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.ProjectileHit
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIsAttached                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ActorPrevTickTransform                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileActor::ProjectileHit(const struct FHitResult& Hit, bool bIsAttached, const struct FTransform& ActorPrevTickTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "ProjectileHit");

	Params::ProjectileActor_ProjectileHit Parms{};

	Parms.Hit = std::move(Hit);
	Parms.bIsAttached = bIsAttached;
	Parms.ActorPrevTickTransform = std::move(ActorPrevTickTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ProjectileActor.SetAddEffectToGroundtHit
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          AddEffectList                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void AProjectileActor::SetAddEffectToGroundtHit(const TArray<struct FPrimaryAssetId>& AddEffectList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "SetAddEffectToGroundtHit");

	Params::ProjectileActor_SetAddEffectToGroundtHit Parms{};

	Parms.AddEffectList = std::move(AddEffectList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.SetAddEffectToTargetHit
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          AddEffectList                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void AProjectileActor::SetAddEffectToTargetHit(const TArray<struct FPrimaryAssetId>& AddEffectList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "SetAddEffectToTargetHit");

	Params::ProjectileActor_SetAddEffectToTargetHit Parms{};

	Parms.AddEffectList = std::move(AddEffectList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.SetHomingMagnitude
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InHomingMagnitude                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileActor::SetHomingMagnitude(float InHomingMagnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "SetHomingMagnitude");

	Params::ProjectileActor_SetHomingMagnitude Parms{};

	Parms.InHomingMagnitude = InHomingMagnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.SetHomingTargetComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InHomingTargetComponent                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileActor::SetHomingTargetComponent(class USceneComponent* InHomingTargetComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "SetHomingTargetComponent");

	Params::ProjectileActor_SetHomingTargetComponent Parms{};

	Parms.InHomingTargetComponent = InHomingTargetComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.StopPierce
// (Final, Native, Protected, BlueprintCallable)

void AProjectileActor::StopPierce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "StopPierce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ProjectileActor.TimelineFinishedEvent
// (Event, Protected, BlueprintEvent)

void AProjectileActor::TimelineFinishedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "TimelineFinishedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.ProjectileActor.TimelineUpdateEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimelinePosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectileActor::TimelineUpdateEvent(float Value, float TimelinePosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "TimelineUpdateEvent");

	Params::ProjectileActor_TimelineUpdateEvent Parms{};

	Parms.Value = Value;
	Parms.TimelinePosition = TimelinePosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ProjectileActor.GetArtDataProjectile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UArtDataProjectile*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArtDataProjectile* AProjectileActor::GetArtDataProjectile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProjectileActor", "GetArtDataProjectile");

	Params::ProjectileActor_GetArtDataProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.ReligionContentsWidget.DeActivateReligionSeasonWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsCurrentSeason                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasReligion                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReligionContentsWidget::DeActivateReligionSeasonWidget(bool bIsCurrentSeason, bool bHasReligion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionContentsWidget", "DeActivateReligionSeasonWidget");

	Params::ReligionContentsWidget_DeActivateReligionSeasonWidget Parms{};

	Parms.bIsCurrentSeason = bIsCurrentSeason;
	Parms.bHasReligion = bHasReligion;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ReligionContentsWidget.OnReligionInfoSetting
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCReligionInfo                  Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UReligionContentsWidget::OnReligionInfoSetting(const struct FDCReligionInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionContentsWidget", "OnReligionInfoSetting");

	Params::ReligionContentsWidget_OnReligionInfoSetting Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ReligionContentsWidget.OnReligionPersonalRankInfoSetting
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCReligionRankEntryInfo         Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UReligionContentsWidget::OnReligionPersonalRankInfoSetting(const struct FDCReligionRankEntryInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionContentsWidget", "OnReligionPersonalRankInfoSetting");

	Params::ReligionContentsWidget_OnReligionPersonalRankInfoSetting Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ReligionContentsWidget.OnReligionRankInfoSetting
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FDCReligionRankInfo              Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UReligionContentsWidget::OnReligionRankInfoSetting(const struct FDCReligionRankInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionContentsWidget", "OnReligionRankInfoSetting");

	Params::ReligionContentsWidget_OnReligionRankInfoSetting Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ReligionContentsWidget.SetBlessingLevel
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReligionContentsWidget::SetBlessingLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionContentsWidget", "SetBlessingLevel");

	Params::ReligionContentsWidget_SetBlessingLevel Parms{};

	Parms.Level = Level;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ReligionContentsWidget.SetButtonType
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    HasReligion                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReligionContentsWidget::SetButtonType(bool HasReligion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionContentsWidget", "SetButtonType");

	Params::ReligionContentsWidget_SetButtonType Parms{};

	Parms.HasReligion = HasReligion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ReligionContentsWidget.SetOfferingWidgetVisible
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Param_IsVisible                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReligionContentsWidget::SetOfferingWidgetVisible(bool Param_IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionContentsWidget", "SetOfferingWidgetVisible");

	Params::ReligionContentsWidget_SetOfferingWidgetVisible Parms{};

	Parms.Param_IsVisible = Param_IsVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ReligionContentsWidget.SetRankDurationSwitcherIndex
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReligionContentsWidget::SetRankDurationSwitcherIndex(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionContentsWidget", "SetRankDurationSwitcherIndex");

	Params::ReligionContentsWidget_SetRankDurationSwitcherIndex Parms{};

	Parms.Param_Index = Param_Index;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ReligionContentsWidget.SetReligionTimer
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FReligionRankTimerInfo           Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UReligionContentsWidget::SetReligionTimer(const struct FReligionRankTimerInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionContentsWidget", "SetReligionTimer");

	Params::ReligionContentsWidget_SetReligionTimer Parms{};

	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ReligionRankListEntry.OnFMsgWidgetStreamingModeNotifyBlueprint
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMsgWidgetStreamingModeNotify    InMsg                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UReligionRankListEntry::OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionRankListEntry", "OnFMsgWidgetStreamingModeNotifyBlueprint");

	Params::ReligionRankListEntry_OnFMsgWidgetStreamingModeNotifyBlueprint Parms{};

	Parms.InMsg = std::move(InMsg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.ReligionRankListEntry.OnReligionRankRecordData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FReligionRankRecordData          NewValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FReligionRankRecordData          OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UReligionRankListEntry::OnReligionRankRecordData(const struct FReligionRankRecordData& NewValue, const struct FReligionRankRecordData& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReligionRankListEntry", "OnReligionRankRecordData");

	Params::ReligionRankListEntry_OnReligionRankRecordData Parms{};

	Parms.NewValue = std::move(NewValue);
	Parms.OldValue = std::move(OldValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.SampleSubObject.BeginSampleSubObject
// (Native, Event, Public, BlueprintEvent)

void USampleSubObject::BeginSampleSubObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleSubObject", "BeginSampleSubObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleSubObject.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USampleSubObject::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleSubObject", "BroadcastMsgBlueprint");

	Params::SampleSubObject_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleSubObject.InitializeSampleSubObject
// (Native, Event, Public, BlueprintEvent)

void USampleSubObject::InitializeSampleSubObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleSubObject", "InitializeSampleSubObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleSubObject.TerminateBase
// (Native, Public)

void USampleSubObject::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleSubObject", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleSubObject.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USampleSubObject::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleSubObject", "UnbindMsg");

	Params::SampleSubObject_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleSubObject.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USampleSubObject::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleSubObject", "UnbindMsgAll");

	Params::SampleSubObject_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleObject.BeginSampleObject
// (Native, Event, Public, BlueprintEvent)

void USampleObject::BeginSampleObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleObject", "BeginSampleObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleObject.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USampleObject::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleObject", "BroadcastMsgBlueprint");

	Params::SampleObject_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleObject.InitializeSampleObject
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void USampleObject::InitializeSampleObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleObject", "InitializeSampleObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleObject.TerminateBase
// (Native, Public)

void USampleObject::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleObject", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleObject.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USampleObject::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleObject", "UnbindMsg");

	Params::SampleObject_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SampleObject.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USampleObject::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SampleObject", "UnbindMsgAll");

	Params::SampleObject_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ServerAccountSubsystem.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerAccountSubsystem::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerAccountSubsystem", "BroadcastMsgBlueprint");

	Params::ServerAccountSubsystem_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ServerAccountSubsystem.TerminateBase
// (Native, Public)

void UServerAccountSubsystem::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerAccountSubsystem", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ServerAccountSubsystem.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerAccountSubsystem::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerAccountSubsystem", "UnbindMsg");

	Params::ServerAccountSubsystem_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ServerAccountSubsystem.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerAccountSubsystem::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerAccountSubsystem", "UnbindMsgAll");

	Params::ServerAccountSubsystem_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.ShapeShiftComponent.OnRep_Data
// (Final, Native, Protected)
// Parameters:
// class UDCShapeShiftDataAsset*           OldData                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShapeShiftComponent::OnRep_Data(const class UDCShapeShiftDataAsset* OldData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShapeShiftComponent", "OnRep_Data");

	Params::ShapeShiftComponent_OnRep_Data Parms{};

	Parms.OldData = OldData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "BroadcastMsgBlueprint");

	Params::SkillComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillComponent.GameplayEffectStackChanged
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      EffectHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewStackCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PreviousStackCount                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillComponent::GameplayEffectStackChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, int32 NewStackCount, int32 PreviousStackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "GameplayEffectStackChanged");

	Params::SkillComponent_GameplayEffectStackChanged Parms{};

	Parms.EffectGameplayTag = std::move(EffectGameplayTag);
	Parms.EffectHandle = std::move(EffectHandle);
	Parms.NewStackCount = NewStackCount;
	Parms.PreviousStackCount = PreviousStackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillComponent.OnRep_SkillActorList
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<class ASkillActor*>              OldSkillActors                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USkillComponent::OnRep_SkillActorList(TArray<class ASkillActor*>* OldSkillActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "OnRep_SkillActorList");

	Params::SkillComponent_OnRep_SkillActorList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OldSkillActors != nullptr)
		*OldSkillActors = std::move(Parms.OldSkillActors);
}


// Function DungeonCrawler.SkillComponent.OnRep_SkillDataList
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FSkillDataInfo>           OldSkillDataList                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USkillComponent::OnRep_SkillDataList(const TArray<struct FSkillDataInfo>& OldSkillDataList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "OnRep_SkillDataList");

	Params::SkillComponent_OnRep_SkillDataList Parms{};

	Parms.OldSkillDataList = std::move(OldSkillDataList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillComponent.SetCooldownForDebug_Server
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bNoCooldownTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillComponent::SetCooldownForDebug_Server(bool bNoCooldownTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "SetCooldownForDebug_Server");

	Params::SkillComponent_SetCooldownForDebug_Server Parms{};

	Parms.bNoCooldownTime = bNoCooldownTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillComponent.TerminateBase
// (Native, Public)

void USkillComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "UnbindMsg");

	Params::SkillComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillComponent", "UnbindMsgAll");

	Params::SkillComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillWidget.InitializeSkillWidget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  InSkillId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillWidget::InitializeSkillWidget(const struct FPrimaryAssetId& InSkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillWidget", "InitializeSkillWidget");

	Params::SkillWidget_InitializeSkillWidget Parms{};

	Parms.InSkillId = std::move(InSkillId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SkillWidget.OnSetSkillData
// (Event, Public, BlueprintEvent)

void USkillWidget::OnSetSkillData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillWidget", "OnSetSkillData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DungeonCrawler.SkillWidget.SetSkillData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             SkillName                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             SkillDesc                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USkillWidget::SetSkillData(const class FText& SkillName, const class FText& SkillDesc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillWidget", "SetSkillData");

	Params::SkillWidget_SetSkillData Parms{};

	Parms.SkillName = std::move(SkillName);
	Parms.SkillDesc = std::move(SkillDesc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SoundBlueprintLibrary.IsMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundBlueprintLibrary::IsMute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundBlueprintLibrary", "IsMute");

	Params::SoundBlueprintLibrary_IsMute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundBlueprintLibrary.IsSoundPlayable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InSoundPlayer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InSoundProvider                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InSoundEventTag                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundBlueprintLibrary::IsSoundPlayable(class UObject* InSoundPlayer, const class UObject* InSoundProvider, const struct FGameplayTag& InSoundEventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundBlueprintLibrary", "IsSoundPlayable");

	Params::SoundBlueprintLibrary_IsSoundPlayable Parms{};

	Parms.InSoundPlayer = InSoundPlayer;
	Parms.InSoundProvider = InSoundProvider;
	Parms.InSoundEventTag = std::move(InSoundEventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundBlueprintLibrary.PlaySound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InSoundPlayer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundBlueprintLibrary::PlaySound(class UObject* InSoundPlayer, class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundBlueprintLibrary", "PlaySound");

	Params::SoundBlueprintLibrary_PlaySound Parms{};

	Parms.InSoundPlayer = InSoundPlayer;
	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundOnPlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundBlueprintLibrary::PlaySoundOnPlayerController(const class UObject* WorldContextObject, class UAkAudioEvent* AkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundBlueprintLibrary", "PlaySoundOnPlayerController");

	Params::SoundBlueprintLibrary_PlaySoundOnPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AkEvent = AkEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundWithSwitch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InSoundPlayer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InSoundProvider                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        Surface                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SwitchGroup                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SwitchState                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundBlueprintLibrary::PlaySoundWithSwitch(class UObject* InSoundPlayer, class UAkAudioEvent* AkEvent, const class UObject* InSoundProvider, const struct FGameplayTag& Tag, const EPhysicalSurface Surface, const class FString& SwitchGroup, const class FString& SwitchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundBlueprintLibrary", "PlaySoundWithSwitch");

	Params::SoundBlueprintLibrary_PlaySoundWithSwitch Parms{};

	Parms.InSoundPlayer = InSoundPlayer;
	Parms.AkEvent = AkEvent;
	Parms.InSoundProvider = InSoundProvider;
	Parms.Tag = std::move(Tag);
	Parms.Surface = Surface;
	Parms.SwitchGroup = std::move(SwitchGroup);
	Parms.SwitchState = std::move(SwitchState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundWithTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          InSoundPlayer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InSoundProvider                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundBlueprintLibrary::PlaySoundWithTag(class UObject* InSoundPlayer, const class UObject* InSoundProvider, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundBlueprintLibrary", "PlaySoundWithTag");

	Params::SoundBlueprintLibrary_PlaySoundWithTag Parms{};

	Parms.InSoundPlayer = InSoundPlayer;
	Parms.InSoundProvider = InSoundProvider;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundBlueprintLibrary.SetRTPCValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InSoundPlayer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkRtpc*                          RtpcValue                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InterpolationTimeMs                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundBlueprintLibrary::SetRTPCValue(class UObject* InSoundPlayer, const class UAkRtpc* RtpcValue, float Value, int32 InterpolationTimeMs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundBlueprintLibrary", "SetRTPCValue");

	Params::SoundBlueprintLibrary_SetRTPCValue Parms{};

	Parms.InSoundPlayer = InSoundPlayer;
	Parms.RtpcValue = RtpcValue;
	Parms.Value = Value;
	Parms.InterpolationTimeMs = InterpolationTimeMs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundBlueprintLibrary.SetSwitch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InSoundPlayer                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkSwitchValue*                   AkSwitchValue                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USoundBlueprintLibrary::SetSwitch(class UObject* InSoundPlayer, class UAkSwitchValue* AkSwitchValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SoundBlueprintLibrary", "SetSwitch");

	Params::SoundBlueprintLibrary_SetSwitch Parms{};

	Parms.InSoundPlayer = InSoundPlayer;
	Parms.AkSwitchValue = AkSwitchValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundProvider.GetEvent
// (Native, Public, HasOutParams, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* ISoundProvider::GetEvent(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundProvider", "GetEvent");

	Params::SoundProvider_GetEvent Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundProvider.GetEvents
// (Native, Public, Const)
// Parameters:
// TMap<struct FGameplayTag, class UAkAudioEvent*>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, class UAkAudioEvent*> ISoundProvider::GetEvents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundProvider", "GetEvents");

	Params::SoundProvider_GetEvents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundProvider.GetLastPrimaryAssetId
// (Native, Public, HasDefaults, Const)
// Parameters:
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId ISoundProvider::GetLastPrimaryAssetId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundProvider", "GetLastPrimaryAssetId");

	Params::SoundProvider_GetLastPrimaryAssetId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundProvider.GetSwitch
// (Native, Public, HasOutParams, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        Surface                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkSwitchValue*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkSwitchValue* ISoundProvider::GetSwitch(const struct FGameplayTag& Tag, const EPhysicalSurface Surface) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundProvider", "GetSwitch");

	Params::SoundProvider_GetSwitch Parms{};

	Parms.Tag = std::move(Tag);
	Parms.Surface = Surface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundProvider.GetSwitches
// (Native, Public, Const)
// Parameters:
// TMap<struct FGameplayTag, struct FDCSoundDataContainer>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, struct FDCSoundDataContainer> ISoundProvider::GetSwitches() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundProvider", "GetSwitches");

	Params::SoundProvider_GetSwitches Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundProvider.GetTagQueries
// (Native, Public, Const)
// Parameters:
// TMap<struct FGameplayTag, struct FGameplayTagQuery>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, struct FGameplayTagQuery> ISoundProvider::GetTagQueries() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundProvider", "GetTagQueries");

	Params::SoundProvider_GetTagQueries Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SoundProvider.GetTagQuery
// (Native, Public, HasOutParams, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagQuery                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagQuery ISoundProvider::GetTagQuery(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SoundProvider", "GetTagQuery");

	Params::SoundProvider_GetTagQuery Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SpellActor.OnRep_SpellData
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FSpellData                       OldSpellData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASpellActor::OnRep_SpellData(const struct FSpellData& OldSpellData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellActor", "OnRep_SpellData");

	Params::SpellActor_OnRep_SpellData Parms{};

	Parms.OldSpellData = std::move(OldSpellData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellActor.GetArtDataSpell
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UArtDataSpell*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArtDataSpell* ASpellActor::GetArtDataSpell() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellActor", "GetArtDataSpell");

	Params::SpellActor_GetArtDataSpell Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SpellActor.GetDesignDataSpell
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDesignDataSpell                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDesignDataSpell ASpellActor::GetDesignDataSpell() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellActor", "GetDesignDataSpell");

	Params::SpellActor_GetDesignDataSpell Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SpellActor.GetSoundDataSpell
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundData*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundData* ASpellActor::GetSoundDataSpell() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellActor", "GetSoundDataSpell");

	Params::SpellActor_GetSoundDataSpell Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SpellActor.GetSpellData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSpellData                       ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSpellData ASpellActor::GetSpellData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellActor", "GetSpellData");

	Params::SpellActor_GetSpellData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.SpellCastComponent.RequestCancelSpellCast
// (Net, NetReliable, Native, Event, Public, NetServer)

void USpellCastComponent::RequestCancelSpellCast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellCastComponent", "RequestCancelSpellCast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellComponent.BroadcastMsgBlueprint
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InMsg                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpellComponent::BroadcastMsgBlueprint(const int32& InMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellComponent", "BroadcastMsgBlueprint");

	Params::SpellComponent_BroadcastMsgBlueprint Parms{};

	Parms.InMsg = InMsg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellComponent.OnRep_CurrentSpellTag
// (Final, Native, Private)

void USpellComponent::OnRep_CurrentSpellTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellComponent", "OnRep_CurrentSpellTag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellComponent.OnRep_SpellActors
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<class ASpellActor*>              OldASpellActors                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USpellComponent::OnRep_SpellActors(const TArray<class ASpellActor*>& OldASpellActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellComponent", "OnRep_SpellActors");

	Params::SpellComponent_OnRep_SpellActors Parms{};

	Parms.OldASpellActors = std::move(OldASpellActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellComponent.ServerSetCurrentSpell
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FGameplayTag                     SpellTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpellComponent::ServerSetCurrentSpell(const struct FGameplayTag& SpellTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellComponent", "ServerSetCurrentSpell");

	Params::SpellComponent_ServerSetCurrentSpell Parms{};

	Parms.SpellTag = std::move(SpellTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellComponent.TerminateBase
// (Native, Public)

void USpellComponent::TerminateBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellComponent", "TerminateBase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellComponent.UnbindMsg
// (Native, Public)
// Parameters:
// class UScriptStruct*                    InMsgType                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpellComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellComponent", "UnbindMsg");

	Params::SpellComponent_UnbindMsg Parms{};

	Parms.InMsgType = InMsgType;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.SpellComponent.UnbindMsgAll
// (Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpellComponent::UnbindMsgAll(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpellComponent", "UnbindMsgAll");

	Params::SpellComponent_UnbindMsgAll Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.GenerateItemsAndRequestInjection
// (Final, Native, Private)

void UTestItemInjectionWidgetBase::GenerateItemsAndRequestInjection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "GenerateItemsAndRequestInjection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.OnCanEquipCheckBoxStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bIsChecked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestItemInjectionWidgetBase::OnCanEquipCheckBoxStateChanged(bool bIsChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "OnCanEquipCheckBoxStateChanged");

	Params::TestItemInjectionWidgetBase_OnCanEquipCheckBoxStateChanged Parms{};

	Parms.bIsChecked = bIsChecked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.OnGenerateCountTextChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTestItemInjectionWidgetBase::OnGenerateCountTextChanged(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "OnGenerateCountTextChanged");

	Params::TestItemInjectionWidgetBase_OnGenerateCountTextChanged Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.OnItemChildTypeSelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          WidgetData                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestItemInjectionWidgetBase::OnItemChildTypeSelected(class UObject* WidgetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "OnItemChildTypeSelected");

	Params::TestItemInjectionWidgetBase_OnItemChildTypeSelected Parms{};

	Parms.WidgetData = WidgetData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.OnItemPropertySelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          WidgetData                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestItemInjectionWidgetBase::OnItemPropertySelected(class UObject* WidgetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "OnItemPropertySelected");

	Params::TestItemInjectionWidgetBase_OnItemPropertySelected Parms{};

	Parms.WidgetData = WidgetData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.OnItemRaritySelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          WidgetData                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestItemInjectionWidgetBase::OnItemRaritySelected(class UObject* WidgetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "OnItemRaritySelected");

	Params::TestItemInjectionWidgetBase_OnItemRaritySelected Parms{};

	Parms.WidgetData = WidgetData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.OnItemSelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          WidgetData                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestItemInjectionWidgetBase::OnItemSelected(class UObject* WidgetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "OnItemSelected");

	Params::TestItemInjectionWidgetBase_OnItemSelected Parms{};

	Parms.WidgetData = WidgetData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.OnItemTypeSelected
// (Final, Native, Private)
// Parameters:
// class UObject*                          WidgetData                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestItemInjectionWidgetBase::OnItemTypeSelected(class UObject* WidgetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "OnItemTypeSelected");

	Params::TestItemInjectionWidgetBase_OnItemTypeSelected Parms{};

	Parms.WidgetData = WidgetData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.OnPropertySearchTextChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTestItemInjectionWidgetBase::OnPropertySearchTextChanged(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "OnPropertySearchTextChanged");

	Params::TestItemInjectionWidgetBase_OnPropertySearchTextChanged Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.OnSearchTextChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTestItemInjectionWidgetBase::OnSearchTextChanged(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "OnSearchTextChanged");

	Params::TestItemInjectionWidgetBase_OnSearchTextChanged Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.OnSelectedPropertyValueChanged
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// struct FPrimaryAssetId                  PropertyTypeAssetId                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPropertyValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestItemInjectionWidgetBase::OnSelectedPropertyValueChanged(const struct FPrimaryAssetId& PropertyTypeAssetId, int32 InPropertyValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "OnSelectedPropertyValueChanged");

	Params::TestItemInjectionWidgetBase_OnSelectedPropertyValueChanged Parms{};

	Parms.PropertyTypeAssetId = std::move(PropertyTypeAssetId);
	Parms.InPropertyValue = InPropertyValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TestItemInjectionWidgetBase.RemoveAllSelections
// (Final, Native, Private)

void UTestItemInjectionWidgetBase::RemoveAllSelections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestItemInjectionWidgetBase", "RemoveAllSelections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TotalGoldCountWidgetBase.CountTotalGold
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTotalGoldCountWidgetBase::CountTotalGold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotalGoldCountWidgetBase", "CountTotalGold");

	Params::TotalGoldCountWidgetBase_CountTotalGold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.TradeChannelButtonBase.OnChannelButtonClicked
// (Final, Native, Private)

void UTradeChannelButtonBase::OnChannelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelButtonBase", "OnChannelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelButtonBase.SetChannelName
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InChannelName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelButtonBase::SetChannelName(const class FText& InChannelName, int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelButtonBase", "SetChannelName");

	Params::TradeChannelButtonBase_SetChannelName Parms{};

	Parms.InChannelName = std::move(InChannelName);
	Parms.InIndex = InIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.TradeChannelButtonBase.SetMemberText
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   InMemberCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTradeChannelButtonBase::SetMemberText(int32 InMemberCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelButtonBase", "SetMemberText");

	Params::TradeChannelButtonBase_SetMemberText Parms{};

	Parms.InMemberCount = InMemberCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DungeonCrawler.TradeChannelListWidget.OnFeatureLockTimerRunsOut
// (Final, Native, Private)

void UTradeChannelListWidget::OnFeatureLockTimerRunsOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelListWidget", "OnFeatureLockTimerRunsOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeChannelListWidget.CannotEnterTradingPost
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTradeChannelListWidget::CannotEnterTradingPost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeChannelListWidget", "CannotEnterTradingPost");

	Params::TradeChannelListWidget_CannotEnterTradingPost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.TradeMasterWidget.OpenTradersGuildSubscriptionPopup
// (Final, Native, Private)

void UTradeMasterWidget::OpenTradersGuildSubscriptionPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeMasterWidget", "OpenTradersGuildSubscriptionPopup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeUserListEntryWidget.OnRightClicked
// (Native, Protected)

void UTradeUserListEntryWidget::OnRightClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeUserListEntryWidget", "OnRightClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeUserListWidget.OnBlockUpdated
// (Final, Native, Private)

void UTradeUserListWidget::OnBlockUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeUserListWidget", "OnBlockUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.TradeUserListWidget.OnTextChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FText                             FindId                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTradeUserListWidget::OnTextChanged(const class FText& FindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TradeUserListWidget", "OnTextChanged");

	Params::TradeUserListWidget_OnTextChanged Parms{};

	Parms.FindId = std::move(FindId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DungeonCrawler.DCAT_WaitforOverlap.WaitForOverlap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyTriggerOnce                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitforOverlap*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitforOverlap* UDCAT_WaitforOverlap::WaitForOverlap(class UGameplayAbility* OwningAbility, bool bOnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitforOverlap", "WaitForOverlap");

	Params::DCAT_WaitforOverlap_WaitForOverlap Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.bOnlyTriggerOnce = bOnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitforOverlap.WaitForOverlapByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               TargetActor                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyTriggerOnce                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDCAT_WaitforOverlap*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDCAT_WaitforOverlap* UDCAT_WaitforOverlap::WaitForOverlapByClass(class UGameplayAbility* OwningAbility, TSubclassOf<class AActor> TargetActor, bool bOnlyTriggerOnce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DCAT_WaitforOverlap", "WaitForOverlapByClass");

	Params::DCAT_WaitforOverlap_WaitForOverlapByClass Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetActor = TargetActor;
	Parms.bOnlyTriggerOnce = bOnlyTriggerOnce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DungeonCrawler.DCAT_WaitforOverlap.OnHitCallback
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDCAT_WaitforOverlap::OnHitCallback(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DCAT_WaitforOverlap", "OnHitCallback");

	Params::DCAT_WaitforOverlap_OnHitCallback Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

